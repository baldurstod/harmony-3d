import { vec3, vec4, vec2, quat, mat4, mat3 } from 'gl-matrix';
import { MyEventTarget, StaticEventTarget, setTimeoutPromise, Queue, Map2, once as once$1 } from 'harmony-utils';
import { display, createElement, hide, show, createShadowRoot, defineHarmonyColorPicker, defineHarmony2dManipulator, defineHarmonyToggleButton, ManipulatorDirection, I18n, toggle, defineHarmonyAccordion, defineHarmonyMenu } from 'harmony-ui';
import { ShortcutHandler, saveFile } from 'harmony-browser-utils';
import { FBXManager, fbxSceneToFBXFile, FBXExporter, FBX_SKELETON_TYPE_LIMB, FBX_PROPERTY_TYPE_COLOR_3, FBX_PROPERTY_FLAG_STATIC } from 'harmony-fbx';
import { decodeRGBE } from '@derschmale/io-rgbe';
import { BinaryReader, TWO_POW_MINUS_14, TWO_POW_10 } from 'harmony-binary-reader';
import { zoomOutSVG, zoomInSVG, contentCopySVG, dragPanSVG, panZoomSVG, rotateSVG, runSVG, walkSVG, repeatSVG, repeatOnSVG, lockOpenRightSVG, lockSVG, restartSVG, visibilityOnSVG, visibilityOffSVG, playSVG, pauseSVG } from 'harmony-svg';
import { Vpk } from 'harmony-vpk';
import { ZipReader, BlobReader, BlobWriter } from '@zip.js/zip.js';
import { MeshoptDecoder } from 'meshoptimizer';
import { decode } from 'fast-png';
import { murmurhash2_32_gc } from 'murmurhash';

// From http://paulbourke.net/geometry/polygonise/
class TRIANGLE {
    p = [vec3.create(), vec3.create(), vec3.create()];
}
class GRIDCELL {
    p = [vec3.create(), vec3.create(), vec3.create(), vec3.create(), vec3.create(), vec3.create(), vec3.create(), vec3.create(),];
    val = new Float32Array(8);
}
const edgeTable = new Uint16Array([
    0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,
    0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
    0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,
    0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
    0x230, 0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, 0x53c,
    0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
    0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6, 0x6af, 0x5a5, 0x4ac,
    0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
    0x460, 0x569, 0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c,
    0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
    0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc,
    0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
    0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c,
    0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
    0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc,
    0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
    0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,
    0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
    0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,
    0x15c, 0x55, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
    0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,
    0x2fc, 0x3f5, 0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
    0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,
    0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460,
    0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,
    0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0,
    0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,
    0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33, 0x339, 0x230,
    0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,
    0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99, 0x190,
    0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,
    0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0
]);
const triTable = new Int8Array([
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1,
    3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1,
    3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1,
    3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1,
    9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1,
    1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1,
    9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1,
    2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1,
    8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1,
    9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1,
    4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1,
    3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1,
    1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1,
    4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1,
    4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1,
    9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1,
    1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1,
    5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1,
    2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1,
    9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1,
    0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1,
    2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1,
    10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1,
    4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1,
    5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1,
    5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1,
    9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1,
    0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1,
    1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1,
    10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1,
    8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1,
    2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1,
    7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1,
    9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1,
    2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1,
    11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1,
    9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1,
    5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1,
    11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1,
    11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1,
    1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1,
    9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1,
    5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1,
    2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1,
    0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1,
    5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1,
    6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1,
    0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1,
    3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1,
    6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1,
    5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1,
    1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1,
    10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1,
    6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1,
    1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1,
    8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1,
    7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1,
    3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1,
    5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1,
    0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1,
    9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1,
    8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1,
    5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1,
    0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1,
    6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1,
    10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1,
    10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1,
    8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1,
    1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1,
    3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1,
    0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1,
    10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1,
    0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1,
    3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1,
    6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1,
    9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1,
    8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1,
    3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1,
    6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1,
    0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1,
    10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1,
    10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1,
    1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1,
    2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1,
    7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1,
    7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1,
    2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1,
    1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1,
    11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1,
    8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1,
    0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1,
    7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1,
    10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1,
    2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1,
    6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1,
    7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1,
    2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1,
    1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1,
    10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1,
    10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1,
    0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1,
    7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1,
    6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1,
    8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1,
    9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1,
    6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1,
    1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1,
    4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1,
    10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1,
    8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1,
    0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1,
    1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1,
    8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1,
    10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1,
    4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1,
    10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1,
    5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1,
    11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1,
    9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1,
    6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1,
    7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1,
    3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1,
    7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1,
    9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1,
    3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1,
    6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1,
    9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1,
    1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1,
    4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1,
    7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1,
    6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1,
    3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1,
    0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1,
    6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1,
    1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1,
    0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1,
    11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1,
    6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1,
    5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1,
    9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1,
    1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1,
    1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1,
    10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1,
    0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1,
    5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1,
    10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1,
    11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1,
    0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1,
    9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1,
    7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1,
    2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1,
    8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1,
    9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1,
    9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1,
    1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1,
    9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1,
    9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1,
    5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1,
    0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1,
    10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1,
    2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1,
    0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1,
    0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1,
    9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1,
    5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1,
    3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1,
    5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1,
    8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1,
    0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1,
    9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1,
    0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1,
    1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1,
    3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1,
    4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1,
    9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1,
    11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1,
    11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1,
    2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1,
    9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1,
    3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1,
    1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1,
    4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1,
    4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1,
    0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1,
    3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1,
    3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1,
    0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1,
    9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1,
    1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
]);
/*
    Given a grid cell and an isolevel, calculate the triangular
    facets required to represent the isosurface through the cell.
    Return the number of triangular facets, the array "triangles"
    will be loaded up with the vertices at most 5 triangular facets.
    0 will be returned if the grid cell is either totally above
    of totally below the isolevel.
*/
function polygonise(/*GRIDCELL */ grid, /*double */ isolevel, /*TRIANGLE **/ triangles) {
    //XYZ vertlist[12];
    const vertlist = [];
    for (let i = 0; i < 12; ++i) {
        vertlist.push(vec3.create());
    }
    /*
        Determine the index into the edge table which
        tells us which vertices are inside of the surface
    */
    let cubeindex = 0;
    if (grid.val[0] < isolevel)
        cubeindex |= 1;
    if (grid.val[1] < isolevel)
        cubeindex |= 2;
    if (grid.val[2] < isolevel)
        cubeindex |= 4;
    if (grid.val[3] < isolevel)
        cubeindex |= 8;
    if (grid.val[4] < isolevel)
        cubeindex |= 16;
    if (grid.val[5] < isolevel)
        cubeindex |= 32;
    if (grid.val[6] < isolevel)
        cubeindex |= 64;
    if (grid.val[7] < isolevel)
        cubeindex |= 128;
    /* Cube is entirely in/out of the surface */
    if (edgeTable[cubeindex] == 0)
        return (0);
    /* Find the vertices where the surface intersects the cube */
    if (edgeTable[cubeindex] & 1)
        vertlist[0] =
            vertexInterp(isolevel, grid.p[0], grid.p[1], grid.val[0], grid.val[1]);
    if (edgeTable[cubeindex] & 2)
        vertlist[1] =
            vertexInterp(isolevel, grid.p[1], grid.p[2], grid.val[1], grid.val[2]);
    if (edgeTable[cubeindex] & 4)
        vertlist[2] =
            vertexInterp(isolevel, grid.p[2], grid.p[3], grid.val[2], grid.val[3]);
    if (edgeTable[cubeindex] & 8)
        vertlist[3] =
            vertexInterp(isolevel, grid.p[3], grid.p[0], grid.val[3], grid.val[0]);
    if (edgeTable[cubeindex] & 16)
        vertlist[4] =
            vertexInterp(isolevel, grid.p[4], grid.p[5], grid.val[4], grid.val[5]);
    if (edgeTable[cubeindex] & 32)
        vertlist[5] =
            vertexInterp(isolevel, grid.p[5], grid.p[6], grid.val[5], grid.val[6]);
    if (edgeTable[cubeindex] & 64)
        vertlist[6] =
            vertexInterp(isolevel, grid.p[6], grid.p[7], grid.val[6], grid.val[7]);
    if (edgeTable[cubeindex] & 128)
        vertlist[7] =
            vertexInterp(isolevel, grid.p[7], grid.p[4], grid.val[7], grid.val[4]);
    if (edgeTable[cubeindex] & 256)
        vertlist[8] =
            vertexInterp(isolevel, grid.p[0], grid.p[4], grid.val[0], grid.val[4]);
    if (edgeTable[cubeindex] & 512)
        vertlist[9] =
            vertexInterp(isolevel, grid.p[1], grid.p[5], grid.val[1], grid.val[5]);
    if (edgeTable[cubeindex] & 1024)
        vertlist[10] =
            vertexInterp(isolevel, grid.p[2], grid.p[6], grid.val[2], grid.val[6]);
    if (edgeTable[cubeindex] & 2048)
        vertlist[11] =
            vertexInterp(isolevel, grid.p[3], grid.p[7], grid.val[3], grid.val[7]);
    /* Create the triangle */
    let ntriang = 0;
    cubeindex <<= 4;
    for (let i = 0; triTable[cubeindex] != -1; i += 3) {
        const triangle = triangles[ntriang] ?? new TRIANGLE();
        triangles[ntriang] = triangle;
        // TODO: fix that
        triangle.p[0] = vertlist[triTable[cubeindex]];
        triangle.p[1] = vertlist[triTable[cubeindex + 1]];
        triangle.p[2] = vertlist[triTable[cubeindex + 2]];
        ntriang++;
        cubeindex += 3;
    }
    return ntriang;
}
/*
    Linearly interpolate the position where an isosurface cuts
    an edge between two vertices, each with their own scalar value
*/
function vertexInterp(isolevel, p1, p2, valp1, valp2) {
    const p = vec3.create();
    if (Math.abs(isolevel - valp1) < 0.00001)
        return (p1);
    if (Math.abs(isolevel - valp2) < 0.00001)
        return (p2);
    if (Math.abs(valp1 - valp2) < 0.00001)
        return (p1);
    const mu = (isolevel - valp1) / (valp2 - valp1);
    p[0] = p1[0] + mu * (p2[0] - p1[0]);
    p[1] = p1[1] + mu * (p2[1] - p1[1]);
    p[2] = p1[2] + mu * (p2[2] - p1[2]);
    return p;
}

class AudioGroup {
    name;
    #muted = false;
    groups = new Map();
    audioList = new Set();
    constructor(name) {
        this.name = name;
    }
    mute(mute) {
        this.#muted = (mute == true);
        for (const audio of this.audioList) {
            audio.muted = this.#muted;
        }
    }
    isMute() {
        return this.#muted;
    }
    getGroup(groupPath) {
        if (groupPath[0] == this.name) {
            if (groupPath.length == 1) {
                return this;
            }
            let group = this.groups.get(groupPath[1]);
            if (!group) {
                group = this.createSubGroup(groupPath[1]);
            }
            return group.getGroup(groupPath.slice(1));
        }
        return null;
    }
    createSubGroup(name) {
        console.log('Creating group ' + name);
        const subGroup = new AudioGroup(name);
        this.groups.set(name, subGroup);
        return subGroup;
    }
    async playAudio(audio) {
        audio.muted = this.#muted;
        audio.currentTime = 0;
        try {
            await audio.play();
        }
        catch (e) {
            console.error(e);
        }
        this.audioList.add(audio);
    }
}

class AudioMixer {
    static master = new AudioGroup('master');
    static muteGroup(groupName, mute = true) {
        this.getGroup(groupName)?.mute(mute);
    }
    static mute(mute = true) {
        this.master.mute(mute);
    }
    static getGroup(groupName = '') {
        return this.master.getGroup(groupName.split('.'));
    }
    static async playAudio(groupName, audio) {
        await this.getGroup(groupName)?.playAudio(audio);
    }
}

class BackGround {
    render(renderer, camera) {
    }
    dispose() {
    }
    is(s) {
        return s == 'BackGround';
    }
}

vec3.create();
class ColorBackground extends BackGround {
    #color = vec4.fromValues(0, 0, 0, 1);
    constructor(params = {}) {
        super();
        if (params.color) {
            vec4.copy(this.#color, params.color);
        }
    }
    render(renderer, camera) {
        renderer.clearColor(this.#color);
        renderer.clear(true, false, false);
    }
    setColor(color) {
        vec4.copy(this.#color, color);
    }
    getColor(out = vec4.create()) {
        vec4.copy(out, this.#color);
    }
    dispose() {
    }
    is(s) {
        if (s == 'ColorBackground') {
            return true;
        }
        else {
            return super.is(s);
        }
    }
}

const entities$1 = new Map();
function registerEntity(ent) {
    if (entities$1.has(ent.getEntityName().toLowerCase())) {
        console.error(`${ent.getEntityName().toLowerCase()} is already registered`);
    }
    entities$1.set(ent.getEntityName().toLowerCase(), ent);
}
function getEntity(name) {
    return entities$1.get(name.toLowerCase());
}

class JSONLoader {
    static async fromJSON(rootEntity) {
        let loadedResolve = () => { }; // Note: typescript falsely complains about loadedResolve not being assigned without this.
        const loadedPromise = new Promise(resolve => {
            loadedResolve = resolve;
        });
        const entities = new Map();
        const root = await this.loadEntity(rootEntity, entities, loadedPromise);
        loadedResolve(true);
        return root;
    }
    static async loadEntity(jsonEntity, entities, loadedPromise) {
        if (jsonEntity) {
            const constructor = getEntity(jsonEntity['constructor']);
            if (constructor) {
                const entity = await constructor.constructFromJSON(jsonEntity, entities, loadedPromise);
                if (!entity) {
                    return null;
                }
                entity.fromJSON(jsonEntity);
                entities.set(entity.id, entity);
                if (jsonEntity.children) {
                    for (const child of jsonEntity.children) {
                        const childEntity = await this.loadEntity(child, entities, loadedPromise);
                        if (childEntity && entity['addChild']) {
                            entity['addChild'](childEntity);
                        }
                    }
                }
                return entity;
            }
            else {
                console.error('Unknown constructor', jsonEntity.constructor);
            }
        }
        return null;
    }
    static registerEntity(ent) {
        registerEntity(ent);
    }
}

const __DISABLE_WEBGL2__ = false;
const DISABLE_WEBGL2 = __DISABLE_WEBGL2__; // Set to true to force webgl1

//See https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants
const GL_NONE = 0;
const GL_ZERO = 0;
const GL_ONE = 1;
const GL_FALSE = 0;
const GL_TRUE = 1;
/* ErrorCode */
const GL_NO_ERROR = 0;
const GL_INVALID_ENUM = 0x0500;
const GL_INVALID_VALUE = 0x0501;
const GL_INVALID_OPERATION = 0x0502;
const GL_STACK_OVERFLOW = 0x0503;
const GL_STACK_UNDERFLOW = 0x0504;
const GL_OUT_OF_MEMORY = 0x0505;
//Shaders
const GL_FRAGMENT_SHADER = 0x8B30;
const GL_VERTEX_SHADER = 0x8B31;
//clear
const GL_DEPTH_BUFFER_BIT = 0x00000100;
const GL_STENCIL_BUFFER_BIT = 0x00000400;
const GL_COLOR_BUFFER_BIT = 0x00004000;
const GL_RED = 0x1903;
const GL_GREEN = 0x1904;
const GL_BLUE = 0x1905;
const GL_ALPHA = 0x1906;
const GL_RGB = 0x1907;
const GL_RGBA = 0x1908;
const GL_LUMINANCE = 0x1909;
const GL_LUMINANCE_ALPHA = 0x190A;
const GL_R8 = 0x8229;
const GL_R8_SNORM = 0x8F94;
const GL_RGBA32F = 0x8814;
const GL_RGB32F = 0x8815;
const GL_RGBA16F = 0x881A;
// drawArrays mode
const GL_POINTS = 0x0000;
const GL_LINES = 0x0001;
const GL_LINE_LOOP = 0x0002;
const GL_LINE_STRIP = 0x0003;
const GL_TRIANGLES = 0x0004;
const GL_TRIANGLE_STRIP = 0x0005;
const GL_TRIANGLE_FAN = 0x0006;
//bufferData usage
const GL_STREAM_DRAW = 0x88E0;
const GL_STREAM_READ = 0x88E1;
const GL_STREAM_COPY = 0x88E2;
const GL_STATIC_DRAW = 0x88E4;
const GL_STATIC_READ = 0x88E5;
const GL_STATIC_COPY = 0x88E6;
const GL_DYNAMIC_DRAW = 0x88E8;
const GL_DYNAMIC_READ = 0x88E9;
const GL_DYNAMIC_COPY = 0x88EA;
//bindBuffer target
const GL_ARRAY_BUFFER = 0x8892;
const GL_ELEMENT_ARRAY_BUFFER = 0x8893;
const GL_COPY_READ_BUFFER = 0x8F36;
const GL_COPY_WRITE_BUFFER = 0x8F37;
const GL_TRANSFORM_FEEDBACK_BUFFER = 0x8C8E;
const GL_UNIFORM_BUFFER = 0x8A11;
const GL_PIXEL_PACK_BUFFER = 0x88EB;
const GL_PIXEL_UNPACK_BUFFER = 0x88EC;
//buffer type / uniform type
const GL_BYTE = 0x1400;
const GL_UNSIGNED_BYTE = 0x1401;
const GL_SHORT = 0x1402;
const GL_UNSIGNED_SHORT = 0x1403;
const GL_INT = 0x1404;
const GL_UNSIGNED_INT = 0x1405;
const GL_FLOAT = 0x1406;
const GL_HALF_FLOAT = 0x140B;
const GL_FLOAT_VEC2 = 0x8B50;
const GL_FLOAT_VEC3 = 0x8B51;
const GL_FLOAT_VEC4 = 0x8B52;
const GL_INT_VEC2 = 0x8B53;
const GL_INT_VEC3 = 0x8B54;
const GL_INT_VEC4 = 0x8B55;
const GL_BOOL = 0x8B56;
const GL_BOOL_VEC2 = 0x8B57;
const GL_BOOL_VEC3 = 0x8B58;
const GL_BOOL_VEC4 = 0x8B59;
const GL_FLOAT_MAT2 = 0x8B5A;
const GL_FLOAT_MAT3 = 0x8B5B;
const GL_FLOAT_MAT4 = 0x8B5C;
const GL_SAMPLER_2D = 0x8B5E;
const GL_SAMPLER_CUBE = 0x8B60;
const GL_UNSIGNED_INT_VEC2 = 0x8DC6;
const GL_UNSIGNED_INT_VEC3 = 0x8DC7;
const GL_UNSIGNED_INT_VEC4 = 0x8DC8;
const GL_UNSIGNED_INT_24_8 = 0x84FA;
const GL_FLOAT_MAT2x3 = 0x8B65;
const GL_FLOAT_MAT2x4 = 0x8B66;
const GL_FLOAT_MAT3x2 = 0x8B67;
const GL_FLOAT_MAT3x4 = 0x8B68;
const GL_FLOAT_MAT4x2 = 0x8B69;
const GL_FLOAT_MAT4x3 = 0x8B6A;
const GL_SAMPLER_3D = 0x8B5F;
const GL_SAMPLER_2D_SHADOW = 0x8B62;
const GL_SAMPLER_2D_ARRAY = 0x8DC1;
const GL_SAMPLER_2D_ARRAY_SHADOW = 0x8DC4;
const GL_SAMPLER_CUBE_SHADOW = 0x8DC5;
const GL_INT_SAMPLER_2D = 0x8DCA;
const GL_INT_SAMPLER_3D = 0x8DCB;
const GL_INT_SAMPLER_CUBE = 0x8DCC;
const GL_INT_SAMPLER_2D_ARRAY = 0x8DCF;
const GL_UNSIGNED_INT_SAMPLER_2D = 0x8DD2;
const GL_UNSIGNED_INT_SAMPLER_3D = 0x8DD3;
const GL_UNSIGNED_INT_SAMPLER_CUBE = 0x8DD4;
const GL_UNSIGNED_INT_SAMPLER_2D_ARRAY = 0x8DD7;
const GL_UNSIGNED_SHORT_4_4_4_4 = 0x8033;
const GL_UNSIGNED_SHORT_5_5_5_1 = 0x8034;
const GL_UNSIGNED_SHORT_5_6_5 = 0x8363;
const GL_UNSIGNED_INT_2_10_10_10_REV = 0x8368;
const GL_UNSIGNED_INT_10F_11F_11F_REV = 0x8C3B;
const GL_UNSIGNED_INT_5_9_9_9_REV = 0x8C3E;
const GL_FLOAT_32_UNSIGNED_INT_24_8_REV = 0x8DAD;
// Extensions
const GL_HALF_FLOAT_OES = 0x8D61;
//get parameters
const GL_MAX_VERTEX_ATTRIBS = 0x8869;
//depthFunc
const GL_NEVER = 0x0200;
const GL_LESS = 0x0201;
const GL_EQUAL = 0x0202;
const GL_LEQUAL = 0x0203;
const GL_GREATER = 0x0204;
const GL_NOTEQUAL = 0x0205;
const GL_GEQUAL = 0x0206;
const GL_ALWAYS = 0x0207;
//enable
const GL_BLEND = 0x0BE2;
const GL_CULL_FACE = 0x0B44;
const GL_DEPTH_TEST = 0x0B71;
const GL_DITHER = 0x0BD0;
const GL_POLYGON_OFFSET_FILL = 0x8037;
const GL_SAMPLE_ALPHA_TO_COVERAGE = 0x809E;
const GL_SAMPLE_COVERAGE = 0x80A0;
const GL_SCISSOR_TEST = 0x0C11;
const GL_STENCIL_TEST = 0x0B90;
const GL_RASTERIZER_DISCARD = 0x8C89;
//textures
const GL_TEXTURE0 = 0x84C0; //GL_RENDERING_CONTEXT.TEXTURE0;
//Framebuffers and renderbuffers
const GL_MAX_RENDERBUFFER_SIZE = 0x84E8;
//texture targets
const GL_TEXTURE_2D = 0x0DE1;
const GL_TEXTURE_CUBE_MAP = 0x8513;
const GL_TEXTURE_3D = 0x806F;
const GL_TEXTURE_2D_ARRAY = 0x8C1A;
const GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;
const GL_TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;
const GL_TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;
const GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;
const GL_TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;
const GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A;
//texParameter
const GL_TEXTURE_MAG_FILTER = 0x2800;
const GL_TEXTURE_MIN_FILTER = 0x2801;
const GL_TEXTURE_WRAP_S = 0x2802;
const GL_TEXTURE_WRAP_T = 0x2803;
//export const GL_TEXTURE_MAX_ANISOTROPY_EXT = GL_RENDERING_CONTEXT.TEXTURE_MAX_ANISOTROPY_EXT;//TODO
const GL_TEXTURE_BASE_LEVEL = 0x813C;
const GL_TEXTURE_COMPARE_FUNC = 0x884D;
const GL_TEXTURE_COMPARE_MODE = 0x884C;
const GL_TEXTURE_MAX_LEVEL = 0x813D;
const GL_TEXTURE_MAX_LOD = 0x813B;
const GL_TEXTURE_MIN_LOD = 0x813A;
const GL_TEXTURE_WRAP_R = 0x8072;
//texture filter
const GL_NEAREST = 0x2600;
const GL_LINEAR = 0x2601;
const GL_NEAREST_MIPMAP_NEAREST = 0x2700;
const GL_LINEAR_MIPMAP_NEAREST = 0x2701;
const GL_NEAREST_MIPMAP_LINEAR = 0x2702;
const GL_LINEAR_MIPMAP_LINEAR = 0x2703;
// texture wrap
const GL_REPEAT = 0x2901;
const GL_CLAMP_TO_EDGE = 0x812F;
const GL_MIRRORED_REPEAT = 0x8370;
//TEXTURE_MAX_ANISOTROPY_EXT //TODO EXT_texture_filter_anisotropic
//pixelStorei
const GL_UNPACK_FLIP_Y_WEBGL = 0x9240;
const GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;
const GL_UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;
//blendFunc
const GL_SRC_COLOR = 0x0300;
const GL_ONE_MINUS_SRC_COLOR = 0x0301;
const GL_DST_COLOR = 0x0306;
const GL_ONE_MINUS_DST_COLOR = 0x0307;
const GL_SRC_ALPHA = 0x0302;
const GL_ONE_MINUS_SRC_ALPHA = 0x0303;
const GL_DST_ALPHA = 0x0304;
const GL_ONE_MINUS_DST_ALPHA = 0x0305;
const GL_CONSTANT_COLOR = 0x8001;
const GL_ONE_MINUS_CONSTANT_COLOR = 0x8002;
const GL_CONSTANT_ALPHA = 0x8003;
const GL_ONE_MINUS_CONSTANT_ALPHA = 0x8004;
const GL_SRC_ALPHA_SATURATE = 0x0308;
//blendEquation
const GL_FUNC_ADD = 0x8006; //GL_RENDERING_CONTEXT.GL_FUNC_ADD;
const GL_FUNC_SUBTRACT = 0x800A; //GL_RENDERING_CONTEXT.FUNC_SUBTRACT;
const GL_FUNC_REVERSE_SUBTRACT = 0x800B; //GL_RENDERING_CONTEXT.FUNC_REVERSE_SUBTRACT;
const GL_MIN_EXT = 0x8007; //GL_RENDERING_CONTEXT.MIN_EXT;//TODOv3 EXT_blend_minmax
const GL_MAX_EXT = 0x8008; //GL_RENDERING_CONTEXT.MAX_EXT;//TODOv3 EXT_blend_minmax
const GL_MIN = 0x8007; //GL_RENDERING_CONTEXT.MIN;
const GL_MAX = 0x8008; //GL_RENDERING_CONTEXT.MAX;
//cullFace
const GL_FRONT = 0x0404;
const GL_BACK = 0x0405;
const GL_FRONT_AND_BACK = 0x0408;
//frontFace
const GL_CW = 0x0900;
const GL_CCW = 0x0901;
const GL_RGB4 = 0x804F;
const GL_RGB5 = 0x8050;
const GL_RGB8 = 0x8051;
const GL_RGB10 = 0x8052;
const GL_RGB12 = 0x8053;
const GL_RGB16 = 0x8054;
const GL_RGBA2 = 0x8055;
const GL_RGBA4 = 0x8056;
const GL_RGB5_A1 = 0x8057;
const GL_RGBA8 = 0x8058;
const GL_RGB10_A2 = 0x8059;
const GL_RGBA12 = 0x805A;
const GL_RGBA16 = 0x805B;
const GL_RGBA32UI = 0x8D70;
const GL_RGBA16UI = 0x8D76;
const GL_RGB16UI = 0x8D77;
const GL_RGBA8UI = 0x8D7C;
const GL_RGBA32I = 0x8D82;
const GL_RGB32I = 0x8D83;
const GL_RGBA16I = 0x8D88;
const GL_RGB16I = 0x8D89;
const GL_RGBA8I = 0x8D8E;
const GL_RGB10_A2UI = 0x906F;
const GL_VERTEX_ARRAY = 0x8074;
const GL_DEPTH_COMPONENT = 0x1902;
const GL_DEPTH_COMPONENT16 = 0x81A5;
const GL_DEPTH_COMPONENT24 = 0x81A6;
const GL_DEPTH_COMPONENT32 = 0x81A7;
const GL_DEPTH_COMPONENT32F = 0x8CAC;
const FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 0x8210;
const GL_SRGB = 0x8C40;
const GL_SRGB8 = 0x8C41;
const GL_SRGB_ALPHA = 0x8C42;
const GL_SRGB8_ALPHA8 = 0x8C43;
const GL_RG8 = 0x822B;
const GL_R8I = 0x8231;
const GL_R8UI = 0x8232;
const GL_R16I = 0x8233;
const GL_R16UI = 0x8234;
const GL_R32I = 0x8235;
const GL_R32UI = 0x8236;
const GL_RG8I = 0x8237;
const GL_RG8UI = 0x8238;
const GL_RG16I = 0x8239;
const GL_RG16UI = 0x823A;
const GL_RG32I = 0x823B;
const GL_RG32UI = 0x823C;
// drawBuffers
const GL_MAX_COLOR_ATTACHMENTS = 0x8CDF;
const GL_COLOR_ATTACHMENT0 = 0x8CE0;
const GL_COLOR_ATTACHMENT1 = 0x8CE1;
const GL_COLOR_ATTACHMENT2 = 0x8CE2;
const GL_COLOR_ATTACHMENT3 = 0x8CE3;
const GL_COLOR_ATTACHMENT4 = 0x8CE4;
const GL_COLOR_ATTACHMENT5 = 0x8CE5;
const GL_COLOR_ATTACHMENT6 = 0x8CE6;
const GL_COLOR_ATTACHMENT7 = 0x8CE7;
const GL_COLOR_ATTACHMENT8 = 0x8CE8;
const GL_COLOR_ATTACHMENT9 = 0x8CE9;
const GL_COLOR_ATTACHMENT10 = 0x8CEA;
const GL_COLOR_ATTACHMENT11 = 0x8CEB;
const GL_COLOR_ATTACHMENT12 = 0x8CEC;
const GL_COLOR_ATTACHMENT13 = 0x8CED;
const GL_COLOR_ATTACHMENT14 = 0x8CEE;
const GL_COLOR_ATTACHMENT15 = 0x8CEF;
const GL_COLOR_ATTACHMENT16 = 0x8CF0;
const GL_COLOR_ATTACHMENT17 = 0x8CF1;
const GL_COLOR_ATTACHMENT18 = 0x8CF2;
const GL_COLOR_ATTACHMENT19 = 0x8CF3;
const GL_COLOR_ATTACHMENT20 = 0x8CF4;
const GL_COLOR_ATTACHMENT21 = 0x8CF5;
const GL_COLOR_ATTACHMENT22 = 0x8CF6;
const GL_COLOR_ATTACHMENT23 = 0x8CF7;
const GL_COLOR_ATTACHMENT24 = 0x8CF8;
const GL_COLOR_ATTACHMENT25 = 0x8CF9;
const GL_COLOR_ATTACHMENT26 = 0x8CFA;
const GL_COLOR_ATTACHMENT27 = 0x8CFB;
const GL_COLOR_ATTACHMENT28 = 0x8CFC;
const GL_COLOR_ATTACHMENT29 = 0x8CFD;
const GL_COLOR_ATTACHMENT30 = 0x8CFE;
const GL_COLOR_ATTACHMENT31 = 0x8CFF;
const GL_DEPTH_ATTACHMENT = 0x8D00;
const GL_STENCIL_ATTACHMENT = 0x8D20;
//Framebuffers and renderbuffers
const GL_FRAMEBUFFER = 0x8D40;
const GL_RENDERBUFFER = 0x8D41;
const GL_READ_FRAMEBUFFER = 0x8CA8;
const GL_DRAW_FRAMEBUFFER = 0x8CA9;
const GL_RGB565 = 0x8D62;
const GL_STENCIL_INDEX8 = 0x8D48;
const GL_DEPTH_STENCIL = 0x84F9;
const GL_DEPTH24_STENCIL8 = 0x88F0;
const GL_DEPTH32F_STENCIL8 = 0x8CAD;

var BlendingFactor;
(function (BlendingFactor) {
    BlendingFactor[BlendingFactor["Zero"] = 0] = "Zero";
    BlendingFactor[BlendingFactor["One"] = 1] = "One";
    BlendingFactor[BlendingFactor["SrcColor"] = 768] = "SrcColor";
    BlendingFactor[BlendingFactor["OneMinusSrcColor"] = 769] = "OneMinusSrcColor";
    BlendingFactor[BlendingFactor["DstColor"] = 774] = "DstColor";
    BlendingFactor[BlendingFactor["OneMinusDstColor"] = 775] = "OneMinusDstColor";
    BlendingFactor[BlendingFactor["SrcAlpha"] = 770] = "SrcAlpha";
    BlendingFactor[BlendingFactor["OneMinusSrcAlpha"] = 771] = "OneMinusSrcAlpha";
    BlendingFactor[BlendingFactor["DstAlpha"] = 772] = "DstAlpha";
    BlendingFactor[BlendingFactor["OneMinusDstAlpha"] = 773] = "OneMinusDstAlpha";
    BlendingFactor[BlendingFactor["ConstantColor"] = 32769] = "ConstantColor";
    BlendingFactor[BlendingFactor["OneMinusConstantColor"] = 32770] = "OneMinusConstantColor";
    BlendingFactor[BlendingFactor["ConstantAlpha"] = 32771] = "ConstantAlpha";
    BlendingFactor[BlendingFactor["OneMinusConstantAlpha"] = 32772] = "OneMinusConstantAlpha";
    BlendingFactor[BlendingFactor["SrcAlphaSaturate"] = 776] = "SrcAlphaSaturate";
})(BlendingFactor || (BlendingFactor = {}));
var BlendingEquation;
(function (BlendingEquation) {
    BlendingEquation[BlendingEquation["Add"] = 32774] = "Add";
    BlendingEquation[BlendingEquation["Subtract"] = 32778] = "Subtract";
    BlendingEquation[BlendingEquation["ReverseSubtract"] = 32779] = "ReverseSubtract";
    BlendingEquation[BlendingEquation["Min"] = 32775] = "Min";
    BlendingEquation[BlendingEquation["Max"] = 32776] = "Max";
})(BlendingEquation || (BlendingEquation = {}));

var RenderFace;
(function (RenderFace) {
    RenderFace[RenderFace["Both"] = 0] = "Both";
    RenderFace[RenderFace["Front"] = 1] = "Front";
    RenderFace[RenderFace["Back"] = 2] = "Back";
    RenderFace[RenderFace["None"] = 3] = "None";
})(RenderFace || (RenderFace = {}));
var BlendingMode;
(function (BlendingMode) {
    BlendingMode[BlendingMode["None"] = 0] = "None";
    BlendingMode[BlendingMode["Normal"] = 1] = "Normal";
    BlendingMode[BlendingMode["Additive"] = 2] = "Additive";
    BlendingMode[BlendingMode["Substractive"] = 3] = "Substractive";
    BlendingMode[BlendingMode["Multiply"] = 4] = "Multiply";
})(BlendingMode || (BlendingMode = {}));

function isTypedArray(arr) {
    return ArrayBuffer.isView(arr) && !(arr instanceof DataView);
}
function isVec(vec) {
    return Array.isArray(vec) || isTypedArray(vec);
}
function isVec4(vec) {
    return isVec(vec) && vec.length === 4;
}

var MateriaParameterType;
(function (MateriaParameterType) {
    MateriaParameterType[MateriaParameterType["None"] = 0] = "None";
    MateriaParameterType[MateriaParameterType["Boolean"] = 1] = "Boolean";
    MateriaParameterType[MateriaParameterType["Integer"] = 2] = "Integer";
    MateriaParameterType[MateriaParameterType["Float"] = 3] = "Float";
    MateriaParameterType[MateriaParameterType["NormalizedFloat"] = 4] = "NormalizedFloat";
    MateriaParameterType[MateriaParameterType["ClampedFloat"] = 5] = "ClampedFloat";
    MateriaParameterType[MateriaParameterType["Vec2"] = 6] = "Vec2";
    MateriaParameterType[MateriaParameterType["Vec3"] = 7] = "Vec3";
    MateriaParameterType[MateriaParameterType["Vec4"] = 8] = "Vec4";
    MateriaParameterType[MateriaParameterType["Mat2"] = 9] = "Mat2";
    MateriaParameterType[MateriaParameterType["Mat3"] = 10] = "Mat3";
    MateriaParameterType[MateriaParameterType["Mat4"] = 11] = "Mat4";
    MateriaParameterType[MateriaParameterType["Color2"] = 12] = "Color2";
    MateriaParameterType[MateriaParameterType["Color3"] = 13] = "Color3";
    MateriaParameterType[MateriaParameterType["Color4"] = 14] = "Color4";
    MateriaParameterType[MateriaParameterType["Texture"] = 15] = "Texture";
    MateriaParameterType[MateriaParameterType["Texture1D"] = 16] = "Texture1D";
    MateriaParameterType[MateriaParameterType["Texture2D"] = 17] = "Texture2D";
    MateriaParameterType[MateriaParameterType["Texture3D"] = 18] = "Texture3D";
})(MateriaParameterType || (MateriaParameterType = {}));
class MateriaParameter {
    #name;
    #type = MateriaParameterType.None;
    #value;
    #changed;
    constructor(name, type, value, changed) {
        this.#name = name;
        this.#type = type;
        this.#changed = changed;
        this.setValue(value);
    }
    setValue(value) {
        if (!this.#checkValue(value)) {
            console.warn('Material parameter value has an incorrect type');
        }
        // Todo: check value type
        // Todo: check if value actually changed
        if (this.#changed) {
            this.#changed(value, this.#value);
        }
        this.#value = value;
    }
    #checkValue(value) {
        if (value === undefined || value === null) {
            return true;
        }
        switch (this.#type) {
            case MateriaParameterType.NormalizedFloat:
                return (typeof value == 'number') && (value >= 0) && (value <= 1);
            case MateriaParameterType.Color4:
                return isVec4(value);
            case MateriaParameterType.Texture:
                return value.isTexture;
            default:
                throw 'unknown type: ' + this.#type;
        }
    }
}

const MATERIAL_BLENDING_NONE = 0;
const MATERIAL_BLENDING_NORMAL = 1;
const MATERIAL_BLENDING_ADDITIVE = 2;
const MATERIAL_CULLING_NONE = 0;
const MATERIAL_CULLING_FRONT = GL_FRONT;
const MATERIAL_CULLING_BACK = GL_BACK;
const MATERIAL_CULLING_FRONT_AND_BACK = GL_FRONT_AND_BACK;
var MaterialColorMode;
(function (MaterialColorMode) {
    MaterialColorMode[MaterialColorMode["None"] = 0] = "None";
    MaterialColorMode[MaterialColorMode["PerVertex"] = 1] = "PerVertex";
    MaterialColorMode[MaterialColorMode["PerMesh"] = 2] = "PerMesh";
})(MaterialColorMode || (MaterialColorMode = {}));
const DEFAULT_COLOR = vec4.fromValues(1.0, 1.0, 1.0, 1.0);
class Material {
    id = '';
    name = '';
    #renderFace = RenderFace.Front;
    #renderLights = true;
    #color = vec4.create();
    #alphaTest = false;
    #alphaTestReference = 0;
    #users = new Set();
    #parameters = new Map();
    uniforms = {}; // TODO: transform to map ?
    defines = {}; //TODOv3: put defines in meshes too ? TODO: transform to map ?
    parameters;
    depthTest;
    depthFunc;
    depthMask;
    colorMask;
    blend = false;
    srcRGB = BlendingFactor.One;
    dstRGB = BlendingFactor.Zero;
    srcAlpha = BlendingFactor.One;
    dstAlpha = BlendingFactor.Zero;
    modeRGB; //TODO: create type like above
    modeAlpha;
    polygonOffset;
    polygonOffsetFactor;
    polygonOffsetUnits;
    _dirtyProgram;
    #colorMode = MaterialColorMode.None;
    colorMap = null;
    properties = new Map();
    static materialList = {};
    constructor(params = {}) {
        this.parameters = params;
        this.depthTest = params.depthTest ?? true;
        this.depthFunc = GL_LESS;
        this.depthMask = true;
        this.colorMask = vec4.fromValues(1.0, 1.0, 1.0, 1.0);
        this.modeRGB = GL_FUNC_ADD;
        this.modeAlpha = GL_FUNC_ADD;
        //this.culling = parameters.culling ?? DEFAULT_CULLING_MODE;
        this.color = DEFAULT_COLOR;
        this.polygonOffset = params.polygonOffset ?? false;
        this.polygonOffsetFactor = params.polygonOffsetFactor ?? -5;
        this.polygonOffsetUnits = params.polygonOffsetUnits ?? -5;
        this._dirtyProgram = true; //TODOv3 use another method
    }
    get transparent() {
        return this.blend;
    }
    set renderLights(renderLights) {
        this.#renderLights = renderLights;
    }
    get renderLights() {
        return this.#renderLights;
    }
    setDefine(define, value = '') {
        if (this.defines[define] !== value) {
            this.defines[define] = value;
            this._dirtyProgram = true; //TODOv3: invalidate program here ?
        }
    }
    removeDefine(define) {
        if (this.defines[define] !== undefined) {
            delete this.defines[define];
            this._dirtyProgram = true; //TODOv3: invalidate program here ?
        }
    }
    setValues(values) {
        if (values === undefined)
            return;
    }
    clone() {
        throw 'cant\'t clone Material, missing clone() in ' + this.constructor.name;
        //return new this.constructor(this.parameters);
    }
    setTransparency(srcRGB, dstRGB, srcAlpha, dstAlpha) {
        this.blend = true;
        this.depthMask = false;
        this.srcRGB = srcRGB;
        this.dstRGB = dstRGB;
        this.srcAlpha = srcAlpha ?? srcRGB;
        this.dstAlpha = dstAlpha ?? dstRGB;
    }
    setBlending(mode, premultipliedAlpha = false) {
        if (premultipliedAlpha) {
            switch (mode) {
                case BlendingMode.None:
                    this.blend = false;
                    break;
                case BlendingMode.Normal:
                    this.setTransparency(GL_ONE, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
                    break;
                case BlendingMode.Additive:
                    this.setTransparency(GL_ONE, GL_ONE);
                    break;
                case BlendingMode.Substractive:
                    this.setTransparency(GL_ZERO, GL_ZERO, GL_ONE_MINUS_SRC_COLOR, GL_ONE_MINUS_SRC_ALPHA);
                    break;
                case BlendingMode.Multiply:
                    this.setTransparency(GL_ZERO, GL_SRC_COLOR, GL_ZERO, GL_SRC_ALPHA);
                    break;
            }
        }
        else {
            switch (mode) {
                case BlendingMode.None:
                    this.blend = false;
                    break;
                case BlendingMode.Normal:
                    this.setTransparency(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
                    break;
                case BlendingMode.Additive:
                    this.setTransparency(GL_SRC_ALPHA, GL_ONE);
                    break;
                case BlendingMode.Substractive:
                    this.setTransparency(GL_ZERO, GL_ONE_MINUS_SRC_COLOR);
                    break;
                case BlendingMode.Multiply:
                    this.setTransparency(GL_ZERO, GL_SRC_COLOR);
                    break;
            }
        }
    }
    updateMaterial(time, mesh) {
    }
    beforeRender(camera) {
    }
    /**
     * @deprecated Please use `renderFace` instead.
     */
    set culling(mode) {
        throw 'deprecated';
        /*
        this.#cullingMode = mode;
        if (mode === MATERIAL_CULLING_NONE) {
            this.setDefine('CULLING_DISABLED');
            this.removeDefine('REVERSE_CULLING');
            this.disableCulling = true;
        } else {
            this.disableCulling = false;
            this.cullMode = mode;
            this.removeDefine('CULLING_DISABLED');
            mode === MATERIAL_CULLING_BACK ? this.removeDefine('REVERSE_CULLING') : this.setDefine('REVERSE_CULLING');
        }
        */
    }
    renderFace(renderFace) {
        this.#renderFace = renderFace;
        if (renderFace == RenderFace.Both) {
            this.setDefine('CULLING_DISABLED');
            this.removeDefine('REVERSE_CULLING');
        }
        else {
            this.removeDefine('CULLING_DISABLED');
            if (renderFace == RenderFace.Front) {
                this.removeDefine('REVERSE_CULLING');
            }
            else {
                this.setDefine('REVERSE_CULLING');
            }
        }
    }
    getRenderFace() {
        return this.#renderFace;
    }
    setColorMode(colorMode) {
        this.#colorMode = colorMode;
        switch (colorMode) {
            case MaterialColorMode.None:
                this.removeDefine('USE_VERTEX_COLOR');
                this.removeDefine('USE_MESH_COLOR');
                break;
            case MaterialColorMode.PerVertex:
                this.setDefine('USE_VERTEX_COLOR');
                this.removeDefine('USE_MESH_COLOR');
                break;
            case MaterialColorMode.PerMesh:
                this.removeDefine('USE_VERTEX_COLOR');
                this.setDefine('USE_MESH_COLOR');
                break;
        }
    }
    getColorMode() {
        return this.#colorMode;
    }
    /**
     * @deprecated Please use `setColorMode` instead.
     */
    set colorMode(colorMode) {
        this.setColorMode(colorMode);
    }
    /**
     * @deprecated Please use `getColorMode` instead.
     */
    get colorMode() {
        return this.getColorMode();
    }
    setColor(color) {
        vec4.copy(this.#color, color);
        this.uniforms['uColor'] = this.#color;
    }
    set color(color) {
        this.setColor(color);
    }
    get color() {
        return vec4.clone(this.#color);
    }
    setMeshColor(color = DEFAULT_COLOR) {
        this.setColorMode(MaterialColorMode.PerMesh);
        this.color = color;
    }
    setTexture(uniformName, texture, shaderDefine) {
        const previousTexture = this.uniforms[uniformName];
        if (previousTexture != texture) {
            if (previousTexture) {
                previousTexture.removeUser(this);
            }
            if (texture) {
                texture.addUser(this);
                this.uniforms[uniformName] = texture;
                if (shaderDefine) {
                    this.setDefine(shaderDefine);
                }
            }
            else {
                this.uniforms[uniformName] = null;
                if (shaderDefine) {
                    this.removeDefine(shaderDefine);
                }
            }
        }
    }
    setTextureArray(uniformName, textureArray) {
        const previousTextureArray = this.uniforms[uniformName];
        const keepMe = new Set();
        if (textureArray) {
            textureArray.forEach(texture => {
                if (texture) {
                    texture.addUser(this);
                    keepMe.add(texture);
                }
            });
            this.uniforms[uniformName] = textureArray;
        }
        else {
            this.uniforms[uniformName] = null;
        }
        if (previousTextureArray) {
            previousTextureArray.forEach(texture => {
                if (texture && !keepMe.has(texture)) {
                    texture.removeUser(this);
                }
            });
        }
    }
    setColorMap(texture) {
        this.setTexture('colorMap', texture, 'USE_COLOR_MAP');
        this.colorMap = texture;
    }
    setColor2Map(texture) {
        this.setTexture('color2Map', texture, 'USE_COLOR2_MAP');
    }
    setDetailMap(texture) {
        this.setTexture('detailMap', texture, 'USE_DETAIL_MAP');
    }
    setNormalMap(texture) {
        this.setTexture('normalMap', texture, 'USE_NORMAL_MAP');
    }
    setCubeMap(texture) {
        this.setTexture('cubeMap', texture, 'USE_CUBE_MAP');
    }
    setAlphaTest(alphaTest) {
        this.#alphaTest = alphaTest;
        this.#setAlphaTest();
    }
    /**
     * @deprecated Please use `setAlphaTest` instead.
     */
    set alphaTest(alphaTest) {
        this.setAlphaTest(alphaTest);
    }
    setAlphaTestReference(alphaTestReference) {
        this.#alphaTestReference = alphaTestReference;
        this.#setAlphaTest();
    }
    /**
     * @deprecated Please use `setAlphaTestReference` instead.
     */
    set alphaTestReference(alphaTestReference) {
        this.setAlphaTestReference(alphaTestReference);
    }
    #setAlphaTest() {
        if (this.#alphaTest) {
            this.setDefine('ALPHA_TEST');
            this.uniforms['uAlphaTestReference'] = this.#alphaTestReference ?? 0.5;
            this.depthMask = true;
        }
        else {
            this.removeDefine('ALPHA_TEST');
        }
    }
    getColorMapSize(size = vec2.create()) {
        if (this.colorMap) {
            size[0] = this.colorMap.width;
            size[1] = this.colorMap.height;
        }
        return size;
    }
    addParameter(name, type, value, changed) {
        const param = new MateriaParameter(name, type, value, changed);
        this.#parameters.set(name, param);
        return param;
    }
    removeParameter(name) {
        this.#parameters.delete(name);
    }
    getParameter(name) {
        return this.#parameters.get(name);
    }
    setParameterValue(name, value) {
        const parameter = this.#parameters.get(name);
        if (parameter !== undefined) {
            parameter.setValue(value);
        }
    }
    setColor4Uniform(uniformName, value) {
        this.uniforms[uniformName] = value;
    }
    toJSON() {
        const json = {
            constructor: this.constructor.getEntityName(),
        };
        //TODO
        json.parameters = this.parameters;
        json.color = this.color;
        json.colormode = this.colorMode;
        json.alphatest = this.#alphaTest;
        json.alphaTestReference = this.#alphaTestReference;
        if (this.#renderFace != RenderFace.Front) {
            json.render_face = this.#renderFace;
        }
        return json;
    }
    static async constructFromJSON(json) {
        return new Material(json.parameters /*TODO: check validity*/);
    }
    fromJSON(json) {
        this.color = json.color;
        this.setColorMode(json.colormode);
        this.setAlphaTest(json.alphatest);
        this.setAlphaTestReference(json.alphaTestReference);
        this.renderFace(json.render_face ?? RenderFace.Front);
    }
    addUser(user) {
        this.#users.add(user);
    }
    removeUser(user) {
        this.#users.delete(user);
        this.dispose();
    }
    hasNoUser() {
        return this.#users.size == 0;
    }
    #disposeUniform(uniform) {
        if (Array.isArray(uniform)) {
            uniform.forEach((subValue) => this.#disposeUniform(subValue));
        }
        else {
            uniform?.removeUser?.(this);
        }
    }
    dispose() {
        if (this.hasNoUser()) {
            const uniforms = this.uniforms;
            const uniformArray = Object.keys(uniforms);
            for (const uniformName of uniformArray) {
                const uniform = uniforms[uniformName];
                this.#disposeUniform(uniform);
            }
        }
    }
    static getEntityName() {
        return 'Material';
    }
    get shaderSource() {
        // TODO: remove this
        throw 'get shaderSource() must be overridden';
    }
    getShaderSource() {
        return this.shaderSource;
    }
}
registerEntity(Material);

class MeshBasicMaterial extends Material {
    map = null;
    lightMap = null;
    lightMapIntensity = 1.0;
    aoMap = null;
    aoMapIntensity = 1.0;
    specularMap = null;
    alphaMap = null;
    envMap = null;
    combine = 0 /*MultiplyOperation*/;
    reflectivity = 1;
    refractionRatio = 0.98;
    wireframe = false;
    wireframeLinewidth = 1;
    wireframeLinecap = 'round';
    wireframeLinejoin = 'round';
    skinning = false;
    morphTargets = false;
    constructor(params) {
        super(params);
        this.setValues(params);
    }
    getShaderSource() {
        return 'meshbasic';
    }
    toJSON() {
        const json = super.toJSON();
        json.skinning = this.skinning;
        return json;
    }
    static async constructFromJSON(json) {
        return new MeshBasicMaterial();
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.skinning = json.skinning;
    }
    static getEntityName() {
        return 'MeshBasicMaterial';
    }
}
Material.materialList['MeshBasic'] = MeshBasicMaterial;
registerEntity(MeshBasicMaterial);

const tempVec3$w = vec3.create();
const tempMin = vec3.create();
const tempMax = vec3.create();
class BoundingBox {
    min = vec3.create();
    max = vec3.create();
    empty = true;
    setPoints(points) {
        this.reset();
        this.addPoints(points);
    }
    addPoints(pointArray) {
        vec3.set(tempMin, +Infinity, +Infinity, +Infinity);
        vec3.set(tempMax, -Infinity, -Infinity, -Infinity);
        for (let i = 0; i < pointArray.length; i += 3) {
            tempVec3$w[0] = pointArray[i + 0];
            tempVec3$w[1] = pointArray[i + 1];
            tempVec3$w[2] = pointArray[i + 2];
            vec3.min(tempMin, tempMin, tempVec3$w);
            vec3.max(tempMax, tempMax, tempVec3$w);
        }
        if (pointArray.length) {
            if (!this.empty) {
                vec3.min(tempMin, tempMin, this.min);
                vec3.max(tempMax, tempMax, this.max);
            }
            vec3.copy(this.min, tempMin);
            vec3.copy(this.max, tempMax);
            this.empty = false;
        }
    }
    addBoundingBox(boundingBox) {
        if (boundingBox.empty) {
            return;
        }
        if (!this.empty) {
            vec3.min(this.min, boundingBox.min, this.min);
            vec3.max(this.max, boundingBox.max, this.max);
        }
        else {
            vec3.copy(this.min, boundingBox.min);
            vec3.copy(this.max, boundingBox.max);
        }
        this.empty = false;
    }
    reset() {
        vec3.zero(this.min);
        vec3.zero(this.max);
        this.empty = true;
    }
    get center() {
        return this.getCenter();
    }
    getCenter(center = vec3.create()) {
        return vec3.lerp(center, this.min, this.max, 0.5);
    }
    get size() {
        return this.getSize();
    }
    getSize(size = vec3.create()) {
        return vec3.sub(size, this.max, this.min);
    }
}

const PI = Math.PI;
const TAU = Math.PI * 2.0;
const TWO_PI = TAU;
const HALF_PI = Math.PI * 0.5;
const DEG_TO_RAD = Math.PI / 180;
const RAD_TO_DEG = 180 / Math.PI;
const EPSILON$2 = 1e-7;
const FLT_EPSILON = 1.19209290e-07;
const ONE_EPS = 1.0000001;

function degToRad(deg) {
    return deg * DEG_TO_RAD;
}
function radToDeg(rad) {
    return rad * RAD_TO_DEG;
}
function clamp$1(val, min, max) {
    return Math.min(Math.max(min, val), max);
}
function pow2(n) {
    return (n >= 0 && n < 31) ? (1 << n) : Math.pow(2, n);
}
function RemapValClamped(val, A, B, C, D) {
    if (A == B) {
        return val >= B ? D : C;
    }
    let cVal = (val - A) / (B - A);
    cVal = Math.min(Math.max(0.0, cVal), 1.0); //clamp(cVal, 0.0, 1.0);
    return C + (D - C) * cVal;
}
function RemapValClampedBias(val, A, B, C, D, bias) {
    if (A == B) {
        return val >= B ? D : C;
    }
    let cVal = (val - A) / (B - A);
    cVal = Math.min(Math.max(0.0, cVal), 1.0); //clamp(cVal, 0.0, 1.0);
    if (bias != 0.5) {
        cVal = Bias(cVal, bias);
    }
    return C + (D - C) * cVal;
}
// SIMD versions of mathlib simplespline functions
// hermite basis function for smooth interpolation
// Similar to Gain() above, but very cheap to call
// value should be between 0 & 1 inclusive
function SimpleSpline(value) {
    const valueSquared = value * value;
    return (3 * valueSquared) - (2 * value * valueSquared);
    /*// Arranged to avoid a data dependency between these two MULs:
    fltx4 valueDoubled = MulSIMD(value, Four_Twos);
    fltx4 valueSquared = MulSIMD(value, value);

    // Nice little ease-in, ease-out spline-like curve
    return SubSIMD(
        MulSIMD(Four_Threes,	valueSquared),
        MulSIMD(valueDoubled, valueSquared));*/
}
/**
 * Generates a random vector within two given vectors
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} a the second operand
 * @returns {vec3} out
 */
function vec3RandomBox(out, a, b) {
    const ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2];
    out[0] = (bx - ax) * Math.random() + ax;
    out[1] = (by - ay) * Math.random() + ay;
    out[2] = (bz - az) * Math.random() + az;
    return out;
}
/**
 * Clamp each component of vec3 to scalar values
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to clamp
 * @param {Number} min Min value
 * @param {Number} max Max value
 * @returns {vec3} out
 */
function vec3ClampScalar(out, a, min, max) {
    out[0] = clamp$1(a[0], min, max);
    out[1] = clamp$1(a[1], min, max);
    out[2] = clamp$1(a[2], min, max);
    return out;
}
function RandomFloat(min, max) {
    return Math.random() * (max - min) + min;
}
function RandomFloatExp(min, max, exponent) {
    const rand = Math.pow(Math.random(), exponent);
    return rand * (max - min) + min;
}
/**
 * Computes the mid point of two vectors
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function Vec3Middle(out, a, b) {
    const ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2];
    out[0] = (bx + ax) * 0.5;
    out[1] = (by + ay) * 0.5;
    out[2] = (bz + az) * 0.5;
    return out;
}
/**
 * Same as quat.fromEuler with angles in radians
 */
function quatFromEulerRad(out, x, y, z) {
    const halfToRad = 0.5;
    x *= halfToRad;
    y *= halfToRad;
    z *= halfToRad;
    const sx = Math.sin(x);
    const cx = Math.cos(x);
    const sy = Math.sin(y);
    const cy = Math.cos(y);
    const sz = Math.sin(z);
    const cz = Math.cos(z);
    out[0] = sx * cy * cz - cx * sy * sz;
    out[1] = cx * sy * cz + sx * cy * sz;
    out[2] = cx * cy * sz - sx * sy * cz;
    out[3] = cx * cy * cz + sx * sy * sz;
    return out;
}
function isNumeric(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
}
function lerp(min, max, v) {
    return min + (max - min) * v;
}
function ceilPowerOfTwo(n) {
    if (n === 0) {
        return 1;
    }
    n--;
    n |= n >> 1;
    n |= n >> 2;
    n |= n >> 4;
    n |= n >> 8;
    n |= n >> 16;
    return n + 1;
}
function RandomVectorInUnitSphere(out) {
    // Guarantee uniform random distribution within a sphere
    // Graphics gems III contains this algorithm ('Nonuniform random point sets via warping')
    const u = Math.random(); //RandomFloat(nRandomSampleId, 0.0f, 1.0f);
    const v = Math.random(); //RandomFloat(nRandomSampleId+1, 0.0f, 1.0f);
    const w = Math.random(); //RandomFloat(nRandomSampleId+2, 0.0f, 1.0f);
    const flPhi = Math.acos(1 - 2 * u);
    const flTheta = 2 * Math.PI * v;
    const flRadius = Math.pow(w, 1.0 / 3.0);
    const flSinPhi = Math.sin(flPhi);
    const flCosPhi = Math.cos(flPhi);
    const flSinTheta = Math.sin(flTheta);
    const flCosTheta = Math.cos(flTheta);
    //SinCos(flPhi, &flSinPhi, &flCosPhi);
    //SinCos(flTheta, &flSinTheta, &flCosTheta);
    out[0] = flRadius * flSinPhi * flCosTheta;
    out[1] = flRadius * flSinPhi * flSinTheta;
    out[2] = flRadius * flCosPhi;
    return flRadius;
}
function ExponentialDecay(decayTo, decayTime, dt) {
    return Math.exp(Math.log(decayTo) / decayTime * dt);
}
function Bias(value, bias) {
    return Math.pow(value, Math.log(bias) * -1.4427);
}
function generateRandomUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        const r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

var PropertyType;
(function (PropertyType) {
    PropertyType["Null"] = "null";
    PropertyType["Undefined"] = "undefined";
    PropertyType["String"] = "string";
    PropertyType["Number"] = "number";
    PropertyType["Bigint"] = "bigint";
    PropertyType["Boolean"] = "boolean";
    PropertyType["Array"] = "array";
    PropertyType["Object"] = "object";
})(PropertyType || (PropertyType = {}));
class Property {
    type;
    value;
    constructor(type, value) {
        this.type = type;
        this.value = value;
    }
}
class Properties {
    #properties = new Map();
    set(name, property) {
        this.#properties.set(name, property);
    }
    delete(name) {
        this.#properties.delete(name);
    }
    get(name) {
        return this.#properties.get(name);
    }
    copy(source, keys) {
        if (keys) {
            for (const key of keys) {
                const value = source.get(key);
                if (value) {
                    this.set(key, value);
                }
            }
        }
        else {
            for (const [key, value] of source.#properties) {
                this.set(key, value);
            }
        }
    }
    setString(name, value) {
        this.#properties.set(name, new Property(PropertyType.String, value));
    }
    getString(name) {
        const prop = this.#properties.get(name);
        if (prop?.type == PropertyType.String) {
            return prop.value;
        }
    }
    setBoolean(name, value) {
        this.#properties.set(name, new Property(PropertyType.Boolean, value));
    }
    getBoolean(name) {
        const prop = this.#properties.get(name);
        if (prop?.type == PropertyType.Boolean) {
            return prop.value;
        }
    }
    setNumber(name, value) {
        this.#properties.set(name, new Property(PropertyType.Number, value));
    }
    getNumber(name) {
        const prop = this.#properties.get(name);
        if (prop?.type == PropertyType.Number) {
            return prop.value;
        }
    }
    setBigint(name, value) {
        this.#properties.set(name, new Property(PropertyType.Bigint, value));
    }
    getBigint(name) {
        const prop = this.#properties.get(name);
        if (prop?.type == PropertyType.Bigint) {
            return prop.value;
        }
    }
    setArray(name, value) {
        this.#properties.set(name, new Property(PropertyType.Array, value));
    }
    getArray(name) {
        const prop = this.#properties.get(name);
        if (prop?.type == PropertyType.Array) {
            return prop.value;
        }
    }
    setObject(name, value) {
        this.#properties.set(name, new Property(PropertyType.Object, value));
    }
    getObject(name) {
        const prop = this.#properties.get(name);
        if (prop?.type == PropertyType.Object) {
            return prop.value;
        }
    }
}

function FileNameFromPath(path) {
    const startIndex = path.lastIndexOf('/') + 1;
    const endIndex = path.lastIndexOf('.');
    return path.slice(startIndex, endIndex == -1 ? undefined : endIndex);
}
function stringToVec3(s, v = vec3.create()) {
    const arr = s.split(' ');
    if (arr.length == 3) {
        return vec3.set(v, Number(arr[0]), Number(arr[1]), Number(arr[2]));
    }
    return v;
}
function stringToQuat(s, q = quat.create()) {
    const arr = s.split(' ');
    if (arr.length == 4) {
        return quat.set(q, Number(arr[0]), Number(arr[1]), Number(arr[2]), Number(arr[3]));
    }
    return q;
}

var EntityObserverEventType;
(function (EntityObserverEventType) {
    EntityObserverEventType["ParentChanged"] = "parentchanged";
    EntityObserverEventType["ChildAdded"] = "childadded";
    EntityObserverEventType["ChildRemoved"] = "childremoved";
    EntityObserverEventType["EntityDeleted"] = "entitydeleted";
    EntityObserverEventType["PropertyChanged"] = "propertychanged";
    EntityObserverEventType["AttributeChanged"] = "attributechanged";
})(EntityObserverEventType || (EntityObserverEventType = {}));
class EntityObserverClass extends MyEventTarget {
    parentChanged(child, oldParent, newParent) {
        this.dispatchEvent(new CustomEvent(EntityObserverEventType.ParentChanged, { detail: { child: child, oldParent: oldParent, newParent: newParent } }));
    }
    childAdded(parent, child) {
        this.dispatchEvent(new CustomEvent(EntityObserverEventType.ChildAdded, { detail: { child: child, parent: parent } }));
    }
    childRemoved(parent, child) {
        this.dispatchEvent(new CustomEvent(EntityObserverEventType.ChildRemoved, { detail: { child: child, parent: parent } }));
    }
    entityDeleted(entity) {
        this.dispatchEvent(new CustomEvent(EntityObserverEventType.EntityDeleted, { detail: { entity: entity } }));
    }
    propertyChanged(entity, propertyName, oldValue, newValue) {
        this.dispatchEvent(new CustomEvent(EntityObserverEventType.PropertyChanged, { detail: { entity: entity, propertyName: propertyName, newPropertyValue: newValue, oldPropertyValue: oldValue } }));
    }
    attributeChanged(entity, attributeName, oldValue, newValue) {
        this.dispatchEvent(new CustomEvent(EntityObserverEventType.AttributeChanged, { detail: { entity: entity, attributeName: attributeName, newAttributeValue: newValue, oldAttributeValue: oldValue } }));
    }
}
const EntityObserver = new EntityObserverClass();

const pickList = new Map();

const X_VECTOR = vec3.fromValues(1, 0, 0);
const Y_VECTOR = vec3.fromValues(0, 1, 0);
const Z_VECTOR$2 = vec3.fromValues(0, 0, 1);
const tempVec3_1$3 = vec3.create();
const tempVec3_2$a = vec3.create();
const tempVec3_3$2 = vec3.create();
const tempVec3_4$1 = vec3.create();
const tempQuat$c = quat.create();
const tempQuat2$1 = quat.create();
const tempQuat3 = quat.create();
const tempMat4$4 = mat4.create();
const _upVector = vec3.fromValues(0, 0, 1);
let incrementalPickingId = 0;
const IDENTITY_QUAT$1 = quat.create();
const IDENTITY_VEC3 = vec3.create();
const UNITY_VEC3 = vec3.fromValues(1, 1, 1);
const LAYER_MAX = 50;
var EngineEntityAttributes;
(function (EngineEntityAttributes) {
    EngineEntityAttributes["IsTool"] = "is tool";
})(EngineEntityAttributes || (EngineEntityAttributes = {}));
class Entity {
    static addSubMenu;
    id = generateRandomUUID();
    #wireframe = 0;
    #hideInExplorer = false;
    #serializable = true;
    #castShadow;
    #receiveShadow;
    #visible;
    #playing = true;
    #worldMatrix = mat4.create();
    #name = '';
    #children = new Set();
    #attributes = new Map();
    #pickingColor;
    enumerable = true;
    animable = false;
    resetable = false;
    _position = vec3.create();
    _quaternion = quat.create();
    _scale = vec3.clone(UNITY_VEC3);
    _mvMatrix = mat4.create();
    _normalMatrix = mat3.create();
    _parent = null;
    materialsParams = {};
    isRenderable = false;
    lockPos = false;
    lockRot = false;
    //lockScale = false;
    drawOutline = false;
    locked = false; // Prevents updates from animation system
    lockPosition = false;
    lockRotation = false;
    lockScale = false;
    static editMaterial;
    properties = new Properties(); //Map<string, any>();
    loadedPromise;
    #layer = undefined;
    constructor(params) {
        this.setParameters(params);
    }
    setParameters(parameters) {
        if (!parameters) {
            return;
        }
        if (parameters.name) {
            this.#name = parameters.name;
        }
        if (parameters.parent) {
            this.parent = parameters.parent;
        }
        if (parameters.childs) {
            parameters.childs.forEach((child) => this.addChild(child));
        }
        if (parameters.position) {
            this.position = parameters.position;
        }
        if (parameters.quaternion) {
            this.quaternion = parameters.quaternion;
        }
        if (parameters.scale) {
            this.scale = parameters.scale;
        }
        if (parameters.hideInExplorer) {
            this.hideInExplorer = parameters.hideInExplorer;
        }
        if (parameters.castShadow) {
            this.castShadow = parameters.castShadow;
        }
        if (parameters.receiveShadow) {
            this.receiveShadow = parameters.receiveShadow;
        }
        if (parameters.visible !== undefined) {
            this.setVisible(parameters.visible);
        }
    }
    set name(name) {
        const oldValue = this.#name;
        this.#name = name;
        if (oldValue != name) {
            EntityObserver.propertyChanged(this, 'name', oldValue, name);
        }
    }
    get name() {
        return this.#name;
    }
    setPosition(position) {
        if (this.lockPosition) {
            return;
        }
        const oldValue = vec3.copy(tempVec3_4$1, this._position);
        vec3.copy(this._position, position);
        if (!vec3.exactEquals(oldValue, position)) {
            EntityObserver.propertyChanged(this, 'position', oldValue, position);
        }
    }
    getPosition(position = vec3.create()) {
        return vec3.copy(position, this._position);
    }
    /**
     * @deprecated Please use `setPosition` instead.
     */
    set position(position) {
        // TODO: deprecate
        this.setPosition(position);
    }
    /**
     * @deprecated Please use `getPosition` instead.
     */
    get position() {
        // TODO: deprecate
        return this.getPosition();
    }
    getWorldPosition(vec = vec3.create()) {
        if (this._parent) {
            this._parent.getWorldPosition(vec);
            this._parent.getWorldQuaternion(tempQuat$c);
            vec3.mul(tempVec3_3$2, this._position, this._parent.getWorldScale(tempVec3_3$2));
            vec3.transformQuat(tempVec3_3$2, tempVec3_3$2, tempQuat$c);
            vec3.add(vec, vec, tempVec3_3$2);
        }
        else {
            vec3.copy(vec, this._position);
        }
        return vec;
    }
    getPositionFrom(other, vec = vec3.create()) {
        this.getWorldPosition(tempVec3_1$3);
        other.getWorldPosition(tempVec3_2$a);
        return vec3.sub(vec, tempVec3_2$a, tempVec3_1$3);
    }
    setWorldPosition(position) {
        if (this._parent) {
            this._parent.getWorldPosition(tempVec3_1$3);
            this._parent.getWorldQuaternion(tempQuat$c);
            vec3.sub(tempVec3_1$3, position, tempVec3_1$3);
            quat.invert(tempQuat$c, tempQuat$c);
            vec3.transformQuat(tempVec3_1$3, tempVec3_1$3, tempQuat$c);
            this.position = tempVec3_1$3;
        }
        else {
            this.position = position;
        }
    }
    getWorldQuaternion(q = quat.create()) {
        if (this._parent) {
            this._parent.getWorldQuaternion(q);
            quat.mul(q, q, this._quaternion);
        }
        else {
            quat.copy(q, this._quaternion);
        }
        return q;
    }
    setWorldQuaternion(quaternion) {
        if (this._parent) {
            this._parent.getWorldQuaternion(tempQuat$c);
            quat.invert(tempQuat$c, tempQuat$c);
            quat.mul(this._quaternion, tempQuat$c, quaternion);
        }
        else {
            quat.copy(this._quaternion, quaternion);
        }
    }
    getWorldScale(vec = vec3.create()) {
        if (this._parent) {
            this._parent.getWorldScale(vec);
            vec3.mul(vec, vec, this._scale);
        }
        else {
            vec3.copy(vec, this._scale);
        }
        return vec;
    }
    get positionAsString() {
        return `${this._position[0].toFixed(2)} ${this._position[1].toFixed(2)} ${this._position[2].toFixed(2)}`;
    }
    setQuaternion(quaternion) {
        if (this.lockRotation) {
            return;
        }
        const oldValue = quat.copy(tempQuat3, this._quaternion);
        quat.normalize(this._quaternion, quaternion);
        if (!quat.exactEquals(oldValue, this._quaternion)) {
            EntityObserver.propertyChanged(this, 'quaternion', oldValue, this._quaternion);
        }
    }
    getQuaternion(quaternion = quat.create()) {
        return quat.copy(quaternion, this._quaternion);
    }
    /**
     * @deprecated Please use `setQuaternion` instead.
     */
    set quaternion(quaternion) {
        this.setQuaternion(quaternion);
    }
    /**
     * @deprecated Please use `getQuaternion` instead.
     */
    get quaternion() {
        return this.getQuaternion();
    }
    get quaternionAsString() {
        return `${this._quaternion[0].toFixed(2)} ${this._quaternion[1].toFixed(2)} ${this._quaternion[2].toFixed(2)} ${this._quaternion[3].toFixed(2)}`;
    }
    set scale(scale) {
        if (this.lockScale) {
            return;
        }
        vec3.copy(this._scale, scale);
    }
    get scale() {
        return vec3.clone(this._scale);
    }
    get worldMatrix() {
        //TODO: optimize
        this.getWorldPosition(tempVec3_1$3);
        this.getWorldQuaternion(tempQuat$c);
        //console.error(...tempVec3_1);
        mat4.fromRotationTranslationScale(this.#worldMatrix, tempQuat$c, tempVec3_1$3, this.getWorldScale());
        return this.#worldMatrix;
    }
    render(canvas) {
    }
    get transparent() {
        return false;
    }
    setVisible(visible) {
        const oldValue = this.#visible;
        this.#visible = visible;
        if (oldValue != visible) {
            EntityObserver.propertyChanged(this, 'visible', oldValue, visible);
        }
    }
    /**
     * @deprecated Please use `setVisible` instead.
     */
    set visible(visible) {
        this.setVisible(visible);
    }
    isVisible() {
        if (this.#visible === undefined) {
            return this._parent?.isVisible() ?? true;
        }
        else {
            return this.#visible;
        }
    }
    isVisibleSelf() {
        return this.#visible;
    }
    /**
     * @deprecated Please use `isVisible` instead.
     */
    get visible() {
        return this.isVisible();
    }
    /**
     * @deprecated Please use `isVisibleSelf` instead.
     */
    get visibleSelf() {
        return this.#visible;
    }
    toggleVisibility() {
        const oldValue = this.#visible;
        if (this.#visible === undefined) {
            if (this.isVisible()) {
                this.setVisible(false);
            }
            else {
                this.setVisible(true);
            }
        }
        else if (this.#visible === true) {
            if (this._parent) {
                if (this._parent.isVisible()) {
                    this.setVisible(false);
                }
                else {
                    this.setVisible(undefined);
                }
            }
            else {
                this.setVisible(false);
            }
        }
        else { // false
            if (this._parent) {
                if (this._parent.isVisible()) {
                    this.setVisible(undefined);
                }
                else {
                    this.setVisible(true);
                }
            }
            else {
                this.setVisible(undefined);
            }
        }
        if (oldValue != this.#visible) {
            EntityObserver.propertyChanged(this, 'visible', oldValue, this.#visible);
        }
    }
    setPlaying(playing) {
        const oldValue = this.#playing;
        this.#playing = playing;
        if (oldValue != playing) {
            EntityObserver.propertyChanged(this, 'playing', oldValue, playing);
        }
    }
    isPlaying() {
        return this.#playing;
    }
    togglePlaying() {
        this.setPlaying(!this.#playing);
    }
    do(action, params) { }
    #setParent(parent) {
        EntityObserver.parentChanged(this, this._parent, parent);
        if (this._parent != null) {
            this._parent.removeChild(this);
        }
        if (this._parent != parent) {
            this._parent = parent;
        }
        this.#propagate();
        this.parentChanged(parent);
    }
    parentChanged(parent) { }
    *getParentIterator() {
        const ws = new WeakSet();
        let current = this._parent;
        while (current) {
            ws.add(current);
            yield current;
            current = current.parent;
            if (!current || ws.has(current)) {
                return null;
            }
        }
    }
    remove() {
        if (this._parent != null) {
            this.#setParent(null);
        }
    }
    removeThis() {
        for (const child of this.#children) {
            child.parent = this.parent;
        }
        this.remove();
    }
    removeChildren() {
        for (const child of this.#children) {
            child.remove();
        }
    }
    disposeChildren() {
        for (const child of this.#children) {
            child.dispose();
        }
    }
    removeSiblings() {
        if (this._parent != null) {
            for (const child of this._parent.#children) {
                if (child !== this) {
                    child.remove();
                }
            }
        }
    }
    removeSimilarSiblings() {
        if (this._parent != null) {
            const constructorName = this.constructor.name;
            for (const child of this._parent.#children) {
                if (child !== this && child.constructor.name === constructorName) {
                    child.remove();
                }
            }
        }
    }
    set parent(parent) {
        if (parent) {
            parent.addChild(this);
        }
        /*if (parent instanceof Entity) {
        } else {
            if (DEBUG) {
                console.log(parent, ' is not instanceof Entity');
            }
        }*/
    }
    get parent() {
        return this._parent;
    }
    get root() {
        let currentEntity = this;
        let parent;
        while (currentEntity) {
            parent = currentEntity._parent;
            if (parent) {
                currentEntity = parent;
            }
            else {
                return currentEntity;
            }
        }
        return currentEntity;
    }
    addChild(child) {
        if (!child) {
            return;
        }
        if (!(child instanceof Entity)) {
            return;
        }
        if (child === this) {
            return;
        }
        if (this.#children.has(child)) {
            return;
        }
        if (this.isParent(child)) {
            return;
        }
        this.#children.add(child);
        EntityObserver.childAdded(this, child);
        child.#setParent(this);
        return child;
    }
    addChilds(...childs) {
        childs.forEach(child => this.addChild(child));
    }
    isParent(parent) {
        const _parent = this._parent;
        if (_parent) {
            if (_parent === parent) {
                return true;
            }
            else {
                return _parent.isParent(parent);
            }
        }
        return false;
    }
    removeChild(child) {
        if (child && this.#children.has(child)) {
            this.#children.delete(child);
            child.#setParent(null);
            EntityObserver.childRemoved(this, child);
        }
    }
    toString() {
        return this.#name !== undefined ? this.#name : '';
    }
    translate(v) {
        vec3.add(tempVec3_1$3, this._position, v);
        this.position = tempVec3_1$3;
    }
    translateOnAxis(axis, distance) {
        vec3.transformQuat(tempVec3_1$3, axis, this._quaternion);
        vec3.scaleAndAdd(tempVec3_1$3, this._position, tempVec3_1$3, distance);
        this.position = tempVec3_1$3;
        return this;
    }
    translateX(distance) {
        return this.translateOnAxis(X_VECTOR, distance);
    }
    translateY(distance) {
        return this.translateOnAxis(Y_VECTOR, distance);
    }
    translateZ(distance) {
        return this.translateOnAxis(Z_VECTOR$2, distance);
    }
    rotateX(rad) {
        quat.rotateX(this._quaternion, this._quaternion, rad);
        this.locked = true;
    }
    rotateY(rad) {
        quat.rotateY(this._quaternion, this._quaternion, rad);
        this.locked = true;
    }
    rotateZ(rad) {
        quat.rotateZ(this._quaternion, this._quaternion, rad);
        this.locked = true;
    }
    rotateGlobalX(rad) {
        quat.rotateX(tempQuat$c, IDENTITY_QUAT$1, rad);
        quat.mul(this._quaternion, tempQuat$c, this._quaternion);
        this.locked = true;
    }
    rotateGlobalY(rad) {
        quat.rotateY(tempQuat$c, IDENTITY_QUAT$1, rad);
        quat.mul(this._quaternion, tempQuat$c, this._quaternion);
        this.locked = true;
    }
    rotateGlobalZ(rad) {
        quat.rotateZ(tempQuat$c, IDENTITY_QUAT$1, rad);
        quat.mul(this._quaternion, tempQuat$c, this._quaternion);
        this.locked = true;
    }
    /**
     * Makes this object look at the specified location.
     *
     * @param {Float32Array(3)} target Point in space to look at.
     *
     * @return {void}.
     */
    lookAt(target, upVector) {
        const parent = this._parent;
        mat4.lookAt(tempMat4$4, this._position, target, upVector ?? _upVector);
        mat4.getRotation(tempQuat$c, tempMat4$4);
        quat.invert(tempQuat$c, tempQuat$c);
        if (parent) {
            quat.conjugate(tempQuat2$1, parent._quaternion);
            quat.mul(tempQuat$c, tempQuat2$1, tempQuat$c);
        }
        this.quaternion = tempQuat$c;
    }
    getMeshList() {
        const meshList = new Set();
        const treated = new WeakSet();
        let currentEntity = this;
        const objectStack = [];
        while (currentEntity) {
            if (currentEntity.isRenderable && (currentEntity.isVisible() !== false)) {
                meshList.add(currentEntity);
            }
            for (const child of currentEntity.#children) {
                if (!treated.has(child)) {
                    objectStack.push(child);
                    treated.add(child);
                }
            }
            currentEntity = objectStack.shift();
        }
        return meshList;
    }
    showOutline(show, color) {
        if (show) {
            this.drawOutline = true;
            this.materialsParams.drawOutline = true;
            if (color) {
                this.materialsParams.outlineColor = color;
            }
        }
        else {
            this.drawOutline = false;
            this.materialsParams.drawOutline = false;
        }
    }
    getAllChilds(includeSelf) {
        const ws = new WeakSet();
        const childs = new Set();
        const objectStack = [];
        let currentEntity = this;
        if (includeSelf) {
            childs.add(this);
        }
        while (currentEntity) {
            for (const child of currentEntity.#children) {
                if (!ws.has(child)) {
                    objectStack.push(child);
                    childs.add(child);
                    ws.add(child);
                }
            }
            currentEntity = objectStack.shift();
        }
        return childs;
    }
    getBoundsModelSpace(min = vec3.create(), max = vec3.create()) {
        //TODO: deprecate
        if (this.#children.size > 0) {
            min[0] = Infinity;
            min[1] = Infinity;
            min[2] = Infinity;
            max[0] = -Infinity;
            max[1] = -Infinity;
            max[2] = -Infinity;
            for (const child of this.#children) {
                child.getBoundsModelSpace(tempVec3_1$3, tempVec3_2$a);
                vec3.min(min, min, tempVec3_1$3);
                vec3.max(max, max, tempVec3_2$a);
            }
        }
        else {
            min[0] = 0;
            min[1] = 0;
            min[2] = 0;
            max[0] = 0;
            max[1] = 0;
            max[2] = 0;
        }
    }
    getBoundingBox(boundingBox = new BoundingBox()) {
        boundingBox.reset();
        const childBoundingBox = new BoundingBox();
        for (const child of this.#children) {
            if (child.isVisible()) {
                boundingBox.addBoundingBox(child.getBoundingBox(childBoundingBox));
            }
        }
        return boundingBox;
    }
    getParentModel() {
        return this._parent?.getParentModel();
    }
    getChildList(type) {
        const ws = new WeakSet();
        const childs = new Set();
        const objectStack = [];
        let currentEntity = this;
        while (currentEntity) {
            for (const child of currentEntity.#children) {
                if (!ws.has(child) && child.enumerable) {
                    objectStack.push(child);
                    ws.add(child);
                }
            }
            if (type === undefined || currentEntity.is(type)) {
                childs.add(currentEntity);
            }
            currentEntity = objectStack.shift();
        }
        return childs;
    }
    forEach(callback) {
        callback(this);
        for (const child of this.#children) {
            child.forEach(callback);
        }
    }
    forEachVisible(callback) {
        if (this.#visible) {
            callback(this);
            for (const child of this.#children) {
                child.forEach(callback);
            }
        }
    }
    forEachParent(callback) {
        const parent = this._parent;
        if (parent) {
            callback(parent);
            parent.forEachParent(callback);
        }
    }
    setupPickingId() {
        const pickingId = ++incrementalPickingId;
        pickList.set(pickingId, this);
        this.#pickingColor = vec3.fromValues(((pickingId >> 16) & 0xFF) / 255.0, ((pickingId >> 8) & 0xFF) / 255.0, ((pickingId >> 0) & 0xFF) / 255.0);
    }
    get pickingColor() {
        return this.#pickingColor ?? this._parent?.pickingColor;
    }
    update(scene, camera, delta) {
    }
    set castShadow(castShadow) {
        this.#castShadow = castShadow;
    }
    get castShadow() {
        if (this.#castShadow === undefined) {
            return this._parent ? this._parent.castShadow : true;
        }
        else {
            return this.#castShadow;
        }
    }
    toggleCastShadow() {
        if (this.#castShadow === undefined) {
            if (this.castShadow) {
                this.castShadow = false;
            }
            else {
                this.castShadow = true;
            }
        }
        else if (this.#castShadow === true) {
            if (this._parent?.castShadow) {
                this.castShadow = false;
            }
            else {
                this.castShadow = undefined;
            }
        }
        else {
            if (this._parent?.castShadow) {
                this.castShadow = undefined;
            }
            else {
                this.castShadow = true;
            }
        }
    }
    set receiveShadow(receiveShadow) {
        this.#receiveShadow = receiveShadow;
    }
    get receiveShadow() {
        if (this.#receiveShadow === undefined) {
            return this._parent ? this._parent.receiveShadow : true;
        }
        else {
            return this.#receiveShadow;
        }
    }
    toggleReceiveShadow() {
        if (this.#receiveShadow === undefined) {
            if (this.receiveShadow) {
                this.receiveShadow = false;
            }
            else {
                this.receiveShadow = true;
            }
        }
        else if (this.#receiveShadow === true) {
            if (this._parent?.receiveShadow) {
                this.receiveShadow = false;
            }
            else {
                this.receiveShadow = undefined;
            }
        }
        else {
            if (this._parent?.receiveShadow) {
                this.receiveShadow = undefined;
            }
            else {
                this.receiveShadow = true;
            }
        }
    }
    set serializable(serializable) {
        this.#serializable = serializable;
    }
    get serializable() {
        return this.#serializable;
    }
    set hideInExplorer(hideInExplorer) {
        this.#hideInExplorer = hideInExplorer;
    }
    get hideInExplorer() {
        return this.#hideInExplorer;
    }
    buildContextMenu() {
        const menu = {
            visibility: { i18n: '#visibility', selected: this.isVisible(), f: () => this.toggleVisibility() },
            remove: { i18n: '#remove', f: () => this.remove() },
            destroy: { i18n: '#destroy', f: () => this.dispose() },
            remove_more: {
                i18n: '#remove_more', submenu: [
                    { i18n: '#remove_this', f: () => this.removeThis() },
                    { i18n: '#remove_childs', f: () => this.removeChildren() },
                    { i18n: '#remove_siblings', f: () => this.removeSiblings() },
                    { i18n: '#remove_similar_siblings', f: () => this.removeSimilarSiblings() },
                ]
            },
            name: { i18n: '#name', f: () => { const n = prompt('Name', this.name); if (n !== null) {
                    this.name = n;
                } } },
            add: { i18n: '#add', submenu: Entity.addSubMenu },
            entitynull_1: null,
            position: { i18n: '#position', f: () => { const v = prompt('Position', this.position.join(' ')); if (v !== null) {
                    this.lockPos = true;
                    this.position = stringToVec3(v);
                } } },
            translate: { i18n: '#translate', f: () => { const t = prompt('Translation', '0 0 0'); if (t !== null) {
                    this.lockPos = true;
                    this.translate(stringToVec3(t));
                } } },
            reset_position: { i18n: '#reset_position', f: () => this.position = IDENTITY_VEC3 },
            entitynull_2: null,
            quaternion: { i18n: '#quaternion', f: () => { const v = prompt('Quaternion', this.quaternion.join(' ')); if (v !== null) {
                    this.lockRot = true;
                    this.quaternion = stringToQuat(v);
                } } },
            rotate: {
                i18n: '#rotate', submenu: [
                    { i18n: '#rotate_x_global', f: () => { const r = Number(prompt('Rotation around X global', '0')); if (r !== null) {
                            this.lockRot = true;
                            this.rotateGlobalX(r * DEG_TO_RAD);
                        } } },
                    { i18n: '#rotate_y_global', f: () => { const r = Number(prompt('Rotation around Y global', '0')); if (r !== null) {
                            this.lockRot = true;
                            this.rotateGlobalY(r * DEG_TO_RAD);
                        } } },
                    { i18n: '#rotate_z_global', f: () => { const r = Number(prompt('Rotation around Z global', '0')); if (r !== null) {
                            this.lockRot = true;
                            this.rotateGlobalZ(r * DEG_TO_RAD);
                        } } },
                    { i18n: '#rotate_x', f: () => { const r = Number(prompt('Rotation around X', '0')); if (r !== null) {
                            this.lockRot = true;
                            this.rotateX(r * DEG_TO_RAD);
                        } } },
                    { i18n: '#rotate_y', f: () => { const r = Number(prompt('Rotation around Y', '0')); if (r !== null) {
                            this.lockRot = true;
                            this.rotateY(r * DEG_TO_RAD);
                        } } },
                    { i18n: '#rotate_z', f: () => { const r = Number(prompt('Rotation around Z', '0')); if (r !== null) {
                            this.lockRot = true;
                            this.rotateZ(r * DEG_TO_RAD);
                        } } },
                ]
            },
            reset_rotation: { i18n: '#reset_rotation', f: () => this.quaternion = IDENTITY_QUAT$1 },
            entitynull_3: null,
            scale: {
                i18n: '#scale', f: () => {
                    const s = prompt('Scale', this.scale.join(' '));
                    if (s !== null) {
                        const arr = s.split(' ');
                        if (arr.length == 3) {
                            this.scale = vec3.set(tempVec3_1$3, Number(arr[0]), Number(arr[1]), Number(arr[2]));
                        }
                        else if (arr.length == 1) {
                            this.scale = vec3.set(tempVec3_1$3, Number(arr[0]), Number(arr[0]), Number(arr[0]));
                        }
                    }
                }
            },
            reset_scale: { i18n: '#reset_scale', f: () => this.scale = UNITY_VEC3 },
            entitynull_4: null,
            wireframe: { i18n: '#wireframe', selected: this.wireframe > 0, f: () => this.toggleWireframe() },
            cast_shadows: { i18n: '#cast_shadows', selected: this.castShadow, f: () => this.toggleCastShadow() },
            receive_shadows: { i18n: '#receive_shadows', selected: this.receiveShadow, f: () => this.toggleReceiveShadow() },
            material: { i18n: '#material', submenu: {} },
        };
        if (this.material) {
            Object.assign(menu.material.submenu, {
                entitynull_5: null,
                edit_material: { i18n: '#edit_material', f: () => Entity.editMaterial(this) }
            });
        }
        return menu;
    }
    raycast(raycaster, intersections) {
    }
    setWireframe(wireframe, recursive = true) {
        this.wireframe = wireframe;
        if (recursive) {
            for (const child of this.#children) {
                child.setWireframe(wireframe, recursive);
            }
        }
    }
    set wireframe(wireframe) {
        this.#wireframe = wireframe;
    }
    get wireframe() {
        return this.#wireframe ?? this._parent?.wireframe ?? 0;
    }
    get children() {
        return this.#children;
    }
    toggleWireframe() {
        if (this.#wireframe === undefined) {
            switch (this.wireframe) {
                case 0:
                    this.wireframe = 1;
                    break;
                case 1:
                    this.wireframe = 2;
                    break;
                case 2:
                    this.wireframe = 0;
                    break;
            }
        }
        else {
            //switch (this._parent?.wireframe) {
            let target;
            switch (this.wireframe) {
                case 0:
                    target = 1;
                    break;
                case 1:
                    target = 2;
                    break;
                case 2:
                    target = 0;
                    break;
            }
            if (this._parent?.wireframe === target) {
                this.wireframe = undefined;
            }
            else {
                this.wireframe = target;
            }
        }
    }
    dispose() {
        this.remove();
        EntityObserver.entityDeleted(this);
    }
    replaceMaterial(material, recursive = true) {
        if (recursive) {
            for (const child of this.#children) {
                child.replaceMaterial(material, recursive);
            }
        }
    }
    resetMaterial(recursive = true) {
        if (recursive) {
            for (const child of this.#children) {
                child.resetMaterial(recursive);
            }
        }
    }
    setAttribute(attributeName, attributeValue) {
        const oldValue = this.#attributes.get(attributeName);
        this.#attributes.set(attributeName, attributeValue);
        EntityObserver.attributeChanged(this, attributeName, oldValue, attributeValue);
        this.#propagate();
    }
    getAttribute(attributeName, inherited = true) {
        if (this.#attributes.has(attributeName)) {
            return this.#attributes.get(attributeName);
        }
        if (inherited && this._parent) {
            return this._parent.getAttribute(attributeName, inherited);
        }
    }
    #propagate() {
        this.propagate();
        for (const child of this.#children) {
            child.#propagate();
        }
    }
    propagate() {
    }
    copy(source) {
        //TODO: should we copy world pos / quat ?
        vec3.copy(this._position, source._position);
        quat.copy(this._quaternion, source._quaternion);
        vec3.copy(this._scale, source._scale);
    }
    getProperty(name) {
        return this.properties.get(name);
    }
    setProperty(name, value) {
        return this.properties.set(name, value);
    }
    setLayer(layer) {
        if (Number.isNaN(Number(layer))) {
            this.#layer = undefined;
        }
        else {
            this.#layer = clamp$1(layer, 0, LAYER_MAX);
        }
    }
    getLayer() {
        if (this.#layer === undefined) {
            return this._parent?.getLayer() ?? undefined;
        }
        else {
            return this.#layer;
        }
    }
    setMaterialParam(name, value) {
        this.materialsParams[name] = value;
    }
    toJSON() {
        const children = [];
        for (const child of this.#children) {
            if (child.#serializable) {
                children.push(child.toJSON());
            }
        }
        const json = {
            constructor: this.constructor.getEntityName(),
            id: this.id,
            name: this.name
        };
        if (this.#visible !== undefined) {
            json.visible = this.#visible ? true : false;
        }
        if (!vec3.exactEquals(this._position, IDENTITY_VEC3)) {
            json.position = this.position;
        }
        if (!quat.exactEquals(this._quaternion, IDENTITY_QUAT$1)) {
            json.quaternion = this.quaternion;
        }
        if (!vec3.exactEquals(this._scale, UNITY_VEC3)) {
            json.scale = this.scale;
        }
        if (this.#castShadow !== undefined) {
            json.castshadow = this.#castShadow ? true : false;
        }
        if (this.#receiveShadow !== undefined) {
            json.receiveshadow = this.#receiveShadow ? true : false;
        }
        if (this.#hideInExplorer) {
            json.hideinexplorer = true;
        }
        if (this.materialsParams && Object.keys(this.materialsParams).length) {
            json.materialsparams = this.materialsParams;
        }
        if (children.length) {
            json.children = children;
        }
        if (this.wireframe !== undefined) {
            json.wireframe = this.wireframe;
        }
        if (this.#layer !== undefined) {
            json.layer = this.#layer;
        }
        return json;
    }
    static async constructFromJSON(json, entities, loadedPromise) {
        const entity = new Entity({ name: json.name });
        entity.fromJSON(json);
        return entity;
    }
    async createChild(entityName, parameters) {
        const entity = await JSONLoader.fromJSON({
            constructor: entityName,
            ...parameters,
        });
        if (entity) {
            this.addChild(entity);
            return entity;
        }
    }
    fromJSON(json) {
        this.id = json.id ?? generateRandomUUID();
        this.#name = json.name;
        this.#visible = json.visible;
        if (json.position) {
            this.position = json.position;
        }
        if (json.quaternion) {
            this.quaternion = json.quaternion;
        }
        if (json.scale) {
            this.scale = json.scale;
        }
        this.castShadow = json.castshadow;
        this.receiveShadow = json.receiveshadow;
        this.materialsParams = json.materialsparams;
        this.#hideInExplorer = json.hideinexplorer ?? false;
        this.wireframe = json.wireframe;
        this.#layer = json.layer;
    }
    static getEntityName() {
        return 'Entity';
    }
    is(s) {
        return s == 'Entity';
    }
}
registerEntity(Entity);

const TypedArrayProto = Object.getPrototypeOf(Int8Array); // we can't use TypedArray directly
var BufferUsage;
(function (BufferUsage) {
    BufferUsage[BufferUsage["StaticDraw"] = 35044] = "StaticDraw";
    BufferUsage[BufferUsage["DynamicDraw"] = 35048] = "DynamicDraw";
    BufferUsage[BufferUsage["StreamDraw"] = 35040] = "StreamDraw";
    BufferUsage[BufferUsage["StaticRead"] = 35045] = "StaticRead";
    BufferUsage[BufferUsage["DynamicRead"] = 35049] = "DynamicRead";
    BufferUsage[BufferUsage["StreamRead"] = 35041] = "StreamRead";
    BufferUsage[BufferUsage["StaticCopy"] = 35046] = "StaticCopy";
    BufferUsage[BufferUsage["DynamicCopy"] = 35050] = "DynamicCopy";
    BufferUsage[BufferUsage["StreamCopy"] = 35042] = "StreamCopy";
})(BufferUsage || (BufferUsage = {}));
class BufferAttribute {
    #type;
    #usage = BufferUsage.StaticDraw;
    #target;
    #wireframeDirty = true;
    #solidWireframeDirty = true;
    itemSize;
    dirty;
    _array;
    count = 0;
    _buffer = null;
    #source;
    divisor = 0;
    constructor(array, itemSize) {
        this.itemSize = itemSize;
        if (isNaN(this.itemSize)) {
            throw new TypeError('Argument itemSize must be an Integer');
        }
        this.#target = GL_ARRAY_BUFFER;
        this.#type = 0;
        //TODO: normalized ?
        this.dirty = true;
        if (array) {
            this.array = array;
        }
        return this;
    }
    get type() {
        return this.#type;
    }
    set usage(usage) {
        this.#usage = usage;
        this.dirty = true;
        this.#wireframeDirty = true;
        this.#solidWireframeDirty = true;
    }
    set target(target) {
        this.#target = target;
        this.dirty = true;
        this.#wireframeDirty = true;
        this.#solidWireframeDirty = true;
    }
    set array(array) {
        this.setArray(array);
    }
    setArray(array) {
        if (!(array instanceof TypedArrayProto)) {
            throw new TypeError('Argument array must be a TypedArray');
        }
        this._array = array;
        this.count = array.length / this.itemSize;
        this.dirty = true;
        this.#wireframeDirty = true;
        this.#solidWireframeDirty = true;
        switch (true) {
            case array instanceof Float32Array:
                this.#type = GL_FLOAT;
                break;
            case array instanceof Int8Array:
                this.#type = GL_BYTE;
                break;
            case array instanceof Int16Array:
                this.#type = GL_SHORT;
                break;
            case array instanceof Int32Array:
                this.#type = GL_INT;
                break;
            case array instanceof Uint8Array:
                this.#type = GL_UNSIGNED_BYTE;
                break;
            case array instanceof Uint16Array:
                this.#type = GL_UNSIGNED_SHORT;
                break;
            case array instanceof Uint32Array:
                this.#type = GL_UNSIGNED_INT;
                break;
            default:
                throw 'Unsupported array type';
        }
    }
    update(glContext) {
        if (this.dirty) {
            if (!this._buffer) {
                this._buffer = glContext.createBuffer(); //TODOv3: createBuffer in graphics
            }
            glContext.bindBuffer(this.#target, this._buffer);
            glContext.bufferData(this.#target, this._array, this.#usage);
            this.dirty = false;
            this.#wireframeDirty = true;
            this.#solidWireframeDirty = true;
        }
    }
    updateWireframe(glContext) {
        if (this.#wireframeDirty) {
            if (this._buffer === undefined) {
                this._buffer = glContext.createBuffer(); //TODOv3: createBuffer in graphics
            }
            const lineArray = new Uint32Array(2 * this._array.length);
            let a, b, c;
            const arr = this._array;
            let j = 0;
            for (let i = 0; i < arr.length; i += 3) {
                a = arr[i + 0];
                b = arr[i + 1];
                c = arr[i + 2];
                //lineArray.push(a, b, b, c, c, a);
                lineArray[j++] = a;
                lineArray[j++] = b;
                lineArray[j++] = b;
                lineArray[j++] = c;
                lineArray[j++] = c;
                lineArray[j++] = a;
            }
            glContext.bindBuffer(this.#target, this._buffer);
            glContext.bufferData(this.#target, lineArray, this.#usage);
            this.dirty = true;
            this.#wireframeDirty = false;
        }
    }
    clone() {
        return new this.constructor(this.#source, this.itemSize /*, this._array.byteOffset, this._array.byteLength*/);
    }
    setSource(source) {
        this.#source = source;
    }
    getBuffer() {
        return this._buffer;
    }
}
class Uint8BufferAttribute extends BufferAttribute {
    constructor(array, itemSize, offset, length) {
        super(null, itemSize);
        this.setSource(array);
        this.array = new Uint8Array(array);
    }
}
class Uint16BufferAttribute extends BufferAttribute {
    constructor(array, itemSize, offset, length) {
        super(null, itemSize);
        this.setSource(array);
        this.array = new Uint16Array(array, offset, length);
    }
}
class Uint32BufferAttribute extends BufferAttribute {
    constructor(array, itemSize, offset, length) {
        super(null, itemSize);
        this.setSource(array);
        this.array = new Uint32Array(array, offset, length);
    }
}
class Float32BufferAttribute extends BufferAttribute {
    constructor(array, itemSize, offset, length) {
        super(null, itemSize);
        this.setSource(array);
        this.array = new Float32Array(array, offset, length);
    }
}

class BufferGeometry {
    #elementArrayType = GL_UNSIGNED_INT;
    #users = new Set();
    attributes = new Map();
    dirty = true;
    count = 0;
    properties = new Properties(); //new Map<string, any>();
    getAttribute(name) {
        return this.attributes.get(name);
    }
    setAttribute(name, attribute) {
        this.attributes.set(name, attribute);
    }
    hasAttribute(name) {
        return this.attributes.has(name);
    }
    deleteAttribute(name) {
        this.attributes.delete(name);
    }
    get elementArrayType() {
        return this.#elementArrayType;
    }
    /*getUniform(name) {
        return this.uniforms.get(name);
    }

    setUniform(name, uniform) {
        this.uniforms.set(name, uniform);
    }

    deleteUniform(name) {
        this.uniforms.delete(name);
    }*/
    setIndex(attribute) {
        this.#elementArrayType = attribute instanceof Uint32BufferAttribute ? GL_UNSIGNED_INT : GL_UNSIGNED_SHORT;
        attribute.target = GL_ELEMENT_ARRAY_BUFFER;
        this.setAttribute('index', attribute);
        return;
        /*let attribute;
        if (Array.isArray(index)) {
            attribute = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1, offset, length);
        } else {
            attribute = index;
        }

        this.#elementArrayType = attribute instanceof Uint32BufferAttribute ? GL_UNSIGNED_INT : GL_UNSIGNED_SHORT;
        attribute.target = GL_ELEMENT_ARRAY_BUFFER;
        this.setAttribute('index', attribute);
*/
    }
    update(glContext) {
        throw 'error';
    }
    computeVertexNormals() {
        /* TODO
        var index = this.index;
        var attributes = this.attributes;

        if (attributes.position) {
            var positions = attributes.position.array;
            if (attributes.normal === undefined) {
                this.setAttribute('normal', new BufferAttribute(new Float32Array(positions.length), 3));//TODOV3: replace with a Float32BufferAttribute
            } else {
                // reset existing normals to zero
                var array = attributes.normal.array;
                for (var i = 0, il = array.length; i < il; i++) {
                    array[i] = 0;
                }
            }

            var normals = attributes.normal.array;

            var vA, vB, vC;
            var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
            var cb = new Vector3(), ab = new Vector3();

            // indexed elements

            if (index) {
                var indices = index.array;
                for (var i = 0, il = index.count; i < il; i += 3) {
                    vA = indices[i + 0] * 3;
                    vB = indices[i + 1] * 3;
                    vC = indices[i + 2] * 3;

                    pA.fromArray(positions, vA);
                    pB.fromArray(positions, vB);
                    pC.fromArray(positions, vC);

                    cb.subVectors(pC, pB);
                    ab.subVectors(pA, pB);
                    cb.cross(ab);

                    normals[vA] += cb.x;
                    normals[vA + 1] += cb.y;
                    normals[vA + 2] += cb.z;

                    normals[vB] += cb.x;
                    normals[vB + 1] += cb.y;
                    normals[vB + 2] += cb.z;

                    normals[vC] += cb.x;
                    normals[vC + 1] += cb.y;
                    normals[vC + 2] += cb.z;
                }
            } else {
                // non-indexed elements (unconnected triangle soup)
                for (var i = 0, il = positions.length; i < il; i += 9) {
                    pA.fromArray(positions, i);
                    pB.fromArray(positions, i + 3);
                    pC.fromArray(positions, i + 6);

                    cb.subVectors(pC, pB);
                    ab.subVectors(pA, pB);
                    cb.cross(ab);

                    normals[i] = cb.x;
                    normals[i + 1] = cb.y;
                    normals[i + 2] = cb.z;

                    normals[i + 3] = cb.x;
                    normals[i + 4] = cb.y;
                    normals[i + 5] = cb.z;

                    normals[i + 6] = cb.x;
                    normals[i + 7] = cb.y;
                    normals[i + 8] = cb.z;
                }
            }
            this.normalizeNormals();
            attributes.normal.needsUpdate = true;
        }
            */
    }
    clone() {
        const clone = new BufferGeometry();
        for (const [attributeName, attribute] of this.attributes) {
            clone.attributes.set(attributeName, attribute);
        }
        clone.count = this.count;
        clone.#elementArrayType = this.#elementArrayType;
        this.dirty = true; //TODO: or should we copy this.dirty ?
        return clone;
    }
    addUser(user) {
        this.#users.add(user);
    }
    removeUser(user) {
        this.#users.delete(user);
        this.dispose();
    }
    hasNoUser() {
        return this.#users.size == 0;
    }
    hasOnlyUser(user) {
        return (this.#users.size == 1) && (this.#users.has(user));
    }
    dispose() {
        if (this.hasNoUser()) ;
    }
}

class MaterialManager {
    static #materials = new Map();
    static registerMaterial(materialName, materialClass, manager /*TODO: better type*/) {
        this.#materials.set(materialName, { materialClass: materialClass, manager: manager });
    }
    static getMaterial(materialName, callback) {
        const material = this.#materials.get(materialName);
        if (material) {
            const manager = material.manager;
            const materialClass = material.materialClass;
            if (manager) {
                manager.pickMaterial(materialName, materialClass, callback);
            }
            else {
                callback(new materialClass);
            }
        }
    }
    static getMaterialList() {
        return this.#materials.keys();
    }
}

const v0 = vec3.create();
const v1$3 = vec3.create();
const v2$2 = vec3.create();
const v3$2 = vec3.create();
function getBarycentricCoordinates(out, position, a, b, c) {
    vec3.sub(v0, c, a);
    vec3.sub(v1$3, b, a);
    vec3.sub(v2$2, position, a);
    const dot00 = vec3.dot(v0, v0);
    const dot01 = vec3.dot(v0, v1$3);
    const dot02 = vec3.dot(v0, v2$2);
    const dot11 = vec3.dot(v1$3, v1$3);
    const dot12 = vec3.dot(v1$3, v2$2);
    const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    // barycentric coordinates must always sum to 1
    return vec3.set(out, 1 - u - v, v, u);
}
function getUV(out, position, a, b, c, uv1, uv2, uv3) {
    getBarycentricCoordinates(v3$2, position, a, b, c);
    out[0] = uv1[0] * v3$2[0] + uv2[0] * v3$2[1] + uv3[0] * v3$2[2];
    out[1] = uv1[1] * v3$2[0] + uv2[1] * v3$2[1] + uv3[1] * v3$2[2];
    return out;
}
function getNormal(out, position, a, b, c, normal1, normal2, normal3) {
    getBarycentricCoordinates(v3$2, position, a, b, c);
    out[0] = normal1[0] * v3$2[0] + normal2[0] * v3$2[1] + normal3[0] * v3$2[2];
    out[1] = normal1[1] * v3$2[0] + normal2[1] * v3$2[1] + normal3[1] * v3$2[2];
    out[2] = normal1[2] * v3$2[0] + normal2[2] * v3$2[1] + normal3[2] * v3$2[2];
    return out;
}

class Intersection {
    position;
    normal;
    uv;
    distance;
    entity;
    distanceFromRay;
    constructor(position, normal, uv, distance, entity, distanceFromRay) {
        this.position = vec3.clone(position);
        if (normal) {
            this.normal = vec3.clone(normal);
        }
        if (uv) {
            this.uv = vec2.clone(uv);
        }
        this.distance = distance;
        this.entity = entity;
        this.distanceFromRay = distanceFromRay;
    }
}

const EPSILON$1 = 1e-7;
const edge1 = vec3.create();
const edge2 = vec3.create();
const h = vec3.create();
const h2 = vec3.create();
const s$1 = vec3.create();
const q$2 = vec3.create();
const m = mat4.create();
const _segCenter = vec3.create();
const _segDir = vec3.create();
const _diff = vec3.create();
class Ray {
    origin = vec3.create();
    direction = vec3.create();
    constructor(origin, direction) {
        if (origin) {
            vec3.copy(this.origin, origin);
        }
        if (direction) {
            vec3.copy(this.direction, direction);
        }
    }
    set(origin, direction) {
        vec3.copy(this.origin, origin);
        vec3.copy(this.direction, direction);
    }
    copy(other) {
        vec3.copy(this.origin, other.origin);
        vec3.copy(this.direction, other.direction);
    }
    copyTransform(other, worldMatrix) {
        mat4.invert(m, worldMatrix);
        vec3.transformMat4(this.origin, other.origin, m);
        const x = other.direction[0];
        const y = other.direction[1];
        const z = other.direction[2];
        this.direction[0] = m[0] * x + m[4] * y + m[8] * z;
        this.direction[1] = m[1] * x + m[5] * y + m[9] * z;
        this.direction[2] = m[2] * x + m[6] * y + m[10] * z;
    }
    setOrigin(origin) {
        vec3.copy(this.origin, origin);
    }
    setDirection(direction) {
        vec3.copy(this.direction, direction);
    }
    positionAt(distance, position) {
        vec3.scaleAndAdd(position, this.origin, this.direction, distance);
    }
    intersectTriangle(v0, v1, v2, intersectionPoint) {
        //Möller-Trumbore intersection algorithm
        vec3.sub(edge1, v1, v0);
        vec3.sub(edge2, v2, v0);
        vec3.cross(h, this.direction, edge2);
        const a = vec3.dot(edge1, h);
        if (a > -EPSILON$1 && a < EPSILON$1) {
            return false;
        }
        const f = 1.0 / a;
        vec3.sub(s$1, this.origin, v0);
        const u = f * vec3.dot(s$1, h);
        if (u < 0.0 || u > 1.0) {
            return false;
        }
        vec3.cross(q$2, s$1, edge1);
        const v = f * vec3.dot(this.direction, q$2);
        if (v < 0.0 || u + v > 1.0) {
            return false;
        }
        // At this stage we can compute t to find out where the intersection point is on the line.
        const t = f * vec3.dot(edge2, q$2);
        if (t > EPSILON$1) { // ray intersection
            this.positionAt(t, intersectionPoint);
            return true;
        }
        else { // This means that there is a line intersection but not a ray intersection.
            return false;
        }
    }
    intersectSphere(position, radius, scale, intersectionPoint1, intersectionPoint2) {
        vec3.sub(h, this.origin, position);
        vec3.div(h, h, scale);
        vec3.div(h2, this.direction, scale);
        vec3.normalize(h2, h2);
        const p = vec3.dot(h2, h);
        const q = vec3.dot(h, h) - (radius * radius);
        const discriminant = (p * p) - q;
        if (discriminant < 0.0) {
            return false;
        }
        const dRoot = Math.sqrt(discriminant);
        const dist1 = -p - dRoot;
        const dist2 = -p + dRoot;
        vec3.scaleAndAdd(intersectionPoint1, h, h2, dist1);
        vec3.scaleAndAdd(intersectionPoint2, h, h2, dist2);
        vec3.mul(intersectionPoint1, intersectionPoint1, scale);
        vec3.mul(intersectionPoint2, intersectionPoint2, scale);
        vec3.add(intersectionPoint1, intersectionPoint1, position);
        vec3.add(intersectionPoint2, intersectionPoint2, position);
        return true;
    }
    distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
        // from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
        // It returns the min distance between the ray and the segment
        // defined by v0 and v1
        // It can also set two optional targets :
        // - The closest point on the ray
        // - The closest point on the segment
        //_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
        vec3.add(_segCenter, v0, v1);
        vec3.scale(_segCenter, _segCenter, 0.5);
        //_segDir.copy( v1 ).sub( v0 ).normalize();
        vec3.sub(_segDir, v1, v0);
        vec3.normalize(_segDir, _segDir);
        //_diff.copy( this.origin ).sub( _segCenter );
        vec3.sub(_diff, this.origin, _segCenter);
        //const segExtent = v0.distanceTo( v1 ) * 0.5;
        const segExtent = vec3.dist(v0, v1) * 0.5;
        //const a01 = - this.direction.dot( _segDir );
        const a01 = -vec3.dot(this.direction, _segDir); //this.direction.dot( _segDir );
        //const b0 = _diff.dot( this.direction );
        const b0 = vec3.dot(_diff, this.direction);
        //const b1 = - _diff.dot( _segDir );
        const b1 = -vec3.dot(_diff, _segDir);
        //const c = _diff.lengthSq();
        const c = vec3.sqrLen(_diff);
        const det = Math.abs(1 - a01 * a01);
        let s0, s1, sqrDist, extDet;
        if (det > 0) {
            // The ray and segment are not parallel.
            s0 = a01 * b1 - b0;
            s1 = a01 * b0 - b1;
            extDet = segExtent * det;
            if (s0 >= 0) {
                if (s1 >= -extDet) {
                    if (s1 <= extDet) {
                        // region 0
                        // Minimum at interior points of ray and segment.
                        const invDet = 1 / det;
                        s0 *= invDet;
                        s1 *= invDet;
                        sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                    }
                    else {
                        // region 1
                        s1 = segExtent;
                        s0 = Math.max(0, -(a01 * s1 + b0));
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    }
                }
                else {
                    // region 5
                    s1 = -segExtent;
                    s0 = Math.max(0, -(a01 * s1 + b0));
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
            }
            else {
                if (s1 <= -extDet) {
                    // region 4
                    s0 = Math.max(0, -(-a01 * segExtent + b0));
                    s1 = (s0 > 0) ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
                else if (s1 <= extDet) {
                    // region 3
                    s0 = 0;
                    s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                    sqrDist = s1 * (s1 + 2 * b1) + c;
                }
                else {
                    // region 2
                    s0 = Math.max(0, -(a01 * segExtent + b0));
                    s1 = (s0 > 0) ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
            }
        }
        else {
            // Ray and segment are parallel.
            s1 = (a01 > 0) ? -segExtent : segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
        if (optionalPointOnRay) {
            //optionalPointOnRay.copy( this.origin ).addScaledVector( this.direction, s0 );
            vec3.scaleAndAdd(optionalPointOnRay, this.origin, this.direction, s0);
        }
        if (optionalPointOnSegment) {
            //optionalPointOnSegment.copy( _segCenter ).addScaledVector( _segDir, s1 );
            vec3.scaleAndAdd(optionalPointOnRay, _segCenter, _segDir, s1);
        }
        return sqrDist;
    }
    createIntersection(position, normal, uv, entity, distanceFromRay) {
        return new Intersection(position, normal, uv, vec3.distance(this.origin, position), entity, distanceFromRay);
    }
}

var interactionCSS = ":host {\n\tposition: absolute;\n\twidth: 100%;\n\theight: 100%;\n\tz-index: 10000;\n\ttop: 0px;\n\tleft: 0px;\n\tpointer-events: none;\n}\n\nharmony-color-picker{\n\tpointer-events: all;\n}\n\ninput{\n\tpointer-events: all;\n}\n";

class HTMLFileSelectorTileElement extends HTMLElement {
    #visible = true;
    #selector;
    #file;
    constructor() {
        super();
        this.addEventListener('click', (event) => {
            if (this.#selector && this.#file) {
                this.#selector.fileSelected(this.#file);
            }
        });
    }
    get file() {
        return this.#file;
    }
    setFile(file) {
        this.#file = file;
        this.#updateHtml();
    }
    set selector(selector) {
        this.#selector = selector;
    }
    connectedCallback() {
        this.#updateHtml();
    }
    set visible(visible) {
        this.#visible = visible;
        display(this, visible);
        if (visible) {
            this.#updateHtml();
        }
    }
    #updateHtml() {
        if (this.#visible && this.#file) {
            this.innerText = this.#file.name;
        }
    }
}
let definedTile = false;
function defineFileSelectorTile() {
    if (window.customElements && !definedTile) {
        customElements.define('file-selector-tile', HTMLFileSelectorTileElement);
        definedTile = true;
    }
}

class HTMLFileSelectorFileElement extends HTMLElement {
    #selector;
    #file;
    constructor() {
        super();
        this.addEventListener('click', (event) => {
            if (this.#selector && this.#file) {
                this.#selector.fileSelected(this.#file);
            }
        });
    }
    setFile(file) {
        this.#file = file;
        this.#updateHtml();
    }
    set selector(selector) {
        this.#selector = selector;
    }
    connectedCallback() {
        this.#updateHtml();
    }
    set visible(visible) {
        display(this, visible);
        if (visible) {
            this.#updateHtml();
        }
    }
    #updateHtml() {
        if (this.#file) {
            this.innerText = this.#file.name;
        }
    }
    refreshFilter() {
        if (!this.#selector || !this.#file || !this.#file.path) {
            return false;
        }
        const filterName = this.#selector.filter.name;
        const visible = this.#file.name.toLowerCase().includes(filterName) || this.#file.path.toLowerCase().includes(filterName);
        this.visible = visible;
        return visible;
    }
    get file() {
        return this.#file;
    }
}
let definedFile = false;
function defineFileSelectorFile() {
    if (window.customElements && !definedFile) {
        customElements.define('file-selector-file', HTMLFileSelectorFileElement);
        definedFile = true;
    }
}

class FileSelectorDirectory extends HTMLElement {
    #initialized = false;
    #expanded = false;
    #name = '';
    #childs = [];
    #sortingDirection = 1;
    #visible = true;
    #header;
    #content;
    #file;
    #selector;
    #parentDirectory;
    constructor() {
        super();
        this.#header = createElement('div', {
            class: 'file-selector-directory-header',
            events: {
                click: () => {
                    this.#expanded = !this.#expanded;
                    this.#updateHtml();
                    if (this.#expanded && this.#parentDirectory) {
                        this.#parentDirectory.#childExpanded(this);
                    }
                }
            },
        });
        this.#content = createElement('div', { class: 'file-selector-directory-content' });
    }
    #childExpanded(child) {
        for (const enumeratedChild of this.#content.children) {
            if (enumeratedChild.tagName == 'FILE-SELECTOR-DIRECTORY' && enumeratedChild != child) {
                enumeratedChild.collapse();
            }
        }
    }
    expand() {
        this.#expanded = true;
        this.#updateHtml();
    }
    collapse() {
        this.#expanded = false;
        hide(this.#content);
    }
    setFile(file) {
        this.#file = file;
        this.#initialized = false;
        this.#updateHtml();
    }
    set selector(selector) {
        this.#selector = selector;
    }
    get file() {
        return this.#file;
    }
    connectedCallback() {
        this.append(this.#header, this.#content);
        this.#updateHtml();
    }
    set visible(visible) {
        this.#visible = visible;
        display(this, visible);
        if (visible) {
            this.#updateHtml();
        }
    }
    sort() {
        this.#childs.sort((a, b) => {
            const aIsDir = a.tagName == 'FILE-SELECTOR-DIRECTORY';
            const bIsDir = b.tagName == 'FILE-SELECTOR-DIRECTORY';
            if (aIsDir) {
                if (bIsDir) {
                    const aname = a.file?.name;
                    const bname = b.file?.name;
                    if (aname && bname) {
                        return aname < bname ? -this.#sortingDirection : this.#sortingDirection;
                    }
                }
                else {
                    return -this.#sortingDirection;
                }
            }
            else {
                if (bIsDir) {
                    return this.#sortingDirection;
                }
                else {
                    const aname = a.file?.name;
                    const bname = b.file?.name;
                    if (aname && bname) {
                        return aname < bname ? -this.#sortingDirection : this.#sortingDirection;
                    }
                }
            }
            return 0;
        });
        for (const child of this.#childs) {
            this.#content.append(child);
        }
    }
    refreshFilter() {
        let visible = false;
        if (this.#expanded) {
            for (const child of this.#childs) {
                visible = child.refreshFilter() || visible;
            }
        }
        else {
            if (this.#file) {
                visible = this.#matchFilter(this.#file);
            }
        }
        this.#visible = visible;
        display(this, visible);
        return visible;
    }
    #matchFilter(file) {
        if (file.files) {
            for (const child of file.files) {
                if (this.#matchFilter(child)) {
                    return true;
                }
            }
        }
        else {
            const filterName = this.#selector?.filter.name ?? '';
            return file.name.toLowerCase().includes(filterName) || file.path?.toLowerCase().includes(filterName) || false;
        }
        return false;
    }
    #updateHtml() {
        defineFileSelectorFile();
        if (this.#file && !this.#initialized) {
            this.#name = this.#file.name.replace(/\/$/g, ''); //remove trailing /
            if (this.#expanded) {
                this.#content.replaceChildren();
                this.#childs = [];
                if (this.#file && this.#file.files) {
                    const files = this.#file.files;
                    const l = files.length == 1;
                    for (const file of files) {
                        const fileChilds = file.files;
                        let child;
                        if (fileChilds) {
                            child = document.createElement('file-selector-directory');
                            child.#parentDirectory = this;
                        }
                        else {
                            child = document.createElement('file-selector-file');
                            //child.file = file;
                        }
                        if (this.#selector) {
                            child.selector = this.#selector;
                        }
                        child.setFile(file);
                        this.#content.append(child);
                        this.#childs.push(child);
                        if (fileChilds && l) {
                            child.expand();
                        }
                    }
                }
                this.#initialized = true;
                this.sort();
            }
            if (this.#file) {
                this.#header.innerText = this.#name;
            }
        }
        if (this.#expanded) {
            show(this.#content);
            this.refreshFilter();
        }
        else {
            hide(this.#content);
        }
    }
}
if (customElements) {
    customElements.define('file-selector-directory', FileSelectorDirectory);
}

const FILTER_NAME_DELAY = 200;
class FileSelector extends HTMLElement {
    #fileList;
    #tileView = false;
    #filter = { name: '' };
    #sortingDirection = 1;
    #htmlTiles = [];
    #htmlDirectories = [];
    #header;
    #content;
    #filterNameTimeout;
    #initialized = false;
    constructor() {
        super();
        this.#header = createElement('div', { class: 'file-selector-header' });
        this.#content = createElement('div', { class: 'file-selector-content' });
        const htmlDisplayPropertiesSpan = createElement('span', { parent: this.#header });
        const treeViewId = 'display_tree_view';
        createElement('input', {
            parent: htmlDisplayPropertiesSpan,
            type: 'checkbox',
            id: treeViewId,
            checked: !this.#tileView,
            events: {
                change: () => this.tileView = !this.#tileView
            }
        });
        createElement('label', { i18n: '#display_tree_view', parent: htmlDisplayPropertiesSpan, htmlFor: treeViewId });
        const htmlFilter = createElement('div', { class: 'file-selector-filter', parent: this.#header });
        createElement('input', {
            parent: htmlFilter,
            events: {
                input: (event) => {
                    this.#filter.name = event.target.value;
                    clearTimeout(this.#filterNameTimeout);
                    this.#filterNameTimeout = setTimeout(() => this.refreshFilter(), FILTER_NAME_DELAY);
                }
            },
        });
    }
    fileSelected(file) {
        this.dispatchEvent(new CustomEvent('fileSelected', { detail: { file: file } }));
    }
    set fileList(fileList) {
        this.#fileList = fileList;
        this.#initialized = false;
        this.#updateHtml();
    }
    set tileView(tileView) {
        this.#tileView = tileView;
        this.#initialized = false;
        this.#updateHtml();
    }
    connectedCallback() {
        this.append(this.#header, this.#content);
        this.#updateHtml();
    }
    #getFileList(root) {
        const list = [];
        const stack = [root];
        root.path = '';
        const rootName = root.name; //.replace(/\/$/g, '');
        let current;
        do {
            current = stack.pop();
            if (current) {
                if (current.files) {
                    for (const file of current.files) {
                        const path2 = current.path?.replace(/\/$/g, ''); //remove trailing /
                        const name2 = current.name?.replace(/\/$/g, ''); //remove trailing /
                        if (current == root) {
                            file.path = '/';
                        }
                        else {
                            file.path = (path2 ? path2 + '/' + name2 : name2) + '/';
                            file.root = rootName;
                        }
                        if (file.files) {
                            stack.push(file);
                        }
                        else {
                            list.push(file);
                        }
                    }
                }
            }
        } while (current);
        return list;
    }
    refreshFilter() {
        if (this.#tileView) {
            for (const tile of this.#htmlTiles) {
                tile.visible = this.#matchFilter(tile.file);
            }
        }
        else {
            for (const directory of this.#htmlDirectories) {
                directory.refreshFilter();
            }
        }
    }
    #sortItems() {
        if (this.#tileView) {
            this.#htmlTiles.sort((a, b) => {
                const aname = a.file?.name;
                const bname = b.file?.name;
                if (aname && bname) {
                    return aname < bname ? -this.#sortingDirection : this.#sortingDirection;
                }
                return 0;
            });
            for (const tile of this.#htmlTiles) {
                this.#content.append(tile);
            }
        }
    }
    #matchFilter(file) {
        if (!file) {
            return false;
        }
        let ret = false;
        if (file.name?.toLowerCase().includes(this.#filter.name)) {
            ret = true;
        }
        return ret;
    }
    #updateHtml() {
        if (this.#initialized) {
            return;
        }
        defineFileSelectorTile();
        this.#content.replaceChildren();
        this.#htmlTiles = [];
        this.#htmlDirectories = [];
        if (this.#fileList?.files) {
            if (this.#tileView) {
                for (const rootFile of this.#fileList.files) {
                    const fileList = this.#getFileList(rootFile);
                    for (const file of fileList) {
                        const tile = createElement('file-selector-tile', { parent: this.#content });
                        tile.selector = this;
                        tile.setFile(file);
                        this.#htmlTiles.push(tile);
                        tile.visible = this.#matchFilter(file);
                    }
                }
            }
            else {
                const expandDirectory = this.#fileList.files.length == 1;
                for (const rootFile of this.#fileList.files) {
                    this.#getFileList(rootFile); //Just add path
                    const root = createElement('file-selector-directory', { parent: this.#content });
                    root.selector = this;
                    root.setFile(rootFile);
                    this.#htmlDirectories.push(root);
                    if (expandDirectory) {
                        root.expand();
                    }
                }
            }
        }
        this.#sortItems();
        this.#initialized = true;
    }
    get filter() {
        return this.#filter;
    }
}
if (customElements) {
    customElements.define('file-selector', FileSelector);
}

const DATALIST_ID = 'interaction-datalist';
class Interaction {
    static #instance;
    #htmlColorPicker;
    #shadowRoot;
    #htmlInput;
    #htmlInputDataList;
    #htmlFileSelector;
    //#htmlColorPickeronDone?: (color: any) => void;
    #htmlColorPickeronChange;
    #htmlColorPickerCancel;
    constructor() {
        if (Interaction.#instance) {
            return Interaction.#instance;
        }
        Interaction.#instance = this;
    }
    #initHtml() {
        if (this.#shadowRoot) {
            return;
        }
        this.#shadowRoot = createShadowRoot('div', {
            parent: document.body,
            hidden: true,
            adoptStyle: interactionCSS
        });
        defineHarmonyColorPicker();
        this.#htmlColorPicker = createElement('harmony-color-picker', {
            parent: this.#shadowRoot,
            hidden: true,
            events: {
                change: (event) => {
                    if (this.#htmlColorPickeronChange) {
                        this.#htmlColorPickeronChange(event.detail);
                    }
                },
                ok: () => hide(this.#htmlColorPicker),
                cancel: () => {
                    if (this.#htmlColorPickerCancel) {
                        this.#htmlColorPickerCancel();
                    }
                    hide(this.#htmlColorPicker);
                },
            },
        });
        this.#htmlInput = createElement('input', {
            style: 'pointer-events: all;',
            list: DATALIST_ID,
            parent: this.#shadowRoot,
            hidden: true,
        });
        this.#htmlInputDataList = createElement('datalist', {
            id: DATALIST_ID,
            parent: this.#shadowRoot,
        });
        this.#htmlFileSelector = createElement('div', {
            style: 'pointer-events: all;width: 100%;overflow: auto;height: 100%;',
        });
    }
    show() {
        this.#initHtml();
        show(this.#shadowRoot?.host);
        hide(this.#htmlInput);
        hide(this.#htmlColorPicker);
    }
    hide() {
        hide(this.#shadowRoot?.host);
    }
    async getColor(x, y, defaultValue, onChange, onCancel) {
        this.show();
        //this.#htmlColorPicker.setOptions({alpha:false});
        show(this.#htmlColorPicker);
        const promise = new Promise(resolve => {
        });
        /*
        this.#htmlColorPickeronDone = (color) => {
            let rgba = color.rgba;
            let c = vec4.fromValues(rgba[0] / 255, rgba[1] / 255, rgba[2] / 255, 1.0);
            //console.error(color, color.rgba);
            promiseResolve(c);
            this.hide();
        };
        */
        this.#htmlColorPickeronChange = (color) => {
            const rgba = color.rgba;
            const c = vec4.fromValues(rgba[0], rgba[1], rgba[2], rgba[3]);
            if (onChange) {
                onChange(c);
            }
        };
        this.#htmlColorPickerCancel = () => {
            if (onCancel) {
                onCancel();
            }
        };
        return promise;
    }
    getString(x, y, list, defaultValue) {
        this.show();
        show(this.#htmlInput);
        this.#htmlInput.value = defaultValue ? defaultValue : '';
        if (list) {
            const isMap = list.constructor.name == 'Map';
            this.#htmlInputDataList.innerText = '';
            for (const value of list) {
                const animOption = document.createElement('option');
                this.#htmlInputDataList.append(animOption);
                if (isMap) {
                    animOption.innerText = value[0];
                    animOption.value = value[1];
                }
                else {
                    animOption.innerText = value;
                    animOption.value = value;
                }
            }
        }
        let promiseResolve;
        this.#htmlInput.onchange = (event) => {
            for (const option of this.#htmlInputDataList.options) {
                if (option.value == event.target.value) {
                    promiseResolve(option.value);
                }
            }
            hide(this.#htmlInput);
        };
        const promise = new Promise(resolve => {
            promiseResolve = resolve;
        });
        return promise;
    }
    /*
    async #expandFile(parent, files, callback, repository = '', path = '') {
        parent.replaceChildren();

        files.sort(
            (a, b) => {
                if (a.files) {
                    if (!b.files) {
                        return -1;
                    }
                } else {
                    if (b.files) {
                        return 1;
                    }
                }
                return a.name.toLowerCase() < b.name.toLowerCase() ? -1 : 1;
            }
        );

        for (let file of files) {
            let f = document.createElement('div');
            f.className = 'file-explorer-file';
            parent.append(f);
            if (file.name) {
                let fheader = document.createElement('div');
                fheader.className = 'file-explorer-file-header';
                fheader.append(file.name);
                f.append(fheader);

                fheader.addEventListener('click', (event) => {
                    if (event.target == fheader) {
                        if (file.files) {
                            if (!f.getAttribute('data-initialized')) {
                                f.setAttribute('data-initialized', 'true');
                                let f1 = document.createElement('div');
                                f1.className = 'file-explorer-childs';
                                if (repository == '') {
                                    this.#expandFile(f1, file.files, callback, file.name);
                                } else {
                                    this.#expandFile(f1, file.files, callback, repository, path + file.name + '/');
                                }
                                //f1.style.display = 'none';
                                f.addEventListener('click', (event) => {
                                    if (event.target == f) {
                                        toggle(f1);
                                    }
                                });
                                f.append(f1);
                            }
                        }
                        console.error(path);
                        callback({ repository: repository, path: path, name: file.name });
                    }
                });
            }
        }
    }
        */
    async selectFile(htmlContainer, fileList, callback) {
        this.#initHtml();
        //htmlContainer.append(this.#htmlFileSelector);
        //this.show();
        //this.#htmlFileSelector.style.display = '';
        this.#htmlFileSelector.innerText = '';
        htmlContainer.innerText = '';
        //let value = await
        //this._expandFile(this.#htmlFileSelector, fileList.files, callback);
        //this.#htmlFileSelector.style.display = 'none';
        //this.hide();
        //return value;
        const fileSelector = document.createElement('file-selector'); //TODO: create only once
        htmlContainer.append(fileSelector);
        fileSelector.fileList = fileList;
        fileSelector.addEventListener('fileSelected', event => {
            const file = event.detail.file;
            callback(file.root, file.path + file.name);
        });
    }
    get htmlElement() {
        return this.#shadowRoot?.host;
    }
}

const tempVec3$v = vec3.create();
const v1$2 = vec3.create();
const v2$1 = vec3.create();
const v3$1 = vec3.create();
const n1$1 = vec3.create();
const n2$1 = vec3.create();
const n3$1 = vec3.create();
const uv1$1 = vec2.create();
const uv2$1 = vec2.create();
const uv3$1 = vec2.create();
const intersectionPoint$1 = vec3.create();
const intersectionNormal$2 = vec3.create();
const ray$2 = new Ray();
const uv$2 = vec2.create();
const meshDefaultBufferGeometry = new BufferGeometry();
const meshDefaultMaterial = new MeshBasicMaterial();
class Mesh extends Entity {
    #geometry;
    #material;
    #dirtyProgram = true; //TODOv3 use another method
    renderMode = GL_TRIANGLES;
    isRenderable = true;
    uniforms = {};
    defines = Object.create(null);
    isMesh = true;
    constructor(params) {
        super(params);
        this.setGeometry(params.geometry ?? meshDefaultBufferGeometry);
        this.setMaterial(params.material ?? meshDefaultMaterial);
        this.#desaturate(this.getAttribute('desaturate'));
    }
    /**
     * @deprecated Please use `setMaterial` instead.
     */
    set material(material) {
        this.setMaterial(material);
    }
    /**
     * @deprecated Please use `getMaterial` instead.
     */
    get material() {
        return this.getMaterial();
    }
    setGeometry(geometry) {
        if (this.#geometry == geometry) {
            return;
        }
        if (this.#geometry) {
            this.#geometry.removeUser(this);
        }
        if (geometry) {
            geometry.addUser(this);
        }
        this.#geometry = geometry;
    }
    /**
     * @deprecated Please use `getGeometry` instead.
     */
    get geometry() {
        return this.#geometry;
    }
    getGeometry() {
        return this.#geometry;
    }
    setMaterial(material) {
        if (this.#material != material) {
            if (this.#material) {
                this.#material.removeUser(this);
            }
            if (material) {
                material.addUser(this);
            }
            this.#material = material;
        }
    }
    getMaterial() {
        return this.#material;
    }
    getUniform(name) {
        return this.uniforms[name];
    }
    setUniform(name, uniform) {
        this.uniforms[name] = uniform;
    }
    deleteUniform(name) {
        delete this.uniforms[name];
    }
    setDefine(define, value = '') {
        this.defines[define] = value;
    }
    removeDefine(define) {
        delete this.defines[define];
    }
    exportObj() {
        const ret = {};
        const attributes = { f: 'index', v: 'aVertexPosition', vn: 'aVertexNormal', vt: 'aTextureCoord' };
        const geometry = this.#geometry;
        for (const objAttribute in attributes) {
            const geometryAttribute = attributes[objAttribute];
            if (geometry?.getAttribute(geometryAttribute)) {
                const webglAttrib = geometry.getAttribute(geometryAttribute);
                if (webglAttrib) {
                    ret[objAttribute] = webglAttrib._array;
                }
            }
            else {
                if (objAttribute == 'f') {
                    ret['f'] = new Uint8Array();
                }
                else {
                    ret[objAttribute] = new Float32Array();
                }
            }
        }
        return ret;
    }
    dispose() {
        super.dispose();
        this.#material?.removeUser(this);
        this.#geometry?.removeUser(this);
    }
    toString() {
        return 'Mesh ' + super.toString();
    }
    getBoundsModelSpace(min = vec3.create(), max = vec3.create()) {
        min[0] = Infinity;
        min[1] = Infinity;
        min[2] = Infinity;
        max[0] = -Infinity;
        max[1] = -Infinity;
        max[2] = -Infinity;
        const vertexPosition = this.#geometry.getAttribute('aVertexPosition')?._array;
        for (let i = 0, l = vertexPosition.length; i < l; i += 3) {
            tempVec3$v[0] = vertexPosition[i + 0];
            tempVec3$v[1] = vertexPosition[i + 1];
            tempVec3$v[2] = vertexPosition[i + 2];
            vec3.min(min, min, tempVec3$v);
            vec3.max(max, max, tempVec3$v);
        }
        //console.error(min, max);
    }
    getBoundingBox(boundingBox = new BoundingBox()) {
        boundingBox.reset();
        boundingBox.setPoints(this.#geometry.getAttribute('aVertexPosition')?._array);
        return boundingBox;
    }
    #desaturate(attributeValue) {
        if (attributeValue) {
            this.setDefine('DESATURATE');
        }
        else {
            this.removeDefine('DESATURATE');
        }
    }
    buildContextMenu() {
        const contextMenu = super.buildContextMenu();
        Object.assign(contextMenu.material.submenu, {
            Mesh_1: null,
            set_material: {
                i18n: '#set_material', f: async () => {
                    const materialName = await new Interaction().getString(0, 0, MaterialManager.getMaterialList());
                    if (materialName) {
                        await MaterialManager.getMaterial(materialName, (material) => { if (material) {
                            this.setMaterial(material);
                        } });
                    }
                }
            },
        });
        return contextMenu;
    }
    raycast(raycaster, intersections) {
        const geometry = this.#geometry;
        const indices = geometry?.getAttribute('index')?._array;
        const vertices = geometry?.getAttribute('aVertexPosition')?._array;
        const textureCoords = geometry?.getAttribute('aTextureCoord')?._array;
        let normals = geometry?.getAttribute('aVertexNormal')?._array;
        const worldMatrix = this.worldMatrix;
        ray$2.copyTransform(raycaster.ray, worldMatrix);
        if (normals) {
            for (let i = 0, l = indices.length; i < l; i += 3) {
                let i1 = 3 * indices[i];
                let i2 = 3 * indices[i + 1];
                let i3 = 3 * indices[i + 2];
                vec3.set(v1$2, vertices[i1], vertices[i1 + 1], vertices[i1 + 2]);
                vec3.set(v2$1, vertices[i2], vertices[i2 + 1], vertices[i2 + 2]);
                vec3.set(v3$1, vertices[i3], vertices[i3 + 1], vertices[i3 + 2]);
                if (ray$2.intersectTriangle(v1$2, v2$1, v3$1, intersectionPoint$1)) {
                    vec3.set(n1$1, normals[i1], normals[i1 + 1], normals[i1 + 2]);
                    vec3.set(n2$1, normals[i2], normals[i2 + 1], normals[i2 + 2]);
                    vec3.set(n3$1, normals[i3], normals[i3 + 1], normals[i3 + 2]);
                    i1 = 2 * indices[i];
                    i2 = 2 * indices[i + 1];
                    i3 = 2 * indices[i + 2];
                    vec2.set(uv1$1, textureCoords[i1], textureCoords[i1 + 1]);
                    vec2.set(uv2$1, textureCoords[i2], textureCoords[i2 + 1]);
                    vec2.set(uv3$1, textureCoords[i3], textureCoords[i3 + 1]);
                    getUV(uv$2, intersectionPoint$1, v1$2, v2$1, v3$1, uv1$1, uv2$1, uv3$1);
                    getNormal(intersectionNormal$2, intersectionPoint$1, v1$2, v2$1, v3$1, n1$1, n2$1, n3$1);
                    const x = intersectionNormal$2[0];
                    const y = intersectionNormal$2[1];
                    const z = intersectionNormal$2[2];
                    //Tranform the normal with the world matrix
                    intersectionNormal$2[0] = worldMatrix[0] * x + worldMatrix[4] * y + worldMatrix[8] * z;
                    intersectionNormal$2[1] = worldMatrix[1] * x + worldMatrix[5] * y + worldMatrix[9] * z;
                    intersectionNormal$2[2] = worldMatrix[2] * x + worldMatrix[6] * y + worldMatrix[10] * z;
                    vec3.transformMat4(intersectionPoint$1, intersectionPoint$1, worldMatrix);
                    intersections.push(ray$2.createIntersection(intersectionPoint$1, intersectionNormal$2, uv$2, this, 0));
                }
            }
        }
        else {
            normals = Float32Array.from([1, 0, 0]);
            for (let i = 0, l = indices.length; i < l; i += 3) {
                let i1 = 3 * indices[i];
                let i2 = 3 * indices[i + 1];
                let i3 = 3 * indices[i + 2];
                vec3.set(v1$2, vertices[i1], vertices[i1 + 1], vertices[i1 + 2]);
                vec3.set(v2$1, vertices[i2], vertices[i2 + 1], vertices[i2 + 2]);
                vec3.set(v3$1, vertices[i3], vertices[i3 + 1], vertices[i3 + 2]);
                if (ray$2.intersectTriangle(v1$2, v2$1, v3$1, intersectionPoint$1)) {
                    vec3.set(n1$1, normals[0], normals[1], normals[2]);
                    vec3.set(n2$1, normals[0], normals[1], normals[2]);
                    vec3.set(n3$1, normals[0], normals[1], normals[2]);
                    i1 = 2 * indices[i];
                    i2 = 2 * indices[i + 1];
                    i3 = 2 * indices[i + 2];
                    vec2.set(uv1$1, textureCoords[i1], textureCoords[i1 + 1]);
                    vec2.set(uv2$1, textureCoords[i2], textureCoords[i2 + 1]);
                    vec2.set(uv3$1, textureCoords[i3], textureCoords[i3 + 1]);
                    getUV(uv$2, intersectionPoint$1, v1$2, v2$1, v3$1, uv1$1, uv2$1, uv3$1);
                    getNormal(intersectionNormal$2, intersectionPoint$1, v1$2, v2$1, v3$1, n1$1, n2$1, n3$1);
                    const x = intersectionNormal$2[0];
                    const y = intersectionNormal$2[1];
                    const z = intersectionNormal$2[2];
                    //Tranform the normal with the world matrix
                    intersectionNormal$2[0] = worldMatrix[0] * x + worldMatrix[4] * y + worldMatrix[8] * z;
                    intersectionNormal$2[1] = worldMatrix[1] * x + worldMatrix[5] * y + worldMatrix[9] * z;
                    intersectionNormal$2[2] = worldMatrix[2] * x + worldMatrix[6] * y + worldMatrix[10] * z;
                    vec3.transformMat4(intersectionPoint$1, intersectionPoint$1, worldMatrix);
                    intersections.push(ray$2.createIntersection(intersectionPoint$1, intersectionNormal$2, uv$2, this, 0));
                }
            }
        }
    }
    static getEntityName() {
        return 'Static mesh';
    }
    is(s) {
        if (s == 'Mesh') {
            return true;
        }
        else {
            return super.is(s);
        }
    }
}

class BoxBufferGeometry extends BufferGeometry {
    #indices;
    #vertices;
    #normals;
    #uvs;
    #numberOfVertices = 0;
    updateGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
        widthSegments = Math.floor(widthSegments);
        heightSegments = Math.floor(heightSegments);
        depthSegments = Math.floor(depthSegments);
        // buffers
        this.#indices = [];
        this.#vertices = [];
        this.#normals = [];
        this.#uvs = [];
        // helper variables
        this.#numberOfVertices = 0;
        // build each side of the box geometry
        this.#buildPlane(2, 1, 0, -1, -1, depth, height, width, depthSegments, heightSegments); // px
        this.#buildPlane(2, 1, 0, 1, -1, depth, height, -width, depthSegments, heightSegments); // nx
        this.#buildPlane(0, 2, 1, 1, 1, width, depth, height, widthSegments, depthSegments); // py
        this.#buildPlane(0, 2, 1, 1, -1, width, depth, -height, widthSegments, depthSegments); // ny
        this.#buildPlane(0, 1, 2, 1, -1, width, height, depth, widthSegments, heightSegments); // pz
        this.#buildPlane(0, 1, 2, -1, -1, width, height, -depth, widthSegments, heightSegments); // nz
        // build geometry
        this.setIndex(new Uint16BufferAttribute(this.#indices, 1));
        this.setAttribute('aVertexPosition', new Float32BufferAttribute(this.#vertices, 3));
        this.setAttribute('aVertexNormal', new Float32BufferAttribute(this.#normals, 3));
        this.setAttribute('aTextureCoord', new Float32BufferAttribute(this.#uvs, 2));
        this.count = this.#indices.length;
    }
    #buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY) {
        const segmentWidth = width / gridX;
        const segmentHeight = height / gridY;
        const widthHalf = width / 2;
        const heightHalf = height / 2;
        const depthHalf = depth / 2;
        const gridX1 = gridX + 1;
        const gridY1 = gridY + 1;
        let vertexCounter = 0;
        let ix, iy;
        const vector = vec3.create();
        // generate vertices, normals and uvs
        for (iy = 0; iy < gridY1; iy++) {
            const y = iy * segmentHeight - heightHalf;
            for (ix = 0; ix < gridX1; ix++) {
                const x = ix * segmentWidth - widthHalf;
                // set values to correct vector component
                vector[u] = x * udir;
                vector[v] = y * vdir;
                vector[w] = depthHalf;
                // now apply vector to vertex buffer
                this.#vertices.push(...vector);
                // set values to correct vector component
                vector[u] = 0;
                vector[v] = 0;
                vector[w] = depth > 0 ? 1 : -1;
                // now apply vector to normal buffer
                this.#normals.push(...vector);
                // uvs
                this.#uvs.push(ix / gridX);
                this.#uvs.push(1 - (iy / gridY));
                // counters
                vertexCounter += 1;
            }
        }
        // indices
        // 1. you need three indices to draw a single face
        // 2. a single segment consists of two faces
        // 3. so we need to generate six (2*3) indices per segment
        for (iy = 0; iy < gridY; iy++) {
            for (ix = 0; ix < gridX; ix++) {
                const a = this.#numberOfVertices + ix + gridX1 * iy;
                const b = this.#numberOfVertices + ix + gridX1 * (iy + 1);
                const c = this.#numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
                const d = this.#numberOfVertices + (ix + 1) + gridX1 * iy;
                // faces
                this.#indices.push(a, b, d);
                this.#indices.push(b, c, d);
            }
        }
        // add a group to the geometry. this will ensure multi material support
        // calculate new start value for groups
        // update total number of vertices
        this.#numberOfVertices += vertexCounter;
    }
}

class Box extends Mesh {
    #widthSegments;
    #heightSegments;
    #depthSegments;
    #size = vec3.create(); // width, height, depth
    constructor(params = {}) {
        params.geometry = new BoxBufferGeometry();
        params.material = params.material ?? new MeshBasicMaterial();
        super(params);
        this.#size[0] = params.width ?? 1;
        this.#size[1] = params.height ?? this.#size[0];
        this.#size[2] = params.depth ?? this.#size[0];
        this.#widthSegments = params.widthSegments ?? 1;
        this.#heightSegments = params.heightSegments ?? 1;
        this.#depthSegments = params.depthSegments ?? 1;
        this.#updateGeometry();
        super.setParameters(params);
    }
    #updateGeometry() {
        this.geometry.updateGeometry(this.#size[0], this.#size[1], this.#size[2], this.#widthSegments, this.#heightSegments, this.#depthSegments);
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), {
            Box_1: null,
            width: { i18n: '#width', f: () => { const width = prompt('Width', String(this.#size[0])); if (width) {
                    this.#size[0] = Number(width);
                    this.#updateGeometry();
                } } },
            height: { i18n: '#height', f: () => { const height = prompt('Height', String(this.#size[1])); if (height) {
                    this.#size[1] = Number(height);
                    this.#updateGeometry();
                } } },
            depth: { i18n: '#depth', f: () => { const depth = prompt('Depth', String(this.#size[2])); if (depth) {
                    this.#size[2] = Number(depth);
                    this.#updateGeometry();
                } } },
            cube: { i18n: '#cube', f: () => { let size = prompt('Cube size', '0') ?? '0'; if (size) {
                    size = Number(size);
                    this.#size[0] = size;
                    this.#size[1] = size;
                    this.#size[2] = size;
                    this.#updateGeometry();
                } } },
        });
    }
    toJSON() {
        const json = super.toJSON();
        json.width = this.#size[0];
        json.height = this.#size[1];
        json.depth = this.#size[2];
        json.widthSegments = this.#widthSegments;
        json.heightSegments = this.#heightSegments;
        json.depthSegments = this.#depthSegments;
        json.material = this.material.toJSON();
        return json;
    }
    static async constructFromJSON(json, entities, loadedPromise) {
        const material = await JSONLoader.loadEntity(json.material, entities, loadedPromise);
        return new Box({ width: json.width, height: json.height, depth: json.depth, material: material, widthSegments: json.widthSegments, heightSegments: json.heightSegments, depthSegments: json.depthSegments });
    }
    /*dispose() {
        super.dispose();
        this.geometry.dispose();
        this.material.dispose();
    }*/
    static getEntityName() {
        return 'Box';
    }
    setSize(width, height, depth) {
        this.#size[0] = width;
        this.#size[1] = height;
        this.#size[2] = depth;
        this.#updateGeometry();
    }
    setSizeVec(size) {
        vec3.copy(this.#size, size);
        this.#updateGeometry();
    }
    setWidth(width) {
        this.#size[0] = width;
        this.#updateGeometry();
    }
    setHeight(height) {
        this.#size[1] = height;
        this.#updateGeometry();
    }
    setDepth(depth) {
        this.#size[2] = depth;
        this.#updateGeometry();
    }
}
registerEntity(Box);

const ShaderEventTarget = new EventTarget();

const Shaders = {};

const Includes = {};

const includeSources = new Map();
const customIncludeSources = new Map();
function addIncludeSource(name, source = '') {
    includeSources.set(name, source);
    ShaderEventTarget.dispatchEvent(new CustomEvent('includeadded'));
}
function getIncludeSource(name) {
    if (!includeSources.has(name)) {
        addIncludeSource(name, Includes[name]);
        if (!customIncludeSources.has(name) && Includes[name] === undefined) {
            console.error('unknown include ' + name);
        }
    }
    return customIncludeSources.get(name) ?? includeSources.get(name);
}
function setCustomIncludeSource(name, source) {
    if (source == '') {
        customIncludeSources.delete(name);
    }
    else {
        customIncludeSources.set(name, source);
    }
}
function getIncludeList() {
    return includeSources.keys();
}

var ShaderType;
(function (ShaderType) {
    ShaderType[ShaderType["Vertex"] = 35633] = "Vertex";
    ShaderType[ShaderType["Fragment"] = 35632] = "Fragment";
})(ShaderType || (ShaderType = {}));
function getHeader(type) {
    switch (type) {
        case ShaderType.Vertex:
            return '#include header_vertex';
        case ShaderType.Fragment:
            return '#include header_fragment';
    }
}
const PRAGMA_REGEX = /#pragma (\w+)/;
class WebGLShaderSource {
    static isWebGL2;
    #includes = new Set();
    #type;
    #source = '';
    #extensions = '';
    #sizeOfSourceRow = [];
    #sourceRowToInclude = new Map();
    #compileSource = '';
    #isErroneous = false;
    #error = '';
    #lineDelta = 0;
    constructor(type, source) {
        this.#type = type;
        this.setSource(source);
    }
    setSource(source) {
        this.#source = source;
        this.#extensions = '';
        this.#sizeOfSourceRow = [];
        this.#sourceRowToInclude.clear();
        this.#includes.clear();
        const allIncludes = new Set();
        const sourceLineArray = source.split('\n');
        sourceLineArray.unshift(getHeader(this.#type) ?? '');
        let compileRow = 1;
        //TODOv3: use regexp to do a better job
        const outArray = [];
        for (let i = 0; i < sourceLineArray.length; ++i) {
            const line = sourceLineArray[i];
            let actualSize = 1;
            if (line.startsWith('#extension')) {
                this.#extensions += line + '\n';
                sourceLineArray.splice(i, 1);
                actualSize = 0;
            }
            else if (line.trim().startsWith('#include')) {
                //this.extensions += line + '\n';
                const includeName = line.replace('#include', '').trim();
                const include = this.getInclude(includeName, compileRow, new Set(), allIncludes);
                if (include) {
                    this.#sourceRowToInclude.set(compileRow, [includeName, include.length]);
                    outArray.push(...include);
                    compileRow += include.length;
                    actualSize = include.length;
                }
                else {
                    if (include === undefined) {
                        console.error(`Include not found : ${line}`);
                    }
                }
            }
            else {
                outArray.push(line);
                ++compileRow;
            }
            this.#sizeOfSourceRow[i] = actualSize;
        }
        this.#compileSource = outArray.join('\n');
        this.#isErroneous = false;
        this.#error = '';
        this.#lineDelta = 0;
        return this;
    }
    isErroneous() {
        return this.#isErroneous;
    }
    getSource() {
        return this.#source;
    }
    getInclude(includeName, compileRow = 0, recursion = new Set(), allIncludes = new Set()) {
        this.#includes.add(includeName);
        if (recursion.has(includeName)) {
            console.error('Include recursion in ' + includeName);
            return undefined;
        }
        recursion.add(includeName);
        const include = getIncludeSource(includeName);
        if (include == undefined) {
            return undefined;
        }
        const includeLineArray = include.trim().split('\n');
        includeLineArray.unshift(''); //Add an empty line to insure nested include won't occupy the same line #
        const outArray = [];
        for (let i = 0, l = includeLineArray.length; i < l; ++i) {
            const line = includeLineArray[i];
            if (line.trim().startsWith('#include')) {
                const includeName = line.replace('#include', '').trim();
                const include = this.getInclude(includeName, compileRow + i, recursion, allIncludes);
                if (include) {
                    this.#sourceRowToInclude.set(compileRow, [includeName, include.length]);
                    outArray.push(...include);
                    compileRow += include.length;
                }
                continue;
            }
            if (line.trim().startsWith('#pragma')) {
                const result = PRAGMA_REGEX.exec(line);
                if (result && result[1] == 'once') {
                    if (allIncludes.has(includeName)) {
                        return null;
                    }
                    continue;
                }
            }
            outArray.push(line);
            ++compileRow;
        }
        allIncludes.add(includeName);
        return outArray;
    }
    getCompileSource(includeCode = '') {
        function getDefineValue(defineName, includeCode = '') {
            const sourceLineArray = includeCode.split('\n');
            const definePattern = /\s*#define\s+(\S+)\s+(\S+)/;
            for (const line of sourceLineArray) {
                const regexResult = definePattern.exec(line);
                if (regexResult && defineName) {
                    if (regexResult[1] == defineName) {
                        return regexResult[2];
                    }
                }
            }
            return defineName;
        }
        function unrollLoops(source, includeCode = '') {
            let nextUnroll = Infinity;
            let unrollSubstring;
            const forPattern = /for\s*\(\s*int\s+(\S+)\s*=\s*(\S+)\s*;\s*(\S+)\s*<\s*(\S+)\s*;\s*(\S+)\s*\+\+\s*\)\s*{/g;
            while ((nextUnroll = source.lastIndexOf('#pragma unroll', nextUnroll - 1)) != -1) {
                forPattern.lastIndex = 0;
                unrollSubstring = source.substring(nextUnroll);
                const regexResult = forPattern.exec(unrollSubstring);
                if (regexResult && regexResult.length == 6) {
                    const loopVariable = regexResult[1];
                    if ((loopVariable == regexResult[3]) && (loopVariable == regexResult[5])) { //Check the variable name is the same everywhere
                        let startIndex = forPattern.lastIndex;
                        let curlyCount = 1; //we already ate one
                        const startLoopName = regexResult[2];
                        const endLoopName = regexResult[4];
                        let loopSnippet = '';
                        curlyLoop: while (startIndex != -1) {
                            let car = unrollSubstring.charAt(startIndex++);
                            switch (car) {
                                case '/':
                                    car = unrollSubstring.charAt(startIndex++);
                                    switch (car) {
                                        case '*':
                                            startIndex = unrollSubstring.indexOf('*/', startIndex);
                                            if (startIndex != -1) {
                                                startIndex += 2;
                                            }
                                            break;
                                        case '/':
                                            startIndex = unrollSubstring.indexOf('\n', startIndex);
                                            break;
                                    }
                                    break;
                                case '{':
                                    ++curlyCount;
                                    break;
                                case '}':
                                    --curlyCount;
                                    if (curlyCount == 0) {
                                        loopSnippet = source.substring(nextUnroll + forPattern.lastIndex, nextUnroll + startIndex - 1);
                                        break curlyLoop;
                                    }
                                    break;
                            }
                        }
                        if (loopSnippet) {
                            const loopVariableRegexp = new RegExp('\\[\\s*' + loopVariable + '\\s*\\]', 'g');
                            const loopVariableRegexp2 = new RegExp('\\{\\s*' + loopVariable + '\\s*\\}', 'g');
                            const startLoopIndex = Number.parseInt(getDefineValue(startLoopName, includeCode));
                            const endLoopIndex = Number.parseInt(getDefineValue(endLoopName, includeCode));
                            let unrolled = '';
                            for (let i = startLoopIndex; i < endLoopIndex; i++) {
                                unrolled += loopSnippet.replace(loopVariableRegexp, `[${i}]`).replace(loopVariableRegexp2, `${i}`);
                            }
                            source = source.substring(0, nextUnroll - 1) + unrolled + source.substring(nextUnroll + startIndex);
                        }
                    }
                }
            }
            return source;
        }
        return (WebGLShaderSource.isWebGL2 ? '#version 300 es\n' : '\n') + this.#extensions + includeCode + unrollLoops(this.#compileSource, includeCode);
    }
    getCompileSourceLineNumber(includeCode) {
        const source = this.getCompileSource(includeCode);
        const sourceLineArray = source.split('\n');
        for (let i = sourceLineArray.length - 1; i >= 0; i--) {
            sourceLineArray[i] = (i + 1).toString().padStart(4) + ' ' + sourceLineArray[i];
        }
        return sourceLineArray.join('\n');
    }
    setCompileError(error, includeCode = '') {
        let lineDelta = ((includeCode).match(/\n/g) || []).length;
        lineDelta += 1; //#version line
        this.#isErroneous = true;
        this.#error = error;
        this.#lineDelta = lineDelta;
    }
    getCompileError(convertRows = true) {
        const errorArray = [];
        const splitRegex = /(ERROR|WARNING) *: *(\d*):(\d*): */;
        function consumeLine(arr) {
            let line;
            while ((line = arr.shift()) !== undefined) {
                if (line === '') {
                    continue;
                }
                return line;
            }
            return null;
        }
        const arr = this.#error.replace('\n', '').split(splitRegex);
        while (arr.length) {
            const errorType = consumeLine(arr);
            const errorCol = consumeLine(arr);
            const errorRow = Number(consumeLine(arr));
            const errorText = consumeLine(arr);
            if (errorType && errorCol && errorRow && errorText) {
                let row = Math.max(errorRow - this.#lineDelta, 0);
                if (convertRows) {
                    row = this.compileRowToSourceRow(row);
                }
                row = Math.max(row, 0);
                errorArray.push({ type: errorType.toLowerCase(), column: errorCol, row: row, text: errorText });
            }
        }
        return errorArray;
    }
    getIncludeAnnotations() {
        const annotations = [];
        const sourceLineArray = this.#source.split('\n');
        sourceLineArray.unshift(getHeader(this.#type) ?? '');
        for (let i = sourceLineArray.length - 1; i >= 0; i--) {
            const line = sourceLineArray[i];
            if (line.trim().startsWith('#include')) {
                const include = this.getInclude(line.replace('#include', '').trim());
                if (include) {
                    include.shift(); //Remove the first empty line
                    annotations.push({ type: 'info', column: 0, row: Math.max(i - 1, 0), text: include.join('\n') });
                }
            }
        }
        return annotations;
    }
    compileRowToSourceRow(row) {
        let totalSoFar = 0;
        for (let i = 0; i < this.#sizeOfSourceRow.length; i++) {
            totalSoFar += this.#sizeOfSourceRow[i];
            if (totalSoFar >= row) {
                return i - 1;
            }
        }
        return 0;
    }
    isValid() {
        return (this.#source != '') && !this.#isErroneous;
    }
    reset() {
        this.#isErroneous = false;
        this.setSource(this.#source);
    }
    containsInclude(includeName) {
        return this.#includes.has(includeName);
    }
    getType() {
        return this.#type;
    }
    getSourceRowToInclude() {
        return new Map(this.#sourceRowToInclude);
    }
}

class ShaderManager {
    static #displayCompileError = false;
    static #shaderList = new Map();
    static #customShaderList = new Map();
    static addSource(type, name, source) {
        this.#shaderList.set(name, new WebGLShaderSource(type, source));
        ShaderEventTarget.dispatchEvent(new CustomEvent('shaderadded'));
    }
    static getShaderSource(type, name, invalidCustomShaders = false) {
        if (this.#shaderList.get(name) === undefined) {
            const source = Shaders[name];
            if (source) {
                this.addSource(type, name, source);
            }
            else {
                console.error('Shader not found : ', name);
            }
        }
        const customSource = this.#customShaderList.get(name);
        const source = this.#shaderList.get(name);
        return customSource && (customSource.isValid() ?? invalidCustomShaders) ? customSource : source;
    }
    static setCustomSource(type, name, source) {
        if (source == '') {
            this.#customShaderList.delete(name);
        }
        else {
            const customSource = this.#customShaderList.get(name) ?? new WebGLShaderSource(type, '');
            customSource.setSource(source);
            this.#customShaderList.set(name, customSource);
        }
    }
    static getCustomSourceAnnotations(name) {
        const customSource = this.#customShaderList.get(name);
        if (customSource) {
            return customSource.getCompileError().concat(customSource.getIncludeAnnotations());
        }
        return null;
    }
    static getIncludeAnnotations(includeName) {
        let annotations;
        for (const [shaderName, shaderSource] of this.#shaderList) {
            annotations = this.#getIncludeAnnotations(includeName, shaderName, shaderSource);
            if (annotations.length) {
                return annotations;
            }
        }
        for (const [shaderName, shaderSource] of this.#customShaderList) {
            annotations = this.#getIncludeAnnotations(includeName, shaderName, shaderSource);
            if (annotations.length) {
                return annotations;
            }
        }
    }
    static #getIncludeAnnotations(includeName, shaderName, shaderSource) {
        const errorArray = [];
        if (shaderSource.isErroneous()) {
            if (shaderSource.containsInclude(includeName)) {
                const errors = shaderSource.getCompileError(false);
                for (const error of errors) {
                    const sourceRowToInclude = shaderSource.getSourceRowToInclude();
                    for (const [startLine, [includeName2, includeLength]] of sourceRowToInclude) {
                        //let [includeName2, includeLength] = shaderSource.sourceRowToInclude[startLine];
                        if (startLine <= error.row && (startLine + includeLength) > error.row && includeName == includeName2) {
                            errorArray.push({ type: error.type, column: error.column, row: error.row - startLine, text: error.text });
                        }
                    }
                }
            }
        }
        return errorArray;
    }
    static get shaderList() {
        return this.#shaderList.keys();
    }
    static resetShadersSource() {
        for (const source of this.#shaderList.values()) {
            source.reset();
        }
        for (const source of this.#customShaderList.values()) {
            source.reset();
        }
    }
    static set displayCompileError(displayCompileError) {
        this.#displayCompileError = displayCompileError;
    }
    static get displayCompileError() {
        return this.#displayCompileError;
    }
    static setCompileError(shaderName, shaderInfoLog) {
        return;
    }
}

let id$1 = 0;
class ShaderMaterial extends Material {
    #shaderSource = '';
    constructor(params = {}) {
        super(params);
        this.shaderSource = params.shaderSource;
        const name = `shadermaterial_${++id$1}`;
        if (params.vertex) {
            ShaderManager.addSource(GL_VERTEX_SHADER, name + '.vs', params.vertex);
            this.shaderSource = name;
        }
        if (params.fragment) {
            ShaderManager.addSource(GL_FRAGMENT_SHADER, name + '.fs', params.fragment);
        }
        if (params.uniforms) {
            for (const name in params.uniforms) {
                this.uniforms[name] = params.uniforms[name];
            }
        }
        if (params.defines) {
            for (const name in params.defines) {
                this.setDefine(name, params.defines[name]);
            }
        }
    }
    getShaderSource() {
        return this.#shaderSource;
    }
    set shaderSource(shaderSource) {
        this.#shaderSource = shaderSource;
    }
}

var TextureTarget;
(function (TextureTarget) {
    TextureTarget[TextureTarget["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
    TextureTarget[TextureTarget["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
    TextureTarget[TextureTarget["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
    TextureTarget[TextureTarget["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
    TextureTarget[TextureTarget["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
    TextureTarget[TextureTarget["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
    TextureTarget[TextureTarget["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TextureTarget || (TextureTarget = {}));
var TextureFormat;
(function (TextureFormat) {
    TextureFormat[TextureFormat["Rgb"] = 6407] = "Rgb";
    TextureFormat[TextureFormat["Rgba"] = 6408] = "Rgba";
    TextureFormat[TextureFormat["Luminance"] = 6409] = "Luminance";
    TextureFormat[TextureFormat["LuminanceAlpha"] = 6410] = "LuminanceAlpha";
    TextureFormat[TextureFormat["Alpha"] = 6406] = "Alpha";
    TextureFormat[TextureFormat["R8"] = 33321] = "R8";
    TextureFormat[TextureFormat["R8SignedNormalized"] = 33321] = "R8SignedNormalized";
    TextureFormat[TextureFormat["Rgba_32F"] = 34836] = "Rgba_32F";
    TextureFormat[TextureFormat["Rgb_32F"] = 34837] = "Rgb_32F";
    TextureFormat[TextureFormat["Rgba_16F"] = 34842] = "Rgba_16F";
    TextureFormat[TextureFormat["Rgba_32UI"] = 36208] = "Rgba_32UI";
})(TextureFormat || (TextureFormat = {}));
var TextureType;
(function (TextureType) {
    TextureType[TextureType["UnsignedByte"] = 5121] = "UnsignedByte";
    TextureType[TextureType["UnsignedShort_5_6_5"] = 33635] = "UnsignedShort_5_6_5";
    TextureType[TextureType["UnsignedShort_4_4_4_4"] = 32819] = "UnsignedShort_4_4_4_4";
    TextureType[TextureType["UnsignedShort_5_5_5_1"] = 32820] = "UnsignedShort_5_5_5_1";
    TextureType[TextureType["UnsignedShort"] = 5123] = "UnsignedShort";
    TextureType[TextureType["UnsignedInt"] = 5125] = "UnsignedInt";
    TextureType[TextureType["UnsignedInt_24_8"] = 34042] = "UnsignedInt_24_8";
    TextureType[TextureType["Float"] = 5126] = "Float";
    TextureType[TextureType["HalfFloatOes"] = 36193] = "HalfFloatOes";
    TextureType[TextureType["HalfFloat"] = 5131] = "HalfFloat";
    TextureType[TextureType["Byte"] = 5120] = "Byte";
    TextureType[TextureType["Short"] = 5122] = "Short";
    TextureType[TextureType["Int"] = 5124] = "Int";
    TextureType[TextureType["UnsignedInt_2_10_10_10"] = 33640] = "UnsignedInt_2_10_10_10";
    TextureType[TextureType["UnsignedInt_10F_11F_11F"] = 35899] = "UnsignedInt_10F_11F_11F";
    TextureType[TextureType["UnsignedInt_5_9_9_9"] = 35902] = "UnsignedInt_5_9_9_9";
    TextureType[TextureType["UnsignedFloat_32_UnsignedInt_24_8"] = 36269] = "UnsignedFloat_32_UnsignedInt_24_8";
})(TextureType || (TextureType = {}));
var FrameBufferTarget;
(function (FrameBufferTarget) {
    FrameBufferTarget[FrameBufferTarget["FrameBuffer"] = 36160] = "FrameBuffer";
    FrameBufferTarget[FrameBufferTarget["DrawFrameBuffer"] = 36009] = "DrawFrameBuffer";
    FrameBufferTarget[FrameBufferTarget["ReadFrameBuffer"] = 36008] = "ReadFrameBuffer";
})(FrameBufferTarget || (FrameBufferTarget = {}));
var ColorSpace;
(function (ColorSpace) {
    ColorSpace[ColorSpace["None"] = 0] = "None";
    ColorSpace[ColorSpace["Linear"] = 1] = "Linear";
    ColorSpace[ColorSpace["Srgb"] = 2] = "Srgb";
    ColorSpace[ColorSpace["SrgbLinear"] = 3] = "SrgbLinear";
})(ColorSpace || (ColorSpace = {}));
var ToneMapping;
(function (ToneMapping) {
    ToneMapping[ToneMapping["None"] = 0] = "None";
    ToneMapping[ToneMapping["Linear"] = 1] = "Linear";
    ToneMapping[ToneMapping["Reinhard"] = 2] = "Reinhard";
    ToneMapping[ToneMapping["ReinhardExtended"] = 3] = "ReinhardExtended";
})(ToneMapping || (ToneMapping = {}));
var TextureMapping;
(function (TextureMapping) {
    TextureMapping[TextureMapping["UvMapping"] = 0] = "UvMapping";
    TextureMapping[TextureMapping["CubeMapping"] = 1] = "CubeMapping";
    TextureMapping[TextureMapping["CubeUvMapping"] = 2] = "CubeUvMapping";
})(TextureMapping || (TextureMapping = {}));
var RenderBufferInternalFormat;
(function (RenderBufferInternalFormat) {
    RenderBufferInternalFormat[RenderBufferInternalFormat["Rgba4"] = 32854] = "Rgba4";
    RenderBufferInternalFormat[RenderBufferInternalFormat["Rgb565"] = 36194] = "Rgb565";
    RenderBufferInternalFormat[RenderBufferInternalFormat["Rgb5_A1"] = 32855] = "Rgb5_A1";
    RenderBufferInternalFormat[RenderBufferInternalFormat["Depth_Component16"] = 33189] = "Depth_Component16";
    RenderBufferInternalFormat[RenderBufferInternalFormat["Stencil_Index_8"] = 36168] = "Stencil_Index_8";
    RenderBufferInternalFormat[RenderBufferInternalFormat["Depth_Stencil"] = 34041] = "Depth_Stencil";
    RenderBufferInternalFormat[RenderBufferInternalFormat["R8"] = 33321] = "R8";
    RenderBufferInternalFormat[RenderBufferInternalFormat["R8I"] = 33329] = "R8I";
    RenderBufferInternalFormat[RenderBufferInternalFormat["R8UI"] = 33330] = "R8UI";
    RenderBufferInternalFormat[RenderBufferInternalFormat["R16I"] = 33331] = "R16I";
    RenderBufferInternalFormat[RenderBufferInternalFormat["R16UI"] = 33332] = "R16UI";
    RenderBufferInternalFormat[RenderBufferInternalFormat["R32I"] = 33333] = "R32I";
    RenderBufferInternalFormat[RenderBufferInternalFormat["R32UI"] = 33334] = "R32UI";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RG8"] = 33323] = "RG8";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RG8I"] = 33335] = "RG8I";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RG8UI"] = 33336] = "RG8UI";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RG16I"] = 33337] = "RG16I";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RG16UI"] = 33338] = "RG16UI";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RG32I"] = 33339] = "RG32I";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RG32UI"] = 33340] = "RG32UI";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RGB8"] = 32849] = "RGB8";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RGBA8"] = 32856] = "RGBA8";
    RenderBufferInternalFormat[RenderBufferInternalFormat["SRGB8_ALPHA8"] = 35907] = "SRGB8_ALPHA8";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RGB10_A2"] = 32857] = "RGB10_A2";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RGBA8UI"] = 36220] = "RGBA8UI";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RGBA8I"] = 36238] = "RGBA8I";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RGB10_A2UI"] = 36975] = "RGB10_A2UI";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RGBA16UI"] = 36214] = "RGBA16UI";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RGBA16I"] = 36232] = "RGBA16I";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RGBA32I"] = 36226] = "RGBA32I";
    RenderBufferInternalFormat[RenderBufferInternalFormat["RGBA32UI"] = 36208] = "RGBA32UI";
    RenderBufferInternalFormat[RenderBufferInternalFormat["DEPTH_COMPONENT24"] = 33190] = "DEPTH_COMPONENT24";
    RenderBufferInternalFormat[RenderBufferInternalFormat["DEPTH_COMPONENT32F"] = 36012] = "DEPTH_COMPONENT32F";
    RenderBufferInternalFormat[RenderBufferInternalFormat["DEPTH24_STENCIL8"] = 35056] = "DEPTH24_STENCIL8";
    RenderBufferInternalFormat[RenderBufferInternalFormat["DEPTH32F_STENCIL8"] = 36013] = "DEPTH32F_STENCIL8";
})(RenderBufferInternalFormat || (RenderBufferInternalFormat = {}));

class Scene extends Entity {
    #layers = new Map();
    #world;
    background;
    layers = new Set();
    environment;
    activeCamera;
    constructor(parameters = {}) {
        super(parameters);
        this.activeCamera = parameters.camera;
        this.background = parameters.background;
        this.environment = parameters.environment;
        this.#layers[Symbol.iterator] = function* () {
            yield* [...this.entries()].sort((a, b) => {
                return a[1] < b[1] ? -1 : 1;
            });
        };
    }
    addLayer(layer /*TODO: create a layer type*/, index) {
        this.#layers.set(layer, index);
        this.#updateLayers();
        return layer;
    }
    removeLayer(layer /*TODO: create a layer type*/) {
        this.#layers.delete(layer);
        this.#updateLayers();
    }
    #updateLayers() {
        this.layers.clear();
        for (const [layer, index] of this.#layers) {
            this.layers.add(layer);
        }
    }
    setWorld(world) {
        this.#world = world;
    }
    getWorld() {
        return this.#world;
    }
    toString() {
        return 'Scene ' + super.toString();
    }
    static async constructFromJSON(json) {
        return new Scene({ name: json.name });
    }
    static getEntityName() {
        return 'Scene';
    }
    is(s) {
        if (s == 'Scene') {
            return true;
        }
        else {
            return super.is(s);
        }
    }
}
registerEntity(Scene);

const tempVec3$u = vec3.create();
class CubeBackground extends BackGround {
    #box = new Box();
    #scene = new Scene();
    #material = new ShaderMaterial({ shaderSource: 'skybox' });
    constructor(params = {}) {
        super();
        this.#material.depthTest = false;
        this.#material.depthMask = false;
        this.#material.renderFace(RenderFace.Back);
        this.#material.renderLights = false;
        this.#box.material = this.#material;
        this.#scene.addChild(this.#box);
        if (params.texture) {
            this.setTexture(params.texture);
        }
    }
    render(renderer, camera) {
        this.#box.setPosition(camera.getPosition(tempVec3$u));
        renderer.render(this.#scene, camera, 0, { DisableToolRendering: true });
    }
    setTexture(texture) {
        this.#material.setTexture('uCubeTexture', texture);
        if (texture.mapping == TextureMapping.CubeUvMapping) {
            this.#material.setDefine('TEXTURE_MAPPING_CUBE_UV');
            const envMapCubeUVSize = generateCubeUVSize(texture.height);
            this.#material.setDefine('CUBEUV_TEXEL_WIDTH', envMapCubeUVSize.texelWidth.toFixed(8));
            this.#material.setDefine('CUBEUV_TEXEL_HEIGHT', envMapCubeUVSize.texelHeight.toFixed(8));
            this.#material.setDefine('CUBEUV_MAX_MIP', envMapCubeUVSize.maxMip.toFixed(2));
        }
        else {
            this.#material.removeDefine('TEXTURE_MAPPING_CUBE_UV');
        }
    }
    dispose() {
        this.#box.dispose();
    }
    is(s) {
        if (s == 'CubeBackground') {
            return true;
        }
        else {
            return super.is(s);
        }
    }
}
function generateCubeUVSize(height) {
    const maxMip = Math.log2(height) - 2;
    const texelHeight = 1.0 / height;
    const texelWidth = 1.0 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
    return { texelWidth, texelHeight, maxMip };
}

var CameraProjection;
(function (CameraProjection) {
    CameraProjection[CameraProjection["Perspective"] = 0] = "Perspective";
    CameraProjection[CameraProjection["Orthographic"] = 1] = "Orthographic";
    CameraProjection[CameraProjection["Mixed"] = 2] = "Mixed";
})(CameraProjection || (CameraProjection = {}));
const tempQuat$b = quat.create();
const tempVec3$t = vec3.create();
const proj1 = mat4.create();
const proj2 = mat4.create();
const DEFAULT_NEAR_PLANE = 1;
const DEFAULT_FAR_PLANE = 1000;
const DEFAULT_ORTHO_ZOOM = 1;
const DEFAULT_PROJECTION = CameraProjection.Perspective;
const DEFAULT_PROJECTION_MIX = 0;
const DEFAULT_VERTICAL_FOV = 60;
const DEFAULT_ASPECT_RATIO = 1;
const DEFAULT_UP_VECTOR = vec3.fromValues(0, 0, 1);
const DEFAULT_LEFT = -1;
const DEFAULT_RIGHT = 1;
const DEFAULT_TOP = 1;
const DEFAULT_BOTTOM = -1;
const DEFAULT_AUTO_RESIZE = false;
const FrontVector = vec3.fromValues(0, 0, -1);
const LAMBDA = 10;
const LAMBDA_DIVIDOR = 1 - Math.exp(-LAMBDA);
class Camera extends Entity {
    #nearPlane;
    #farPlane;
    #orthoZoom;
    #projection;
    #projectionMix; // 0: full perspective 1: full ortho
    #left;
    #right;
    #top;
    #bottom;
    #cameraMatrix = mat4.create();
    #projectionMatrix = mat4.create();
    #verticalFov;
    #aspectRatio;
    #dirtyCameraMatrix = true;
    #dirtyProjectionMatrix = true;
    #projectionMatrixInverse = mat4.create();
    #worldMatrixInverse = mat4.create();
    #upVector = vec3.create();
    isPerspective;
    isOrthographic;
    #tanHalfVerticalFov;
    autoResize;
    constructor(params = {}) {
        super();
        super.setParameters(params);
        this.nearPlane = params.nearPlane ?? DEFAULT_NEAR_PLANE;
        this.farPlane = params.farPlane ?? DEFAULT_FAR_PLANE;
        this.orthoZoom = params.orthoZoom ?? DEFAULT_ORTHO_ZOOM;
        this.projectionMix = params.projectionMix ?? DEFAULT_PROJECTION_MIX;
        this.setProjection(params.projection ?? DEFAULT_PROJECTION);
        this.verticalFov = params.verticalFov ?? DEFAULT_VERTICAL_FOV;
        this.aspectRatio = params.aspectRatio ?? DEFAULT_ASPECT_RATIO;
        this.upVector = params.upVector ?? DEFAULT_UP_VECTOR;
        this.left = params.left ?? DEFAULT_LEFT;
        this.right = params.right ?? DEFAULT_RIGHT;
        this.top = params.top ?? DEFAULT_TOP;
        this.bottom = params.bottom ?? DEFAULT_BOTTOM;
        this.autoResize = params.autoResize ?? DEFAULT_AUTO_RESIZE;
        this.dirty();
        //this._renderMode = 2;
    }
    computeCameraMatrix() {
        mat4.fromRotationTranslation(this.#cameraMatrix, this.getWorldQuaternion(tempQuat$b), this.getWorldPosition(tempVec3$t));
        mat4.invert(this.#cameraMatrix, this.#cameraMatrix);
    }
    #computeProjectionMatrix() {
        if (this.#projection == CameraProjection.Perspective) {
            mat4.perspective(this.#projectionMatrix, this.#verticalFov, this.#aspectRatio, this.#nearPlane, this.#farPlane);
        }
        else if (this.#projection == CameraProjection.Orthographic) {
            const ortho = this.#orthoZoom;
            mat4.ortho(this.#projectionMatrix, this.#left / ortho, this.#right / ortho, this.#bottom / ortho, this.#top / ortho, this.#nearPlane, this.#farPlane);
        }
        else {
            // Mixed perspective / ortho
            const invOrtho = 1 / this.#orthoZoom;
            mat4.perspective(proj1, this.#verticalFov, this.#aspectRatio, this.#nearPlane, this.#farPlane);
            mat4.ortho(proj2, this.#left * invOrtho, this.#right * invOrtho, this.#bottom * invOrtho, this.#top * invOrtho, this.#nearPlane, this.#farPlane);
            mat4.multiplyScalar(this.#projectionMatrix, proj1, 1 - this.#projectionMix);
            mat4.multiplyScalarAndAdd(this.#projectionMatrix, this.#projectionMatrix, proj2, this.#projectionMix);
        }
    }
    reset() {
    }
    setProjection(projection) {
        const oldValue = this.#projection;
        this.#projection = projection;
        this.#dirtyProjectionMatrix = true;
        this.isPerspective = projection == CameraProjection.Perspective;
        this.isOrthographic = projection == CameraProjection.Orthographic;
        if (oldValue != projection) {
            EntityObserver.propertyChanged(this, 'projection', oldValue, this.#projection);
        }
    }
    get projection() {
        return this.#projection;
    }
    setProjectionMix(projectionMix) {
        this.projectionMix = (1 - Math.exp(-LAMBDA * projectionMix)) / LAMBDA_DIVIDOR;
    }
    set projectionMix(projectionMix) {
        const oldValue = this.#projectionMix;
        this.#projectionMix = projectionMix;
        if (projectionMix == 0) {
            this.setProjection(CameraProjection.Perspective);
        }
        else if (projectionMix == 1) {
            this.setProjection(CameraProjection.Orthographic);
        }
        else {
            this.setProjection(CameraProjection.Mixed);
        }
        if (oldValue != projectionMix) {
            EntityObserver.propertyChanged(this, 'projectionmix', oldValue, this.#projectionMix);
        }
    }
    get projectionMix() {
        return this.#projectionMix;
    }
    set nearPlane(nearPlane) {
        const oldValue = this.#nearPlane;
        this.#nearPlane = Number(nearPlane);
        this.#dirtyProjectionMatrix = true;
        if (oldValue != nearPlane) {
            EntityObserver.propertyChanged(this, 'nearplane', oldValue, this.#nearPlane);
        }
    }
    get nearPlane() {
        return this.#nearPlane;
    }
    set farPlane(farPlane) {
        const oldValue = this.#farPlane;
        this.#farPlane = Number(farPlane);
        this.#dirtyProjectionMatrix = true;
        if (oldValue != farPlane) {
            EntityObserver.propertyChanged(this, 'farplane', oldValue, this.#farPlane);
        }
    }
    get farPlane() {
        return this.#farPlane;
    }
    set orthoZoom(orthoZoom) {
        const oldValue = this.#orthoZoom;
        this.#orthoZoom = Number(orthoZoom);
        this.#dirtyProjectionMatrix = true;
        if (oldValue != orthoZoom) {
            EntityObserver.propertyChanged(this, 'orthozoom', oldValue, this.#orthoZoom);
        }
    }
    get orthoZoom() {
        return this.#orthoZoom;
    }
    set verticalFov(verticalFov) {
        const oldValue = this.#verticalFov;
        this.#verticalFov = verticalFov * DEG_TO_RAD;
        this.#tanHalfVerticalFov = Math.tan(this.#verticalFov * 0.5);
        this.#dirtyProjectionMatrix = true;
        if (oldValue != this.#verticalFov) {
            EntityObserver.propertyChanged(this, 'verticalfov', oldValue, this.#verticalFov);
        }
    }
    get verticalFov() {
        return this.#verticalFov * RAD_TO_DEG;
    }
    getTanHalfVerticalFov() {
        return this.#tanHalfVerticalFov;
    }
    set aspectRatio(aspectRatio) {
        const oldValue = this.#aspectRatio;
        this.#aspectRatio = Number(aspectRatio);
        this.#dirtyProjectionMatrix = true;
        if (oldValue != this.#aspectRatio) {
            EntityObserver.propertyChanged(this, 'aspectratio', oldValue, this.#aspectRatio);
        }
    }
    get aspectRatio() {
        return this.#aspectRatio;
    }
    set upVector(upVector) {
        vec3.copy(this.#upVector, upVector);
    }
    get upVector() {
        return this.#upVector;
    }
    set left(left) {
        const oldValue = this.#left;
        this.#left = Number(left);
        this.#dirtyProjectionMatrix = true;
        if (oldValue != this.#left) {
            EntityObserver.propertyChanged(this, 'left', oldValue, this.#left);
        }
    }
    get left() {
        return this.#left;
    }
    set right(right) {
        const oldValue = this.#right;
        this.#right = Number(right);
        this.#dirtyProjectionMatrix = true;
        if (oldValue != this.#right) {
            EntityObserver.propertyChanged(this, 'right', oldValue, this.#right);
        }
    }
    get right() {
        return this.#right;
    }
    set top(top) {
        const oldValue = this.#top;
        this.#top = Number(top);
        this.#dirtyProjectionMatrix = true;
        if (oldValue != this.#top) {
            EntityObserver.propertyChanged(this, 'top', oldValue, this.#top);
        }
    }
    get top() {
        return this.#top;
    }
    set bottom(bottom) {
        const oldValue = this.#bottom;
        this.#bottom = Number(bottom);
        this.#dirtyProjectionMatrix = true;
        if (oldValue != this.#bottom) {
            EntityObserver.propertyChanged(this, 'bottom', oldValue, this.#bottom);
        }
    }
    get bottom() {
        return this.#bottom;
    }
    dirty() {
        this.#dirtyCameraMatrix = true;
        this.#dirtyProjectionMatrix = true;
    }
    get cameraMatrix() {
        if (this.#dirtyCameraMatrix) {
            this.computeCameraMatrix();
            this.#dirtyCameraMatrix = false;
        }
        return this.#cameraMatrix;
    }
    get projectionMatrix() {
        if (this.#dirtyProjectionMatrix) {
            this.#computeProjectionMatrix();
            mat4.invert(this.#projectionMatrixInverse, this.#projectionMatrix);
            this.#dirtyProjectionMatrix = false;
        }
        return this.#projectionMatrix;
    }
    get projectionMatrixInverse() {
        if (this.#dirtyProjectionMatrix) {
            this.#computeProjectionMatrix();
            mat4.invert(this.#projectionMatrixInverse, this.#projectionMatrix);
            this.#dirtyProjectionMatrix = false;
        }
        return this.#projectionMatrixInverse;
    }
    get worldMatrixInverse() {
        //TODO: optimize
        mat4.invert(this.#worldMatrixInverse, this.worldMatrix);
        return this.#worldMatrixInverse;
    }
    distanceFrom(point) {
        return vec3.distance(this._position, point);
    }
    set position(position) {
        super.position = position;
        this.#dirtyCameraMatrix = true;
    }
    get position() {
        return super.position;
    }
    set quaternion(quaternion) {
        super.quaternion = quaternion;
        this.#dirtyCameraMatrix = true;
    }
    get quaternion() {
        return super.quaternion;
    }
    /*set renderMode(mode) {
        throw 'set renderMode(mode) {';
        if ((mode === 0) || (mode === 1) || (mode === 2) || (mode === 3)) {
            this._renderMode = mode;
        }
    }
    get renderMode() {
        throw 'get renderMode(mode) {';
        return this._renderMode;
    }*/
    toString() {
        return 'Camera ' + super.toString();
    }
    setActiveCamera() {
        const scene = this.root;
        if (scene.is('Scene')) {
            scene.activeCamera = this;
        }
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), {
            camera1: null,
            cameraPerspective: { i18n: '#perspective_camera', selected: this.isPerspective, f: () => this.setProjection(CameraProjection.Perspective) },
            cameraOrthographic: { i18n: '#orthographic_camera', selected: this.isOrthographic, f: () => this.setProjection(CameraProjection.Orthographic) },
            cameraNearPlane: { i18n: '#near_plane', f: () => { const nearPlane = prompt('Near plane', String(this.nearPlane)); if (nearPlane !== null) {
                    this.nearPlane = Number(nearPlane);
                } } },
            cameraFarPlane: { i18n: '#far_plane', f: () => { const farPlane = prompt('Far plane', String(this.farPlane)); if (farPlane !== null) {
                    this.farPlane = Number(farPlane);
                } } },
            cameraOrthoZoom: { i18n: '#zoom', f: () => { const zoom = prompt('Zoom', String(this.orthoZoom)); if (zoom !== null) {
                    this.orthoZoom = Number(zoom);
                } } },
            cameraFov: { i18n: '#fov', f: () => { const fov = prompt('FOV', String(this.verticalFov)); if (fov !== null) {
                    this.verticalFov = Number(fov);
                } } },
            cameraSetActiveCamera: { i18n: '#set_active_camera', f: () => this.setActiveCamera() },
        });
    }
    invertProjection(v3) {
        vec3.transformMat4(v3, v3, this.projectionMatrixInverse);
    }
    getViewDirection(v = vec3.create()) {
        return vec3.transformQuat(v, FrontVector, this.getWorldQuaternion(tempQuat$b));
    }
    copy(source) {
        super.copy(source);
        this.nearPlane = source.nearPlane;
        this.farPlane = source.farPlane;
        this.orthoZoom = source.orthoZoom;
        this.setProjection(source.projection);
        this.projectionMix = source.projectionMix;
        this.verticalFov = source.verticalFov;
        this.aspectRatio = source.aspectRatio;
        this.upVector = source.upVector;
        this.left = source.left;
        this.right = source.right;
        this.top = source.top;
        this.bottom = source.bottom;
        this.autoResize = source.autoResize;
        this.dirty();
    }
    toJSON() {
        const json = super.toJSON();
        if (this.nearPlane != DEFAULT_NEAR_PLANE) {
            json.nearplane = this.#nearPlane;
        }
        if (this.#farPlane != DEFAULT_FAR_PLANE) {
            json.farplane = this.#farPlane;
        }
        if (this.orthoZoom != DEFAULT_ORTHO_ZOOM) {
            json.orthoZoom = this.orthoZoom;
        }
        if (this.projection != DEFAULT_PROJECTION) {
            json.projection = this.projection;
        }
        if (this.#projectionMix != DEFAULT_PROJECTION_MIX) {
            json.projectionMix = this.#projectionMix;
        }
        if (this.verticalFov != DEFAULT_VERTICAL_FOV) {
            json.verticalFov = this.verticalFov;
        }
        if (this.aspectRatio != DEFAULT_ASPECT_RATIO) {
            json.aspectRatio = this.aspectRatio;
        }
        if (!vec3.equals(this.#upVector, DEFAULT_UP_VECTOR)) {
            json.upVector = this.upVector;
        }
        if (this.left != DEFAULT_LEFT) {
            json.left = this.left;
        }
        if (this.right != DEFAULT_RIGHT) {
            json.right = this.right;
        }
        if (this.top != DEFAULT_TOP) {
            json.top = this.top;
        }
        if (this.bottom != DEFAULT_BOTTOM) {
            json.bottom = this.bottom;
        }
        if (this.autoResize != DEFAULT_AUTO_RESIZE) {
            json.autoResize = this.autoResize;
        }
        return json;
    }
    static async constructFromJSON(json) {
        return new Camera(json);
    }
    static getEntityName() {
        return 'Camera';
    }
    is(s) {
        if (s == 'Camera') {
            return true;
        }
        else {
            return super.is(s);
        }
    }
}
registerEntity(Camera);

let Graphics$1;
function setGraphics(graphics) {
    Graphics$1 = graphics;
}

class Pass {
    camera;
    quad;
    scene;
    enabled = true;
    swapBuffers = true;
    renderToScreen = false;
    setSize(width, height) {
    }
    render(readBuffer, writeBuffer, renderToScreen, delta, context) {
        throw 'Can\'t render default pass';
    }
}

class ClearPass extends Pass {
    swapBuffers = false;
    #clearColor = vec4.create(); //TODO change to Color
    #clearDepth = 0;
    #clearStencil = 0;
    constructor(clearColor, clearDepth, clearStencil) {
        super();
        this.clearColor = clearColor;
        this.clearDepth = clearDepth;
        this.clearStencil = clearStencil;
    }
    set clearColor(clearColor) {
        vec4.copy(this.#clearColor, clearColor);
    }
    set clearDepth(clearDepth) {
        this.#clearDepth = clearDepth ?? null;
    }
    set clearStencil(clearStencil) {
        this.#clearStencil = clearStencil ?? null;
    }
    render(readBuffer, writeBuffer, renderToScreen, delta, context) {
        const clearColor = this.#clearColor != null;
        const clearDepth = this.#clearDepth != null;
        const clearStencil = this.#clearStencil != null;
        if (clearColor) {
            Graphics$1.clearColor(this.#clearColor);
        }
        if (clearDepth) {
            Graphics$1.clearDepth(this.#clearDepth);
        }
        if (clearStencil) {
            Graphics$1.clearStencil(this.#clearStencil);
        }
        Graphics$1.pushRenderTarget(renderToScreen ? null : writeBuffer);
        Graphics$1.clear(clearColor, clearDepth, clearStencil);
        Graphics$1.popRenderTarget();
    }
}

class FullScreenQuadGeometry extends BufferGeometry {
    constructor() {
        super();
        const indices = [0, 2, 1, 2, 3, 1];
        const vertices = [-1.0, 1.0, 0.0, 1.0, 1.0, 0.0, -1.0, -1.0, 0.0, 1.0, -1.0, 0.0];
        const uvs = [0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0];
        this.setIndex(new Uint16BufferAttribute(indices, 1));
        this.setAttribute('aVertexPosition', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('aVertexNormal', new Float32BufferAttribute(vertices, 3)); //TODOv3: fix this
        this.setAttribute('aTextureCoord', new Float32BufferAttribute(uvs, 2));
        this.count = indices.length;
    }
}
class FullScreenQuad extends Mesh {
    constructor(params = {}) {
        params.geometry = new FullScreenQuadGeometry();
        params.material = params.material ?? new MeshBasicMaterial();
        super(params);
        this.setDefine('SKIP_PROJECTION');
        super.setParameters(arguments[0]);
    }
}

class CopyPass extends Pass {
    constructor(camera) {
        super();
        const material = new ShaderMaterial({ shaderSource: 'copy', depthTest: false });
        material.addUser(this);
        this.scene = new Scene();
        this.quad = new FullScreenQuad({ material: material, parent: this.scene });
        this.camera = camera;
    }
    render(readBuffer, writeBuffer, renderToScreen, delta, context) {
        this.quad.getMaterial().uniforms['colorMap'] = readBuffer.getTexture();
        Graphics$1.pushRenderTarget(renderToScreen ? null : writeBuffer);
        Graphics$1.render(this.scene, this.camera, 0, context);
        Graphics$1.popRenderTarget();
    }
}

class CrosshatchPass extends Pass {
    constructor(camera) {
        super();
        const material = new ShaderMaterial({ shaderSource: 'crosshatch' });
        material.addUser(this);
        material.depthTest = false;
        this.scene = new Scene();
        this.quad = new FullScreenQuad({ material: material, parent: this.scene });
        this.camera = camera;
    }
    render(readBuffer, writeBuffer, renderToScreen, delta, context) {
        this.quad.getMaterial().uniforms['colorMap'] = readBuffer.getTexture();
        Graphics$1.pushRenderTarget(renderToScreen ? null : writeBuffer);
        Graphics$1.render(this.scene, this.camera, 0, context);
        Graphics$1.popRenderTarget();
    }
}

class GrainPass extends Pass {
    #intensity;
    //#density;
    //#size;
    constructor(camera) {
        super();
        const material = new ShaderMaterial({ shaderSource: 'grain' });
        material.addUser(this);
        material.uniforms['uGrainParams'] = vec4.create();
        material.depthTest = false;
        this.scene = new Scene();
        this.quad = new FullScreenQuad({ material: material, parent: this.scene });
        this.camera = camera;
        this.intensity = 0.2;
        //this.density = 0.2;
        //this.size = 1.0;
    }
    set intensity(intensity) {
        this.#intensity = intensity;
        this.quad.getMaterial().uniforms['uGrainIntensity'] = this.#intensity;
    }
    /*set density(density) {
        this.#density = density;
        this.quad.material.uniforms['uGrainParams'][1] = this.#density;
    }

    set size(size) {
        this.#size = size;
        this.quad.material.uniforms['uGrainParams'][2] = this.#size;
    }*/
    render(readBuffer, writeBuffer, renderToScreen, delta, context) {
        this.quad.getMaterial().uniforms['colorMap'] = readBuffer.getTexture();
        Graphics$1.pushRenderTarget(renderToScreen ? null : writeBuffer);
        Graphics$1.render(this.scene, this.camera, 0, context);
        Graphics$1.popRenderTarget();
    }
}

class OldMoviePass extends Pass {
    constructor(camera) {
        super();
        const material = new ShaderMaterial({ shaderSource: 'oldmovie' });
        material.addUser(this);
        material.depthTest = false;
        this.scene = new Scene();
        this.quad = new FullScreenQuad({ material: material, parent: this.scene });
        this.camera = camera;
    }
    render(readBuffer, writeBuffer, renderToScreen, delta, context) {
        this.quad.getMaterial().uniforms['colorMap'] = readBuffer.getTexture();
        Graphics$1.pushRenderTarget(renderToScreen ? null : writeBuffer);
        Graphics$1.render(this.scene, this.camera, 0, context);
        Graphics$1.popRenderTarget();
    }
}

const ATTACHMENT_TYPE_RENDER_BUFFER = 0;
const ATTACHMENT_TYPE_TEXTURE2D = 1;
class Framebuffer {
    #target;
    #frameBuffer;
    #width = 1;
    #height = 1;
    #attachments = new Map();
    #dirty = true;
    constructor(target) {
        this.#target = target;
        this.#frameBuffer = Graphics$1.createFramebuffer();
    }
    /*
    createRenderTarget(colorFormat, colorType, depth, stencil) {
        this.#frameBuffer.addTexture2D(GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, this._createTexture());
        this.frameBufferTexture = TextureManager.createTexture();

        this.bind();
    }

    _createTexture(internalFormat, width, height, format, type) {
        let texture = TextureManager.createTexture();

        Graphics.glContext.bindTexture(GL_TEXTURE_2D, texture);
        Graphics.glContext.texImage2D(GL_TEXTURE_2D, 0, internalFormat, width, height, 0, format, type, null);
        Graphics.glContext.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        Graphics.glContext.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        Graphics.glContext.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
        return texture;
    }
*/
    addRenderbuffer(attachmentPoint, renderbuffer) {
        this.#attachments.set(attachmentPoint, { renderbuffer: renderbuffer, type: ATTACHMENT_TYPE_RENDER_BUFFER });
        this.#dirty = true;
    }
    addTexture2D(attachmentPoint, textureTarget, texture) {
        this.#attachments.set(attachmentPoint, { target: textureTarget, texture: texture, type: ATTACHMENT_TYPE_TEXTURE2D });
        this.#dirty = true;
    }
    #setupAttachments() {
        for (const [attachmentPoint, attachmentParams] of this.#attachments) {
            switch (attachmentParams.type) {
                case ATTACHMENT_TYPE_RENDER_BUFFER:
                    //Graphics.glContext.bindRenderbuffer(GL_RENDERBUFFER, attachmentParams.renderbuffer);
                    //Graphics.renderbufferStorage(GL_RENDERBUFFER, GL_RGBA4, 256, 256);
                    Graphics$1.glContext.framebufferRenderbuffer(this.#target, attachmentPoint, GL_RENDERBUFFER, attachmentParams.renderbuffer.getRenderbuffer());
                    //Graphics.bindRenderbuffer(GL_RENDERBUFFER, null);
                    break;
                case ATTACHMENT_TYPE_TEXTURE2D:
                    //console.error(Graphics.getError());
                    const webGLTexture = attachmentParams.texture.texture;
                    Graphics$1.glContext.bindTexture(attachmentParams.target, null);
                    Graphics$1.glContext.framebufferTexture2D(this.#target, attachmentPoint, attachmentParams.target, webGLTexture, 0);
                    break;
            }
        }
        this.#dirty = false;
        //console.error(Graphics.checkFramebufferStatus(this.#target));
        //TODO: checkFramebufferStatus
    }
    bind() {
        Graphics$1.glContext.bindFramebuffer(this.#target, this.#frameBuffer);
        /*console.error(Graphics.getError());
        this.#setupAttachments();//TODOv3
        console.error(Graphics.getError());
        return;*/
        if (this.#dirty) {
            this.#setupAttachments();
        }
    }
    dispose() {
        Graphics$1.deleteFramebuffer(this.#frameBuffer);
        for (const [attachmentPoint, attachment] of this.#attachments) {
            switch (attachment.type) {
                case ATTACHMENT_TYPE_RENDER_BUFFER:
                    attachment.renderbuffer.dispose();
                    break;
                case ATTACHMENT_TYPE_TEXTURE2D:
                    attachment.texture.removeUser(this);
                    break;
            }
        }
    }
}

function renderbufferStorage(renderbuffer, internalFormat, width, height, samples) {
    const glContext = Graphics$1.glContext;
    glContext.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer);
    if (Graphics$1.isWebGL2 && samples > 0) {
        glContext.renderbufferStorageMultisample(GL_RENDERBUFFER, samples, internalFormat, width, height);
    }
    else {
        glContext.renderbufferStorage(GL_RENDERBUFFER, internalFormat, width, height);
    }
    glContext.bindRenderbuffer(GL_RENDERBUFFER, null);
}
class Renderbuffer {
    #renderbuffer;
    #internalFormat;
    #samples;
    constructor(internalFormat, width, height, samples) {
        this.#renderbuffer = Graphics$1.createRenderbuffer();
        this.#internalFormat = internalFormat;
        renderbufferStorage(this.#renderbuffer, this.#internalFormat, width, height, this.#samples ?? 0);
    }
    resize(width, height) {
        renderbufferStorage(this.#renderbuffer, this.#internalFormat, width, height, this.#samples ?? 0);
    }
    getRenderbuffer() {
        return this.#renderbuffer;
    }
    dispose() {
        Graphics$1.deleteRenderbuffer(this.#renderbuffer);
    }
}

class Color {
    r = 1;
    g = 1;
    b = 1;
    a = 1;
    constructor(r, g, b, a) {
        this.r = r ?? 1;
        this.g = g ?? 1;
        this.b = b ?? 1;
        this.a = a ?? 1;
    }
}

const textures$1 = new Set();
let context$1;
const TextureFactoryEventTarget = new EventTarget();
function setTextureFactoryContext(c) {
    context$1 = c;
}
function createTexture() {
    const texture = context$1.createTexture();
    textures$1.add(texture);
    TextureFactoryEventTarget.dispatchEvent(new CustomEvent('textureCreated', { detail: { texture: texture, count: textures$1.size } }));
    return texture;
}
function deleteTexture(texture) {
    if (texture) {
        context$1.deleteTexture(texture);
        textures$1.delete(texture);
        TextureFactoryEventTarget.dispatchEvent(new CustomEvent('textureDeleted', { detail: { texture: texture, count: textures$1.size } }));
    }
}
function fillFlatTexture(texture, color, needCubeMap) {
    const width = 64;
    const height = 64;
    if (texture) {
        const byteArray = new Uint8Array(width * height * 3);
        let pixelIndex = 0;
        const r = color.r * 255;
        const g = color.g * 255;
        const b = color.b * 255;
        for (let i = 0; i < width; i++) {
            for (let j = 0; j < height; j++) {
                //if ((i + j) % 2 == 0) {
                byteArray[pixelIndex] = r;
                byteArray[pixelIndex + 1] = g;
                byteArray[pixelIndex + 2] = b;
                //}
                pixelIndex += 3;
            }
        }
        if (needCubeMap) {
            context$1.bindTexture(GL_TEXTURE_CUBE_MAP, texture.texture);
            context$1.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context$1.texImage2D(GL_TEXTURE_CUBE_MAP_NEGATIVE_X, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context$1.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_Y, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context$1.texImage2D(GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context$1.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_Z, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context$1.texImage2D(GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context$1.texParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
            context$1.texParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
            context$1.generateMipmap(GL_TEXTURE_CUBE_MAP);
            context$1.bindTexture(GL_TEXTURE_CUBE_MAP, null);
        }
        else {
            context$1.bindTexture(GL_TEXTURE_2D, texture.texture); //TODOv3: pass param to createTexture and remove this
            context$1.texImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context$1.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
            context$1.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
            context$1.generateMipmap(GL_TEXTURE_2D);
            context$1.bindTexture(GL_TEXTURE_2D, null);
        }
    }
    return texture;
}
function fillCheckerTexture(texture, color, width = 64, height = 64, needCubeMap) {
    if (texture) {
        const byteArray = new Uint8Array(width * height * 3);
        let pixelIndex = 0;
        const r = color.r * 255;
        const g = color.g * 255;
        const b = color.b * 255;
        for (let i = 0; i < width; i++) {
            for (let j = 0; j < height; j++) {
                if ((i + j) % 2 == 0) {
                    byteArray[pixelIndex] = r;
                    byteArray[pixelIndex + 1] = g;
                    byteArray[pixelIndex + 2] = b;
                }
                pixelIndex += 3;
            }
        }
        if (needCubeMap) {
            context$1.bindTexture(GL_TEXTURE_CUBE_MAP, texture.texture);
            context$1.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context$1.texImage2D(GL_TEXTURE_CUBE_MAP_NEGATIVE_X, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context$1.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_Y, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context$1.texImage2D(GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context$1.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_Z, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context$1.texImage2D(GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context$1.texParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
            context$1.texParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
            context$1.generateMipmap(GL_TEXTURE_CUBE_MAP);
            context$1.bindTexture(GL_TEXTURE_CUBE_MAP, null);
        }
        else {
            context$1.bindTexture(GL_TEXTURE_2D, texture.texture); //TODOv3: pass param to createTexture and remove this
            context$1.texImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context$1.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
            context$1.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
            context$1.generateMipmap(GL_TEXTURE_2D);
            context$1.bindTexture(GL_TEXTURE_2D, null);
        }
    }
    return texture;
}
function fillNoiseTexture(texture, width = 64, height = 64, needCubeMap = false) {
    if (texture) {
        const byteArray = new Uint8Array(width * height * 3);
        let pixelIndex = 0;
        const randomVec3 = vec3.create();
        for (let i = 0; i < width; i++) {
            for (let j = 0; j < height; j++) {
                vec3.random(randomVec3, 255.0);
                byteArray[pixelIndex] = randomVec3[0];
                byteArray[pixelIndex + 1] = randomVec3[1];
                byteArray[pixelIndex + 2] = randomVec3[2];
                pixelIndex += 3;
            }
        }
        if (needCubeMap) {
            context$1.bindTexture(GL_TEXTURE_CUBE_MAP, texture.texture);
            context$1.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context$1.texImage2D(GL_TEXTURE_CUBE_MAP_NEGATIVE_X, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context$1.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_Y, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context$1.texImage2D(GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context$1.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_Z, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context$1.texImage2D(GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context$1.texParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
            context$1.texParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
            context$1.generateMipmap(GL_TEXTURE_CUBE_MAP);
            context$1.bindTexture(GL_TEXTURE_CUBE_MAP, null);
        }
        else {
            context$1.bindTexture(GL_TEXTURE_2D, texture.texture); //TODOv3: pass param to createTexture and remove this
            context$1.texImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, byteArray);
            context$1.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
            context$1.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
            context$1.generateMipmap(GL_TEXTURE_2D);
            context$1.bindTexture(GL_TEXTURE_2D, null);
        }
    }
    return texture;
}
function fillTextureWithImage(texture, image) {
    context$1.bindTexture(GL_TEXTURE_2D, texture.texture);
    context$1.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
    context$1.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, texture.flipY);
    context$1.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, GL_RGBA, GL_UNSIGNED_BYTE, image);
    context$1.generateMipmap(GL_TEXTURE_2D);
    context$1.bindTexture(GL_TEXTURE_2D, null);
    texture.width = image.width;
    texture.height = image.height;
    context$1.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, false);
}

class Texture {
    mapping = TextureMapping.UvMapping;
    #users = new Set();
    #alphaBits = 0;
    image;
    internalFormat;
    format;
    type;
    magFilter;
    minFilter;
    wrapS;
    wrapT;
    anisotropy;
    generateMipmaps = true;
    flipY = false;
    premultiplyAlpha = false;
    dirty = true;
    texture = null;
    width = 0;
    height = 0;
    isTexture = true;
    name = '';
    #colorSpace;
    isRenderTargetTexture = false;
    properties = new Map();
    defines = new Map();
    constructor(textureParams = {}) {
        //this.target = GL_TEXTURE_2D;//TODOv3 target bound to texture ?
        this.image = textureParams.image;
        this.internalFormat = textureParams.internalFormat || GL_RGBA;
        this.magFilter = textureParams.magFilter || GL_LINEAR;
        this.minFilter = textureParams.minFilter || GL_NEAREST_MIPMAP_LINEAR;
        this.wrapS = textureParams.wrapS || GL_REPEAT;
        this.wrapT = textureParams.wrapT || GL_REPEAT;
        //this.width = textureParams.width || 0;TODOv3
        //this.height = textureParams.height || 0;
        this.anisotropy = 0;
        this.flipY = textureParams.flipY ?? false;
        this.premultiplyAlpha = textureParams.premultiplyAlpha ?? false;
        this.#colorSpace = textureParams.colorSpace ?? ColorSpace.None;
        this.dirty = true; //removeme ?
        //this.texture = TextureManager.createTexture();
        //this.setParameters();
        /*gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, width, height, 0, gl.RGB, gl.UNSIGNED_BYTE, byteArray);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);*/
        /*gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);*/
    }
    setParameters(glContext, target) {
        glContext.bindTexture(target, this.texture);
        glContext.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, this.flipY);
        glContext.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);
        glContext.texParameteri(target, GL_TEXTURE_MAG_FILTER, this.magFilter);
        glContext.texParameteri(target, GL_TEXTURE_MIN_FILTER, this.minFilter);
        glContext.texParameteri(target, GL_TEXTURE_WRAP_S, this.wrapS);
        glContext.texParameteri(target, GL_TEXTURE_WRAP_T, this.wrapT);
        glContext.bindTexture(target, null);
    }
    texImage2D(glContext, target, width, height, format, type, pixels = null, level = 0) {
        glContext.bindTexture(target, this.texture);
        glContext.texImage2D(target, level, this.internalFormat, width, height, 0, format, type, pixels);
        glContext.bindTexture(target, null);
        this.width = width;
        this.height = height;
    }
    generateMipmap(glContext, target) {
        glContext.bindTexture(target, this.texture);
        glContext.generateMipmap(target);
        glContext.bindTexture(target, null);
    }
    clone() {
        return new Texture().copy(this);
    }
    copy(other) {
        this.image = other.image;
        this.#alphaBits = other.#alphaBits;
        this.internalFormat = other.internalFormat;
        this.magFilter = other.magFilter;
        this.minFilter = other.minFilter;
        this.wrapS = other.wrapS;
        this.wrapT = other.wrapT;
        this.anisotropy = other.anisotropy;
        this.generateMipmaps = other.generateMipmaps;
        this.flipY = other.flipY;
        this.premultiplyAlpha = other.premultiplyAlpha;
        this.dirty = true; //removeme ?
    }
    setAlphaBits(bits) {
        this.#alphaBits = bits;
    }
    getAlphaBits() {
        return this.#alphaBits;
    }
    hasAlphaChannel() {
        return this.#alphaBits > 0;
    }
    getWidth() {
        return this.width;
    }
    getHeight() {
        return this.height;
    }
    is(type) {
        return type === 'Texture';
    }
    addUser(user) {
        this.#users.add(user);
    }
    removeUser(user) {
        this.#users.delete(user);
        this.dispose();
    }
    hasNoUser() {
        return this.#users.size == 0;
    }
    hasOnlyUser(user) {
        return (this.#users.size == 1) && (this.#users.has(user));
    }
    dispose() {
        if (this.hasNoUser()) {
            deleteTexture(this.texture);
        }
    }
}

class TextureManager {
    static #texturesList = new Map();
    static setTexture(path, texture) {
        this.#texturesList.set(path, texture);
    }
    static createTexture(textureParams) {
        const texture = new Texture(textureParams);
        texture.texture = createTexture();
        //TODOv3: init texture parameters
        //texture.setParameters(Graphics.glContext, target);
        return texture;
    }
    static deleteTexture(texture) {
        deleteTexture(texture.texture);
    }
    static createFlatTexture(color = new Color(1, 0, 1), needCubeMap = false) {
        const texture = this.createTexture();
        fillFlatTexture(texture, color, needCubeMap);
        return texture;
    }
    static createCheckerTexture(color = new Color(1, 0, 1), width = 64, height = 64, needCubeMap = false) {
        const texture = this.createTexture();
        fillCheckerTexture(texture, color, width, height, needCubeMap);
        return texture;
    }
    static createNoiseTexture(width, height, needCubeMap = false) {
        const texture = this.createTexture();
        fillNoiseTexture(texture, width, height, needCubeMap);
        return texture;
    }
    static createTextureFromImage(image, textureParams) {
        const texture = this.createTexture(textureParams);
        fillTextureWithImage(texture, image);
        return texture;
    }
    static fillTextureWithImage(texture, image) {
        return fillTextureWithImage(texture, image);
    }
}

class RenderTarget {
    #width = 0;
    #height = 0;
    #target = GL_FRAMEBUFFER;
    #frameBuffer = new Framebuffer(this.#target);
    #depthRenderbuffer;
    #texture;
    #scissor = vec4.create();
    #viewport = vec4.create();
    #scissorTest = false;
    #depthBuffer;
    #stencilBuffer;
    #depthTexture;
    constructor(params = {} /*width, height, options = {}/*depth, stencil, texture*/) {
        const width = params.width ?? 1;
        const height = params.height ?? 1;
        if (params.texture) {
            this.#texture = params.texture;
        }
        else {
            this.#texture = TextureManager.createTexture({ internalFormat: params.internalFormat, format: params.format, type: params.type } /*{minFilter:GL_LINEAR, wrapS:GL_CLAMP_TO_EDGE, wrapT:GL_CLAMP_TO_EDGE}*/);
        }
        this.#texture.addUser(this);
        this.#texture.minFilter = GL_LINEAR;
        this.#texture.wrapS = GL_CLAMP_TO_EDGE;
        this.#texture.wrapT = GL_CLAMP_TO_EDGE;
        this.#texture.setParameters(Graphics$1.glContext, GL_TEXTURE_2D); //TODOv3: remove
        this.setViewport(0, 0, width, height);
        this.#depthBuffer = params.depthBuffer ?? true;
        this.#stencilBuffer = params.stencilBuffer ?? false;
        this.#depthTexture = params.depthTexture ?? false;
        this.#create(width, height);
    }
    #create(width, height) {
        this.#frameBuffer.addTexture2D(GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, this.#texture);
        this.#createDepthBuffer(width, height);
        if (this.#stencilBuffer) ;
        this.resize(width, height);
    }
    #createDepthBuffer(width, height) {
        if (this.#depthBuffer && !this.#depthRenderbuffer) { //TODOv3 DEPTH_STENCIL
            this.#depthRenderbuffer = new Renderbuffer(GL_DEPTH_COMPONENT16, width, height);
            this.#frameBuffer.addRenderbuffer(GL_DEPTH_ATTACHMENT, this.#depthRenderbuffer);
        }
    }
    setDepthBuffer(depthBuffer) {
        this.#depthBuffer = depthBuffer;
        this.#createDepthBuffer(this.#width, this.#height);
    }
    setScissorTest(scissorTest) {
        this.#scissorTest = scissorTest;
    }
    getWidth() {
        return this.#width;
    }
    getHeight() {
        return this.#height;
    }
    getTexture() {
        return this.#texture;
    }
    /**
     * @deprecated Please use `getTexture` instead.
     */
    get texture() {
        throw 'deprecated, use getTexture()';
    }
    bind() {
        this.#frameBuffer.bind();
        Graphics$1.viewport = this.#viewport;
    }
    unbind() {
        Graphics$1.glContext.bindFramebuffer(GL_FRAMEBUFFER, null);
    }
    resize(width, height) {
        this.#width = width;
        this.#height = height;
        this.#texture.texImage2D(Graphics$1.glContext, GL_TEXTURE_2D, width, height, TextureFormat.Rgba, TextureType.UnsignedByte);
        //TODOv3: stencil / depth buffer
        if (this.#depthRenderbuffer) {
            this.#depthRenderbuffer.resize(width, height);
        }
        this.setViewport(0, 0, width, height);
    }
    setViewport(x, y, width, height) {
        vec4.set(this.#viewport, x, y, width, height);
        vec4.set(this.#scissor, x, y, width, height);
    }
    clone() {
        const dest = new RenderTarget({ width: this.#width, height: this.#height, depthBuffer: this.#depthBuffer, stencilBuffer: this.#stencilBuffer });
        //dest.texture = this.#texture.clone();
        return dest;
    }
    dispose() {
        this.#texture.removeUser(this);
        this.#frameBuffer.dispose();
    }
}

const CLEAR_COLOR$1 = vec4.fromValues(0, 0, 0, 0);
const tempVec2$4 = vec2.create();
class OutlinePass extends Pass {
    #edgedetectionMaterial;
    #copyMaterial;
    outlineScene;
    #renderTargetDepthBuffer;
    #renderTargetMaskDownSampleBuffer;
    #renderTargetBlurBuffer1;
    #renderTargetBlurBuffer2;
    #renderTargetEdgeBuffer1;
    #renderTargetEdgeBuffer2;
    width = 1;
    height = 1;
    constructor(outlineScene, camera) {
        super();
        this.outlineScene = outlineScene;
        this.camera = camera;
        this.#initRenderTargets();
        this.#copyMaterial = new ShaderMaterial({ shaderSource: 'copy' });
        this.#copyMaterial.addUser(this);
        this.#copyMaterial.depthTest = false;
        this.#copyMaterial.setBlending(MATERIAL_BLENDING_ADDITIVE);
        this.#edgedetectionMaterial = new ShaderMaterial({ shaderSource: 'edgedetection' });
        this.#edgedetectionMaterial.addUser(this);
        this.scene = new Scene();
        this.quad = new FullScreenQuad({ parent: this.scene });
        //this.quad.material = material;
        this.camera = camera;
    }
    #initRenderTargets() {
        this.#renderTargetDepthBuffer = new RenderTarget({ width: 1, height: 1, } /*, {internalFormat:GL_DEPTH_COMPONENT16, format:GL_DEPTH_COMPONENT, type:GL_UNSIGNED_INT}*/);
        this.#renderTargetMaskDownSampleBuffer = new RenderTarget({ width: 1, height: 1, });
        this.#renderTargetBlurBuffer1 = new RenderTarget({ width: 1, height: 1, });
        this.#renderTargetBlurBuffer2 = new RenderTarget({ width: 1, height: 1, });
        this.#renderTargetEdgeBuffer1 = new RenderTarget({ width: 1, height: 1, });
        this.#renderTargetEdgeBuffer2 = new RenderTarget({ width: 1, height: 1, });
    }
    setSize(width, height) {
        this.width = width;
        this.height = height;
        this.#renderTargetDepthBuffer.resize(width, height);
        this.#renderTargetMaskDownSampleBuffer.resize(width, height);
        this.#renderTargetBlurBuffer1.resize(width, height);
        this.#renderTargetBlurBuffer2.resize(width, height);
        this.#renderTargetEdgeBuffer1.resize(width, height);
        this.#renderTargetEdgeBuffer2.resize(width, height);
    }
    changeVisibilityOfSelectedObjects(visible) {
        this.outlineScene.forEach((entity) => {
            if (entity.properties.get('selected') && entity.isRenderable) {
                if (visible) {
                    entity.setVisible(entity.properties.getBoolean('oldVisible'));
                    entity.properties.delete('oldVisible');
                }
                else {
                    const isVisibleSelf = entity.isVisibleSelf();
                    if (isVisibleSelf !== undefined) {
                        entity.properties.setBoolean('oldVisible', isVisibleSelf);
                    }
                    entity.setVisible(visible);
                }
            }
        });
    }
    changeVisibilityOfNonSelectedObjects(visible) {
        this.outlineScene.forEach((entity) => {
            if (!entity.properties.get('selected') && entity.isRenderable) {
                if (visible) {
                    entity.setVisible(entity.properties.getBoolean('oldVisible'));
                    entity.properties.delete('oldVisible');
                }
                else {
                    const isVisibleSelf = entity.isVisibleSelf();
                    if (isVisibleSelf !== undefined) {
                        entity.properties.setBoolean('oldVisible', isVisibleSelf);
                    }
                    entity.setVisible(visible);
                }
            }
        });
    }
    render(readBuffer, writeBuffer, renderToScreen, delta, context) {
        Graphics$1.getSize(tempVec2$4);
        tempVec2$4[0];
        tempVec2$4[1];
        Graphics$1.clearColor(CLEAR_COLOR$1);
        Graphics$1.pushRenderTarget(this.#renderTargetDepthBuffer);
        Graphics$1.clear(true, true, false);
        //renderer.setIncludeCode('WRITE_DEPTH_TO_COLOR', '#define WRITE_DEPTH_TO_COLOR');
        this.changeVisibilityOfSelectedObjects(false);
        Graphics$1.setColorMask([0, 0, 0, 0]);
        Graphics$1.render(this.outlineScene, this.camera, 0, context);
        Graphics$1.setColorMask([1, 1, 1, 1]);
        this.changeVisibilityOfSelectedObjects(true);
        //renderer.setIncludeCode('WRITE_DEPTH_TO_COLOR', '');
        this.changeVisibilityOfNonSelectedObjects(false);
        Graphics$1.setIncludeCode('outline_pass_silhouette_mode', '#define SILHOUETTE_MODE');
        Graphics$1.setIncludeCode('silhouetteColor', '#define SILHOUETTE_COLOR vec4(1.0)');
        Graphics$1.render(this.outlineScene, this.camera, 0, context);
        Graphics$1.setIncludeCode('outline_pass_silhouette_mode', '#undef SILHOUETTE_MODE');
        this.changeVisibilityOfNonSelectedObjects(true);
        Graphics$1.popRenderTarget();
        /**************/
        this.#edgedetectionMaterial.uniforms['colorMap'] = this.#renderTargetDepthBuffer.getTexture(); //TODO: optiùmize this
        this.#edgedetectionMaterial.uniforms['uTexSize'] = [this.width, this.height];
        this.#edgedetectionMaterial.uniforms['uVisibleEdgeColor'] = [1, 1, 1];
        this.#edgedetectionMaterial.uniforms['uHiddenEdgeColor'] = [0, 1, 0];
        this.quad.setMaterial(this.#edgedetectionMaterial);
        Graphics$1.pushRenderTarget(this.#renderTargetEdgeBuffer1);
        Graphics$1.clear(true, true, false);
        Graphics$1.render(this.scene, this.camera, 0, context);
        Graphics$1.popRenderTarget();
        /**************/
        this.#copyMaterial.uniforms['colorMap'] = readBuffer.getTexture();
        this.quad.setMaterial(this.#copyMaterial);
        Graphics$1.pushRenderTarget(renderToScreen ? null : writeBuffer);
        Graphics$1.clear(true, true, false);
        Graphics$1.render(this.scene, this.camera, 0, context);
        Graphics$1.popRenderTarget();
        /***************/
        this.#copyMaterial.uniforms['colorMap'] = this.#renderTargetEdgeBuffer1.getTexture();
        this.quad.setMaterial(this.#copyMaterial);
        Graphics$1.pushRenderTarget(renderToScreen ? null : writeBuffer);
        Graphics$1.render(this.scene, this.camera, 0, context);
        Graphics$1.popRenderTarget();
    }
}

class PalettePass extends Pass {
    constructor(camera) {
        super();
        const material = new ShaderMaterial({ shaderSource: 'palette' });
        material.addUser(this);
        material.depthTest = false;
        this.scene = new Scene();
        this.quad = new FullScreenQuad({ material: material, parent: this.scene });
        this.camera = camera;
    }
    render(readBuffer, writeBuffer, renderToScreen, delta, context) {
        this.quad.getMaterial().uniforms['colorMap'] = readBuffer.getTexture();
        Graphics$1.pushRenderTarget(renderToScreen ? null : writeBuffer);
        Graphics$1.render(this.scene, this.camera, 0, context);
        Graphics$1.popRenderTarget();
    }
}

class PixelatePass extends Pass {
    #horizontalTiles = 0;
    #pixelStyle = 0;
    #material;
    constructor(camera) {
        super();
        this.#material = new ShaderMaterial({ shaderSource: 'pixelate' });
        this.#material.addUser(this);
        this.#material.depthTest = false;
        this.scene = new Scene();
        this.quad = new FullScreenQuad({ material: this.#material, parent: this.scene });
        this.camera = camera;
        this.horizontalTiles = 10;
    }
    set horizontalTiles(horizontalTiles) {
        this.#horizontalTiles = horizontalTiles;
        this.#material.uniforms['uHorizontalTiles'] = this.#horizontalTiles;
    }
    set pixelStyle(pixelStyle /*TODO: creacte enum*/) {
        this.#pixelStyle = pixelStyle;
        this.#material.setDefine('PIXEL_STYLE', String(pixelStyle));
    }
    render(readBuffer, writeBuffer, renderToScreen, delta, context) {
        this.#material.uniforms['colorMap'] = readBuffer.getTexture();
        Graphics$1.pushRenderTarget(renderToScreen ? null : writeBuffer);
        Graphics$1.render(this.scene, this.camera, 0, context);
        Graphics$1.popRenderTarget();
    }
}

class RenderPass extends Pass {
    constructor(scene, camera) {
        super();
        this.swapBuffers = false;
        this.scene = scene;
        this.camera = camera;
    }
    render(readBuffer, writeBuffer, renderToScreen, delta, context) {
        Graphics$1.pushRenderTarget(renderToScreen ? null : writeBuffer);
        Graphics$1.render(this.scene, this.camera, delta, context);
        Graphics$1.popRenderTarget();
    }
}

class SaturatePass extends Pass {
    #saturation = 0;
    constructor(camera) {
        super();
        const material = new ShaderMaterial({ shaderSource: 'saturate' });
        material.addUser(this);
        material.depthTest = false;
        this.scene = new Scene();
        this.quad = new FullScreenQuad({ material: material, parent: this.scene });
        this.camera = camera;
        this.saturation = 1.0;
    }
    set saturation(saturation) {
        this.#saturation = saturation;
        this.quad.getMaterial().uniforms['uSaturation'] = this.#saturation;
    }
    render(readBuffer, writeBuffer, renderToScreen, delta, context) {
        this.quad.getMaterial().uniforms['colorMap'] = readBuffer.getTexture();
        Graphics$1.pushRenderTarget(renderToScreen ? null : writeBuffer);
        Graphics$1.render(this.scene, this.camera, 0, context);
        Graphics$1.popRenderTarget();
    }
}

class SketchPass extends Pass {
    constructor(camera) {
        super();
        const material = new ShaderMaterial({ shaderSource: 'sketch' });
        material.addUser(this);
        material.depthTest = false;
        this.scene = new Scene();
        this.quad = new FullScreenQuad({ material: material, parent: this.scene });
        this.camera = camera;
    }
    render(readBuffer, writeBuffer, renderToScreen, delta, context) {
        this.quad.getMaterial().uniforms['colorMap'] = readBuffer.getTexture();
        Graphics$1.pushRenderTarget(renderToScreen ? null : writeBuffer);
        Graphics$1.render(this.scene, this.camera, 0, context);
        Graphics$1.popRenderTarget();
    }
}

const tempVec2$3 = vec2.create();
class Composer {
    #width = 0;
    #height = 0;
    enabled = true;
    #passes = [];
    #renderTarget1;
    #renderTarget2;
    #readBuffer;
    #writeBuffer;
    constructor(renderTarget) {
        if (!renderTarget) {
            const rendererSize = Graphics$1.getSize();
            renderTarget = new RenderTarget({ width: rendererSize[0], height: rendererSize[1], depthBuffer: true, stencilBuffer: true });
        }
        this.#setRenderTarget(renderTarget);
    }
    render(delta, context) {
        let pass;
        let swapBuffer;
        Graphics$1.getSize(tempVec2$3);
        this.setSize(tempVec2$3[0], tempVec2$3[1]);
        let lastPass = -1;
        for (let i = this.#passes.length - 1; i > 0; --i) {
            if (this.#passes[i].enabled) {
                lastPass = i;
                break;
            }
        }
        for (let i = 0, l = this.#passes.length; i < l; ++i) {
            pass = this.#passes[i];
            if (!pass.enabled) {
                continue;
            }
            if (pass.swapBuffers) {
                swapBuffer = this.#readBuffer;
                this.#readBuffer = this.#writeBuffer;
                this.#writeBuffer = swapBuffer;
            }
            pass.render(this.#readBuffer, this.#writeBuffer, i == lastPass, delta, context);
        }
    }
    savePicture(filename, width, height) {
        this.setSize(width, height);
        this.render(0, { DisableToolRendering: true });
        Graphics$1._savePicture(filename);
    }
    addPass(pass) {
        this.#passes.push(pass);
        Graphics$1.getSize(tempVec2$3);
        pass.setSize(tempVec2$3[0], tempVec2$3[1]);
    }
    #setRenderTarget(renderTarget) {
        this.#renderTarget1 = renderTarget;
        this.#renderTarget2 = renderTarget.clone();
        this.#writeBuffer = this.#renderTarget1;
        this.#readBuffer = this.#renderTarget2;
    }
    setSize(width, height) {
        if (this.#width != width || this.#height != height) {
            this.#width = width;
            this.#height = height;
            this.#renderTarget1.resize(width, height);
            this.#renderTarget2.resize(width, height);
            for (let i = 0, l = this.#passes.length; i < l; ++i) {
                this.#passes[i].setSize(width, height);
            }
        }
    }
}

class CameraControl {
    #camera;
    #enabled = true;
    constructor(camera) {
        this.#camera = camera;
    }
    set enabled(enabled) {
        this.#enabled = enabled;
        this.handleEnabled();
    }
    get enabled() {
        return this.#enabled && !Graphics$1.dragging;
    }
    set camera(camera) {
        this.#camera = camera;
        this.setupCamera();
    }
    get camera() {
        return this.#camera;
    }
    setupCamera() {
    }
    handleEnabled() {
    }
    update(delta) {
    }
}

const EPSILON = 0.000001;
class Spherical {
    theta;
    phi;
    radius;
    constructor(theta = 0, phi = 0, radius = 1.0) {
        this.set(theta, phi, radius);
    }
    set(theta = 0, phi = 0, radius = 1.0) {
        this.theta = theta;
        this.phi = phi;
        this.radius = radius;
    }
    clone() {
        return new Spherical().copy(this);
    }
    copy(other) {
        this.radius = other.radius;
        this.phi = other.phi;
        this.theta = other.theta;
    }
    makeSafe() {
        this.phi = Math.max(EPSILON, Math.min(Math.PI - EPSILON, this.phi));
    }
    setFromVector3(v) {
        this.setFromCartesianCoords(v[0], v[1], v[2]);
    }
    setFromCartesianCoords(x, y, z) {
        this.radius = Math.sqrt(x * x + y * y + z * z);
        if (this.radius === 0) {
            this.theta = 0;
            this.phi = 0;
        }
        else {
            this.theta = Math.atan2(y, x);
            this.phi = Math.atan2(Math.sqrt(x * x + y * y), z);
        }
    }
    toCartesian(v) {
        const sinPhiRadius = Math.sin(this.phi) * this.radius;
        v[0] = sinPhiRadius * Math.cos(this.theta);
        v[1] = sinPhiRadius * Math.sin(this.theta);
        v[2] = Math.cos(this.phi) * this.radius;
    }
}

var GraphicsEvent;
(function (GraphicsEvent) {
    GraphicsEvent["MouseMove"] = "mousemove";
    GraphicsEvent["MouseDown"] = "mousedown";
    GraphicsEvent["MouseUp"] = "mouseup";
    GraphicsEvent["Wheel"] = "wheel";
    GraphicsEvent["Resize"] = "resize";
    GraphicsEvent["Tick"] = "tick";
    GraphicsEvent["KeyDown"] = "keydown";
    GraphicsEvent["KeyUp"] = "keyup";
    GraphicsEvent["TouchStart"] = "touchstart";
    GraphicsEvent["TouchMove"] = "touchmove";
    GraphicsEvent["TouchCancel"] = "touchcancel";
})(GraphicsEvent || (GraphicsEvent = {}));
class GraphicsEvents extends StaticEventTarget {
    static isGraphicsEvents = true;
    static tick(delta, time, speed) {
        this.dispatchEvent(new CustomEvent(GraphicsEvent.Tick, { detail: { delta: delta, time: time, speed: speed } }));
    }
    static resize(width, height) {
        this.dispatchEvent(new CustomEvent(GraphicsEvent.Resize, { detail: { width: width, height: height } }));
    }
    static mouseMove(x, y, pickedEntity, mouseEvent) {
        this.dispatchEvent(new CustomEvent(GraphicsEvent.MouseMove, { detail: { x: x, y: y, entity: pickedEntity, mouseEvent: mouseEvent } }));
    }
    static mouseDown(x, y, pickedEntity, mouseEvent) {
        this.dispatchEvent(new CustomEvent(GraphicsEvent.MouseDown, { detail: { x: x, y: y, entity: pickedEntity, mouseEvent: mouseEvent } }));
    }
    static mouseUp(x, y, pickedEntity, mouseEvent) {
        this.dispatchEvent(new CustomEvent(GraphicsEvent.MouseUp, { detail: { x: x, y: y, entity: pickedEntity, mouseEvent: mouseEvent } }));
    }
    static wheel(x, y, pickedEntity, wheelEvent) {
        this.dispatchEvent(new CustomEvent(GraphicsEvent.Wheel, { detail: { x: x, y: y, entity: pickedEntity, wheelEvent: wheelEvent } }));
    }
    static keyDown(keyboardEvent) {
        this.dispatchEvent(new CustomEvent(GraphicsEvent.KeyDown, { detail: { keyboardEvent: keyboardEvent } }));
    }
    static keyUp(keyboardEvent) {
        this.dispatchEvent(new CustomEvent(GraphicsEvent.KeyUp, { detail: { keyboardEvent: keyboardEvent } }));
    }
    static touchStart(pickedEntity, touchEvent) {
        this.dispatchEvent(new CustomEvent(GraphicsEvent.TouchStart, { detail: { entity: pickedEntity, touchEvent: touchEvent } }));
    }
    static touchMove(pickedEntity, touchEvent) {
        this.dispatchEvent(new CustomEvent(GraphicsEvent.TouchMove, { detail: { entity: pickedEntity, touchEvent: touchEvent } }));
    }
    static touchCancel(pickedEntity, touchEvent) {
        this.dispatchEvent(new CustomEvent(GraphicsEvent.TouchCancel, { detail: { entity: pickedEntity, touchEvent: touchEvent } }));
    }
}

const xUnitVec3$1 = vec3.fromValues(1, 0, 0);
vec3.fromValues(0, 1, 0);
const zUnitVec3$2 = vec3.fromValues(0, 0, 1);
const minusZUnitVec3 = vec3.fromValues(0, 0, -1);
const tempVec3$s = vec3.create();
const spherical$1 = new Spherical();
class FirstPersonControl extends CameraControl {
    #enableDamping = false;
    #dampingFactor = 0.05;
    #sphericalDelta = new Spherical();
    #rotateDelta = vec2.create();
    movementSpeed = 1.0;
    lookSpeed = 0.005;
    #rotateSpeed = 0.3;
    lookVertical = true;
    autoForward = false;
    activeLook = true;
    heightSpeed = false;
    heightCoef = 1.0;
    heightMin = 0.0;
    heightMax = 1.0;
    constrainVertical = false;
    verticalMin = 0;
    verticalMax = Math.PI;
    #mouseDragOn = false;
    #autoSpeedFactor = 0.0;
    #mouseX = 0;
    #mouseY = 0;
    #moveForward = false;
    #moveBackward = false;
    #moveLeft = false;
    #moveRight = false;
    #moveUp = false;
    #moveDown = false;
    #viewHalfX = 0;
    #viewHalfY = 0;
    #lat = 0;
    #lon = 0;
    #startLat = 0;
    #startLon = 0;
    #click = false;
    #q = quat.create();
    #quatInverse = quat.create();
    //#clickOffsetX: number;
    //#clickOffsetY: number;
    constructor(camera) {
        super(camera);
        //private
        //var target = vec3.create();
        //todo: set in webglcanvas
        /*if (this.htmlElement !== document) {
            this.htmlElement.setAttribute('tabindex', - 1);
        }*/
        this.#setupEventsListeners();
        this.#handleResize();
        //this.update();
        quat.invert(this.#quatInverse, this.#q);
        this.#setOrientation();
    }
    #handleResize() {
        return;
        /*
        if (this.htmlElement === document) {
            this.viewHalfX = window.innerWidth / 2;
            this.viewHalfY = window.innerHeight / 2;
        } else {
            this.viewHalfX = this.htmlElement.offsetWidth / 2;
            this.viewHalfY = this.htmlElement.offsetHeight / 2;
        }
            */
    }
    #onMouseDown(event) {
        if (!this.enabled) {
            return;
        }
        //if (this.htmlElement !== document) {
        //this.htmlElement.focus();
        //}
        //event.preventDefault();
        //event.stopPropagation();
        const mouseEvent = event.detail.mouseEvent;
        if (this.activeLook) {
            switch (mouseEvent.button) {
                case 0:
                    this.#click = true;
                    //this.#clickOffsetX = mouseEvent.offsetX;
                    //this.#clickOffsetY = mouseEvent.offsetY;
                    this.#startLat = this.#lat;
                    this.#startLon = this.#lon;
                    this.#mouseX = 0;
                    this.#mouseY = 0;
                    break;
                //case 0: this.#moveForward = true; break;
                //case 2: this.#moveBackward = true; break;
            }
        }
        event.target.requestPointerLock();
        this.#mouseDragOn = true;
    }
    #onMouseUp(event) {
        document.exitPointerLock();
        const mouseEvent = event.detail.mouseEvent;
        mouseEvent.preventDefault();
        //event.stopPropagation();
        if (this.activeLook) {
            switch (mouseEvent.button) {
                case 0:
                    this.#click = false;
                    this.#startLat = this.#lat;
                    this.#startLon = this.#lon;
                    break;
                case 0:
                    this.#moveForward = false;
                    break;
                case 2:
                    this.#moveBackward = false;
                    break;
            }
        }
        this.#mouseDragOn = false;
    }
    #onMouseMove(event) {
        const mouseEvent = event.detail.mouseEvent;
        if (this.#mouseDragOn) {
            {
                /*this.#mouseX = (event.offsetX - this.viewHalfX - this.#clickOffsetX);
                this.#mouseY = (event.offsetY - this.viewHalfY - this.#clickOffsetY);
                this.#mouseX = (event.offsetX - this.#clickOffsetX);
                this.#mouseY = (event.offsetY - this.#clickOffsetY);*/
                this.#mouseX += mouseEvent.movementX;
                this.#mouseY += mouseEvent.movementY;
                //console.error(event, this.#clickOffsetX, this.#clickOffsetY);
            }
            //console.error(this.#mouseX, this.#mouseY);
            this.#rotateDelta[0] = mouseEvent.movementX * this.#rotateSpeed;
            this.#rotateDelta[1] = mouseEvent.movementY * this.#rotateSpeed;
            //console.error(event.movementX, event.movementY, ...this.#rotateDelta);
            const element = mouseEvent.target;
            this.#rotateLeft(2 * Math.PI * this.#rotateDelta[0] / element.clientHeight); // yes, height
            this.#rotateUp(-2 * Math.PI * this.#rotateDelta[1] / element.clientHeight);
        }
    }
    #onKeyDown(event) {
        //event.preventDefault();
        switch (event.detail.keyboardEvent.code) {
            case 'ArrowUp':
            case 'KeyW':
                this.#moveForward = true;
                break;
            case 'ArrowLeft':
            case 'KeyA':
                this.#moveLeft = true;
                break;
            case 'ArrowDown':
            case 'KeyS':
                this.#moveBackward = true;
                break;
            case 'ArrowRight':
            case 'KeyD':
                this.#moveRight = true;
                break;
            case 'Space':
                this.#moveUp = true;
                break;
            case 'KeyC':
                this.#moveDown = true;
                break;
        }
        //console.error(event.code);//removeme
    }
    #onKeyUp(event) {
        switch (event.detail.keyboardEvent.code) {
            case 'ArrowUp':
            case 'KeyW':
                this.#moveForward = false;
                break;
            case 'ArrowLeft':
            case 'KeyA':
                this.#moveLeft = false;
                break;
            case 'ArrowDown':
            case 'KeyS':
                this.#moveBackward = false;
                break;
            case 'ArrowRight':
            case 'KeyD':
                this.#moveRight = false;
                break;
            case 'Space':
                this.#moveUp = false;
                break;
            case 'KeyC':
                this.#moveDown = false;
                break;
        }
    }
    update(delta = 0) {
        if (this.enabled === false) {
            return;
        }
        if (this.heightSpeed) {
            const y = clamp$1(this.camera?.position[1] ?? 0, this.heightMin, this.heightMax); //TODO
            const heightDelta = y - this.heightMin;
            this.#autoSpeedFactor = delta * (heightDelta * this.heightCoef);
        }
        else {
            this.#autoSpeedFactor = 0.0;
        }
        const actualMoveSpeed = delta * this.movementSpeed;
        if (this.#moveForward || (this.autoForward && !this.#moveBackward)) {
            this.camera?.translateZ(-(actualMoveSpeed + this.#autoSpeedFactor));
        }
        if (this.#moveBackward) {
            this.camera?.translateZ(actualMoveSpeed);
        }
        if (this.#moveLeft) {
            this.camera?.translateX(-actualMoveSpeed);
        }
        if (this.#moveRight) {
            this.camera?.translateX(actualMoveSpeed);
        }
        if (this.#moveUp) {
            this.camera?.translateY(actualMoveSpeed);
        }
        if (this.#moveDown) {
            this.camera?.translateY(-actualMoveSpeed);
        }
        let actualLookSpeed = this.lookSpeed;
        if (!this.activeLook) {
            actualLookSpeed = 0;
        }
        if (!this.#click) {
            actualLookSpeed = 0;
        }
        let verticalLookRatio = 1;
        if (this.constrainVertical) {
            verticalLookRatio = Math.PI / (this.verticalMax - this.verticalMin);
        }
        //this.#lon -= this.#mouseX * actualLookSpeed;
        this.#lon = this.#startLon - this.#mouseX * actualLookSpeed;
        if (this.#click) ;
        if (this.lookVertical) {
            this.#lat = this.#startLat - this.#mouseY * actualLookSpeed * verticalLookRatio;
        }
        if (this.#click) ;
        if (this.#enableDamping) {
            spherical$1.theta += this.#sphericalDelta.theta * this.#dampingFactor;
            spherical$1.phi += this.#sphericalDelta.phi * this.#dampingFactor;
        }
        else {
            spherical$1.theta += this.#sphericalDelta.theta;
            spherical$1.phi += this.#sphericalDelta.phi;
        }
        //this.#lat = Math.max(- 85, Math.min(85, this.#lat));
        //this.#lat = 90;//removeme
        let phi = DEG_TO_RAD * (90 - this.#lat);
        DEG_TO_RAD * (this.#lon);
        if (this.#click) ;
        function mapLinear(x, a1, a2, b1, b2) {
            return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
        }
        if (this.constrainVertical) {
            phi = mapLinear(phi, 0, Math.PI, this.verticalMin, this.verticalMax);
        }
        const position = this.camera?.position ?? vec3.create() /*TODO: optimize*/;
        spherical$1.toCartesian(tempVec3$s);
        // rotate offset back to 'camera-up-vector-is-up' space
        //offset.applyQuaternion(quatInverse);
        //vec3.transformQuat(tempVec3, tempVec3, this.#quatInverse);
        //position.copy(this.target).add(offset);
        vec3.add(position, position, tempVec3$s);
        this.camera?.lookAt(position); //TODO: optimize
        if (this.#enableDamping === true) {
            this.#sphericalDelta.theta *= (1 - this.#dampingFactor);
            this.#sphericalDelta.phi *= (1 - this.#dampingFactor);
            //this.panOffset.multiplyScalar(1 - this.#dampingFactor);
        }
        else {
            this.#sphericalDelta.set(0, 0, 0);
            //vec3.set(this.panOffset, 0, 0, 0);
        }
        return;
        /*

        def from_spherical_coords(theta_phi, phi=None):
        """Return the quaternion corresponding to these spherical coordinates

        Assumes the spherical coordinates correspond to the quaternion R via

            R = exp(phi*z/2) * exp(theta*y/2)

        The angles naturally must be in radians for this to make any sense.

        Note that this quaternion rotates `z` onto the point with the given
        spherical coordinates, but also rotates `x` and `y` onto the usual basis
        vectors (theta and phi, respectively) at that point.

        Parameters
        ----------
        theta_phi: float or array of floats
            This argument may either contain an array with last dimension of
            size 2, where those two elements describe the (theta, phi) values in
            radians for each point; or it may contain just the theta values in
            radians, in which case the next argument must also be given.
        phi: None, float, or array of floats
            If this array is given, it must be able to broadcast against the
            first argument.

        Returns
        -------
        R: quaternion array
            If the second argument is not given to this function, the shape
            will be the same as the input shape except for the last dimension,
            which will be removed.If the second argument is given, this
            output array will have the shape resulting from broadcasting the
            two input arrays against each other.

        """
        # Figure out the input angles from either type of input
        if phi is None:
            theta_phi = np.asarray(theta_phi, dtype=np.double)
            theta = theta_phi[..., 0]
            phi = theta_phi[..., 1]
        else:
            theta = np.asarray(theta_phi, dtype=np.double)
            phi = np.asarray(phi, dtype=np.double)

        # Set up the output array
        R = np.empty(np.broadcast(theta, phi).shape + (4,), dtype=np.double)

        # Compute the actual values of the quaternion components
        R[..., 0] = np.cos(phi/2)*np.cos(theta/2) # scalar quaternion components
        R[..., 1] = -np.sin(phi/2)*np.sin(theta/2) # x quaternion components
        R[..., 2] = np.cos(phi/2)*np.sin(theta/2) # y quaternion components
        R[..., 3] = np.sin(phi/2)*np.cos(theta/2) # z quaternion components

        return as_quat_array(R)
        */
    }
    /*
    contextmenu(event) {
        event.preventDefault();
    }
    */
    #setOrientation() {
        /*

        var position = this.camera._position;

        //offset.copy(position).sub(this.target);
        vec3.sub(tempVec3, position, this._target);

        // rotate offset to 'y-axis-is-up' space
        //offset.applyQuaternion(q);
        vec3.transformQuat(tempVec3, tempVec3, this.#q);

        // angle from z-axis around y-axis
        spherical.setFromVector3(tempVec3);
        */
        vec3.copy(tempVec3$s, xUnitVec3$1 /*minusZUnitVec3*/);
        vec3.transformQuat(tempVec3$s, tempVec3$s, this.camera?._quaternion ?? quat.create() /*TODO: optimize*/);
        spherical$1.setFromVector3(tempVec3$s);
        this.#lat = -(90 - RAD_TO_DEG * (spherical$1.phi));
        this.#lon = -RAD_TO_DEG * (spherical$1.theta);
        this.#startLat = this.#lat;
        this.#startLon = this.#lon;
        this.update();
    }
    /*
    #onContextMenu(event) {
        if (this.enabled === false) return;
        event.preventDefault();
    }
    */
    #setupEventsListeners() {
        //this.htmlElement.addEventListener('contextmenu', event => this.#onContextMenu(event));
        //this.htmlElement.addEventListener('mousemove', event => this.#onMouseMove(event));
        GraphicsEvents.addEventListener(GraphicsEvent.MouseMove, (event) => this.#onMouseMove(event));
        //this.htmlElement.addEventListener('mousedown', event => this.#onMouseDown(event));
        GraphicsEvents.addEventListener(GraphicsEvent.MouseDown, (event) => this.#onMouseDown(event));
        //this.htmlElement.addEventListener('mouseup', event => this.#onMouseUp(event));
        GraphicsEvents.addEventListener(GraphicsEvent.MouseUp, (event) => this.#onMouseUp(event));
        //this.htmlElement.addEventListener('keydown', event => this.#onKeyDown(event), false);
        GraphicsEvents.addEventListener(GraphicsEvent.KeyDown, (event) => this.#onKeyDown(event));
        //this.htmlElement.addEventListener('keyup', event => this.#onKeyUp(event), false);
        GraphicsEvents.addEventListener(GraphicsEvent.KeyUp, (event) => this.#onKeyUp(event));
    }
    setupCamera() {
        if (this.camera) {
            quat.rotationTo(this.#q, this.camera.upVector, zUnitVec3$2);
            this.#quatInverse = quat.invert(this.#quatInverse, this.#q);
            vec3.transformQuat(tempVec3$s, minusZUnitVec3, this.camera.quaternion);
            spherical$1.setFromVector3(tempVec3$s);
        }
    }
    handleEnabled() {
        if (this.enabled) {
            this.setupCamera();
        }
    }
    #rotateLeft(angle) {
        this.#sphericalDelta.theta -= angle;
    }
    #rotateUp(angle) {
        this.#sphericalDelta.phi -= angle;
    }
}

// It is just a basic entity
class Target extends Entity {
    static async constructFromJSON(json) {
        return new Target({ name: json.name });
    }
    static getEntityName() {
        return 'Target';
    }
}
registerEntity(Target);

// This set of controls performs orbiting, dollying(zooming), and panning.
// Unlike TrackballControls, it maintains the 'up' direction object.up(+Y by default).
//
// Orbit - left mouse / touch: one-finger move
// Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
// Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move
const zUnitVec3$1 = vec3.fromValues(0, 0, 1);
const tempVec3$r = vec3.create();
const tempVec3_2$9 = vec3.create();
const spherical = new Spherical();
// Mouse buttons
const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2, NONE: -1 };
({ LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN });
// Touch fingers
const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
const touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };
const STATE = {
    NONE: -1,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2,
    TOUCH_ROTATE: 3,
    TOUCH_PAN: 4,
    TOUCH_DOLLY_PAN: 5,
    TOUCH_DOLLY_ROTATE: 6
};
class OrbitControl extends CameraControl {
    #upVector = vec3.fromValues(0, 0, 1);
    #keyRotateHorizontal = 0;
    #keyRotateVertical = 0;
    #autoRotate = false;
    #autoRotateSpeed = 1.0;
    #enableDamping = false;
    #target = new Target({ name: 'Orbit control target' });
    #minDistance = 0;
    #maxDistance = Infinity;
    #minZoom = 0.01;
    #maxZoom = Infinity;
    #minPolarAngle = 0;
    #maxPolarAngle = Math.PI;
    #minAzimuthAngle = -Infinity;
    #maxAzimuthAngle = Infinity;
    #dampingFactor = 0.05;
    #enableDolly = true;
    #dollySpeed = 1.0;
    #enableRotate = true;
    #rotateSpeed = 1.0;
    #enablePan = true;
    #panSpeed = 0.001;
    #screenSpacePanning = false; // if true, pan in screen-space
    #keyPanSpeed = 7.0; // pixels moved per arrow key push
    #enableKeys = true;
    #position0 = vec3.create();
    #mouseButtons = [MOUSE.ROTATE, MOUSE.DOLLY, MOUSE.PAN];
    #state = STATE.NONE;
    #scale = 1.0;
    #q = quat.create();
    #quatInverse = quat.create();
    #lastPosition = vec3.create();
    #lastQuaternion = quat.create();
    #sphericalDelta = new Spherical();
    #panOffset = vec3.create();
    #zoomChanged = false;
    #rotateStart = vec2.create();
    #rotateEnd = vec2.create();
    #rotateDelta = vec2.create();
    #panStart = vec2.create();
    #panEnd = vec2.create();
    #panDelta = vec2.create();
    #dollyStart = vec2.create();
    #dollyEnd = vec2.create();
    #dollyDelta = vec2.create();
    constructor(camera) {
        super(camera);
        //TODO end
        if (camera) {
            vec3.copy(this.#position0, camera.position);
        }
        this.setupCamera();
        this.#setupEventsListeners();
        this.update();
    }
    set target(target) {
        this.#target = target;
        this.update();
    }
    get target() {
        return this.#target;
    }
    setTargetPosition(position) {
        this.#target.position = position;
        this.update();
    }
    set upVector(upVector) {
        vec3.copy(this.#upVector, upVector);
        this.update();
    }
    get upVector() {
        return this.#upVector;
    }
    set minPolarAngle(minPolarAngle) {
        this.#minPolarAngle = minPolarAngle;
    }
    get minPolarAngle() {
        return this.#minPolarAngle;
    }
    set maxPolarAngle(maxPolarAngle) {
        this.#maxPolarAngle = maxPolarAngle;
    }
    get maxPolarAngle() {
        return this.#maxPolarAngle;
    }
    set dampingFactor(dampingFactor) {
        this.#dampingFactor = dampingFactor;
    }
    get dampingFactor() {
        return this.#dampingFactor;
    }
    setupCamera() {
        if (this.camera) {
            quat.rotationTo(this.#q, this.#upVector, zUnitVec3$1);
            this.#quatInverse = quat.invert(this.#quatInverse, this.#q);
        }
    }
    update(delta = 1) {
        if (this.enabled === false || !this.camera) {
            return;
        }
        const position = this.camera._position;
        //offset.copy(position).sub(this.target);
        vec3.sub(tempVec3$r, position, this.#target.getWorldPosition()); //TODO: optimise
        // rotate offset to 'y-axis-is-up' space
        //offset.applyQuaternion(q);
        vec3.transformQuat(tempVec3$r, tempVec3$r, this.#q);
        // angle from z-axis around y-axis
        spherical.setFromVector3(tempVec3$r);
        if (this.#autoRotate && this.#state === STATE.NONE) {
            this.#rotateLeft(this.#autoRotateSpeed);
        }
        if (this.#keyRotateVertical) {
            this.#rotateUp(this.#keyRotateVertical * 2 * Math.PI * delta);
        }
        if (this.#keyRotateHorizontal) {
            this.#rotateLeft(this.#keyRotateHorizontal * 2 * Math.PI * delta);
        }
        if (this.#enableDamping) {
            spherical.theta += this.#sphericalDelta.theta * this.#dampingFactor;
            spherical.phi += this.#sphericalDelta.phi * this.#dampingFactor;
        }
        else {
            spherical.theta += this.#sphericalDelta.theta;
            spherical.phi += this.#sphericalDelta.phi;
        }
        // restrict theta to be between desired limits
        spherical.theta = Math.max(this.#minAzimuthAngle, Math.min(this.#maxAzimuthAngle, spherical.theta));
        // restrict phi to be between desired limits
        spherical.phi = Math.max(this.#minPolarAngle, Math.min(this.#maxPolarAngle, spherical.phi));
        spherical.makeSafe();
        spherical.radius *= this.#scale;
        // restrict radius to be between desired limits
        spherical.radius = Math.max(this.#minDistance, Math.min(this.#maxDistance, spherical.radius));
        // move target to panned location
        if (this.#enableDamping === true) {
            vec3.scaleAndAdd(tempVec3_2$9, this.#target._position, this.#panOffset, this.#dampingFactor);
            this.#target.setPosition(tempVec3_2$9);
        }
        else {
            //this.target.add(this.#panOffset);
            vec3.add(tempVec3_2$9, this.#target._position, this.#panOffset);
            this.#target.setPosition(tempVec3_2$9);
        }
        spherical.toCartesian(tempVec3$r);
        // rotate offset back to 'camera-up-vector-is-up' space
        //offset.applyQuaternion(quatInverse);
        vec3.transformQuat(tempVec3$r, tempVec3$r, this.#quatInverse);
        //position.copy(this.target).add(offset);
        vec3.add(tempVec3$r, this.#target.getWorldPosition(), tempVec3$r);
        this.camera.setPosition(tempVec3$r);
        this.camera.lookAt(this.#target.getWorldPosition(), this.#upVector); //TODO: optimize
        if (this.#enableDamping === true) {
            this.#sphericalDelta.theta *= (1 - this.#dampingFactor);
            this.#sphericalDelta.phi *= (1 - this.#dampingFactor);
            vec3.scale(this.#panOffset, this.#panOffset, 1 - this.#dampingFactor);
        }
        else {
            this.#sphericalDelta.set(0, 0, 0);
            vec3.set(this.#panOffset, 0, 0, 0);
        }
        this.#scale = 1;
        // update condition is:
        // min(camera displacement, camera rotation in radians)^2 > Number.EPSILON
        // using small-angle approximation cos(x/2)= 1 - x^2 / 8
        if (this.#zoomChanged ||
            vec3.squaredDistance(this.#lastPosition, this.camera._position) > Number.EPSILON ||
            8 * (1 - quat.dot(this.#lastQuaternion, this.camera._quaternion)) > Number.EPSILON) {
            //this.dispatchEvent(changeEvent);
            vec3.copy(this.#lastPosition, this.camera._position);
            quat.copy(this.#lastQuaternion, this.camera._quaternion);
            this.#zoomChanged = false;
            //this.camera.dirtyCameraMatrix = true;
            return true;
        }
        return false;
    }
    set autoRotateSpeed(speed) {
        this.#autoRotateSpeed = 2 * Math.PI / 60 / 60 * speed;
    }
    get zoomScale() {
        return Math.pow(0.95, this.#dollySpeed);
    }
    #rotateLeft(angle) {
        this.#sphericalDelta.theta -= angle;
    }
    #rotateUp(angle) {
        this.#sphericalDelta.phi -= angle;
    }
    #panLeft(distance, rotation) {
        vec3.transformQuat(tempVec3$r, [1, 0, 0], rotation);
        vec3.scale(tempVec3$r, tempVec3$r, -distance);
        vec3.add(this.#panOffset, this.#panOffset, tempVec3$r);
    }
    #panUp(distance, rotation) {
        vec3.transformQuat(tempVec3$r, [0, 1, 0], rotation);
        vec3.scale(tempVec3$r, tempVec3$r, distance);
        vec3.add(this.#panOffset, this.#panOffset, tempVec3$r);
    }
    #pan(deltaX, deltaY, element) {
        if (!this.camera) {
            return;
        }
        if (this.camera.isPerspective) {
            // perspective
            const position = this.camera.position;
            //offset.copy(position).sub(this.target);
            vec3.sub(tempVec3$r, position, this.#target.getWorldPosition()); //todo // OPTIMIZE:
            let targetDistance = vec3.len(tempVec3$r);
            // half of the fov is center to top of screen
            targetDistance *= this.camera.getTanHalfVerticalFov(); //Math.tan((this.camera.fov / 2)* Math.PI / 180.0);
            // we use only clientHeight here so aspect ratio does not distort speed
            this.#panLeft(2 * deltaX * targetDistance / element.clientHeight, this.camera._quaternion);
            this.#panUp(2 * deltaY * targetDistance / element.clientHeight, this.camera._quaternion);
        }
        else if (this.camera.isOrthographic) {
            // orthographic
            this.#panLeft(deltaX * (this.camera.right - this.camera.left) / this.camera.orthoZoom / element.clientWidth, this.camera._quaternion);
            this.#panUp(deltaY * (this.camera.top - this.camera.bottom) / this.camera.orthoZoom / element.clientHeight, this.camera._quaternion);
        }
        else {
            this.#enablePan = false;
        }
    }
    #dollyIn(dollyScale) {
        if (!this.camera) {
            return;
        }
        if (this.camera.isPerspective) {
            this.#scale /= dollyScale;
        }
        else if (this.camera.isOrthographic) {
            this.camera.orthoZoom = Math.max(this.#minZoom, Math.min(this.#maxZoom, this.camera.orthoZoom * dollyScale));
            this.#zoomChanged = true;
        }
        else {
            this.#enableDolly = false;
        }
    }
    #dollyOut(dollyScale) {
        if (!this.camera) {
            return;
        }
        if (this.camera.isPerspective) {
            this.#scale *= dollyScale;
        }
        else if (this.camera.isOrthographic) {
            this.camera.orthoZoom = Math.max(this.#minZoom, Math.min(this.#maxZoom, this.camera.orthoZoom / dollyScale));
            this.#zoomChanged = true;
        }
        else {
            this.#enableDolly = false;
        }
    }
    #handleMouseDownRotate(event) {
        vec2.set(this.#rotateStart, event.clientX, event.clientY);
    }
    #handleMouseDownDolly(event) {
        vec2.set(this.#dollyStart, event.clientX, event.clientY);
    }
    #handleMouseDownPan(event) {
        vec2.set(this.#panStart, event.clientX, event.clientY);
    }
    #handleMouseMoveRotate(event) {
        const mouseEvent = event.detail.mouseEvent;
        vec2.set(this.#rotateEnd, mouseEvent.clientX, mouseEvent.clientY);
        this.#rotateDelta[0] = mouseEvent.movementX * this.#rotateSpeed;
        this.#rotateDelta[1] = mouseEvent.movementY * this.#rotateSpeed;
        //console.error(event.movementX, event.movementY, ...this.#rotateDelta);
        const element = mouseEvent.target;
        this.#rotateLeft(2 * Math.PI * this.#rotateDelta[0] / element.clientHeight); // yes, height
        this.#rotateUp(2 * Math.PI * this.#rotateDelta[1] / element.clientHeight);
        vec2.copy(this.#rotateStart, this.#rotateEnd);
        this.update();
    }
    #handleMouseMoveDolly(event) {
        //console.error(event.movementX, event.movementY, ...this.#dollyDelta);
        //dollyEnd.set(event.clientX, event.clientY);
        vec2.set(this.#dollyEnd, event.movementX, event.movementY);
        //dollyDelta.subVectors(dollyEnd, dollyStart);
        //vec2.sub(this.#dollyDelta, this.#dollyEnd, this.#dollyStart);
        vec2.sub(this.#dollyDelta, this.#dollyDelta, this.#dollyEnd);
        if (this.#dollyDelta[1] > 0) {
            this.#dollyIn(this.zoomScale);
        }
        else if (this.#dollyDelta[1] < 0) {
            this.#dollyOut(this.zoomScale);
        }
        //dollyStart.copy(dollyEnd);
        //vec2.copy(this.#dollyStart, this.#dollyEnd);
        this.update();
    }
    #handleMouseMovePan(event) {
        this.#panSpeed = 1.0;
        this.#panDelta[0] = event.detail.mouseEvent.movementX * this.#panSpeed;
        this.#panDelta[1] = event.detail.mouseEvent.movementY * this.#panSpeed;
        this.#pan(this.#panDelta[0], this.#panDelta[1], event.detail.mouseEvent.target);
        this.update();
    }
    #handleMouseWheel(event) {
        //console.error(event.deltaY, this.zoomScale);
        const wheelEvent = event.detail.wheelEvent;
        if (wheelEvent.deltaY < 0) {
            this.#dollyOut(this.zoomScale);
        }
        else if (wheelEvent.deltaY > 0) {
            this.#dollyIn(this.zoomScale);
        }
        this.update();
    }
    #handleKeyDown(event) {
        if (this.enabled === false || this.#enableKeys === false || this.#enablePan === false) {
            return;
        }
        const keyboardEvent = event.detail.keyboardEvent;
        let needsUpdate = false;
        if (keyboardEvent.ctrlKey || keyboardEvent.metaKey || keyboardEvent.altKey) {
            return;
        }
        if (keyboardEvent.shiftKey) {
            switch (keyboardEvent.code) {
                case 'ArrowUp':
                case 'KeyW':
                    this.#keyRotateVertical = 1;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    this.#keyRotateVertical = -1;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    this.#keyRotateHorizontal = 1;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    this.#keyRotateHorizontal = -1;
                    break;
            }
            return;
        }
        switch (keyboardEvent.code) {
            case 'ArrowUp':
            case 'KeyW':
                this.#pan(0, this.#keyPanSpeed, keyboardEvent.target);
                needsUpdate = true;
                break;
            case 'ArrowDown':
            case 'KeyS':
                this.#pan(0, -this.#keyPanSpeed, keyboardEvent.target);
                needsUpdate = true;
                break;
            case 'ArrowLeft':
            case 'KeyA':
                this.#pan(this.#keyPanSpeed, 0, keyboardEvent.target);
                needsUpdate = true;
                break;
            case 'ArrowRight':
            case 'KeyD':
                this.#pan(-this.#keyPanSpeed, 0, keyboardEvent.target);
                needsUpdate = true;
                break;
            /*


            case 'ArrowUp':
            case 'KeyW': /*W* / this.moveForward = true; break;

            case 'ArrowLeft': /*left* /
            case 'KeyA': /*A* / this.moveLeft = true; break;

            case 'ArrowDown': /*down* /
            case 'KeyS': /*S* / this.moveBackward = true; break;

            case 'ArrowRight': /*right* /
            case 'KeyD': /*D* / this.moveRight = true; break;

            case 'KeyR': /*R* / this.moveUp = true; break;
            case 'KeyF': /*F* / this.moveDown = true; break;
            */
        }
        if (needsUpdate) {
            // prevent the browser from scrolling on cursor keys
            keyboardEvent.preventDefault();
            this.update();
        }
    }
    #handleKeyUp(event) {
        if (this.enabled === false || this.#enableKeys === false || this.#enablePan === false) {
            return;
        }
        switch (event.detail.keyboardEvent.code) {
            case 'ArrowUp':
            case 'KeyW':
            case 'ArrowDown':
            case 'KeyS':
                this.#keyRotateVertical = 0;
                break;
            case 'ArrowLeft':
            case 'KeyA':
            case 'ArrowRight':
            case 'KeyD':
                this.#keyRotateHorizontal = 0;
                break;
        }
    }
    #handleTouchStartRotate(event) {
        if (event.touches.length == 1) {
            vec2.set(this.#rotateStart, event.touches[0].pageX, event.touches[0].pageY);
        }
        else if (event.touches.length == 2) {
            const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
            const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
            vec2.set(this.#rotateStart, x, y);
        }
    }
    #handleTouchStartPan(event) {
        if (event.touches.length == 1) {
            vec2.set(this.#panStart, event.touches[0].pageX, event.touches[0].pageY);
        }
        else if (event.touches.length == 2) {
            const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
            const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
            vec2.set(this.#panStart, x, y);
        }
    }
    #handleTouchStartDolly(event) {
        if (event.touches.length != 2) {
            return;
        }
        const dx = event.touches[0].pageX - event.touches[1].pageX;
        const dy = event.touches[0].pageY - event.touches[1].pageY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        vec2.set(this.#dollyStart, 0, distance);
    }
    #handleTouchStartDollyPan(event) {
        if (this.#enableDolly)
            this.#handleTouchStartDolly(event);
        if (this.#enablePan)
            this.#handleTouchStartPan(event);
    }
    #handleTouchStartDollyRotate(event) {
        if (this.#enableDolly)
            this.#handleTouchStartDolly(event);
        if (this.#enableRotate)
            this.#handleTouchStartRotate(event);
    }
    #handleTouchMoveRotate(event) {
        if (event.touches.length == 1) {
            vec2.set(this.#rotateEnd, event.touches[0].pageX, event.touches[0].pageY);
        }
        else if (event.touches.length == 2) {
            const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
            const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
            vec2.set(this.#rotateEnd, x, y);
        }
        vec2.sub(this.#rotateDelta, this.#rotateEnd, this.#rotateStart);
        vec2.scale(this.#rotateDelta, this.#rotateDelta, this.#rotateSpeed);
        const element = event.target;
        this.#rotateLeft(2 * Math.PI * this.#rotateDelta[0] / element.clientHeight); // yes, height
        this.#rotateUp(2 * Math.PI * this.#rotateDelta[1] / element.clientHeight);
        vec2.copy(this.#rotateStart, this.#rotateEnd);
    }
    #handleTouchMovePan(event) {
        if (event.touches.length == 1) {
            //panEnd.set(event.touches[ 0 ].pageX, event.touches[ 0 ].pageY);
            vec2.set(this.#panEnd, event.touches[0].pageX, event.touches[0].pageY);
        }
        else if (event.touches.length == 2) {
            const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
            const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
            //panEnd.set(x, y);
            vec2.set(this.#panEnd, x, y);
        }
        //panDelta.subVectors(panEnd, panStart).multiplyScalar(this.#panSpeed);
        vec2.scale(this.#panDelta, vec2.sub(this.#panDelta, this.#panEnd, this.#panStart), this.#panSpeed);
        this.#pan(this.#panDelta[0], this.#panDelta[1], event.target);
        vec2.copy(this.#panStart, this.#panEnd);
    }
    #handleTouchMoveDolly(event) {
        if (event.touches.length != 2) {
            return;
        }
        const dx = event.touches[0].pageX - event.touches[1].pageX;
        const dy = event.touches[0].pageY - event.touches[1].pageY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        //dollyEnd.set(0, distance);
        vec2.set(this.#dollyEnd, 0, distance);
        vec2.set(this.#dollyDelta, 0, Math.pow(this.#dollyEnd[1] / this.#dollyStart[1], this.#dollySpeed));
        this.#dollyIn(this.#dollyDelta[1]);
        //dollyStart.copy(this.#dollyEnd);
        vec2.copy(this.#dollyStart, this.#dollyEnd);
    }
    #handleTouchMoveDollyPan(event) {
        if (this.#enableDolly)
            this.#handleTouchMoveDolly(event);
        if (this.#enablePan)
            this.#handleTouchMovePan(event);
    }
    #handleTouchMoveDollyRotate(event) {
        if (this.#enableDolly)
            this.#handleTouchMoveDolly(event);
        if (this.#enableRotate)
            this.#handleTouchMoveRotate(event);
    }
    #onMouseDown(event) {
        if (this.enabled === false) {
            return;
        }
        if (event.detail.entity?.getLayer() ?? 0 > 0) {
            return;
        }
        // Prevent the browser from scrolling.
        event.preventDefault();
        const mouseEvent = event.detail.mouseEvent;
        // Manually set the focus since calling preventDefault above
        // prevents the browser from setting it automatically.
        //this.htmlElement.focus ? this.htmlElement.focus(): window.focus();
        const action = this.#mouseButtons[mouseEvent.button];
        const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2, NONE: -1 };
        switch (action) {
            case MOUSE.ROTATE:
                if (this.#enableRotate) {
                    this.#handleMouseDownRotate(event.detail.mouseEvent);
                    this.#state = STATE.ROTATE;
                    mouseEvent.target.requestPointerLock();
                }
                break;
            case MOUSE.DOLLY:
                if (this.#enableDolly) {
                    this.#handleMouseDownDolly(event.detail.mouseEvent);
                    this.#state = STATE.DOLLY;
                    mouseEvent.target.requestPointerLock();
                }
                break;
            case MOUSE.PAN:
                if (this.#enablePan) {
                    this.#handleMouseDownPan(event.detail.mouseEvent);
                    this.#state = STATE.PAN;
                    mouseEvent.target.requestPointerLock();
                }
                break;
        }
    }
    #onMouseMove(event) {
        if (this.enabled === false) {
            return;
        }
        event.preventDefault();
        switch (this.#state) {
            case STATE.ROTATE:
                if (this.#enableRotate === false)
                    return;
                this.#handleMouseMoveRotate(event);
                break;
            case STATE.DOLLY:
                if (this.#enableDolly === false)
                    return;
                this.#handleMouseMoveDolly(event.detail.mouseEvent);
                break;
            case STATE.PAN:
                if (this.#enablePan === false)
                    return;
                this.#handleMouseMovePan(event);
                break;
        }
    }
    #onMouseUp(event) {
        document.exitPointerLock();
        if (this.enabled === false) {
            return;
        }
        this.#state = STATE.NONE;
    }
    #onMouseWheel(event) {
        if (this.enabled === false || this.#enableDolly === false || (this.#state !== STATE.NONE && this.#state !== STATE.ROTATE))
            return;
        event.preventDefault();
        event.stopPropagation();
        this.#handleMouseWheel(event);
    }
    #onTouchStart(event) {
        if (this.enabled === false) {
            return;
        }
        const touchEvent = event.detail.touchEvent;
        touchEvent.preventDefault();
        switch (touchEvent.touches.length) {
            case 1:
                switch (touches.ONE) {
                    case TOUCH.ROTATE:
                        if (this.#enableRotate === false)
                            return;
                        this.#handleTouchStartRotate(touchEvent);
                        this.#state = STATE.TOUCH_ROTATE;
                        break;
                    case TOUCH.PAN:
                        if (this.#enablePan === false)
                            return;
                        this.#handleTouchStartPan(touchEvent);
                        this.#state = STATE.TOUCH_PAN;
                        break;
                    default:
                        this.#state = STATE.NONE;
                }
                break;
            case 2:
                switch (touches.TWO) {
                    case TOUCH.DOLLY_PAN:
                        if (this.#enableDolly === false && this.#enablePan === false)
                            return;
                        this.#handleTouchStartDollyPan(touchEvent);
                        this.#state = STATE.TOUCH_DOLLY_PAN;
                        break;
                    case TOUCH.DOLLY_ROTATE:
                        if (this.#enableDolly === false && this.#enableRotate === false)
                            return;
                        this.#handleTouchStartDollyRotate(touchEvent);
                        this.#state = STATE.TOUCH_DOLLY_ROTATE;
                        break;
                    default:
                        this.#state = STATE.NONE;
                }
                break;
            default:
                this.#state = STATE.NONE;
        }
        if (this.#state !== STATE.NONE) ;
    }
    #onTouchMove(event) {
        if (this.enabled === false)
            return;
        const touchEvent = event.detail.touchEvent;
        touchEvent.preventDefault();
        touchEvent.stopPropagation();
        switch (this.#state) {
            case STATE.TOUCH_ROTATE:
                if (this.#enableRotate === false)
                    return;
                this.#handleTouchMoveRotate(touchEvent);
                this.update();
                break;
            case STATE.TOUCH_PAN:
                if (this.#enablePan === false)
                    return;
                this.#handleTouchMovePan(touchEvent);
                this.update();
                break;
            case STATE.TOUCH_DOLLY_PAN:
                if (this.#enableDolly === false && this.#enablePan === false)
                    return;
                this.#handleTouchMoveDollyPan(touchEvent);
                this.update();
                break;
            case STATE.TOUCH_DOLLY_ROTATE:
                if (this.#enableDolly === false && this.#enableRotate === false)
                    return;
                this.#handleTouchMoveDollyRotate(touchEvent);
                this.update();
                break;
            default:
                this.#state = STATE.NONE;
        }
    }
    #onTouchCancel(event) {
        if (this.enabled === false) {
            return;
        }
        this.#state = STATE.NONE;
    }
    #onContextMenu(event) {
        if (this.enabled === false)
            return;
        event.preventDefault();
    }
    #setupEventsListeners() {
        GraphicsEvents.addEventListener(GraphicsEvent.MouseDown, (event) => this.#onMouseDown(event));
        GraphicsEvents.addEventListener(GraphicsEvent.MouseMove, (event) => this.#onMouseMove(event));
        GraphicsEvents.addEventListener(GraphicsEvent.MouseUp, (event) => this.#onMouseUp(event));
        GraphicsEvents.addEventListener(GraphicsEvent.Wheel, (event) => this.#onMouseWheel(event));
        GraphicsEvents.addEventListener(GraphicsEvent.TouchStart, (event) => this.#onTouchStart(event));
        GraphicsEvents.addEventListener(GraphicsEvent.TouchMove, (event) => this.#onTouchMove(event));
        GraphicsEvents.addEventListener(GraphicsEvent.TouchCancel, (event) => this.#onTouchCancel(event));
        GraphicsEvents.addEventListener(GraphicsEvent.KeyDown, (event) => this.#handleKeyDown(event));
        GraphicsEvents.addEventListener(GraphicsEvent.KeyUp, (event) => this.#handleKeyUp(event));
        GraphicsEvents.addEventListener(GraphicsEvent.Tick, (event) => this.update(event.detail.delta));
        // make sure element can receive keys.
        /*if(this.htmlElement.tabIndex === - 1) {
            this.htmlElement.tabIndex = 0;
        }*/
    }
    handleEnabled() {
        if (this.enabled) {
            this.update();
        }
    }
}
/*OrbitControls.prototype = Object.create(EventTarget.prototype);
OrbitControls.prototype.constructor = OrbitControls;*/
// This set of controls performs orbiting, dollying(zooming), and panning.
// Unlike TrackballControls, it maintains the 'up' direction object.up(+Y by default).
// This is very similar to OrbitControls, another set of touch behavior
//
// Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate
// Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
// Pan - left mouse, or arrow keys / touch: one-finger move
/*var MapControls = function(object, htmlElement) {

    OrbitControls.call(this, object, htmlElement);

    this.#mouseButtons.LEFT = MOUSE.PAN;
    this.#mouseButtons.RIGHT = MOUSE.ROTATE;

    this.touches.ONE = TOUCH.PAN;
    this.touches.TWO = TOUCH.DOLLY_ROTATE;

};

MapControls.prototype = Object.create(EventTarget.prototype);
MapControls.prototype.constructor = MapControls;*/

const Z_VECTOR$1 = vec3.fromValues(0, 0, 1);
const tempQuat$a = quat.create();
class RotationControl extends Entity {
    #rotationSpeed;
    #axis = vec3.clone(Z_VECTOR$1);
    constructor(params = {}) {
        super(params);
        GraphicsEvents.addEventListener(GraphicsEvent.Tick, (event) => this.#update(event.detail.delta));
        if (params.axis) {
            this.setAxis(params.axis);
        }
        this.#rotationSpeed = params.speed ?? 1;
    }
    setSpeed(rotationSpeed) {
        this.#rotationSpeed = rotationSpeed;
    }
    /**
     * @deprecated Please use `setSpeed` instead.
     */
    set rotationSpeed(rotationSpeed) {
        this.setSpeed(rotationSpeed);
    }
    getSpeed() {
        return this.#rotationSpeed;
    }
    /**
     * @deprecated Please use `getSpeed` instead.
     */
    get rotationSpeed() {
        return this.getSpeed();
    }
    setAxis(axis) {
        vec3.copy(this.#axis, axis);
        quat.identity(this._quaternion);
    }
    /**
     * @deprecated Please use `setAxis` instead.
     */
    set axis(axis) {
        this.setAxis(axis);
    }
    getAxis() {
        return vec3.clone(this.#axis);
    }
    /**
     * @deprecated Please use `getAxis` instead.
     */
    get axis() {
        return this.getAxis();
    }
    #update(delta) {
        const parent = this._parent;
        if (!parent) {
            return;
        }
        quat.setAxisAngle(tempQuat$a, this.#axis, this.#rotationSpeed * delta);
        const quaternion = parent._quaternion;
        quat.mul(quaternion, quaternion, tempQuat$a);
    }
    reset() {
        const parent = this._parent;
        if (!parent) {
            return;
        }
        quat.identity(parent._quaternion);
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), {
            RotationControl_1: null,
            rotation_axis: { i18n: '#rotation_axis', f: () => { const v = prompt('Rotation axis', this.axis.join(' ')); if (v !== null) {
                    this.axis = stringToVec3(v);
                } } },
            rotation_speed: { i18n: '#rotation_speed', f: () => { const s = prompt('Rotation speed', String(this.rotationSpeed * RAD_TO_DEG)); if (s !== null) {
                    this.rotationSpeed = Number(s) * DEG_TO_RAD;
                } } },
        });
    }
}

var TranslationMode;
(function (TranslationMode) {
    TranslationMode[TranslationMode["Bounce"] = 0] = "Bounce";
    TranslationMode[TranslationMode["Loop"] = 1] = "Loop";
    TranslationMode[TranslationMode["Continue"] = 2] = "Continue";
})(TranslationMode || (TranslationMode = {}));
class TranslationControl extends Entity {
    #speed = 1;
    #startPoint = vec3.create();
    #endPoint = vec3.fromValues(10, 0, 0);
    #mode = TranslationMode.Bounce;
    #percent = 0;
    #bounceDirection = 1;
    constructor(params) {
        super(params);
        GraphicsEvents.addEventListener(GraphicsEvent.Tick, (event) => this.#update(event.detail.delta));
    }
    #update(delta) {
        switch (this.#mode) {
            case TranslationMode.Bounce:
                const distance = vec3.distance(this.#startPoint, this.#endPoint);
                const deltaL = distance ? this.#speed * delta / distance : 1;
                let percent = this.#percent + deltaL * this.#bounceDirection;
                if (percent >= 1) {
                    this.#bounceDirection = -1;
                    percent = 1;
                }
                if (percent <= 0) {
                    this.#bounceDirection = 1;
                    percent = 0;
                }
                this.#percent = percent;
                vec3.lerp(this._position, this.#startPoint, this.#endPoint, this.#percent);
                break;
        }
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), {
            TranslationControl_1: null,
            speed: { i18n: '#speed', f: () => { const s = prompt('Speed', String(this.#speed)); if (s !== null) {
                    this.#speed = Number(s);
                } } },
            start_position: { i18n: '#start_position', f: () => { const v = prompt('Position', this.#startPoint.join(' ')); if (v !== null) {
                    stringToVec3(v, this.#startPoint);
                } } },
            end_position: { i18n: '#end_position', f: () => { const v = prompt('Position', this.#endPoint.join(' ')); if (v !== null) {
                    stringToVec3(v, this.#endPoint);
                } } },
        });
    }
}

class LineMaterial extends Material {
    #lineWidth = 1;
    constructor(params = {}) {
        super(params);
        this.lineWidth = params?.lineWidth ?? 10;
        this.setValues(params);
    }
    getShaderSource() {
        return 'line';
    }
    set lineWidth(lineWidth) {
        this.#lineWidth = lineWidth;
        this.uniforms['linewidth'] = lineWidth;
    }
    toJSON() {
        const json = super.toJSON();
        json.linewidth = this.#lineWidth;
        return json;
    }
    static async constructFromJSON(json) {
        return new LineMaterial();
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.lineWidth = json.linewidth;
    }
    static getEntityName() {
        return 'LineMaterial';
    }
}
Material.materialList['Line'] = LineMaterial;
registerEntity(LineMaterial);

class InstancedBufferGeometry extends BufferGeometry {
    instanceCount;
    constructor(count = 0) {
        super();
        this.instanceCount = count;
        return this;
    }
}

class LineSegmentsGeometry extends InstancedBufferGeometry {
    constructor() {
        super();
        this.#setupGeometry();
    }
    #setupGeometry() {
        const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];
        const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];
        const indices = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
        // build geometry
        this.setIndex(new Uint16BufferAttribute(indices, 1));
        this.setAttribute('aVertexPosition', new Float32BufferAttribute(positions, 3));
        this.setAttribute('aTextureCoord', new Float32BufferAttribute(uvs, 2));
        this.count = indices.length;
    }
    setSegments(positions, colors /*TODO: use colors*/, lineStrip) {
        const start = [];
        const end = [];
        let instanceCount = 0;
        const increment = lineStrip ? 3 : 6;
        for (let i = 0, l = positions.length; i < l; i += increment) {
            start.push(positions[i + 0]);
            start.push(positions[i + 1]);
            start.push(positions[i + 2]);
            end.push(positions[i + 3]);
            end.push(positions[i + 4]);
            end.push(positions[i + 5]);
            ++instanceCount;
        }
        const startAttribute = new Float32BufferAttribute(start, 3);
        startAttribute.divisor = 1;
        const endAttribute = new Float32BufferAttribute(end, 3);
        endAttribute.divisor = 1;
        this.setAttribute('aSegmentStart', startAttribute);
        this.setAttribute('aSegmentEnd', endAttribute);
        this.instanceCount = instanceCount;
    }
    updateGeometry() {
        /*************************/
        const start = [];
        const end = [];
        let x = Math.random();
        let y = Math.random();
        let z = Math.random();
        for (let i = 0; i < 10 * 3; i += 3) {
            start[i + 0] = x;
            start[i + 1] = y;
            start[i + 2] = z;
            x = Math.random();
            y = Math.random();
            z = Math.random();
            end[i + 0] = x;
            end[i + 1] = y;
            end[i + 2] = z;
        }
        const startAttribute = new Float32BufferAttribute(start, 3);
        startAttribute.divisor = 1;
        const endAttribute = new Float32BufferAttribute(end, 3);
        endAttribute.divisor = 1;
        this.setAttribute('aSegmentStart', startAttribute);
        this.setAttribute('aSegmentEnd', endAttribute);
        /*************************/
    }
}

class LineSegments extends Mesh {
    #lineStrip;
    constructor(params = {}) {
        params.geometry = new LineSegmentsGeometry();
        params.material = params.material ?? new LineMaterial();
        super(params);
        this.#lineStrip = params.lineStrip ?? true;
    }
    setSegments(positions, colors) {
        this.geometry.setSegments(positions, colors, this.#lineStrip);
    }
}

class Circle extends LineSegments {
    #radius;
    #segments;
    #startAngle;
    #endAngle;
    constructor(params = {}) {
        super(params);
        super.setParameters(params);
        this.#radius = params.radius ?? 1;
        this.#segments = params.segments ?? 64;
        this.#startAngle = params.startAngle ?? 0;
        this.#endAngle = params.endAngle ?? TWO_PI;
        this.#update();
    }
    #update() {
        const startEnd = [];
        const a = (this.#endAngle - this.#startAngle) / this.#segments;
        for (let i = 0; i < this.#segments + 1; i++) {
            const theta = a * i + this.#startAngle;
            const x = this.#radius * Math.cos(theta);
            const y = this.#radius * Math.sin(theta);
            startEnd.push(x);
            startEnd.push(y);
            startEnd.push(0);
        }
        this.setSegments(startEnd);
    }
    toJSON() {
        const json = super.toJSON();
        json.radius = this.#radius;
        json.segments = this.#segments;
        json.startAngle = this.#startAngle;
        json.endAngle = this.#endAngle;
        json.material = this.material.toJSON();
        return json;
    }
    static async constructFromJSON(json, entities, loadedPromise) {
        const material = await JSONLoader.loadEntity(json.material, entities, loadedPromise);
        return new Circle({ radius: json.radius, segments: json.segments, material: material, startAngle: json.startAngle, endAngle: json.endAngle });
    }
    static getEntityName() {
        return 'Circle';
    }
}
registerEntity(Circle);

class ConeBufferGeometry extends BufferGeometry {
    #indices;
    #vertices;
    #normals;
    #uvs;
    updateGeometry(radius = 1, height = 1, segments = 24, hasCap = true) {
        segments = Math.max(Math.floor(segments), 3);
        // buffers
        this.#indices = [];
        this.#vertices = [];
        this.#normals = [];
        this.#uvs = [];
        this.#generateCone(radius, height, segments);
        if (hasCap) {
            this.#generateCap(radius, 0, segments);
            //this.generateCap(radius, +height / 2, segments);
        }
        // build geometry
        this.setIndex(new Uint16BufferAttribute(this.#indices, 1));
        this.setAttribute('aVertexPosition', new Float32BufferAttribute(this.#vertices, 3));
        this.setAttribute('aVertexNormal', new Float32BufferAttribute(this.#normals, 3));
        this.setAttribute('aTextureCoord', new Float32BufferAttribute(this.#uvs, 2));
        this.count = this.#indices.length;
    }
    #generateCone(radius, height, segments) {
        const normal = vec3.create();
        const vertex = vec3.create();
        const thetaPerSegment = TWO_PI / segments;
        //let halfHeight = height / 2.0;
        for (let segmentId = 0; segmentId <= segments; ++segmentId) {
            const theta = thetaPerSegment * segmentId;
            const sinTheta = Math.sin(theta);
            const cosTheta = Math.cos(theta);
            vertex[0] = radius * cosTheta;
            vertex[1] = radius * sinTheta;
            const u = segmentId / segments;
            normal[0] = cosTheta;
            normal[1] = sinTheta;
            //TODO: compute proper normal
            // Bottom vertex
            vertex[2] = 0;
            this.#vertices.push(...vertex);
            this.#normals.push(...normal);
            this.#uvs.push(u, 0);
            // Top vertex
            this.#vertices.push(0, 0, height);
            this.#normals.push(...normal);
            this.#uvs.push(u, 1);
            const indexStart = segmentId * 2;
            this.#indices.push(indexStart, indexStart + 2, indexStart + 1);
            this.#indices.push(indexStart + 1, indexStart + 2, indexStart + 3);
        }
    }
    #generateCap(radius, z, segments) {
        const middlePointIndex = this.#vertices.length / 3;
        // Push middle vertex
        this.#vertices.push(0, 0, z);
        this.#normals.push(0, 0, Math.sign(z));
        this.#uvs.push(0.5, 0.5);
        // Note: we use vertices generated in generateCone for the caps.
        // This uses less memory but limits uv / normals usage
        let indexStart = z <= 0 ? 0 : 1;
        for (let segmentId = 0; segmentId <= segments; ++segmentId) {
            this.#indices.push(indexStart, middlePointIndex, indexStart + 2);
            indexStart += 2;
        }
    }
}

class Cone extends Mesh {
    #radius;
    #height;
    #segments;
    #hasCap;
    constructor(params = {}) {
        params.geometry = new ConeBufferGeometry();
        params.material = params.material ?? new MeshBasicMaterial();
        super(params);
        super.setParameters(params);
        this.#radius = params.radius ?? 1;
        this.#height = params.height ?? 1;
        this.#segments = params.segments ?? 24;
        this.#hasCap = params.hasCap ?? true;
        this.#updateGeometry();
    }
    #updateGeometry() {
        this.geometry.updateGeometry(this.#radius, this.#height, this.#segments, this.#hasCap);
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), {
            Cone_1: null,
            radius: { i18n: '#radius', f: () => { const radius = prompt('Radius', String(this.#radius)); if (radius) {
                    this.#radius = Number(radius);
                    this.#updateGeometry();
                } } },
            height: { i18n: '#height', f: () => { const height = prompt('Height', String(this.#height)); if (height) {
                    this.#height = Number(height);
                    this.#updateGeometry();
                } } },
        });
    }
    static getEntityName() {
        return 'Cone';
    }
}
registerEntity(Cone);

class CylinderBufferGeometry extends BufferGeometry {
    #indices;
    #vertices;
    #normals;
    #uvs;
    updateGeometry(radius, height, segments, hasCap) {
        segments = Math.max(Math.floor(segments), 3);
        // buffers
        this.#indices = [];
        this.#vertices = [];
        this.#normals = [];
        this.#uvs = [];
        this.#generateCylinder(radius, height, segments);
        if (hasCap) {
            this.#generateCap(radius, -height / 2, segments);
            this.#generateCap(radius, +height / 2, segments);
        }
        // build geometry
        this.setIndex(new Uint16BufferAttribute(this.#indices, 1));
        this.setAttribute('aVertexPosition', new Float32BufferAttribute(this.#vertices, 3));
        this.setAttribute('aVertexNormal', new Float32BufferAttribute(this.#normals, 3));
        this.setAttribute('aTextureCoord', new Float32BufferAttribute(this.#uvs, 2));
        this.count = this.#indices.length;
    }
    #generateCylinder(radius, height, segments) {
        const normal = vec3.create();
        const vertex = vec3.create();
        const thetaPerSegment = TWO_PI / segments;
        const halfHeight = height / 2.0;
        for (let segmentId = 0; segmentId <= segments; ++segmentId) {
            const theta = thetaPerSegment * segmentId;
            const sinTheta = Math.sin(theta);
            const cosTheta = Math.cos(theta);
            vertex[0] = radius * cosTheta;
            vertex[1] = radius * sinTheta;
            const u = segmentId / segments;
            normal[0] = cosTheta;
            normal[1] = sinTheta;
            //No need to normalize the normal
            // Bottom vertex
            vertex[2] = -halfHeight;
            this.#vertices.push(...vertex);
            this.#normals.push(...normal);
            this.#uvs.push(u, 0);
            // Top vertex
            vertex[2] = halfHeight;
            this.#vertices.push(...vertex);
            this.#normals.push(...normal);
            this.#uvs.push(u, 1);
            const indexStart = segmentId * 2;
            this.#indices.push(indexStart, indexStart + 2, indexStart + 1);
            this.#indices.push(indexStart + 1, indexStart + 2, indexStart + 3);
        }
    }
    #generateCap(radius, z, segments) {
        const middlePointIndex = this.#vertices.length / 3;
        const sign = Math.sign(z);
        // Push middle vertex
        this.#vertices.push(0, 0, z);
        this.#normals.push(0, 0, sign);
        this.#uvs.push(0.5, 0.5);
        // Note: we use vertices generated in generateCylinder for the caps.
        // This uses less memory but limits uv / normals usage
        let indexStart = z < 0 ? 0 : 1;
        for (let segmentId = 0; segmentId <= segments; ++segmentId) {
            if (sign < 0) {
                this.#indices.push(indexStart, middlePointIndex, indexStart + 2);
            }
            else {
                this.#indices.push(middlePointIndex, indexStart, indexStart + 2);
            }
            indexStart += 2;
        }
    }
}

class Cylinder extends Mesh {
    #radius;
    #height;
    #segments;
    #hasCap;
    constructor(params = {}) {
        params.geometry = new CylinderBufferGeometry();
        params.material = params.material ?? new MeshBasicMaterial();
        super(params);
        super.setParameters(params);
        this.#radius = params.radius ?? 1;
        this.#height = params.height ?? 1;
        this.#segments = params.segments ?? 24;
        this.#hasCap = params.hasCap ?? true;
        this.#updateGeometry();
    }
    #updateGeometry() {
        this.geometry.updateGeometry(this.#radius, this.#height, this.#segments, this.#hasCap);
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), {
            Cylinder_1: null,
            radius: { i18n: '#radius', f: () => { const radius = prompt('Radius', String(this.#radius)); if (radius) {
                    this.#radius = Number(radius);
                    this.#updateGeometry();
                } } },
            height: { i18n: '#height', f: () => { const height = prompt('Height', String(this.#height)); if (height) {
                    this.#height = Number(height);
                    this.#updateGeometry();
                } } },
            segments: { i18n: '#segments', f: () => { const segments = prompt('Segments', String(this.#segments)); if (segments) {
                    this.#segments = Number(segments);
                    this.#updateGeometry();
                } } },
            hasCap: { i18n: '#has_caps', f: () => { const hasCap = prompt('Has Caps', String(this.#hasCap)); if (hasCap) {
                    this.#hasCap = (Number(hasCap) == 1);
                    this.#updateGeometry();
                } } },
        });
    }
    toJSON() {
        const json = super.toJSON();
        json.radius = this.#radius;
        json.height = this.#height;
        json.segments = this.#segments;
        json.hasCap = this.#hasCap;
        json.material = this.material.toJSON();
        return json;
    }
    static async constructFromJSON(json, entities, loadedPromise) {
        const material = await JSONLoader.loadEntity(json.material, entities, loadedPromise);
        return new Cylinder({ radius: json.radius, height: json.height, material: material, segments: json.segments, hasCap: json.hasCap });
    }
    static getEntityName() {
        return 'Cylinder';
    }
}
registerEntity(Cylinder);

class PlaneBufferGeometry extends BufferGeometry {
    updateGeometry(width, height, widthSegments, heightSegments) {
        ///width = width || 1;
        //height = height || 1;
        const width_half = width / 2;
        const height_half = height / 2;
        const gridX = Math.floor(widthSegments);
        const gridY = Math.floor(heightSegments);
        const gridX1 = gridX + 1;
        const gridY1 = gridY + 1;
        const segment_width = width / gridX;
        const segment_height = height / gridY;
        let ix, iy;
        // buffers
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        // generate vertices, normals and uvs
        for (iy = 0; iy < gridY1; iy++) {
            const y = iy * segment_height - height_half;
            for (ix = 0; ix < gridX1; ix++) {
                const x = ix * segment_width - width_half;
                vertices.push(x, -y, 0);
                normals.push(0, 0, 1);
                uvs.push(ix / gridX);
                uvs.push(1 - (iy / gridY));
            }
        }
        // indices
        for (iy = 0; iy < gridY; iy++) {
            for (ix = 0; ix < gridX; ix++) {
                const a = ix + gridX1 * iy;
                const b = ix + gridX1 * (iy + 1);
                const c = (ix + 1) + gridX1 * (iy + 1);
                const d = (ix + 1) + gridX1 * iy;
                // faces
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        // build geometry
        this.setIndex(new Uint16BufferAttribute(indices, 1));
        this.setAttribute('aVertexPosition', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('aVertexNormal', new Float32BufferAttribute(normals, 3));
        this.setAttribute('aTextureCoord', new Float32BufferAttribute(uvs, 2));
        this.count = indices.length;
    }
}

class Plane extends Mesh {
    #widthSegments;
    #heightSegments;
    #width;
    #height;
    constructor(params = {}) {
        params.geometry = new PlaneBufferGeometry();
        params.material = params.material ?? new MeshBasicMaterial();
        super(params);
        this.#width = params.width ?? 1;
        this.#height = params.height ?? this.#width;
        this.#widthSegments = params.widthSegments ?? 1;
        this.#heightSegments = params.heightSegments ?? 1;
        this.#updateGeometry();
    }
    setWidth(width) {
        this.#width = width;
        this.#updateGeometry();
    }
    setHeight(height) {
        this.#height = height;
        this.#updateGeometry();
    }
    setSize(width, height) {
        this.#width = width;
        this.#height = height ?? width;
        this.#updateGeometry();
    }
    #updateGeometry() {
        this.geometry.updateGeometry(this.#width, this.#height, this.#widthSegments, this.#heightSegments);
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), {
            Plane_1: null,
            width: { i18n: '#width', f: () => { const width = prompt(); if (width) {
                    this.#width = Number(width);
                    this.#updateGeometry();
                } } },
            height: { i18n: '#height', f: () => { const height = prompt(); if (height) {
                    this.#height = Number(height);
                    this.#updateGeometry();
                } } },
            square: { i18n: '#square', f: () => { const size = Number(prompt('Square size')); if (size) {
                    this.#width = size;
                    this.#height = size;
                    this.#updateGeometry();
                } } },
        });
    }
    toJSON() {
        const json = super.toJSON();
        json.width = this.#width;
        json.height = this.#height;
        json.widthSegments = this.#widthSegments;
        json.heightsegments = this.#heightSegments;
        json.material = this.material.toJSON();
        return json;
    }
    static async constructFromJSON(json, entities, loadedPromise) {
        const material = await JSONLoader.loadEntity(json.material, entities, loadedPromise);
        return new Plane({ width: json.width, height: json.height, material: material, widthSegments: json.widthSegments, heightSegments: json.heightSegments });
    }
    static getEntityName() {
        return 'Plane';
    }
}
JSONLoader.registerEntity(Plane);

class SphereBufferGeometry extends BufferGeometry {
    updateGeometry(radius, segments, rings, phiStart, phiLength, thetaStart, thetaLength) {
        segments = Math.max(3, Math.floor(segments));
        rings = Math.max(2, Math.floor(rings));
        //phiStart = phiStart !== undefined ? phiStart : 0;
        //phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
        //thetaStart = thetaStart !== undefined ? thetaStart : 0;
        //thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
        const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
        let ix, iy;
        let index = 0;
        const grid = [];
        const vertex = vec3.create();
        const normal = vec3.create();
        // buffers
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        // generate vertices, normals and uvs
        for (iy = 0; iy <= rings; iy++) {
            const verticesRow = [];
            const v = iy / rings;
            // special case for the poles
            let uOffset = 0;
            if (iy == 0 && thetaStart == 0) {
                uOffset = 0.5 / segments;
            }
            else if (iy == rings && thetaEnd == Math.PI) {
                uOffset = -0.5 / segments;
            }
            for (ix = 0; ix <= segments; ix++) {
                const u = ix / segments;
                // vertex
                vertex[0] = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                vertex[2] = radius * Math.cos(thetaStart + v * thetaLength);
                vertex[1] = -radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                vertices.push(...vertex);
                // normal
                vec3.normalize(normal, vertex);
                normals.push(...normal);
                // uv
                uvs.push(u + uOffset, 1 - v);
                verticesRow.push(index++);
            }
            grid.push(verticesRow);
        }
        // indices
        for (iy = 0; iy < rings; iy++) {
            for (ix = 0; ix < segments; ix++) {
                const a = grid[iy][ix + 1];
                const b = grid[iy][ix];
                const c = grid[iy + 1][ix];
                const d = grid[iy + 1][ix + 1];
                if (iy !== 0 || thetaStart > 0)
                    indices.push(a, b, d);
                if (iy !== rings - 1 || thetaEnd < Math.PI)
                    indices.push(b, c, d);
            }
        }
        // build geometry
        this.setIndex(new Uint16BufferAttribute(indices, 1));
        this.setAttribute('aVertexPosition', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('aVertexNormal', new Float32BufferAttribute(normals, 3));
        this.setAttribute('aTextureCoord', new Float32BufferAttribute(uvs, 2));
        this.count = indices.length;
    }
}

const intersectionPoint1 = vec3.create();
const intersectionPoint2 = vec3.create();
const intersectionNormal$1 = vec3.create();
const tempVec3$q = vec3.create();
const v$d = vec3.create();
class Sphere extends Mesh {
    radius;
    segments;
    rings;
    phiStart;
    phiLength;
    thetaStart;
    thetaLength;
    isSphere = true;
    constructor(params = {}) {
        params.geometry = new SphereBufferGeometry();
        params.material = params.material ?? new MeshBasicMaterial();
        super(params);
        this.radius = params.radius ?? 1;
        this.segments = params.segments ?? 8;
        this.rings = params.rings ?? 8;
        this.phiStart = params.phiStart ?? 0;
        this.phiLength = params.phiLength ?? TAU;
        this.thetaStart = params.thetaStart = 0;
        this.thetaLength = params.thetaLength ?? PI;
        this.updateGeometry();
        super.setParameters(arguments[0]);
    }
    setRadius(radius) {
        this.radius = radius;
        this.updateGeometry();
    }
    updateGeometry() {
        this.geometry.updateGeometry(this.radius, this.segments, this.rings, this.phiStart, this.phiLength, this.thetaStart, this.thetaLength);
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), {
            Sphere_1: null,
            radius: { i18n: '#radius', f: () => { const radius = prompt('Radius', String(this.radius)); if (radius) {
                    this.radius = Number(radius);
                    this.updateGeometry();
                } } },
            segments: { i18n: '#segments', f: () => { const segments = prompt('Segments', String(this.segments)); if (segments) {
                    this.segments = Number(segments);
                    this.updateGeometry();
                } } },
            rings: { i18n: '#rings', f: () => { const rings = prompt('Rings', String(this.rings)); if (rings) {
                    this.rings = Number(rings);
                    this.updateGeometry();
                } } }
        });
    }
    raycast(raycaster, intersections) {
        const ray = raycaster.ray;
        const worldPosition = this.getWorldPosition(v$d);
        const inverseRadius = 1 / this.radius;
        if (ray.intersectSphere(worldPosition, this.radius, this.getWorldScale(tempVec3$q), intersectionPoint1, intersectionPoint2)) {
            //return super.raycast(raycaster, intersections);//TODO: improve
            //TODO: case when the ray spawn from inside the sphere
            vec3.sub(intersectionNormal$1, intersectionPoint1, worldPosition);
            vec3.scale(intersectionNormal$1, intersectionNormal$1, inverseRadius);
            intersections.push(ray.createIntersection(intersectionPoint1, intersectionNormal$1, null, this, 0));
            vec3.sub(intersectionNormal$1, intersectionPoint2, worldPosition);
            vec3.scale(intersectionNormal$1, intersectionNormal$1, inverseRadius);
            intersections.push(ray.createIntersection(intersectionPoint2, intersectionNormal$1, null, this, 0));
        }
    }
    toJSON() {
        const json = super.toJSON();
        json.radius = this.radius;
        json.segments = this.segments;
        json.rings = this.rings;
        json.phistart = this.phiStart;
        json.philength = this.phiLength;
        json.thetastart = this.thetaStart;
        json.thetalength = this.thetaLength;
        json.material = this.material.toJSON();
        return json;
    }
    static async constructFromJSON(json, entities, loadedPromise) {
        const material = await JSONLoader.loadEntity(json.material, entities, loadedPromise);
        return new Sphere({ radius: json.radius, material: material, segments: json.segments, rings: json.rings, phiStart: json.phistart, phiLength: json.philength, thetaStart: json.thetastart, thetaLength: json.thetalength });
    }
    static getEntityName() {
        return 'Sphere';
    }
}
registerEntity(Sphere);

const ARROW_RADIUS = 0.1;
const ARROW_LENGTH = 5;
const PLANE_LENGTH = ARROW_LENGTH / 3;
const HALF_PLANE_LENGTH = PLANE_LENGTH / 2;
const TIP_LENGTH = 1;
const RADIUS = 5;
const X_COLOR = vec4.fromValues(1, 0, 0, 1);
const Y_COLOR = vec4.fromValues(0, 1, 0, 1);
const Z_COLOR = vec4.fromValues(0, 0, 1, 1);
const XY_COLOR = vec4.fromValues(1, 1, 0, 0.2);
const XZ_COLOR = vec4.fromValues(1, 0, 1, 0.2);
const YZ_COLOR = vec4.fromValues(0, 1, 1, 0.2);
const GREY_COLOR = vec4.fromValues(0.2, 0.2, 0.2, 1);
const SCREEN_COLOR = vec4.fromValues(1.0, 0.0, 1.0, 1);
const SELECTED_COLOR = vec4.fromValues(1, 1, 0, 1);
const ORIENTATION_WORLD = 0;
const xUnitVec3 = vec3.fromValues(1, 0, 0);
const yUnitVec3 = vec3.fromValues(0, 1, 0);
const zUnitVec3 = vec3.fromValues(0, 0, 1);
const xyUnitVec3 = vec3.fromValues(1, 1, 0);
const xzUnitVec3 = vec3.fromValues(1, 0, 1);
const yzUnitVec3 = vec3.fromValues(0, 1, 1);
const tempVec3$p = vec3.create();
const tempVec3_b = vec3.create();
const translationManipulatorTempQuat = quat.create();
const tempQuat$9 = quat.create();
const MANIPULATOR_SHORTCUT_INCREASE = 'engine.shortcuts.manipulator.size.increase';
const MANIPULATOR_SHORTCUT_DECREASE = 'engine.shortcuts.manipulator.size.decrease';
const MANIPULATOR_SHORTCUT_TRANSLATION = 'engine.shortcuts.manipulator.mode.translation';
const MANIPULATOR_SHORTCUT_ROTATION = 'engine.shortcuts.manipulator.mode.rotation';
const MANIPULATOR_SHORTCUT_SCALE = 'engine.shortcuts.manipulator.mode.scale';
const MANIPULATOR_SHORTCUT_AXIS_ORIENTATION = 'engine.shortcuts.manipulator.axis.orientation';
const MANIPULATOR_SHORTCUT_TOGGLE_X = 'engine.shortcuts.manipulator.toggle.x';
const MANIPULATOR_SHORTCUT_TOGGLE_Y = 'engine.shortcuts.manipulator.toggle.y';
const MANIPULATOR_SHORTCUT_TOGGLE_Z = 'engine.shortcuts.manipulator.toggle.z';
var ManipulatorMode;
(function (ManipulatorMode) {
    ManipulatorMode[ManipulatorMode["Translation"] = 0] = "Translation";
    ManipulatorMode[ManipulatorMode["Rotation"] = 1] = "Rotation";
    ManipulatorMode[ManipulatorMode["Scale"] = 2] = "Scale";
})(ManipulatorMode || (ManipulatorMode = {}));
var ManipulatorAxis;
(function (ManipulatorAxis) {
    ManipulatorAxis[ManipulatorAxis["None"] = 0] = "None";
    ManipulatorAxis[ManipulatorAxis["X"] = 1] = "X";
    ManipulatorAxis[ManipulatorAxis["Y"] = 2] = "Y";
    ManipulatorAxis[ManipulatorAxis["Z"] = 3] = "Z";
    ManipulatorAxis[ManipulatorAxis["XY"] = 4] = "XY";
    ManipulatorAxis[ManipulatorAxis["XZ"] = 5] = "XZ";
    ManipulatorAxis[ManipulatorAxis["YZ"] = 6] = "YZ";
    ManipulatorAxis[ManipulatorAxis["XYZ"] = 7] = "XYZ";
    ManipulatorAxis[ManipulatorAxis["View"] = 8] = "View";
})(ManipulatorAxis || (ManipulatorAxis = {}));
class Manipulator extends Entity {
    #entityAxis = new Map();
    #xMaterial = new MeshBasicMaterial();
    #yMaterial = new MeshBasicMaterial();
    #zMaterial = new MeshBasicMaterial();
    #xyMaterial = new MeshBasicMaterial();
    #xzMaterial = new MeshBasicMaterial();
    #yzMaterial = new MeshBasicMaterial();
    #xyzMaterial = new MeshBasicMaterial();
    #xLineMaterial = new LineMaterial();
    #yLineMaterial = new LineMaterial();
    #zLineMaterial = new LineMaterial();
    #xyzLineMaterial = new LineMaterial();
    #viewLineMaterial = new LineMaterial();
    #xyzSphere = new Sphere({ radius: ARROW_RADIUS * 6.0, material: this.#xyzMaterial, segments: 32, rings: 32, name: 'Manipulator XYZ sphere' });
    #xArrow = new Cylinder({ radius: ARROW_RADIUS, height: ARROW_LENGTH, material: this.#xMaterial, name: 'Manipulator X arrow' });
    #yArrow = new Cylinder({ radius: ARROW_RADIUS, height: ARROW_LENGTH, material: this.#yMaterial, name: 'Manipulator Y arrow' });
    #zArrow = new Cylinder({ radius: ARROW_RADIUS, height: ARROW_LENGTH, material: this.#zMaterial, name: 'Manipulator Z arrow' });
    #xyPlane = new Plane({ width: PLANE_LENGTH, height: PLANE_LENGTH, material: this.#xyMaterial, name: 'Manipulator XY' });
    #xzPlane = new Plane({ width: PLANE_LENGTH, height: PLANE_LENGTH, material: this.#xzMaterial, name: 'Manipulator XZ' });
    #yzPlane = new Plane({ width: PLANE_LENGTH, height: PLANE_LENGTH, material: this.#yzMaterial, name: 'Manipulator YZ' });
    #xCircle = new Circle({ radius: RADIUS, material: this.#xLineMaterial, segments: 32, startAngle: -HALF_PI, endAngle: HALF_PI, name: 'Manipulator rotate X' });
    #yCircle = new Circle({ radius: RADIUS, material: this.#yLineMaterial, segments: 32, startAngle: -PI, endAngle: 0, name: 'Manipulator rotate Y' });
    #zCircle = new Circle({ radius: RADIUS, material: this.#zLineMaterial, segments: 32, startAngle: -HALF_PI, endAngle: HALF_PI, name: 'Manipulator rotate Z' });
    #viewCircle = new Circle({ radius: RADIUS * 1.25, material: this.#xyzLineMaterial, name: 'Manipulator rotate XYZ' });
    #circle = new Circle({ radius: RADIUS, material: this.#viewLineMaterial, name: 'Manipulator rotate view' });
    #xScale = new Cylinder({ radius: ARROW_RADIUS, height: ARROW_LENGTH, material: this.#xMaterial });
    #yScale = new Cylinder({ radius: ARROW_RADIUS, height: ARROW_LENGTH, material: this.#yMaterial });
    #zScale = new Cylinder({ radius: ARROW_RADIUS, height: ARROW_LENGTH, material: this.#zMaterial });
    #cursorPos = vec2.create();
    #axisOrientation = ORIENTATION_WORLD;
    #near = vec3.create();
    #far = vec3.create();
    #startDragPosition = vec3.create();
    #startScalePosition = vec3.create();
    #parentStartScale = vec3.create();
    #mode = ManipulatorMode.Translation;
    enumerable = false;
    camera;
    size = 1;
    #axis = ManipulatorAxis.None;
    #startPosition = vec3.create();
    #startQuaternion = quat.create();
    #startLocalQuaternion = quat.create();
    #startDragVector = 0; //vec3 = vec3.create();
    #translationManipulator = new Entity({ name: 'Translation manipulator' });
    #rotationManipulator = new Entity({ name: 'Rotation manipulator' });
    #scaleManipulator = new Entity({ name: 'Scale manipulator' });
    #enableX = false;
    #enableY = false;
    #enableZ = false;
    constructor(params) {
        super(params);
        this.wireframe = 0;
        this.setLayer(LAYER_MAX);
        this.hideInExplorer = true;
        this.castShadow = false;
        this.serializable = false;
        this.#initMaterials();
        this.#initTranslationManipulator();
        this.#initRotationManipulator();
        this.#initScaleManipulator();
        this.setMode(ManipulatorMode.Translation);
        this.setAttribute(EngineEntityAttributes.IsTool, true);
        this.enableX = true;
        this.enableY = true;
        this.enableZ = true;
        this.forEach((entity) => entity.setupPickingId());
        GraphicsEvents.addEventListener(GraphicsEvent.Tick, () => this.resize(this.root?.activeCamera));
        GraphicsEvents.addEventListener(GraphicsEvent.MouseDown, (event) => {
            const detail = event.detail;
            if (this.#entityAxis.has(detail.entity)) {
                this.#axis = this.#entityAxis.get(detail.entity);
                switch (this.#mode) {
                    case ManipulatorMode.Translation:
                        this.startTranslate(detail.x, detail.y);
                        break;
                    case ManipulatorMode.Rotation:
                        this.startRotate(detail.x, detail.y);
                        break;
                    case ManipulatorMode.Scale:
                        this.startScale(detail.x, detail.y);
                        break;
                }
                Graphics$1.dragging = true;
                this.#setAxisSelected(true);
            }
        });
        GraphicsEvents.addEventListener(GraphicsEvent.MouseMove, (event) => {
            const detail = event.detail;
            if (!detail.entity?.isVisible()) {
                return;
            }
            if (this.#entityAxis.has(detail.entity)) {
                switch (this.#mode) {
                    case ManipulatorMode.Translation:
                        this.#translationMoveHandler(detail.x, detail.y);
                        break;
                    case ManipulatorMode.Rotation:
                        this.#rotationMoveHandler(detail.x, detail.y);
                        break;
                    case ManipulatorMode.Scale:
                        this.#scaleMoveHandler(detail.x, detail.y);
                        break;
                }
            }
        });
        GraphicsEvents.addEventListener(GraphicsEvent.MouseUp, (event) => {
            if (this.#entityAxis.has(event.detail.entity)) {
                Graphics$1.dragging = false;
                this.#setAxisSelected(false);
            }
        });
        ShortcutHandler.addEventListener(MANIPULATOR_SHORTCUT_INCREASE, () => this.size *= 1.1);
        ShortcutHandler.addEventListener(MANIPULATOR_SHORTCUT_DECREASE, () => this.size *= 0.9);
        ShortcutHandler.addEventListener(MANIPULATOR_SHORTCUT_TRANSLATION, () => this.setMode(ManipulatorMode.Translation));
        ShortcutHandler.addEventListener(MANIPULATOR_SHORTCUT_ROTATION, () => this.setMode(ManipulatorMode.Rotation));
        ShortcutHandler.addEventListener(MANIPULATOR_SHORTCUT_SCALE, () => this.setMode(ManipulatorMode.Scale));
        ShortcutHandler.addEventListener(MANIPULATOR_SHORTCUT_AXIS_ORIENTATION, () => this.#axisOrientation = (++this.#axisOrientation) % 2);
        ShortcutHandler.addEventListener(MANIPULATOR_SHORTCUT_TOGGLE_X, () => this.enableX = !this.enableX);
        ShortcutHandler.addEventListener(MANIPULATOR_SHORTCUT_TOGGLE_Y, () => this.enableY = !this.enableY);
        ShortcutHandler.addEventListener(MANIPULATOR_SHORTCUT_TOGGLE_Z, () => this.enableZ = !this.enableZ);
    }
    resize(camera) {
        if (!this.isVisible()) {
            return;
        }
        let scaleFactor = 1;
        if (camera) {
            this.camera = camera;
            if (camera.isPerspective) {
                this.getWorldPosition(tempVec3$p);
                camera.getWorldPosition(tempVec3_b);
                scaleFactor = vec3.distance(tempVec3$p, tempVec3_b) * Math.min(1.9 * Math.tan(camera.verticalFov * DEG_TO_RAD), 7);
                scaleFactor *= 0.02;
            }
            else if (camera.isOrthographic) {
                scaleFactor = (camera.top - camera.bottom) / camera.orthoZoom;
                scaleFactor *= 0.02;
            }
            scaleFactor *= this.size;
            this.scale = vec3.set(tempVec3$p, scaleFactor, scaleFactor, scaleFactor);
            this.#setupAxis();
        }
    }
    #setAxisSelected(selected) {
        switch (this.#axis % 10) {
            case 1:
                this.#xMaterial.setMeshColor(selected ? SELECTED_COLOR : X_COLOR);
                this.#xLineMaterial.setMeshColor(selected ? SELECTED_COLOR : X_COLOR);
                break;
            case 2:
                this.#yMaterial.setMeshColor(selected ? SELECTED_COLOR : Y_COLOR);
                this.#yLineMaterial.setMeshColor(selected ? SELECTED_COLOR : Y_COLOR);
                break;
            case 3:
                this.#zMaterial.setMeshColor(selected ? SELECTED_COLOR : Z_COLOR);
                this.#zLineMaterial.setMeshColor(selected ? SELECTED_COLOR : Z_COLOR);
                break;
            case 4:
                this.#xyMaterial.setMeshColor(selected ? SELECTED_COLOR : XY_COLOR);
                break;
            case 5:
                this.#xzMaterial.setMeshColor(selected ? SELECTED_COLOR : XZ_COLOR);
                break;
            case 6:
                this.#yzMaterial.setMeshColor(selected ? SELECTED_COLOR : YZ_COLOR);
                break;
            case 7:
                this.#xyzLineMaterial.setMeshColor(selected ? SELECTED_COLOR : SCREEN_COLOR);
                break;
        }
    }
    #initMaterials() {
        this.#xMaterial.setMeshColor(X_COLOR);
        this.#xMaterial.setDefine('ALWAYS_ON_TOP');
        this.#yMaterial.setMeshColor(Y_COLOR);
        this.#yMaterial.setDefine('ALWAYS_ON_TOP');
        this.#zMaterial.setMeshColor(Z_COLOR);
        this.#zMaterial.setDefine('ALWAYS_ON_TOP');
        this.#xyMaterial.setMeshColor(XY_COLOR);
        this.#xyMaterial.setDefine('ALWAYS_ON_TOP');
        this.#xyMaterial.renderFace(RenderFace.Both);
        this.#xyMaterial.setBlending(MATERIAL_BLENDING_NORMAL);
        this.#xzMaterial.setMeshColor(XZ_COLOR);
        this.#xzMaterial.setDefine('ALWAYS_ON_TOP');
        this.#xzMaterial.renderFace(RenderFace.Both);
        this.#xzMaterial.setBlending(MATERIAL_BLENDING_NORMAL);
        this.#yzMaterial.setMeshColor(YZ_COLOR);
        this.#yzMaterial.setDefine('ALWAYS_ON_TOP');
        this.#yzMaterial.renderFace(RenderFace.Both);
        this.#yzMaterial.setBlending(MATERIAL_BLENDING_NORMAL);
        this.#xyzMaterial.setDefine('ALWAYS_ON_TOP');
        this.#xLineMaterial.setMeshColor(X_COLOR);
        this.#xLineMaterial.setDefine('ALWAYS_ON_TOP');
        this.#yLineMaterial.setMeshColor(Y_COLOR);
        this.#yLineMaterial.setDefine('ALWAYS_ON_TOP');
        this.#zLineMaterial.setMeshColor(Z_COLOR);
        this.#zLineMaterial.setDefine('ALWAYS_ON_TOP');
        this.#xyzLineMaterial.setMeshColor(SCREEN_COLOR);
        this.#xyzLineMaterial.setDefine('ALWAYS_ON_TOP');
        this.#viewLineMaterial.setMeshColor(GREY_COLOR);
        this.#viewLineMaterial.setDefine('ALWAYS_ON_TOP');
        this.#viewLineMaterial.lineWidth = 2;
    }
    #initTranslationManipulator() {
        this.addChild(this.#translationManipulator);
        this.#xArrow.rotateY(HALF_PI);
        this.#xArrow.translateZ(ARROW_LENGTH / 2);
        this.#yArrow.rotateX(-HALF_PI);
        this.#yArrow.translateZ(ARROW_LENGTH / 2);
        this.#zArrow.translateZ(ARROW_LENGTH / 2);
        const xTip = new Cone({ radius: ARROW_RADIUS * 2, height: TIP_LENGTH, material: this.#xMaterial, name: 'Manipulator X tip' });
        xTip.translateZ(ARROW_LENGTH / 2);
        const yTip = new Cone({ radius: ARROW_RADIUS * 2, height: TIP_LENGTH, material: this.#yMaterial, name: 'Manipulator Y tip' });
        yTip.translateZ(ARROW_LENGTH / 2);
        const zTip = new Cone({ radius: ARROW_RADIUS * 2, height: TIP_LENGTH, material: this.#zMaterial, name: 'Manipulator Z tip' });
        zTip.translateZ(ARROW_LENGTH / 2);
        this.#xyPlane.translateOnAxis([1, 1, 0], HALF_PLANE_LENGTH);
        this.#xzPlane.translateOnAxis([1, 0, 1], HALF_PLANE_LENGTH);
        this.#xzPlane.rotateX(HALF_PI);
        this.#yzPlane.translateOnAxis([0, 1, 1], HALF_PLANE_LENGTH);
        this.#yzPlane.rotateY(HALF_PI);
        this.#translationManipulator.addChild(this.#xyzSphere);
        this.#translationManipulator.addChild(this.#xArrow);
        this.#translationManipulator.addChild(this.#yArrow);
        this.#translationManipulator.addChild(this.#zArrow);
        this.#xArrow.addChild(xTip);
        this.#yArrow.addChild(yTip);
        this.#zArrow.addChild(zTip);
        this.#translationManipulator.addChild(this.#xyPlane);
        this.#translationManipulator.addChild(this.#xzPlane);
        this.#translationManipulator.addChild(this.#yzPlane);
        this.#entityAxis.set(this.#xyzSphere, ManipulatorAxis.XYZ);
        this.#entityAxis.set(this.#xArrow, ManipulatorAxis.X);
        this.#entityAxis.set(xTip, ManipulatorAxis.X);
        this.#entityAxis.set(this.#yArrow, ManipulatorAxis.Y);
        this.#entityAxis.set(yTip, ManipulatorAxis.Y);
        this.#entityAxis.set(this.#zArrow, ManipulatorAxis.Z);
        this.#entityAxis.set(zTip, ManipulatorAxis.Z);
        this.#entityAxis.set(this.#xyPlane, ManipulatorAxis.XY);
        this.#entityAxis.set(this.#xzPlane, ManipulatorAxis.XZ);
        this.#entityAxis.set(this.#yzPlane, ManipulatorAxis.YZ);
    }
    #initRotationManipulator() {
        this.addChild(this.#rotationManipulator);
        this.#rotationManipulator.addChild(this.#xCircle);
        this.#rotationManipulator.addChild(this.#yCircle);
        this.#rotationManipulator.addChild(this.#zCircle);
        this.#rotationManipulator.addChild(this.#viewCircle);
        this.#rotationManipulator.addChild(this.#circle);
        this.#entityAxis.set(this.#xCircle, ManipulatorAxis.X);
        this.#entityAxis.set(this.#yCircle, ManipulatorAxis.Y);
        this.#entityAxis.set(this.#zCircle, ManipulatorAxis.Z);
        this.#entityAxis.set(this.#viewCircle, ManipulatorAxis.View);
    }
    #initScaleManipulator() {
        this.addChild(this.#scaleManipulator);
        //let _xyzSphere = new Sphere(ARROW_RADIUS * 6.0, this.#xyzMaterial, 32, 32);
        this.#xScale.rotateY(HALF_PI);
        this.#xScale.translateZ(ARROW_LENGTH / 2);
        this.#yScale.rotateX(-HALF_PI);
        this.#yScale.translateZ(ARROW_LENGTH / 2);
        this.#zScale.translateZ(ARROW_LENGTH / 2);
        const xScaleTip = new Box({ width: TIP_LENGTH, height: TIP_LENGTH, depth: TIP_LENGTH, material: this.#xMaterial });
        xScaleTip.translateZ(ARROW_LENGTH / 2);
        const yScaleTip = new Box({ width: TIP_LENGTH, height: TIP_LENGTH, depth: TIP_LENGTH, material: this.#yMaterial });
        yScaleTip.translateZ(ARROW_LENGTH / 2);
        const zScaleTip = new Box({ width: TIP_LENGTH, height: TIP_LENGTH, depth: TIP_LENGTH, material: this.#zMaterial });
        zScaleTip.translateZ(ARROW_LENGTH / 2);
        /*this.#xyPlane = new Plane(PLANE_LENGTH, PLANE_LENGTH, this.#xyMaterial);
        this.#xyPlane.translateOnAxis([1, 1, 0], HALF_PLANE_LENGTH);
        this.#xzPlane = new Plane(PLANE_LENGTH, PLANE_LENGTH, this.#xzMaterial);
        this.#xzPlane.translateOnAxis([1, 0, 1], HALF_PLANE_LENGTH);
        this.#xzPlane.rotateX(HALF_PI);
        this.#yzPlane = new Plane(PLANE_LENGTH, PLANE_LENGTH, this.#yzMaterial);
        this.#yzPlane.translateOnAxis([0, 1, 1], HALF_PLANE_LENGTH);
        this.#yzPlane.rotateY(HALF_PI);*/
        //scaleManipulator.addChild(_xyzSphere);
        this.#scaleManipulator.addChild(this.#xScale);
        this.#scaleManipulator.addChild(this.#yScale);
        this.#scaleManipulator.addChild(this.#zScale);
        this.#xScale.addChild(xScaleTip);
        this.#yScale.addChild(yScaleTip);
        this.#zScale.addChild(zScaleTip);
        /*this.addChild(this.#xyPlane);
        this.addChild(this.#xzPlane);
        this.addChild(this.#yzPlane);*/
        //this.#entityAxis.set(_xyzSphere, 20);
        this.#entityAxis.set(this.#xScale, ManipulatorAxis.X);
        this.#entityAxis.set(xScaleTip, ManipulatorAxis.X);
        this.#entityAxis.set(this.#yScale, ManipulatorAxis.Y);
        this.#entityAxis.set(yScaleTip, ManipulatorAxis.Y);
        this.#entityAxis.set(this.#zScale, ManipulatorAxis.Z);
        this.#entityAxis.set(zScaleTip, ManipulatorAxis.Z);
    }
    startTranslate(x, y) {
        if (this._parent) {
            this._parent.getWorldPosition(this.#startPosition);
        }
        else {
            this.getWorldPosition(this.#startPosition);
        }
        this.#computeTranslationPosition(this.#startDragPosition, x, y);
    }
    startRotate(x, y) {
        if (this._parent) {
            this._parent.getWorldQuaternion(this.#startQuaternion);
            this._parent.getQuaternion(this.#startLocalQuaternion);
        }
        else {
            this.getWorldQuaternion(this.#startQuaternion);
            this.getQuaternion(this.#startLocalQuaternion);
        }
        this.#startDragVector = this.#computeQuaternion(x, y);
    }
    startScale(x, y) {
        const startScalePosition = this.#startScalePosition;
        if (this._parent) {
            this._parent.getWorldPosition(this.#startPosition);
        }
        else {
            this.getWorldPosition(this.#startPosition);
        }
        this.#computeTranslationPosition(this.#startScalePosition, x, y);
        vec3.div(startScalePosition, startScalePosition, this.scale);
        vec3.scale(startScalePosition, startScalePosition, 2 / ARROW_LENGTH);
        if (this._parent) {
            vec3.copy(this.#parentStartScale, this._parent._scale);
        }
    }
    #translationMoveHandler(x, y) {
        this.#computeTranslationPosition(tempVec3$p, x, y);
        vec3.sub(tempVec3$p, tempVec3$p, this.#startDragPosition);
        switch (this.#axis) {
            case ManipulatorAxis.None:
                break;
            case ManipulatorAxis.X:
                tempVec3$p[1] = 0;
                tempVec3$p[2] = 0;
                break;
            case ManipulatorAxis.Y:
                tempVec3$p[0] = 0;
                tempVec3$p[2] = 0;
                break;
            case ManipulatorAxis.Z:
                tempVec3$p[0] = 0;
                tempVec3$p[1] = 0;
                break;
            case ManipulatorAxis.XY:
                tempVec3$p[2] = 0;
                break;
            case ManipulatorAxis.XZ:
                tempVec3$p[1] = 0;
                break;
            case ManipulatorAxis.YZ:
                tempVec3$p[0] = 0;
                break;
            default:
                tempVec3$p[0] = 0;
                tempVec3$p[1] = 0;
                tempVec3$p[2] = 0;
        }
        vec3.transformQuat(tempVec3$p, tempVec3$p, this.getWorldQuaternion());
        vec3.add(tempVec3$p, this.#startPosition, tempVec3$p);
        if (this._parent) {
            this._parent.setWorldPosition(tempVec3$p);
            this._parent.locked = true;
        }
        else {
            this.setWorldPosition(tempVec3$p);
        }
    }
    #rotationMoveHandler(x, y) {
        if (!this.camera) {
            return;
        }
        const v3 = this.#computeQuaternion(x, y);
        quat.rotationTo(translationManipulatorTempQuat, this.#startDragVector, v3);
        quat.mul(translationManipulatorTempQuat, this.#startLocalQuaternion, translationManipulatorTempQuat);
        const viewDirection = this.camera.getViewDirection(vec3.create() /*TODO: optimize*/);
        let rotateAxis = xUnitVec3;
        switch (this.#axis) {
            case ManipulatorAxis.Y:
                rotateAxis = yUnitVec3;
                break;
            case ManipulatorAxis.Z:
                rotateAxis = zUnitVec3;
                break;
            case ManipulatorAxis.View:
                rotateAxis = viewDirection;
                break;
        }
        let invert = Math.sign(vec3.dot(rotateAxis, viewDirection));
        if (invert == 0) {
            invert = 1;
        }
        const angleDelta = this.#startDragVector - v3;
        quat.setAxisAngle(translationManipulatorTempQuat, rotateAxis, angleDelta * invert);
        quat.mul(translationManipulatorTempQuat, translationManipulatorTempQuat, this.#startLocalQuaternion);
        if (this._parent) {
            this._parent.quaternion = translationManipulatorTempQuat;
            this._parent.locked = true;
        }
        else {
            this.quaternion = translationManipulatorTempQuat;
        }
    }
    #scaleMoveHandler(x, y) {
        const v3 = this.#computeTranslationPosition(tempVec3$p, x, y);
        if (!v3) {
            return;
        }
        //vec3.sub(v3, v3, this.#startScalePosition);
        vec3.div(v3, v3, this.scale);
        vec3.div(v3, v3, this.#startScalePosition);
        vec3.scale(v3, v3, 2 / ARROW_LENGTH);
        switch (this.#axis) {
            case ManipulatorAxis.None:
                break;
            case ManipulatorAxis.X:
                v3[1] = 1;
                v3[2] = 1;
                break;
            case ManipulatorAxis.Y:
                v3[0] = 1;
                v3[2] = 1;
                break;
            case ManipulatorAxis.Z:
                v3[0] = 1;
                v3[1] = 1;
                break;
            default:
                v3[0] = 1;
                v3[1] = 1;
                v3[2] = 1;
        }
        if (this._parent) {
            this._parent.scale = vec3.mul(v3, v3, this.#parentStartScale);
            this._parent.locked = true;
        }
    }
    #computeTranslationPosition(out, x, y) {
        const camera = this.camera;
        if (camera) {
            const projectionMatrix = camera.projectionMatrix;
            const viewMatrix = camera.cameraMatrix;
            camera.nearPlane;
            camera.farPlane;
            camera.aspectRatio;
            const invProjectionMatrix = mat4.invert(mat4.create(), projectionMatrix);
            const invViewMatrix = mat4.invert(mat4.create(), viewMatrix);
            // transform the screen coordinates to normalized coordinates
            this.#cursorPos[0] = (x / Graphics$1.getWidth()) * 2.0 - 1.0;
            this.#cursorPos[1] = 1.0 - (y / Graphics$1.getHeight()) * 2.0;
            this.#near[0] = this.#far[0] = this.#cursorPos[0];
            this.#near[1] = this.#far[1] = this.#cursorPos[1];
            this.#near[2] = -1.0;
            this.#far[2] = 1.0;
            vec3.transformMat4(this.#near, this.#near, invProjectionMatrix);
            vec3.transformMat4(this.#far, this.#far, invProjectionMatrix);
            vec3.transformMat4(this.#near, this.#near, invViewMatrix);
            vec3.transformMat4(this.#far, this.#far, invViewMatrix);
            function lineIntersection(out, planePoint, planeNormal, linePoint, lineDirection) {
                if (vec3.dot(planeNormal, lineDirection) == 0) {
                    return vec3.create(); //TODO: optimize
                }
                const t = (vec3.dot(planeNormal, planePoint) - vec3.dot(planeNormal, linePoint)) / vec3.dot(planeNormal, lineDirection);
                return vec3.scaleAndAdd(out, linePoint, lineDirection, t);
            }
            let planeNormal = vec3.create();
            switch (this.#axis % 10) {
                case 1:
                    planeNormal = vec3.transformQuat(planeNormal, xUnitVec3, this.getWorldQuaternion());
                    break;
                case 2:
                    planeNormal = vec3.transformQuat(planeNormal, yUnitVec3, this.getWorldQuaternion());
                    break;
                case 3:
                    planeNormal = vec3.transformQuat(planeNormal, zUnitVec3, this.getWorldQuaternion());
                    break;
                case 4:
                    planeNormal = vec3.transformQuat(planeNormal, xyUnitVec3, this.getWorldQuaternion());
                    break;
                case 5:
                    planeNormal = vec3.transformQuat(planeNormal, xzUnitVec3, this.getWorldQuaternion());
                    break;
                case 6:
                    planeNormal = vec3.transformQuat(planeNormal, yzUnitVec3, this.getWorldQuaternion());
                    break;
                default:
                    planeNormal = vec3.sub(vec3.create(), this.#far, this.#near);
                    break;
            }
            /********************/
            const worldPos = this._parent ? this._parent.getWorldPosition() : this.getWorldPosition();
            const A = worldPos; //vec3.clone(this._parent.position) : vec3.clone(this.position);
            const B = vec3.add(vec3.create(), A, planeNormal);
            const P = camera.position;
            const AP = vec3.sub(vec3.create(), P, A); //P-A;
            const AB = vec3.sub(vec3.create(), B, A); //B-A;
            const projPoint = vec3.add(vec3.create(), A, vec3.scale(AB, AB, vec3.dot(AP, AB) / vec3.dot(AB, AB)));
            planeNormal = vec3.sub(vec3.create(), projPoint, camera.position);
            vec3.normalize(planeNormal, planeNormal);
            if (this.#axis == ManipulatorAxis.XYZ) {
                vec3.transformQuat(planeNormal, vec3.fromValues(0, 0, 1), camera.quaternion);
            }
            /********************/
            lineIntersection(out, worldPos, planeNormal, this.#near, vec3.sub(vec3.create(), this.#far, this.#near));
            quat.invert(translationManipulatorTempQuat, this.getWorldQuaternion());
            vec3.transformQuat(out, out, translationManipulatorTempQuat);
            return out;
        }
    }
    #computeQuaternion(x, y) {
        const camera = this.camera;
        if (!camera) {
            return 0;
        }
        // transform the screen coordinates to normalized coordinates
        const normalizedX = (x / Graphics$1.getWidth()) * 2.0 - 1.0;
        const normalizedY = 1.0 - (y / Graphics$1.getHeight()) * 2.0;
        this.getWorldPosition(tempVec3$p);
        vec3.transformMat4(tempVec3$p, tempVec3$p, camera.cameraMatrix);
        vec3.transformMat4(tempVec3$p, tempVec3$p, camera.projectionMatrix);
        return Math.atan2(normalizedY - tempVec3$p[1], normalizedX - tempVec3$p[0]);
    }
    #computeQuaternion_removeme(x, y) {
        const camera = this.camera;
        if (camera) {
            const projectionMatrix = camera.projectionMatrix;
            const viewMatrix = camera.cameraMatrix;
            camera.nearPlane;
            camera.farPlane;
            camera.aspectRatio;
            const invProjectionMatrix = mat4.invert(mat4.create(), projectionMatrix);
            const invViewMatrix = mat4.invert(mat4.create(), viewMatrix);
            this.#cursorPos[0] = (x / Graphics$1.getWidth()) * 2.0 - 1.0;
            this.#cursorPos[1] = 1.0 - (y / Graphics$1.getHeight()) * 2.0;
            this.#near[0] = this.#far[0] = this.#cursorPos[0];
            this.#near[1] = this.#far[1] = this.#cursorPos[1];
            this.#near[2] = -1.0;
            this.#far[2] = 1.0;
            vec3.transformMat4(this.#near, this.#near, invProjectionMatrix);
            vec3.transformMat4(this.#far, this.#far, invProjectionMatrix);
            vec3.transformMat4(this.#near, this.#near, invViewMatrix);
            vec3.transformMat4(this.#far, this.#far, invViewMatrix);
            function lineIntersection(planePoint, planeNormal, linePoint, lineDirection) {
                if (vec3.dot(planeNormal, lineDirection) == 0) {
                    return vec3.create(); //TODO: optimize
                }
                const t = (vec3.dot(planeNormal, planePoint) - vec3.dot(planeNormal, linePoint)) / vec3.dot(planeNormal, lineDirection);
                return vec3.scaleAndAdd(vec3.create(), linePoint, lineDirection, t); //TODO: optimize pass vec3 as param
            }
            let v4;
            let planeNormal = vec3.create();
            if (this.#axisOrientation == ORIENTATION_WORLD) {
                switch (this.#axis) {
                    case ManipulatorAxis.X:
                        planeNormal = vec3.copy(planeNormal, xUnitVec3);
                        break;
                    case ManipulatorAxis.Y:
                        planeNormal = vec3.copy(planeNormal, yUnitVec3);
                        break;
                    case ManipulatorAxis.Z:
                        planeNormal = vec3.copy(planeNormal, zUnitVec3);
                        break;
                    default:
                        this.getPositionFrom(camera, planeNormal);
                        planeNormal = vec3.normalize(planeNormal, planeNormal);
                        break;
                }
            }
            else {
                switch (this.#axis) {
                    case ManipulatorAxis.X:
                        planeNormal = vec3.transformQuat(planeNormal, xUnitVec3, this.#startQuaternion);
                        break;
                    case ManipulatorAxis.Y:
                        planeNormal = vec3.transformQuat(planeNormal, yUnitVec3, this.#startQuaternion);
                        break;
                    case ManipulatorAxis.Z:
                        planeNormal = vec3.transformQuat(planeNormal, zUnitVec3, this.#startQuaternion);
                        break;
                    default:
                        planeNormal = vec3.sub(vec3.create() /*TODO: optimize*/, this.#far, this.#near);
                        break;
                }
            }
            const worldPos = this._parent ? this._parent.getWorldPosition() : this.getWorldPosition();
            v4 = lineIntersection(worldPos, planeNormal, this.#near, vec3.sub(vec3.create(), this.#far, this.#near));
            if (!v4) {
                return vec3.create(); //TODO: optimize
            }
            vec3.sub(v4, v4, worldPos);
            quat.invert(translationManipulatorTempQuat, this.#startQuaternion);
            vec3.transformQuat(v4, v4, translationManipulatorTempQuat);
            vec3.normalize(v4, v4);
            return v4;
        }
    }
    setCamera(camera) {
        this.camera = camera;
    }
    /**
     * @deprecated Please use `setMode` instead.
     */
    set mode(mode) {
        console.warn('deprecated, use setMode()');
        this.setMode(mode);
    }
    setMode(mode) {
        this.#translationManipulator.setVisible(false);
        this.#rotationManipulator.setVisible(false);
        this.#scaleManipulator.setVisible(false);
        this.#setAxisSelected(false);
        Graphics$1.dragging = false;
        this.#mode = mode;
        switch (mode) {
            case ManipulatorMode.Translation:
                this.#translationManipulator.setVisible(undefined);
                break;
            case ManipulatorMode.Rotation:
                this.#rotationManipulator.setVisible(undefined);
                break;
            case ManipulatorMode.Scale:
                this.#scaleManipulator.setVisible(undefined);
                break;
        }
        this.#setAxisSelected(false);
    }
    set axisOrientation(axisOrientation) {
        this.#axisOrientation = axisOrientation;
    }
    getWorldQuaternion(q = quat.create()) {
        if (this.#mode < ManipulatorMode.Scale) {
            switch (this.#axisOrientation) {
                case ORIENTATION_WORLD:
                    quat.identity(q);
                    break;
                default:
                    super.getWorldQuaternion(q);
            }
        }
        else {
            super.getWorldQuaternion(q);
        }
        /*if (this._parent !== null) {
            this._parent.getWorldQuaternion(q);
            quat.mul(q, q, this._quaternion);
        } else {
            quat.copy(q, this._quaternion);
        }*/
        return q;
    }
    getWorldScale(vec = vec3.create()) {
        return vec3.copy(vec, this._scale);
    }
    set enableX(enableX) {
        this.#enableX = enableX;
        const enable = enableX ? undefined : false;
        this.#xArrow.setVisible(enable);
        this.#xCircle.setVisible(enable);
        this.#xScale.setVisible(enable);
    }
    get enableX() {
        return this.#enableX;
    }
    set enableY(enableY) {
        this.#enableY = enableY;
        const enable = enableY ? undefined : false;
        this.#yArrow.setVisible(enable);
        this.#yCircle.setVisible(enable);
        this.#yScale.setVisible(enable);
    }
    get enableY() {
        return this.#enableY;
    }
    set enableZ(enableZ) {
        this.#enableZ = enableZ;
        const enable = enableZ ? undefined : false;
        this.#zArrow.setVisible(enable);
        this.#zCircle.setVisible(enable);
        this.#zScale.setVisible(enable);
    }
    get enableZ() {
        return this.#enableZ;
    }
    #setupAxis() {
        const camera = this.camera;
        if (!camera) {
            return;
        }
        this.getWorldQuaternion(translationManipulatorTempQuat);
        quat.invert(translationManipulatorTempQuat, translationManipulatorTempQuat);
        this.getPositionFrom(camera, tempVec3$p);
        vec3.normalize(tempVec3$p, tempVec3$p);
        vec3.transformQuat(tempVec3$p, tempVec3$p, translationManipulatorTempQuat);
        this.#circle.quaternion = quat.rotationTo(tempQuat$9, zUnitVec3, tempVec3$p);
        this.#viewCircle.quaternion = tempQuat$9;
        this.#xCircle.quaternion = quat.setAxisAngle(tempQuat$9, xUnitVec3, Math.atan2(tempVec3$p[1], -tempVec3$p[2]));
        this.#yCircle.quaternion = quat.setAxisAngle(tempQuat$9, yUnitVec3, Math.atan2(tempVec3$p[0], tempVec3$p[2]));
        this.#zCircle.quaternion = quat.setAxisAngle(tempQuat$9, zUnitVec3, Math.atan2(tempVec3$p[1], tempVec3$p[0]));
        this.#xCircle.rotateY(HALF_PI);
        this.#yCircle.rotateX(-HALF_PI);
    }
}
//Set default shortcuts
ShortcutHandler.setShortcuts('3dview,scene-explorer', new Map([
    [MANIPULATOR_SHORTCUT_INCREASE, 'PLUS'],
    [MANIPULATOR_SHORTCUT_DECREASE, '-'],
    [MANIPULATOR_SHORTCUT_TRANSLATION, 'ALT+T'],
    [MANIPULATOR_SHORTCUT_ROTATION, 'ALT+R'],
    [MANIPULATOR_SHORTCUT_SCALE, 'ALT+S'],
    [MANIPULATOR_SHORTCUT_AXIS_ORIENTATION, 'ALT+O'],
    [MANIPULATOR_SHORTCUT_TOGGLE_X, 'ALT+X'],
    [MANIPULATOR_SHORTCUT_TOGGLE_Y, 'ALT+Y'],
    [MANIPULATOR_SHORTCUT_TOGGLE_Z, 'ALT+Z'],
]));

class KeepOnlyLastChild extends Entity {
    addChild(child) {
        if (!(child instanceof Manipulator)) {
            this.removeChildren();
        }
        return super.addChild(child);
    }
    static getEntityName() {
        return 'Keep only last child';
    }
}
registerEntity(KeepOnlyLastChild);

function quatToEuler(out, q) {
    const test = q[0] * q[3] - q[1] * q[2];
    if (test > 0.5 - EPSILON$2) { // singularity at north pole
        out[1] = 2 * Math.atan2(q[1], q[0]);
        out[0] = Math.PI / 2;
        out[3] = 0;
        return out;
    }
    if (test < -0.5 + EPSILON$2) { // singularity at south pole
        out[1] = -2 * Math.atan2(q[1], q[0]);
        out[0] = -Math.PI / 2;
        out[2] = 0;
        return out;
    }
    // roll (x-axis rotation)
    const sinr_cosp = 2 * (q[3] * q[0] + q[1] * q[2]);
    const cosr_cosp = 1 - 2 * (q[0] * q[0] + q[1] * q[1]);
    out[0] = Math.atan2(sinr_cosp, cosr_cosp);
    // pitch (y-axis rotation)
    const sinp = Math.sqrt(1 + 2 * (q[3] * q[1] - q[0] * q[2]));
    const cosp = Math.sqrt(1 - 2 * (q[3] * q[1] - q[0] * q[2]));
    out[1] = 2 * Math.atan2(sinp, cosp) - Math.PI / 2;
    // yaw (z-axis rotation)
    const siny_cosp = 2 * (q[3] * q[2] + q[0] * q[1]);
    const cosy_cosp = 1 - 2 * (q[1] * q[1] + q[2] * q[2]);
    out[2] = Math.atan2(siny_cosp, cosy_cosp);
    return out;
}
function quatToEulerDeg(out, q) {
    quatToEuler(out, q);
    out[0] = RAD_TO_DEG * out[0];
    out[1] = RAD_TO_DEG * out[1];
    out[2] = RAD_TO_DEG * out[2];
    return out;
}
function QuaternionIdentityBlend(p, t, qt) {
    let sclp;
    sclp = 1.0 - t;
    qt[0] = p[0] * sclp;
    qt[1] = p[1] * sclp;
    qt[2] = p[2] * sclp;
    if (qt[3] < 0.0) {
        qt[3] = p[3] * sclp - t;
    }
    else {
        qt[3] = p[3] * sclp + t;
    }
    quat.normalize(qt, qt);
}

const ROTATE_Z = quat.create();
quat.rotateX(ROTATE_Z, ROTATE_Z, -HALF_PI);
const tempMat4$3 = mat4.create();
async function exportToBinaryFBX(entity) {
    const fbxManager = new FBXManager();
    const fbxFile = fbxSceneToFBXFile(await entityToFBXScene(fbxManager, entity));
    return new FBXExporter().exportBinary(fbxFile);
}
async function entityToFBXScene(fbxManager, entity) {
    const fbxScene = fbxManager.createObject('FBXScene', 'Scene');
    const playing = Graphics$1.isRunning();
    Graphics$1.pause();
    await createFBXSceneEntity(fbxScene, entity);
    if (playing) {
        Graphics$1.play();
    }
    return fbxScene;
}
async function createFBXSceneEntity(fbxScene, entity, context = {
    exportedBones: new Map(), animStackPerEntity: new Map(), animLayerPerEntity: new Map(),
}) {
    switch (true) {
        case entity.isSource1ModelInstance:
            await createSource1ModelInstance(fbxScene, entity, context);
            break;
        case entity.is('Mesh'):
            await createFBXMesh(fbxScene, entity, context);
            break;
        case entity.is('Camera'):
            await createFBXCamera(fbxScene, entity);
            break;
    }
    await createChildEntities(fbxScene, entity, context);
}
async function createChildEntities(fbxScene, entity, context) {
    for (const childEntity of entity.children) {
        await createFBXSceneEntity(fbxScene, childEntity, context);
    }
}
async function createSource1ModelInstance(fbxScene, entity, context) {
    const fbxManager = fbxScene.manager;
    let animStack;
    let animLayer;
    animStack = context.animStackPerEntity.get(entity.parent);
    animLayer = context.animLayerPerEntity.get(entity.parent);
    if (!animStack) {
        animStack = fbxManager.createObject('FBXAnimStack', 'test FBXAnimStack');
        fbxScene.addObject(animStack);
        context.animStackPerEntity.set(entity, animStack);
        animLayer = fbxManager.createObject('FBXAnimLayer', 'test FBXAnimLayer');
        animStack.add(animLayer);
    }
    const exportedBones = context.exportedBones;
    if (entity /*TODO: create a skeleton entity interface*/.skeleton) {
        const bones = entity /*TODO: create a skeleton entity interface*/.skeleton.bones;
        for (const bone of bones) {
            exportedBones.get(bone);
        }
    }
}
async function createFBXMesh(fbxScene, mesh, context) {
    const fbxManager = fbxScene.manager;
    const meshPose = fbxManager.createObject('FBXPose', 'Pose ' + mesh.name);
    fbxScene.addObject(meshPose);
    if (!mesh.exportObj || !mesh.isVisible() || !mesh.is('Mesh') || mesh.parent /*TODO: create a particle entity interface*/?.isParticleSystem) {
        return;
    }
    const fbxMeshNode = fbxManager.createObject('FBXNode', mesh.name);
    fbxMeshNode.localRotation.value = quatToEulerDeg([0, 0, 0], quat.mul(quat.create(), ROTATE_Z, mesh.getWorldQuaternion()));
    fbxMeshNode.localTranslation.value = vec3.transformQuat(vec3.create(), mesh.getWorldPosition(), ROTATE_Z);
    fbxMeshNode.localScaling.value = mesh.getWorldScale();
    const fbxMaterial = fbxManager.createObject('FBXSurfacePhong', 'FBXSurfacePhong');
    fbxMaterial.name = 'mat_' + fbxMaterial.id + '.png';
    const fbxMesh = fbxManager.createObject('FBXMesh', 'Name me FBXMesh');
    fbxMeshNode.nodeAttribute = fbxMesh;
    fbxMeshNode.addMaterial(fbxMaterial);
    fbxScene.rootNode.addChild(fbxMeshNode);
    const meshMaterial = mesh.material;
    //console.log(meshMaterial);
    if (meshMaterial) {
        await configureMaterial(meshMaterial, fbxMaterial, mesh.materialsParams);
    }
    let meshDatas = mesh.exportObj();
    if (mesh /*TODO: create a skeleton entity interface*/.skeleton && mesh.geometry) {
        meshDatas = {
            f: mesh.geometry.getAttribute('index')?._array,
            v: mesh.geometry.getAttribute('aVertexPosition')?._array,
            vn: mesh.geometry.getAttribute('aVertexNormal')?._array,
            vt: mesh.geometry.getAttribute('aTextureCoord')?._array,
            bi: mesh.geometry.getAttribute('aBoneIndices')?._array,
            bw: mesh.geometry.getAttribute('aBoneWeight')?._array,
        };
        meshDatas.bi;
        meshDatas.bw;
    }
    const boneIndexes = new Map();
    const boneWeights = new Map();
    const polygons = [];
    const edges = [];
    const uvIndex = [];
    const vertexIndices = meshDatas.f;
    if (!vertexIndices) {
        return;
    }
    let vertexIndex1;
    let vertexIndex2;
    let vertexIndex3;
    const remappedIndex = new Map();
    let currentIndex = 0;
    const remappedVertices = [];
    const remappedNormals = [];
    const remappedUV = [];
    const remappedBoneIndices = [];
    const remappedBoneWeight = [];
    const bonesPerVertex = mesh.bonesPerVertex;
    function remapIndex(index) {
        if (remappedIndex.has(index)) {
            return remappedIndex.get(index);
        }
        const newIndex = currentIndex++;
        remappedIndex.set(index, newIndex);
        const vIndex = index * 3;
        const uvIndex = index * 2;
        if (meshDatas.v) {
            remappedVertices.push(meshDatas.v[vIndex], meshDatas.v[vIndex + 1], meshDatas.v[vIndex + 2]);
        }
        if (meshDatas.vn) {
            remappedNormals.push(meshDatas.vn[vIndex], meshDatas.vn[vIndex + 1], meshDatas.vn[vIndex + 2]);
        }
        if (meshDatas.vt) {
            remappedUV.push(meshDatas.vt[uvIndex], meshDatas.vt[uvIndex + 1]);
        }
        {
            const boneIndex = index * bonesPerVertex;
            if (meshDatas.bi) {
                for (let j = 0; j < bonesPerVertex; ++j) {
                    remappedBoneIndices.push(meshDatas.bi[boneIndex + j]);
                    remappedBoneWeight.push(meshDatas.bw[boneIndex + j]);
                }
            }
        }
        return newIndex;
    }
    for (let i = 0, j = 0, l = vertexIndices.length; i < l; i += 3, j += 2) {
        vertexIndex1 = remapIndex(vertexIndices[i]) ?? 0;
        vertexIndex2 = remapIndex(vertexIndices[i + 1]) ?? 0;
        vertexIndex3 = remapIndex(vertexIndices[i + 2]) ?? 0;
        polygons.push(vertexIndex1, vertexIndex2, ~vertexIndex3);
        uvIndex.push(vertexIndex1, vertexIndex2, vertexIndex3);
        edges.push(vertexIndex1, vertexIndex2, vertexIndex3);
    }
    {
        for (let vertexIndex = 0, l = remappedBoneIndices.length / bonesPerVertex; vertexIndex < l; ++vertexIndex) {
            for (let j = 0; j < bonesPerVertex; ++j) {
                const k = vertexIndex * bonesPerVertex + j;
                const boneIndex = remappedBoneIndices[k];
                const boneWeight = remappedBoneWeight[k];
                if (boneWeight != 0) {
                    if (!boneIndexes.has(boneIndex)) {
                        boneIndexes.set(boneIndex, []);
                        boneWeights.set(boneIndex, []);
                    }
                    boneIndexes.get(boneIndex)?.push(vertexIndex);
                    boneWeights.get(boneIndex)?.push(boneWeight);
                }
            }
        }
    }
    console.log(boneIndexes, boneWeights);
    fbxMesh.vertices = remappedVertices;
    fbxMesh.normals = remappedNormals;
    fbxMesh.polygons = polygons;
    fbxMesh.edges = edges;
    fbxMesh.uv = remappedUV;
    fbxMesh.uvIndex = uvIndex;
    //let attributes = {f:'index',v:'aVertexPosition',vn:'aVertexNormal',vt:'aTextureCoord'};
    /*let fbxModel = new FBXModel(fbxMesh, fbxMaterial);
    fbxModel.name = mesh.name;*/
    //fbxFile.addModel(fbxModel);
    if (mesh /*TODO: create a skeleton entity interface*/.skeleton) {
        const boneDatas = { bi: boneIndexes, bw: boneWeights };
        //for (let i = 0; i < )
        {
            exportSkeleton(fbxScene, mesh /*TODO: create a skeleton entity interface*/.skeleton, context, fbxMesh, boneDatas, meshPose);
        }
    }
}
async function createFBXCamera(fbxScene, camera) {
    const fbxManager = fbxScene.manager;
    console.log(camera);
    const fbxCameraNode = fbxManager.createObject('FBXNode', camera.name);
    const fbxCamera = fbxManager.createObject('FBXCamera', camera.name);
    fbxCameraNode.nodeAttribute = fbxCamera;
    //fbxCamera.position.value = camera.position;
    fbxCameraNode.localTranslation.value = camera.position;
    quatToEulerDeg([0, 0, 0], camera.quaternion);
    //fbxCameraNode.localRotation.value = angles;
    fbxCameraNode.parent = fbxScene.rootNode; //TODO: set the actual parent
}
//NodeAttribute -> Model -> cluster (subdeformer) -> skin(deformer) -> geometry
//38772576 -> 39350848 -> 49570336 -> 49569504 -> 39673840 samba dancing
function exportSkeleton(fbxScene, skeleton, context, fbxMesh, boneDatas, meshPose) {
    const fbxManager = fbxScene.manager;
    const fbxSkin = fbxManager.createObject('FBXSkin', skeleton.name);
    const exportedClusters = new WeakMap();
    fbxSkin.geometry = fbxMesh;
    for (const bone of skeleton.bones) {
        exportBone(fbxScene, bone, context, exportedClusters, fbxSkin, boneDatas, meshPose);
    }
}
function exportBone(fbxScene, bone, context, exportedClusters, fbxSkin, boneDatas, meshPose) {
    const fbxManager = fbxScene.manager;
    const boneParent = bone.parent ?? bone.skeleton;
    const boneParentSkeletonBone = bone.parentSkeletonBone;
    if (boneParent) {
        if (boneParent.isBone) {
            // Ensure the parent is already exported
            exportBone(fbxScene, boneParent, context, exportedClusters, fbxSkin, boneDatas, meshPose);
        }
    }
    // Export this very bone
    const exportedBones = context.exportedBones;
    let fbxBone = exportedBones.get(bone);
    if (fbxBone) ;
    else {
        if (boneParentSkeletonBone) {
            fbxBone = exportedBones.get(boneParentSkeletonBone);
        }
        if (fbxBone) {
            exportedBones.set(bone, fbxBone);
        }
        else {
            fbxBone = fbxManager.createObject('FBXNode', bone.name);
            const angles = vec3.create();
            const transformedQuat = quat.create();
            const transformedVec = vec3.create();
            if (boneParentSkeletonBone) {
                if (boneParent.isSkeleton) {
                    fbxBone.localTranslation.value = vec3.transformQuat(transformedVec, boneParentSkeletonBone.worldPos, ROTATE_Z);
                    quat.mul(transformedQuat, ROTATE_Z, boneParentSkeletonBone.worldQuat);
                    quatToEulerDeg(angles, transformedQuat);
                }
                else {
                    fbxBone.localTranslation.value = boneParentSkeletonBone.position;
                    quatToEulerDeg(angles, boneParentSkeletonBone.quaternion);
                }
            }
            else {
                if (boneParent.isSkeleton) {
                    fbxBone.localTranslation.value = vec3.transformQuat(transformedVec, bone.worldPos, ROTATE_Z);
                    quat.mul(transformedQuat, ROTATE_Z, bone.worldQuat);
                    quatToEulerDeg(angles, transformedQuat);
                }
                else {
                    fbxBone.localTranslation.value = bone.position;
                    quatToEulerDeg(angles, bone.quaternion);
                }
            }
            meshPose.add(fbxBone, bone.boneMat, true);
            fbxBone.localRotation.value = angles;
            const fbxLimb = fbxManager.createObject('FBXSkeleton', 'Name me FBXSkeleton', FBX_SKELETON_TYPE_LIMB);
            fbxBone.nodeAttribute = fbxLimb;
            fbxBone.parent = exportedBones.get(boneParent) ?? fbxScene.rootNode;
            exportedBones.set(bone, fbxBone);
        }
    }
    if (!exportedClusters.has(bone)) {
        const fbxCluster = fbxManager.createObject('FBXCluster', bone.name);
        fbxCluster.transformMatrix = bone.poseToBone;
        fbxCluster.transformLinkMatrix = mat4.invert(tempMat4$3, bone.poseToBone);
        fbxCluster.link = fbxBone;
        const boneIndices = boneDatas.bi.get(bone.boneId);
        const boneWeights = boneDatas.bw.get(bone.boneId);
        if (boneIndices && boneWeights) {
            for (let i = 0; i < boneIndices.length; ++i) {
                fbxCluster.addVertexIndex(boneIndices[i], boneWeights[i]);
            }
        }
        fbxSkin.addCluster(fbxCluster);
        exportedClusters.set(bone, fbxCluster);
    }
}
/*
export async function entitytoFBXFile(entity) {
    let playing = Graphics.isRunning();
    Graphics.pause();
    let fbxFile = createEmptyFile();
    fbxFile.version = 7400;

    let meshes = entity.getMeshList();

    for (let mesh of meshes) {
        if (!mesh.exportObj || !mesh.visible || !mesh.is('Mesh') || mesh.parent?.isParticleSystem) {
            continue;
        }

        let fbxMaterial = new FBXMaterial();
        fbxMaterial.name = 'mat_' + fbxMaterial.id + '.png';
        let fbxGeometry = new FBXGeometry();
        let meshMaterial = mesh.material;
        //console.log(meshMaterial);
        if (meshMaterial) {
            await configureMaterial(meshMaterial, fbxMaterial, mesh.materialsParams);
        }

        let meshDatas = mesh.exportObj();

        let polygons = [];
        let edges = [];
        let uvIndex = [];
        let uv = [];

        let vertexIndices = meshDatas.f;
        let vertexIndex1;
        let vertexIndex2;
        let vertexIndex3;
        let remappedIndex = new Map();
        let currentIndex = 0;
        let remappedVertices = [];
        let remappedNormals = [];
        let remappedUV = [];
        function remapIndex(index) {
            if (remappedIndex.has(index)) {
                return remappedIndex.get(index);
            }

            let newIndex = currentIndex++;
            remappedIndex.set(index, newIndex);

            let vIndex = index * 3;
            let uvIndex = index * 2;
            remappedVertices.push(meshDatas.v[vIndex], meshDatas.v[vIndex + 1], meshDatas.v[vIndex + 2]);
            remappedNormals.push(meshDatas.vn[vIndex], meshDatas.vn[vIndex + 1], meshDatas.vn[vIndex + 2]);
            remappedUV.push(meshDatas.vt[uvIndex], meshDatas.vt[uvIndex + 1]);

            return newIndex;
        }

        for (let i = 0, j = 0, l = vertexIndices.length; i < l; i += 3, j += 2) {
            vertexIndex1 = remapIndex(vertexIndices[i]);
            vertexIndex2 = remapIndex(vertexIndices[i + 1]);
            vertexIndex3 = remapIndex(vertexIndices[i + 2]);
            polygons.push(vertexIndex1, vertexIndex2, ~vertexIndex3);
            uvIndex.push(vertexIndex1, vertexIndex2, vertexIndex3);
            edges.push(vertexIndex1, vertexIndex2, vertexIndex3);
        }

        fbxGeometry.vertices = remappedVertices;
        fbxGeometry.normals = remappedNormals;
        fbxGeometry.polygons = polygons;
        fbxGeometry.edges = edges;
        fbxGeometry.uv = remappedUV;
        fbxGeometry.uvIndex = uvIndex;

        //let attributes = {f:'index',v:'aVertexPosition',vn:'aVertexNormal',vt:'aTextureCoord'};

        let fbxModel = new FBXModel(fbxGeometry, fbxMaterial);
        fbxModel.name = mesh.name;
        fbxFile.addModel(fbxModel);
    }

    if (playing) {
        Graphics.play();
    }

    return fbxFile;
}
*/
async function configureMaterial(material, fbxMaterial, materialsParams) {
    const fbxManager = fbxMaterial.manager;
    if (material.uniforms['colorMap']) {
        const fbxTexture = fbxManager.createObject('FBXTexture', 'DiffuseColor');
        const fbxVideo = fbxManager.createObject('FBXVideo', 'FBXVideo');
        //fbxTexture.fbxMapping = 'DiffuseColor'; TODO ?????
        fbxTexture.media = fbxVideo;
        fbxTexture.name = 'mat_' + fbxTexture.id + '.png';
        fbxVideo.name = 'mat_' + fbxVideo.id + '.png';
        const renderResult = await renderMaterial(material, materialsParams, RenderMode$1.Color);
        if (renderResult) {
            fbxVideo.content = new Uint8Array(renderResult);
        }
        //fbxMaterial.addTexture(fbxTexture);
        fbxMaterial.diffuse.connectSrcObject(fbxTexture);
    }
    if (material.uniforms['colorMap']) {
        const fbxTexture = fbxManager.createObject('FBXTexture', 'DiffuseColor');
        const fbxVideo = fbxManager.createObject('FBXVideo', 'FBXVideo');
        //fbxTexture.fbxMapping = 'DiffuseColor'; TODO ?????
        fbxTexture.media = fbxVideo;
        fbxTexture.name = 'mat_' + fbxTexture.id + '.png';
        fbxVideo.name = 'mat_' + fbxVideo.id + '.png';
        const renderResult = await renderMaterial(material, materialsParams, RenderMode$1.Normal);
        if (renderResult) {
            fbxVideo.content = new Uint8Array(renderResult);
        }
        // TODO: create a helper function in harmony-fbx
        fbxMaterial.normalMap = fbxMaterial.createProperty(FBX_PROPERTY_TYPE_COLOR_3, 'NormalMap', [0.2, 0.2, 0.2], FBX_PROPERTY_FLAG_STATIC);
        fbxMaterial.normalMap.connectSrcObject(fbxTexture);
        //fbxMaterial.createProperty(FBX_PROPERTY_TYPE_DOUBLE, 'BumpFactor', 1, FBX_PROPERTY_FLAG_STATIC);
    }
}
let scene$1;
let camera$1;
let fullScreenQuadMesh;
var RenderMode$1;
(function (RenderMode) {
    RenderMode[RenderMode["Color"] = 0] = "Color";
    RenderMode[RenderMode["Normal"] = 1] = "Normal";
})(RenderMode$1 || (RenderMode$1 = {}));
async function renderMaterial(material, materialsParams, renderMode) {
    if (!scene$1) {
        scene$1 = new Scene();
        camera$1 = new Camera();
        camera$1.position = [0, 0, 100];
        fullScreenQuadMesh = new FullScreenQuad();
        scene$1.addChild(fullScreenQuadMesh);
    }
    const [previousWidth, previousHeight] = Graphics$1.setSize(1024, 1024); //TODOv3: constant
    const previousClearColor = Graphics$1.getClearColor();
    Graphics$1.clearColor(vec4.fromValues(0, 0, 0, 0));
    Graphics$1.setIncludeCode('EXPORT_TEXTURES', '#define EXPORT_TEXTURES');
    Graphics$1.setIncludeCode('SKIP_PROJECTION', '#define SKIP_PROJECTION');
    Graphics$1.setIncludeCode('SKIP_LIGHTING', '#define SKIP_LIGHTING');
    switch (renderMode) {
        case RenderMode$1.Normal:
            Graphics$1.setIncludeCode('RENDER_MODE', '#define RENDER_MODE 12');
            break;
    }
    fullScreenQuadMesh.material = material;
    fullScreenQuadMesh.materialsParams = materialsParams;
    Graphics$1.render(scene$1, camera$1, 0, { DisableToolRendering: true });
    const imgContent = await Graphics$1.toBlob();
    Graphics$1.setIncludeCode('EXPORT_TEXTURES', '');
    Graphics$1.setIncludeCode('SKIP_PROJECTION', '');
    Graphics$1.setIncludeCode('SKIP_LIGHTING', '');
    Graphics$1.removeIncludeCode('RENDER_MODE');
    Graphics$1.setSize(previousWidth, previousHeight);
    Graphics$1.clearColor(previousClearColor);
    return imgContent?.arrayBuffer() ?? null;
}

const RECORDER_MIME_TYPE = 'video/webm';
const RECORDER_DEFAULT_FILENAME = 'Harmony3D recording.webm';
// Note : you can provide your own url when calling ShaderEditor.initEditor.
const ACE_EDITOR_URI = 'https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/ace.js';
const MAX_HARDWARE_BONES = 256;
const TEXTURE_CLEANUP_DELAY = 100000;
const SMD_HEADER = '// Created by harmony-3d';

class WebGLRenderingState {
    static #viewport = vec4.create();
    static #scissor = vec4.create();
    static #enabledCapabilities = [];
    // clear values
    static #clearColor = vec4.create();
    static #clearDepth = 1.0;
    static #clearStencil = 0;
    // Masking
    static #colorMask = vec4.create();
    static #depthMask = true;
    static #stencilMask;
    // Depth
    static #depthFunc = GL_LESS;
    // Blend
    static #sourceFactor = GL_ONE;
    static #destinationFactor = GL_ZERO;
    static #srcRGB = GL_ONE;
    static #dstRGB = GL_ZERO;
    static #srcAlpha = GL_ONE;
    static #dstAlpha = GL_ZERO;
    static #modeRGB = GL_FUNC_ADD;
    static #modeAlpha = GL_FUNC_ADD;
    // Cull
    static #cullFace = GL_BACK;
    static #frontFace = GL_CCW;
    //polygonOffset
    static #polygonOffsetFactor = 0;
    static #polygonOffsetUnits = 0;
    static #lineWidth = 1;
    static #program;
    static #glContext;
    static #enabledVertexAttribArray;
    static #usedVertexAttribArray;
    static #vertexAttribDivisor;
    static setGraphics() {
        this.#glContext = Graphics$1.glContext;
        const maxVertexAttribs = this.#glContext.getParameter(GL_MAX_VERTEX_ATTRIBS);
        this.#enabledVertexAttribArray = new Uint8Array(maxVertexAttribs);
        this.#usedVertexAttribArray = new Uint8Array(maxVertexAttribs);
        this.#vertexAttribDivisor = new Uint8Array(maxVertexAttribs);
    }
    static clearColor(clearColor) {
        if (!vec4.exactEquals(clearColor, this.#clearColor)) {
            this.#glContext.clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
            vec4.copy(this.#clearColor, clearColor);
        }
    }
    static getClearColor(out = vec4.create()) {
        return vec4.copy(out, this.#clearColor);
    }
    static clearDepth(clearDepth) {
        if (clearDepth !== this.#clearDepth) {
            this.#glContext.clearDepth(clearDepth);
            this.#clearDepth = clearDepth;
        }
    }
    static clearStencil(clearStencil) {
        if (clearStencil !== this.#clearStencil) {
            this.#glContext.clearStencil(clearStencil);
            this.#clearStencil = clearStencil;
        }
    }
    static clear(color, depth, stencil) {
        let bits = 0;
        if (color)
            bits |= GL_COLOR_BUFFER_BIT;
        if (depth)
            bits |= GL_DEPTH_BUFFER_BIT;
        if (stencil)
            bits |= GL_STENCIL_BUFFER_BIT;
        this.#glContext.clear(bits);
    }
    static colorMask(colorMask) {
        if (!vec4.exactEquals(colorMask, this.#colorMask)) {
            this.#glContext.colorMask(Boolean(colorMask[0]), Boolean(colorMask[1]), Boolean(colorMask[2]), Boolean(colorMask[3]));
            vec4.copy(this.#colorMask, colorMask);
        }
    }
    static depthMask(flag) {
        if (flag !== this.#depthMask) {
            this.#glContext.depthMask(flag);
            this.#depthMask = flag;
        }
    }
    static stencilMask(stencilMask) {
        if (stencilMask !== this.#stencilMask) {
            this.#glContext.stencilMask(stencilMask);
            this.#stencilMask = stencilMask;
        }
    }
    static lineWidth(width) {
        if (width !== this.#lineWidth) {
            this.#glContext.lineWidth(width);
            this.#lineWidth = width;
        }
    }
    static viewport(viewport) {
        if (!vec4.exactEquals(viewport, this.#viewport)) {
            this.#glContext.viewport(viewport[0], viewport[1], viewport[2], viewport[3]);
            vec4.copy(this.#viewport, viewport);
        }
    }
    static scissor(scissor) {
        if (!vec4.exactEquals(scissor, this.#scissor)) {
            this.#glContext.scissor(scissor[0], scissor[1], scissor[2], scissor[3]);
            vec4.copy(this.#scissor, scissor);
        }
    }
    static enable(cap) {
        if (this.#enabledCapabilities[cap] !== true) {
            this.#glContext.enable(cap);
            this.#enabledCapabilities[cap] = true;
        }
    }
    static disable(cap) {
        if (this.#enabledCapabilities[cap] !== false) {
            this.#glContext.disable(cap);
            this.#enabledCapabilities[cap] = false;
        }
    }
    static isEnabled(cap) {
        return this.#enabledCapabilities[cap] ?? this.#glContext.isEnabled(cap);
    }
    static useProgram(program) {
        if (this.#program !== program) {
            this.#glContext.useProgram(program);
            this.#program = program;
        }
    }
    static enableVertexAttribArray(index, divisor = 0) {
        if (this.#enabledVertexAttribArray[index] === 0) {
            this.#glContext.enableVertexAttribArray(index);
            this.#enabledVertexAttribArray[index] = 1;
        }
        this.#usedVertexAttribArray[index] = 1;
        if (this.#vertexAttribDivisor[index] !== divisor) {
            this.#vertexAttribDivisor[index] = divisor;
            if (Graphics$1.isWebGL2) {
                this.#glContext.vertexAttribDivisor(index, divisor);
            }
            else {
                Graphics$1.ANGLE_instanced_arrays?.vertexAttribDivisorANGLE(index, divisor);
            }
        }
    }
    static initUsedAttributes() {
        const usedAttributes = this.#usedVertexAttribArray;
        for (let i = 0, l = usedAttributes.length; i < l; i++) {
            usedAttributes[i] = 0;
        }
    }
    static disableUnusedAttributes() {
        const usedAttributes = this.#usedVertexAttribArray;
        const enabledAttributes = this.#enabledVertexAttribArray;
        for (let i = 0, l = usedAttributes.length; i < l; i++) {
            if (usedAttributes[i] !== enabledAttributes[i]) {
                this.#glContext.disableVertexAttribArray(i);
                enabledAttributes[i] = 0;
            }
        }
    }
    static depthFunc(func) {
        if (this.#depthFunc !== func) {
            this.#glContext.depthFunc(func);
            this.#depthFunc = func;
        }
    }
    static blendFunc(sourceFactor, destinationFactor) {
        if ((this.#sourceFactor !== sourceFactor) || (this.#destinationFactor !== destinationFactor)) {
            this.#glContext.blendFunc(sourceFactor, destinationFactor);
            this.#sourceFactor = sourceFactor;
            this.#destinationFactor = destinationFactor;
        }
    }
    static blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha) {
        if ((this.#srcRGB !== srcRGB) || (this.#dstRGB !== dstRGB) || (this.#srcAlpha !== srcAlpha) || (this.#dstAlpha !== dstAlpha)) {
            this.#glContext.blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
            this.#srcRGB = srcRGB;
            this.#dstRGB = dstRGB;
            this.#srcAlpha = srcAlpha;
            this.#dstAlpha = dstAlpha;
        }
    }
    static blendEquationSeparate(modeRGB, modeAlpha) {
        if ((this.#modeRGB !== modeRGB) || (this.#modeAlpha !== modeAlpha)) {
            this.#glContext.blendEquationSeparate(modeRGB, modeAlpha);
            this.#modeRGB = modeRGB;
            this.#modeAlpha = modeAlpha;
        }
    }
    static cullFace(mode) {
        if (this.#cullFace !== mode) {
            this.#glContext.cullFace(mode);
            this.#cullFace = mode;
        }
    }
    static frontFace(mode) {
        if (this.#frontFace !== mode) {
            this.#glContext.frontFace(mode);
            this.#frontFace = mode;
        }
    }
    static polygonOffset(enable, factor, units) {
        if (enable) {
            this.enable(GL_POLYGON_OFFSET_FILL);
            if (this.#polygonOffsetFactor !== factor && this.#polygonOffsetUnits !== units) {
                this.#glContext.polygonOffset(factor, units);
                this.#polygonOffsetFactor = factor;
                this.#polygonOffsetUnits = units;
            }
        }
        else {
            this.disable(GL_POLYGON_OFFSET_FILL);
        }
    }
}

const CLEAR_COLOR = vec4.fromValues(1, 0, 1, 1);
const a$8 = vec4.create();
const mapSize = vec2.create();
const lightPos = vec3.create();
const viewPort = vec4.create();
class ShadowMap {
    #glContext;
    constructor() {
        this.#glContext = Graphics$1.glContext;
    }
    render(renderer, renderList, camera, context) {
        const lights = renderList.lights;
        const blendCapability = WebGLRenderingState.isEnabled(GL_BLEND);
        const scissorCapability = WebGLRenderingState.isEnabled(GL_SCISSOR_TEST);
        const depthCapability = WebGLRenderingState.isEnabled(GL_DEPTH_TEST);
        WebGLRenderingState.getClearColor(a$8);
        WebGLRenderingState.disable(GL_BLEND);
        WebGLRenderingState.disable(GL_SCISSOR_TEST);
        WebGLRenderingState.enable(GL_DEPTH_TEST);
        WebGLRenderingState.clearColor(CLEAR_COLOR);
        Graphics$1.setIncludeCode('WRITE_DEPTH_TO_COLOR', '#define WRITE_DEPTH_TO_COLOR');
        let renderTarget;
        let shadowViewport;
        for (const light of lights) {
            if (light.castShadow) {
                const shadow = light.shadow;
                if (shadow) {
                    light.getWorldPosition(lightPos);
                    renderTarget = shadow.renderTarget;
                    vec2.copy(mapSize, shadow.textureSize);
                    Graphics$1.pushRenderTarget(renderTarget);
                    WebGLRenderingState.clear(true, true, true);
                    Graphics$1.setIncludeCode('IS_POINT_LIGHT', light.isPointLight ? '#define IS_POINT_LIGHT' : '');
                    for (let viewPortIndex = 0; viewPortIndex < shadow.viewPortsLength; ++viewPortIndex) {
                        shadowViewport = shadow.viewPorts[viewPortIndex];
                        vec4.set(viewPort, mapSize[0] * shadowViewport[0], mapSize[1] * shadowViewport[1], mapSize[0] * shadowViewport[2], mapSize[1] * shadowViewport[3]);
                        shadow.computeShadowMatrix(viewPortIndex);
                        Graphics$1.viewport = viewPort;
                        renderer._renderRenderList(renderList, shadow.camera, false, context, lightPos);
                    }
                    Graphics$1.popRenderTarget();
                }
            }
        }
        blendCapability ? WebGLRenderingState.enable(GL_BLEND) : WebGLRenderingState.disable(GL_BLEND);
        scissorCapability ? WebGLRenderingState.enable(GL_SCISSOR_TEST) : WebGLRenderingState.disable(GL_SCISSOR_TEST);
        depthCapability ? WebGLRenderingState.enable(GL_DEPTH_TEST) : WebGLRenderingState.disable(GL_DEPTH_TEST);
        WebGLRenderingState.clearColor(a$8);
        Graphics$1.setIncludeCode('WRITE_DEPTH_TO_COLOR', '');
    }
}

class WebGLStats {
    static #frames = 0;
    static #totalFrames = 0;
    static #fps = 0;
    static #drawElements = 0;
    static #renderTime = 0;
    static #renderTimeMean = 0;
    static #textures = 0;
    static #startTime = 0;
    static #endTime = 0;
    static #startRender = 0;
    static #primitivePerMode = new Map();
    static #htmlElement;
    static {
        this.#initHtml();
        this.#reset();
    }
    static start() {
        this.#startTime = performance.now();
    }
    static beginRender() {
        this.#startRender = performance.now();
    }
    static endRender() {
        this.#renderTime += performance.now() - this.#startRender;
    }
    static #reset() {
        this.#drawElements = 0;
        this.#primitivePerMode.set(GL_POINTS, 0);
        this.#primitivePerMode.set(GL_LINE_STRIP, 0);
        this.#primitivePerMode.set(GL_LINE_LOOP, 0);
        this.#primitivePerMode.set(GL_LINES, 0);
        this.#primitivePerMode.set(GL_TRIANGLE_STRIP, 0);
        this.#primitivePerMode.set(GL_TRIANGLE_FAN, 0);
        this.#primitivePerMode.set(GL_TRIANGLES, 0);
    }
    static tick() {
        this.#endTime = performance.now();
        ++this.#frames;
        const timeSinceReset = this.#endTime - this.#startTime;
        this.#updateHtml();
        if (timeSinceReset > 1000) {
            this.#fps = Math.round(this.#frames / timeSinceReset * 1000);
            this.#renderTimeMean = this.#renderTime / this.#frames;
            this.#frames = 0;
            this.#startTime = this.#endTime;
            this.#renderTime = 0;
        }
        this.#reset();
    }
    static drawElements(mode, count) {
        this.#primitivePerMode.set(mode, count + (this.#primitivePerMode.get(mode) ?? 0));
        ++this.#drawElements;
    }
    static #initHtml() {
        this.#htmlElement = createElement('div');
    }
    static #updateHtml() {
        this.#htmlElement.innerText = '';
        this.#htmlElement.append(String(this.#fps));
        this.#htmlElement.append(createElement('br'), `drawElements : ${this.#drawElements}`);
        this.#htmlElement.append(createElement('br'), `renderTime : ${this.#renderTimeMean.toPrecision(3)}`);
        this.#htmlElement.append(createElement('br'), `textures : ${this.#textures}`);
        for (const [mode, count] of this.#primitivePerMode) {
            //let count = this.primitivePerMode[mode];
            if (count > 0) {
                this.#htmlElement.append(createElement('br'), `${mode} : ${count}`);
            }
        }
    }
    static get htmlElement() {
        return this.#htmlElement;
    }
    static getFps() {
        return this.#fps;
    }
}

function flattenArray(array, arrayCount, arraySize) {
    const out = new Float32Array(arrayCount * arraySize); //TODO: cache this
    let offset = 0;
    for (let i = 0; i < arrayCount; i++) {
        for (let j = 0; j < arraySize; j++) {
            out[offset] = array[i][j];
            ++offset;
        }
    }
    return out;
}
const SAMPLERS = new Set([
    GL_SAMPLER_2D, GL_SAMPLER_3D, GL_SAMPLER_CUBE, GL_SAMPLER_2D_ARRAY,
    GL_SAMPLER_2D_SHADOW, GL_SAMPLER_CUBE_SHADOW, GL_SAMPLER_2D_ARRAY_SHADOW,
    GL_INT_SAMPLER_2D, GL_INT_SAMPLER_3D, GL_INT_SAMPLER_CUBE, GL_INT_SAMPLER_2D_ARRAY,
    GL_UNSIGNED_INT_SAMPLER_2D, GL_UNSIGNED_INT_SAMPLER_3D, GL_UNSIGNED_INT_SAMPLER_CUBE, GL_UNSIGNED_INT_SAMPLER_2D_ARRAY
]);
class Uniform {
    #activeInfo;
    #size;
    #uniformLocation;
    #isTextureSampler;
    #textureUnit;
    setValue;
    constructor(activeInfo, uniformLocation) {
        this.#activeInfo = activeInfo;
        this.#size = activeInfo.size;
        this.#uniformLocation = uniformLocation;
        this.setValue = this.#getSetter(activeInfo.type);
        this.#isTextureSampler = SAMPLERS.has(activeInfo.type);
    }
    #getSetter(type) {
        const name = this.#activeInfo.name;
        if (name.endsWith('[0]')) {
            // Array
            switch (type) {
                case GL_BOOL:
                case GL_INT:
                    return this.#uniform1iv;
                case GL_FLOAT:
                    return this.#uniform1fv;
                case GL_FLOAT_VEC2:
                    return this.#uniform2fv;
                case GL_FLOAT_VEC3:
                    return this.#uniform3fv;
                case GL_FLOAT_VEC4:
                    return this.#uniform4fv;
                case GL_SAMPLER_2D:
                    return this.#uniformSampler2DArray;
                case GL_FLOAT_MAT4:
                    return this.#uniformMatrix4fvArray;
                default:
                    throw 'Unknown uniform array type : ' + type;
            }
        }
        else {
            // Scalar value
            switch (type) {
                case GL_BOOL:
                case GL_INT:
                    return this.#uniform1i;
                case GL_FLOAT:
                    return this.#uniform1f;
                case GL_BOOL_VEC2:
                case GL_INT_VEC2:
                    return this.#uniform2iv;
                case GL_BOOL_VEC3:
                case GL_INT_VEC3:
                    return this.#uniform3iv;
                case GL_BOOL_VEC4:
                case GL_INT_VEC4:
                    return this.#uniform4iv;
                case GL_FLOAT_VEC2:
                    return this.#uniform2fv;
                case GL_FLOAT_VEC3:
                    return this.#uniform3fv;
                case GL_FLOAT_VEC4:
                    return this.#uniform4fv;
                case GL_FLOAT_MAT2:
                    return this.#uniformMatrix2fv;
                case GL_FLOAT_MAT3:
                    return this.#uniformMatrix3fv;
                case GL_FLOAT_MAT4:
                    return this.#uniformMatrix4fv;
                case GL_SAMPLER_2D:
                    return this.#uniformSampler2D;
                case GL_SAMPLER_CUBE:
                    return this.#uniformSamplerCube;
                default:
                    throw 'Unknown uniform type : ' + type;
            }
        }
    }
    setTextureUnit(textureUnit) {
        if (this.#activeInfo.name.endsWith('[0]')) {
            this.#textureUnit = [];
            for (let i = 0; i < this.#size; ++i) {
                this.#textureUnit.push(textureUnit + i);
            }
        }
        else {
            this.#textureUnit = textureUnit;
        }
    }
    isTextureSampler() {
        return this.#isTextureSampler;
    }
    getSize() {
        return this.#size;
    }
    #uniform1i(glContext, value) {
        glContext.uniform1i(this.#uniformLocation, value);
    }
    #uniform1iv(glContext, value) {
        glContext.uniform1iv(this.#uniformLocation, value);
    }
    #uniform2iv(glContext, value) {
        glContext.uniform2iv(this.#uniformLocation, value);
    }
    #uniform3iv(glContext, value) {
        glContext.uniform3iv(this.#uniformLocation, value);
    }
    #uniform4iv(glContext, value) {
        glContext.uniform4iv(this.#uniformLocation, value);
    }
    #uniform1f(glContext, value) {
        glContext.uniform1f(this.#uniformLocation, value);
    }
    #uniform1fv(glContext, value) {
        glContext.uniform1fv(this.#uniformLocation, value);
    }
    #uniform2fv(glContext, value) {
        glContext.uniform2fv(this.#uniformLocation, value);
    }
    #uniform3fv(glContext, value) {
        glContext.uniform3fv(this.#uniformLocation, value);
    }
    #uniform4fv(glContext, value) {
        glContext.uniform4fv(this.#uniformLocation, value);
    }
    #uniformMatrix2fv(glContext, value) {
        glContext.uniformMatrix2fv(this.#uniformLocation, false, value);
    }
    #uniformMatrix3fv(glContext, value) {
        glContext.uniformMatrix3fv(this.#uniformLocation, false, value);
    }
    #uniformMatrix4fv(glContext, value) {
        glContext.uniformMatrix4fv(this.#uniformLocation, false, value);
    }
    #uniformMatrix4fvArray(glContext, value) {
        glContext.uniformMatrix4fv(this.#uniformLocation, false, flattenArray(value, this.#size, 16));
    }
    #uniformSampler2D(glContext, texture) {
        glContext.uniform1i(this.#uniformLocation, this.#textureUnit);
        glContext.activeTexture(GL_TEXTURE0 + this.#textureUnit);
        if (texture) {
            glContext.bindTexture(GL_TEXTURE_2D, texture.texture);
        }
        else {
            glContext.bindTexture(GL_TEXTURE_2D, null);
        }
    }
    #uniformSampler2DArray(glContext, textures) {
        glContext.uniform1iv(this.#uniformLocation, this.#textureUnit);
        for (let i = 0; i < this.#size; ++i) {
            const texture = textures[i];
            glContext.activeTexture(GL_TEXTURE0 + this.#textureUnit[i]);
            if (texture) {
                glContext.bindTexture(GL_TEXTURE_2D, texture.texture);
            }
            else {
                glContext.bindTexture(GL_TEXTURE_2D, null);
            }
        }
    }
    #uniformSamplerCube(glContext, texture) {
        glContext.uniform1i(this.#uniformLocation, this.#textureUnit);
        glContext.activeTexture(GL_TEXTURE0 + this.#textureUnit);
        if (texture) {
            glContext.bindTexture(GL_TEXTURE_CUBE_MAP, texture.texture);
        }
        else {
            glContext.bindTexture(GL_TEXTURE_CUBE_MAP, null);
        }
    }
}

class Program {
    #glContext;
    #program;
    #vs;
    #fs;
    #vertexShaderName;
    #fragmentShaderName;
    #valid = false;
    attributes = new Map();
    uniforms = new Map();
    #linkError = '';
    constructor(glContext, vertexShaderName, fragmentShaderName) {
        this.#glContext = glContext;
        this.#program = glContext.createProgram();
        this.#vs = glContext.createShader(GL_VERTEX_SHADER);
        this.#fs = glContext.createShader(GL_FRAGMENT_SHADER);
        this.#vertexShaderName = vertexShaderName;
        this.#fragmentShaderName = fragmentShaderName;
        glContext.attachShader(this.#program, this.#vs);
        glContext.attachShader(this.#program, this.#fs);
    }
    get program() {
        throw 'error';
    }
    get vs() {
        throw 'error';
    }
    get fs() {
        throw 'error';
    }
    setUniformValue(name, value) {
        const uniform = this.uniforms.get(name);
        if (uniform) {
            uniform.setValue(this.#glContext, value);
        }
    }
    validate(includeCode) {
        const vertexShaderScript = ShaderManager.getShaderSource(GL_VERTEX_SHADER, this.#vertexShaderName);
        const fragmentShaderScript = ShaderManager.getShaderSource(GL_FRAGMENT_SHADER, this.#fragmentShaderName);
        if (vertexShaderScript && fragmentShaderScript && vertexShaderScript.isValid() && fragmentShaderScript.isValid()) {
            const vsOk = this.#compileShader(this.#vs, this.#vertexShaderName, vertexShaderScript, includeCode);
            const fsOk = vsOk && this.#compileShader(this.#fs, this.#fragmentShaderName, fragmentShaderScript, includeCode);
            if (fsOk) {
                this.#glContext.linkProgram(this.#program);
                if (!this.#glContext.getProgramParameter(this.#program, this.#glContext.LINK_STATUS)) {
                    const linkError = this.#glContext.getProgramInfoLog(this.#program);
                    if (this.#linkError != linkError) {
                        console.error(`Failed linking program for ${this.#vertexShaderName} and ${this.#fragmentShaderName}`);
                        console.error('Reason : ' + linkError);
                        this.#linkError = linkError;
                    }
                    return false;
                }
                else {
                    this.#linkError = '';
                }
                this.#initProgram();
                this.#valid = true;
            }
        }
    }
    invalidate() {
        this.#valid = false;
    }
    isValid() {
        return this.#valid;
    }
    getProgram() {
        return this.#program;
    }
    #initProgram() {
        this.attributes.clear();
        this.uniforms.clear();
        const activeAttributes = this.#glContext.getProgramParameter(this.#program, this.#glContext.ACTIVE_ATTRIBUTES);
        for (let i = 0; i < activeAttributes; i++) {
            const attribInfo = this.#glContext.getActiveAttrib(this.#program, i);
            if (attribInfo) {
                this.#setProgramAttribute(attribInfo.name);
            }
        }
        const activeUniforms = this.#glContext.getProgramParameter(this.#program, this.#glContext.ACTIVE_UNIFORMS);
        for (let i = 0; i < activeUniforms; i++) {
            const uniformInfo = this.#glContext.getActiveUniform(this.#program, i);
            if (uniformInfo) {
                this.#setProgramUniform(uniformInfo);
            }
        }
        let samplerId = 0;
        for (const [uniformName, uniform] of this.uniforms) {
            if (uniform.isTextureSampler()) {
                uniform.setTextureUnit(samplerId); //setValue(this.#glContext, samplerId);
                samplerId += uniform.getSize();
            }
        }
    }
    #setProgramAttribute(attributeName) {
        const attributeLocation = this.#glContext.getAttribLocation(this.#program, attributeName);
        this.attributes.set(attributeName, attributeLocation); //TODO: set in attributes ?
    }
    #setProgramUniform(uniformInfo) {
        const uniformLocation = this.#glContext.getUniformLocation(this.#program, uniformInfo.name);
        if (uniformLocation) {
            this.uniforms.set(uniformInfo.name, new Uniform(uniformInfo, uniformLocation));
        }
    }
    #compileShader(shader, shaderName, shaderSource, includeCode) {
        if (!shaderSource || !shaderSource.isValid()) {
            return null;
        }
        const compileSource = shaderSource.getCompileSource(includeCode);
        this.#glContext.shaderSource(shader, compileSource);
        this.#glContext.compileShader(shader);
        if (!this.#glContext.getShaderParameter(shader, this.#glContext.COMPILE_STATUS)) {
            const shaderInfoLog = this.#glContext.getShaderInfoLog(shader);
            const m = 'Compile error in ' + shaderName + '. Reason : ' + shaderInfoLog;
            console.warn(m, shaderSource.getCompileSourceLineNumber(includeCode), m);
            ShaderManager.setCompileError(shaderName, shaderInfoLog);
            shaderSource.setCompileError(this.#glContext.getShaderInfoLog(shader), includeCode);
            return false;
        }
        return true;
    }
}

const tempViewProjectionMatrix = mat4.create();
const lightDirection = vec3.create();
function getDefinesAsString(meshOrMaterial) {
    const defines = [];
    for (const [name, value] of Object.entries(meshOrMaterial.defines)) {
        if (value === false) {
            defines.push('#undef ' + name);
        }
        else {
            defines.push('#define ' + name + ' ' + value);
        }
    }
    return defines.join('\n') + '\n';
}
class Renderer {
    #toneMapping = ToneMapping.None;
    #toneMappingExposure = 1.;
    #glContext;
    #materialsProgram = new Map();
    #globalIncludeCode = '';
    constructor() {
        this.#glContext = Graphics$1.glContext;
    }
    getProgram(mesh, material) {
        let includeCode = Graphics$1.getIncludeCode();
        includeCode += this.#globalIncludeCode;
        includeCode += getDefinesAsString(mesh);
        includeCode += getDefinesAsString(material);
        includeCode += material.getShaderSource();
        let program = this.#materialsProgram.get(includeCode);
        if (!program) {
            const shaderSource = material.getShaderSource();
            program = new Program(this.#glContext, shaderSource + '.vs', shaderSource + '.fs');
            this.#materialsProgram.set(includeCode, program);
        }
        if (!program.isValid()) {
            let includeCode = Graphics$1.getIncludeCode();
            includeCode += this.#globalIncludeCode;
            includeCode += getDefinesAsString(mesh);
            includeCode += getDefinesAsString(material);
            program.validate(includeCode);
            material._dirtyProgram = false;
        }
        return program;
    }
    #setupVertexAttributes(program, geometry, wireframe) {
        WebGLRenderingState.initUsedAttributes();
        const geometryAttributes = geometry.attributes;
        const programAttributes = program.attributes;
        for (const [attributeName, attribute] of geometryAttributes) {
            const attributeLocation = programAttributes.get(attributeName);
            if (attributeName == 'index') {
                if (wireframe == 1) {
                    attribute.updateWireframe(this.#glContext); //TODO: put somewhere else
                }
                else {
                    attribute.update(this.#glContext); //TODO: put somewhere else
                }
                this.#glContext.bindBuffer(GL_ELEMENT_ARRAY_BUFFER, attribute._buffer);
            }
            else if (attributeLocation !== undefined) {
                attribute.update(this.#glContext); //TODO: put somewhere else
                WebGLRenderingState.enableVertexAttribArray(attributeLocation, attribute.divisor);
                this.#glContext.bindBuffer(GL_ARRAY_BUFFER, attribute._buffer);
                this.#glContext.vertexAttribPointer(attributeLocation, attribute.itemSize, attribute.type, false, 0, 0);
            }
        }
        WebGLRenderingState.disableUnusedAttributes();
    }
    #setupVertexUniforms(program, mesh) {
        for (const uniform in mesh.uniforms) {
            program.setUniformValue(uniform, mesh.uniforms[uniform]);
        }
    }
    applyMaterial(program, material) {
    }
    setupLights(renderList, camera, program, viewMatrix) {
        const lightPositionCameraSpace = vec3.create(); //TODO: do not create a vec3
        const lightPositionWorldSpace = vec3.create(); //TODO: do not create a vec3
        const colorIntensity = vec3.create(); //TODO: do not create a vec3
        const pointLights = renderList.pointLights; //scene.getChildList(PointLight);
        const spotLights = renderList.spotLights;
        let shadow;
        let pointLightId = 0;
        const pointShadowMap = [];
        const pointShadowMatrix = [];
        for (const pointLight of pointLights) {
            if (pointLight.isVisible()) {
                pointLight.getWorldPosition(lightPositionWorldSpace);
                vec3.transformMat4(lightPositionCameraSpace, lightPositionWorldSpace, viewMatrix);
                program.setUniformValue('uPointLights[' + pointLightId + '].position', lightPositionCameraSpace);
                program.setUniformValue('uPointLights[' + pointLightId + '].color', vec3.scale(colorIntensity, pointLight.color, pointLight.intensity));
                program.setUniformValue('uPointLights[' + pointLightId + '].range', pointLight.range);
                //program.setUniformValue('uPointLightsuPointLights[' + pointLightId + '].direction', pointLight.getDirection(tempVec3));
                //program.setUniformValue('uPointLights[' + pointLightId + '].direction', [0, 0, -1]);
                program.setUniformValue('uPbrLights[' + pointLightId + '].position', lightPositionWorldSpace);
                program.setUniformValue('uPbrLights[' + pointLightId + '].radiance', vec3.scale(colorIntensity, pointLight.color, pointLight.intensity));
                shadow = pointLight.shadow;
                if (shadow && pointLight.castShadow) {
                    pointShadowMap.push(shadow.renderTarget.getTexture());
                    pointShadowMatrix.push(shadow.shadowMatrix);
                    program.setUniformValue('uPointLightShadows[' + pointLightId + '].mapSize', shadow.textureSize);
                    program.setUniformValue('uPointLightShadows[' + pointLightId + '].near', shadow.camera.nearPlane);
                    program.setUniformValue('uPointLightShadows[' + pointLightId + '].far', shadow.camera.farPlane);
                    program.setUniformValue('uPointLightShadows[' + pointLightId + '].enabled', true);
                }
                ++pointLightId;
            }
        }
        program.setUniformValue('uPointShadowMap[0]', pointShadowMap);
        program.setUniformValue('uPointShadowMatrix[0]', pointShadowMatrix);
        let spotLightId = 0;
        const spotShadowMap = [];
        const spotShadowMatrix = [];
        for (const spotLight of spotLights) {
            if (spotLight.visible) {
                spotLight.getWorldPosition(lightPositionCameraSpace);
                vec3.transformMat4(lightPositionCameraSpace, lightPositionCameraSpace, viewMatrix);
                program.setUniformValue('uSpotLights[' + spotLightId + '].position', lightPositionCameraSpace);
                program.setUniformValue('uSpotLights[' + spotLightId + '].color', vec3.scale(colorIntensity, spotLight.color, spotLight.intensity));
                program.setUniformValue('uSpotLights[' + spotLightId + '].range', spotLight.range);
                program.setUniformValue('uSpotLights[' + spotLightId + '].innerAngleCos', spotLight.innerAngleCos);
                program.setUniformValue('uSpotLights[' + spotLightId + '].outerAngleCos', spotLight.outerAngleCos);
                //program.setUniformValue('uSpotLights[' + spotLightId + '].direction', spotLight.getDirection(tempVec3));
                //program.setUniformValue('uSpotLights[' + spotLightId + '].direction', [0, 0, -1]);
                spotLight.getDirection(lightDirection);
                const m = viewMatrix;
                const x = lightDirection[0];
                const y = lightDirection[1];
                const z = lightDirection[2];
                lightDirection[0] = m[0] * x + m[4] * y + m[8] * z;
                lightDirection[1] = m[1] * x + m[5] * y + m[9] * z;
                lightDirection[2] = m[2] * x + m[6] * y + m[10] * z;
                program.setUniformValue('uSpotLights[' + spotLightId + '].direction', lightDirection);
                shadow = spotLight.shadow;
                if (shadow && spotLight.castShadow) {
                    spotShadowMap.push(shadow.renderTarget.getTexture());
                    spotShadowMatrix.push(shadow.shadowMatrix);
                    program.setUniformValue('uSpotLightShadows[' + spotLightId + '].mapSize', shadow.textureSize);
                    program.setUniformValue('uSpotLightShadows[' + spotLightId + '].enabled', true);
                }
                ++spotLightId;
            }
        }
        program.setUniformValue('uSpotShadowMap[0]', spotShadowMap);
        program.setUniformValue('uSpotShadowMatrix[0]', spotShadowMatrix);
        const ambientLights = renderList.ambientLights; //scene.getChildList(AmbientLight);
        const ambientAccumulator = vec3.create(); //TODO: do not create a vec3
        for (const ambientLight of ambientLights) {
            if (ambientLight.isVisible()) {
                vec3.scaleAndAdd(ambientAccumulator, ambientAccumulator, ambientLight.color, ambientLight.intensity);
            }
        }
        program.setUniformValue('uAmbientLight', ambientAccumulator);
    }
    #setLights(pointLights, spotLights, pointLightShadows, spotLightShadows) {
        Graphics$1.setIncludeCode('USE_SHADOW_MAPPING', '#define USE_SHADOW_MAPPING');
        Graphics$1.setIncludeCode('NUM_POINT_LIGHTS', '#define NUM_POINT_LIGHTS ' + pointLights);
        Graphics$1.setIncludeCode('NUM_PBR_LIGHTS', '#define NUM_PBR_LIGHTS ' + pointLights);
        Graphics$1.setIncludeCode('NUM_SPOT_LIGHTS', '#define NUM_SPOT_LIGHTS ' + spotLights);
        Graphics$1.setIncludeCode('NUM_POINT_LIGHT_SHADOWS', '#define NUM_POINT_LIGHT_SHADOWS ' + pointLightShadows);
        Graphics$1.setIncludeCode('NUM_SPOT_LIGHT_SHADOWS', '#define NUM_SPOT_LIGHT_SHADOWS ' + spotLightShadows);
        //TODO: other lights of disable lighting all together
    }
    #unsetLights() {
        Graphics$1.setIncludeCode('USE_SHADOW_MAPPING', '#undef USE_SHADOW_MAPPING');
        Graphics$1.setIncludeCode('NUM_POINT_LIGHTS', '#define NUM_POINT_LIGHTS 0');
        Graphics$1.setIncludeCode('NUM_SPOT_LIGHTS', '#define NUM_SPOT_LIGHTS 0');
        Graphics$1.setIncludeCode('NUM_POINT_LIGHT_SHADOWS', '#define NUM_POINT_LIGHTS 0');
        Graphics$1.setIncludeCode('NUM_SPOT_LIGHT_SHADOWS', '#define NUM_SPOT_LIGHTS 0');
        //TODO: other lights of disable lighting all together
    }
    renderObject(context, renderList, object, camera, geometry, material, renderLights = true, lightPos) {
        if (!object.isRenderable) {
            return;
        }
        if (object.isVisible() === false) {
            return;
        }
        if (geometry.count === 0) {
            return;
        }
        if (!renderLights) {
            if (!object.castShadow) {
                return;
            }
        }
        renderLights &&= material.renderLights;
        material.updateMaterial(Graphics$1.getTime(), object); //TODO: frame delta
        const cameraMatrix = camera.cameraMatrix;
        const projectionMatrix = camera.projectionMatrix;
        mat4.mul(object._mvMatrix, cameraMatrix, object.worldMatrix);
        //object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
        mat3.normalFromMat4(object._normalMatrix, cameraMatrix); //TODO: fixme
        //let viewProjectionMatrix = mat4.create();//TODOv3 don't recreate the matrix
        mat4.mul(tempViewProjectionMatrix, projectionMatrix, cameraMatrix); //TODO: compute this in camera
        if (renderLights) {
            this.#setLights(renderList.pointLights.length, renderList.spotLights.length, renderList.pointLightShadows, renderList.spotLightShadows);
            if (!object.receiveShadow) {
                Graphics$1.setIncludeCode('USE_SHADOW_MAPPING', '#undef USE_SHADOW_MAPPING');
            }
        }
        else {
            this.#unsetLights();
        }
        if (camera.projection == CameraProjection.Perspective) {
            Graphics$1.setIncludeCode('CAMERA_PROJECTION_TYPE', '#define IS_PERSPECTIVE_CAMERA');
        }
        else {
            Graphics$1.setIncludeCode('CAMERA_PROJECTION_TYPE', '#define IS_ORTHOGRAPHIC_CAMERA');
        }
        const program = this.getProgram(object, material);
        if (program.isValid()) {
            WebGLRenderingState.useProgram(program.getProgram());
            if (renderLights) {
                material.beforeRender(camera);
            }
            this.applyMaterial(program, material);
            program.setUniformValue('uModelMatrix', object.worldMatrix);
            program.setUniformValue('uModelViewMatrix', object._mvMatrix);
            program.setUniformValue('uViewMatrix', cameraMatrix);
            program.setUniformValue('uProjectionMatrix', projectionMatrix);
            program.setUniformValue('uProjectionLogDepth', 2.0 / (Math.log(camera.farPlane + 1.0) / Math.LN2)); //TODO: perf: compute that once we set camera farplane
            program.setUniformValue('uViewProjectionMatrix', tempViewProjectionMatrix);
            program.setUniformValue('uNormalMatrix', object._normalMatrix);
            program.setUniformValue('uCameraPosition', camera.position);
            const pickingColor = object.pickingColor;
            if (pickingColor) {
                program.setUniformValue('uPickingColor', pickingColor);
            }
            //TODO: set this on resolution change
            program.setUniformValue('uResolution', [Graphics$1.getWidth(), Graphics$1.getHeight(), camera.aspectRatio, 0]);
            //TODO: set this at start of the frame
            program.setUniformValue('uTime', [Graphics$1.getTime(), Graphics$1.currentTick, 0, 0]);
            if (renderLights) {
                this.setupLights(renderList, camera, program, cameraMatrix);
            }
            else {
                program.setUniformValue('uLightPosition', lightPos);
                program.setUniformValue('uLightNear', camera.nearPlane);
                program.setUniformValue('uLightFar', camera.farPlane);
            }
            const wireframe = object.wireframe;
            this.#setupVertexAttributes(program, geometry, wireframe);
            this.#setupVertexUniforms(program, object);
            if (geometry.instanceCount === undefined) {
                if (wireframe == 1) {
                    //TODO: case where original geometry is GL_LINES
                    this.#glContext.drawElements(GL_LINES, geometry.count * 2, GL_UNSIGNED_INT, 0);
                }
                else {
                    this.#glContext.drawElements(object.renderMode, geometry.count, geometry.elementArrayType, 0);
                }
            }
            else {
                if (Graphics$1.isWebGL2) {
                    this.#glContext.drawElementsInstanced(object.renderMode, geometry.count, geometry.elementArrayType, 0, geometry.instanceCount);
                }
                else {
                    Graphics$1.ANGLE_instanced_arrays?.drawElementsInstancedANGLE(object.renderMode, geometry.count, geometry.elementArrayType, 0, geometry.instanceCount);
                }
            }
        }
    }
    _prepareRenderList(renderList, scene, camera, delta, context) {
        renderList.reset();
        let currentObject = scene;
        const objectStack = [];
        //scene.pointLights = scene.getChildList(PointLight);
        //scene.ambientLights = scene.getChildList(AmbientLight);
        while (currentObject) {
            if (currentObject.getAttribute(EngineEntityAttributes.IsTool, false) && context.DisableToolRendering) {
                currentObject = objectStack.shift();
                continue;
            }
            //objectStack.push(currentObject);
            for (const child of currentObject.children) {
                {
                    objectStack.push(child);
                }
            }
            if (currentObject.isRenderable) {
                renderList.addObject(currentObject);
            }
            else {
                currentObject.update(scene, camera, delta);
            }
            currentObject = objectStack.shift();
        }
        renderList.finish();
    }
    _renderRenderList(renderList, camera, renderLights, context, lightPos) {
        for (const child of renderList.opaqueList) {
            this.renderObject(context, renderList, child, camera, child.geometry, child.material, renderLights, lightPos);
        }
        if (renderLights) {
            for (const child of renderList.transparentList) {
                this.renderObject(context, renderList, child, camera, child.geometry, child.material, renderLights, lightPos);
            }
        }
    }
    render(scene, camera, delta, context) {
    }
    clear(color, depth, stencil) {
        WebGLRenderingState.clear(color, depth, stencil);
    }
    /*
        get vpMatrix() {
            return mat4.mul(mat4.create(), this.currentCamera.projectionMatrix, this.viewMatrix);
        }
            */
    /**
     * Invalidate all shader (force recompile)
     */
    invalidateShaders() {
        for (const shader of this.#materialsProgram.values()) {
            shader.invalidate();
        }
    }
    clearColor(clearColor) {
        WebGLRenderingState.clearColor(clearColor);
    }
    clearDepth(clearDepth) {
        WebGLRenderingState.clearDepth(clearDepth);
    }
    clearStencil(clearStencil) {
        WebGLRenderingState.clearStencil(clearStencil);
    }
    setToneMapping(toneMapping) {
        this.#toneMapping = toneMapping;
        Graphics$1.setIncludeCode('TONE_MAPPING', `#define TONE_MAPPING ${toneMapping}`);
    }
    getToneMapping() {
        return this.#toneMapping;
    }
    setToneMappingExposure(exposure) {
        this.#toneMappingExposure = exposure;
        Graphics$1.setIncludeCode('TONE_MAPPING_EXPOSURE', `#define TONE_MAPPING_EXPOSURE ${exposure.toFixed(2)}`);
    }
    getToneMappingExposure() {
        return this.#toneMappingExposure;
    }
}

function sortLights(first, second) {
    if (first.castShadow) {
        return -1;
    }
    return 1;
}
class RenderList {
    lights = [];
    pointLights = [];
    spotLights = [];
    ambientLights = [];
    transparentList = [];
    opaqueList = [];
    pointLightShadows = 0;
    spotLightShadows = 0;
    reset() {
        this.lights = [];
        this.pointLights = [];
        this.spotLights = [];
        this.ambientLights = [];
        this.transparentList = [];
        this.opaqueList = [];
        this.pointLightShadows = 0;
        this.spotLightShadows = 0;
    }
    finish() {
        this.pointLights.sort(sortLights);
        this.spotLights.sort(sortLights);
    }
    addObject(entity) {
        if (entity.isVisible() !== false) {
            if (entity.isLight) {
                this.lights.push(entity);
                if (entity.isAmbientLight) {
                    this.ambientLights.push(entity);
                }
                else if (entity.isPointLight) {
                    this.pointLights.push(entity);
                    if (entity.castShadow) {
                        ++this.pointLightShadows;
                    }
                }
                else if (entity.isSpotLight) {
                    this.spotLights.push(entity);
                    if (entity.castShadow) {
                        ++this.spotLightShadows;
                    }
                }
            }
            else {
                const material = entity.material;
                if (material) {
                    if (material.blend) { //TODOv3 changeblend
                        this.transparentList.push(entity);
                    }
                    else {
                        this.opaqueList.push(entity);
                    }
                }
            }
        }
    }
}

class ForwardRenderer extends Renderer {
    #shadowMap;
    #frame = 0;
    constructor() {
        super();
        this.#shadowMap = new ShadowMap();
    }
    applyMaterial(program, material) {
        if (material.depthTest) {
            WebGLRenderingState.enable(GL_DEPTH_TEST);
            WebGLRenderingState.depthFunc(material.depthFunc);
        }
        else {
            WebGLRenderingState.disable(GL_DEPTH_TEST);
        }
        WebGLRenderingState.depthMask(material.depthMask);
        WebGLRenderingState.colorMask(material.colorMask);
        if (material.blend) {
            WebGLRenderingState.enable(GL_BLEND);
            WebGLRenderingState.blendFuncSeparate(material.srcRGB, material.dstRGB, material.srcAlpha, material.dstAlpha);
            WebGLRenderingState.blendEquationSeparate(material.modeRGB, material.modeAlpha);
        }
        else {
            WebGLRenderingState.disable(GL_BLEND);
        }
        /*
        if (material.disableCulling === true) {
            WebGLRenderingState.disable(GL_CULL_FACE);
        } else {
            WebGLRenderingState.enable(GL_CULL_FACE);
            WebGLRenderingState.cullFace(material.cullMode);
        }
            */
        const renderFace = material.getRenderFace();
        switch (renderFace) {
            case RenderFace.Front:
                WebGLRenderingState.enable(GL_CULL_FACE);
                WebGLRenderingState.cullFace(GL_BACK);
                break;
            case RenderFace.Back:
                WebGLRenderingState.enable(GL_CULL_FACE);
                WebGLRenderingState.cullFace(GL_FRONT);
                break;
            case RenderFace.Both:
                WebGLRenderingState.disable(GL_CULL_FACE);
                break;
            case RenderFace.None:
                WebGLRenderingState.enable(GL_CULL_FACE);
                WebGLRenderingState.cullFace(GL_FRONT_AND_BACK);
                break;
        }
        WebGLRenderingState.polygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
        for (const uniform in material.uniforms) {
            program.setUniformValue(uniform, material.uniforms[uniform]);
        }
    }
    render(scene, camera, delta, context) {
        const renderList = new RenderList(); //TODO: optimize
        camera.dirty(); //Force matrices to recompute
        this._prepareRenderList(renderList, scene, camera, delta, context);
        this.#shadowMap.render(this, renderList, camera, context);
        if (scene.background) {
            scene.background.render(this, camera);
        }
        this._renderRenderList(renderList, camera, true, context);
        WebGLRenderingState.depthMask(true); //TODOv3 check why we have to do this
        ++this.#frame;
    }
    set scissorTest(scissorTest) {
        if (scissorTest) {
            WebGLRenderingState.enable(GL_SCISSOR_TEST);
        }
        else {
            WebGLRenderingState.disable(GL_SCISSOR_TEST);
        }
    }
}

const VEC4_ALL_1 = vec4.fromValues(1.0, 1.0, 1.0, 1.0);
var ShaderPrecision;
(function (ShaderPrecision) {
    ShaderPrecision[ShaderPrecision["Low"] = 0] = "Low";
    ShaderPrecision[ShaderPrecision["Medium"] = 1] = "Medium";
    ShaderPrecision[ShaderPrecision["High"] = 2] = "High";
})(ShaderPrecision || (ShaderPrecision = {}));
var ShaderQuality;
(function (ShaderQuality) {
    ShaderQuality[ShaderQuality["Low"] = 0] = "Low";
    ShaderQuality[ShaderQuality["Medium"] = 1] = "Medium";
    ShaderQuality[ShaderQuality["High"] = 2] = "High";
})(ShaderQuality || (ShaderQuality = {}));
var ShaderDebugMode;
(function (ShaderDebugMode) {
    ShaderDebugMode[ShaderDebugMode["None"] = 0] = "None";
})(ShaderDebugMode || (ShaderDebugMode = {}));
class Graphics {
    static #pixelRatio = /*window.devicePixelRatio ?? */ 1.0;
    static #viewport = vec4.create();
    static #scissor = vec4.create();
    static #extensions = new Map();
    static #autoResize = false;
    static isWebGL = false;
    static isWebGL2 = false;
    static autoClear = true;
    static autoClearColor = false;
    static autoClearDepth = true;
    static autoClearStencil = true;
    static #includeCode = new Map();
    static #globalIncludeCode = '';
    static speed = 1.0;
    static #timeOrigin = performance.now();
    static #time = 0;
    static #running = false;
    static #lastTick = performance.now();
    static currentTick = 0;
    static #renderBuffers = new Set();
    static #renderTargetStack = [];
    static #readyPromiseResolve;
    static #readyPromise = new Promise((resolve) => this.#readyPromiseResolve = resolve);
    static #canvas;
    static #canvases = new Map();
    static #width = 300;
    static #height = 150;
    static #offscreenCanvas;
    static #forwardRenderer;
    static glContext;
    static #bipmapContext;
    static #pickedEntity = null;
    static #animationFrame = 0;
    static ANGLE_instanced_arrays;
    static OES_texture_float_linear;
    static #mediaRecorder;
    static dragging = false;
    static #mouseDownFunc = (event) => this.#mouseDown(event);
    static #mouseMoveFunc = (event) => this.#mouseMove(event);
    static #mouseUpFunc = (event) => this.#mouseUp(event);
    static #keyDownFunc = (event) => GraphicsEvents.keyDown(event);
    static #keyUpFunc = (event) => GraphicsEvents.keyUp(event);
    static #wheelFunc = (event) => this.#wheel(event);
    static #touchStartFunc = (event) => GraphicsEvents.touchStart(this.#pickedEntity, event);
    static #touchMoveFunc = (event) => GraphicsEvents.touchMove(this.#pickedEntity, event);
    static #touchCancelFunc = (event) => GraphicsEvents.touchCancel(this.#pickedEntity, event);
    static {
        this.setShaderPrecision(ShaderPrecision.Medium);
        this.setShaderQuality(ShaderQuality.Medium);
        this.setShaderDebugMode(ShaderDebugMode.None);
        this.setIncludeCode('MAX_HARDWARE_BONES', '#define MAX_HARDWARE_BONES ' + MAX_HARDWARE_BONES);
    }
    static initCanvas(contextAttributes = {}) {
        if (contextAttributes.useOffscreenCanvas) {
            this.#offscreenCanvas = new OffscreenCanvas(0, 0);
        }
        else {
            this.#canvas = contextAttributes.canvas ?? createElement('canvas');
            ShortcutHandler.addContext('3dview', this.#canvas);
            this.#width = this.#canvas.width;
            this.#height = this.#canvas.height;
            this.listenCanvas(this.#canvas);
        }
        /*
        if (!this.#canvas.hasAttribute('tabindex')) {
            this.#canvas.setAttribute('tabindex', "1");
        }
        */
        this.#initContext(contextAttributes);
        this.#initObserver();
        WebGLRenderingState.setGraphics();
        // init state
        WebGLRenderingState.enable(GL_CULL_FACE);
        // init state end
        //this.clearColor = vec4.fromValues(0, 0, 0, 255);
        this.#forwardRenderer = new ForwardRenderer();
        const autoResize = contextAttributes.autoResize;
        if (autoResize !== undefined) {
            this.autoResize = autoResize;
        }
        this.#readyPromiseResolve(true);
        return this;
    }
    static addCanvas(canvas, options) {
        canvas = canvas ?? createElement('canvas');
        if (this.#canvases.has(canvas)) {
            return canvas;
        }
        this.listenCanvas(canvas);
        try {
            const bipmapContext = canvas.getContext('bitmaprenderer');
            if (!bipmapContext) {
                return canvas;
            }
            let scenes;
            if (options.scenes) {
                scenes = options.scenes;
            }
            else {
                if (options.scene) {
                    scenes = [{ scene: options.scene, viewport: { x: 0, y: 0, width: 1, height: 1 } }];
                }
                else {
                    scenes = [];
                }
            }
            this.#canvases.set(canvas, {
                name: options.name ?? ' ',
                enabled: true,
                canvas: canvas,
                context: bipmapContext,
                scenes: scenes,
                autoResize: options.autoResize ?? false,
            });
        }
        catch (e) { }
        return canvas;
    }
    static removeCanvas(canvas) {
        if (this.#canvases.has(canvas)) {
            this.unlistenCanvas(canvas);
            this.#canvases.delete(canvas);
        }
    }
    static enableCanvas(canvas, enable) {
        const c = this.#canvases.get(canvas);
        if (c) {
            c.enabled = enable;
        }
    }
    static listenCanvas(canvas) {
        canvas.addEventListener('mousedown', this.#mouseDownFunc);
        canvas.addEventListener('mousemove', this.#mouseMoveFunc);
        canvas.addEventListener('mouseup', this.#mouseUpFunc);
        canvas.addEventListener('keydown', this.#keyDownFunc);
        canvas.addEventListener('keyup', this.#keyUpFunc);
        canvas.addEventListener('wheel', this.#wheelFunc);
        canvas.addEventListener('touchstart', this.#touchStartFunc);
        canvas.addEventListener('touchmove', this.#touchMoveFunc);
        canvas.addEventListener('touchcancel', this.#touchCancelFunc);
        if (!canvas.hasAttribute('tabindex')) {
            canvas.setAttribute('tabindex', "1");
        }
    }
    static unlistenCanvas(canvas) {
        canvas.removeEventListener('mousedown', this.#mouseDownFunc);
        canvas.removeEventListener('mousemove', this.#mouseMoveFunc);
        canvas.removeEventListener('mouseup', this.#mouseUpFunc);
        canvas.removeEventListener('keydown', this.#keyDownFunc);
        canvas.removeEventListener('keyup', this.#keyUpFunc);
        canvas.removeEventListener('wheel', this.#wheelFunc);
        canvas.removeEventListener('touchstart', this.#touchStartFunc);
        canvas.removeEventListener('touchmove', this.#touchMoveFunc);
        canvas.removeEventListener('touchcancel', this.#touchCancelFunc);
    }
    static pickEntity(x, y) {
        if (!this.#canvas) {
            return null;
        }
        this.setIncludeCode('pickingMode', '#define PICKING_MODE');
        GraphicsEvents.tick(0, performance.now(), 0);
        this.setIncludeCode('pickingMode', '#undef PICKING_MODE');
        this.glContext;
        const pixels = new Uint8Array(4);
        this.glContext?.readPixels(x, this.#canvas.height - y, 1, 1, GL_RGBA, GL_UNSIGNED_BYTE, pixels);
        const pickedEntityIndex = (pixels[0] << 16) + (pixels[1] << 8) + (pixels[2]);
        return pickList.get(pickedEntityIndex) ?? null;
    }
    static #mouseDown(event) {
        event.target.focus?.();
        const x = event.offsetX;
        const y = event.offsetY;
        this.#pickedEntity = this.pickEntity(x, y);
        GraphicsEvents.mouseDown(x, y, this.#pickedEntity, event);
    }
    static #mouseMove(event) {
        const x = event.offsetX;
        const y = event.offsetY;
        GraphicsEvents.mouseMove(x, y, this.#pickedEntity, event);
    }
    static #mouseUp(event) {
        const x = event.offsetX;
        const y = event.offsetY;
        GraphicsEvents.mouseUp(x, y, this.#pickedEntity, event);
        this.#pickedEntity = null;
    }
    static #wheel(event) {
        const x = event.offsetX;
        const y = event.offsetY;
        GraphicsEvents.wheel(x, y, this.#pickedEntity, event);
        this.#pickedEntity = null;
        event.preventDefault();
    }
    static getDefinesAsString(material) {
        const defines = [];
        for (const [name, value] of Object.entries(material.defines)) {
            if (value === false) {
                defines.push('#undef ' + name + ' ' + value);
            }
            else {
                defines.push('#define ' + name + ' ' + value);
            }
        }
        return defines.join('\n') + '\n';
    }
    static render(scene, camera, delta, context) {
        if (this.#offscreenCanvas && context.imageBitmap) {
            this.#offscreenCanvas.width = context.imageBitmap.width;
            this.#offscreenCanvas.height = context.imageBitmap.height;
            this.setViewport(vec4.fromValues(0, 0, context.imageBitmap.width, context.imageBitmap.height));
        }
        this.renderBackground(); //TODOv3 put in rendering pipeline
        this.#forwardRenderer.render(scene, camera, delta, context);
        if (this.#offscreenCanvas) {
            const bitmap = this.#offscreenCanvas.transferToImageBitmap();
            (context.imageBitmap?.context ?? this.#bipmapContext)?.transferFromImageBitmap(bitmap);
        }
    }
    static renderMultiCanvas(delta, context = {}) {
        // TODO: mutualize with the method render()
        for (const [_, canvas] of this.#canvases) {
            if (canvas.enabled) {
                this.#renderMultiCanvas(canvas, delta, context);
            }
        }
    }
    static #renderMultiCanvas(canvas, delta, context) {
        if (!canvas.canvas.checkVisibility()) {
            return;
        }
        if (this.#offscreenCanvas) {
            const parentElement = canvas.canvas.parentElement;
            if (canvas.autoResize && parentElement) {
                const width = parentElement.clientWidth;
                const height = parentElement.clientHeight;
                this.#offscreenCanvas.width = width;
                this.#offscreenCanvas.height = height;
                canvas.canvas.width = width * this.#pixelRatio;
                canvas.canvas.height = height * this.#pixelRatio;
            }
            else {
                this.#offscreenCanvas.width = canvas.canvas.width;
                this.#offscreenCanvas.height = canvas.canvas.height;
            }
            this.setViewport(vec4.fromValues(0, 0, canvas.canvas.width, canvas.canvas.height));
        }
        this.renderBackground(); //TODOv3 put in rendering pipeline
        for (const canvasScene of canvas.scenes) {
            const camera = canvasScene.scene.activeCamera;
            if (camera) {
                if (camera.autoResize) {
                    const w = canvas.canvas.width;
                    const h = canvas.canvas.height;
                    camera.left = -w;
                    camera.right = w;
                    camera.bottom = -h;
                    camera.top = h;
                    camera.aspectRatio = w / h;
                }
                this.#forwardRenderer.render(canvasScene.scene, camera, delta, context);
            }
        }
        const bitmap = this.#offscreenCanvas.transferToImageBitmap();
        canvas.context.transferFromImageBitmap(bitmap);
    }
    static renderBackground() {
        if (this.autoClear) {
            this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
        }
    }
    static clear(color, depth, stencil) {
        let bits = 0;
        if (color)
            bits |= GL_COLOR_BUFFER_BIT;
        if (depth)
            bits |= GL_DEPTH_BUFFER_BIT;
        if (stencil)
            bits |= GL_STENCIL_BUFFER_BIT;
        //TODO check if doing a complete state reinitilisation is better ?
        WebGLRenderingState.colorMask(VEC4_ALL_1);
        WebGLRenderingState.depthMask(true);
        WebGLRenderingState.stencilMask(Number.MAX_SAFE_INTEGER);
        this.glContext?.clear(bits);
    }
    static _tick() {
        cancelAnimationFrame(this.#animationFrame);
        {
            this.#animationFrame = requestAnimationFrame(() => this._tick());
        }
        const tick = performance.now();
        this.#time = (tick - this.#timeOrigin) * 0.001;
        const delta = (tick - this.#lastTick) * this.speed * 0.001;
        if (this.#running) {
            ++this.currentTick;
            GraphicsEvents.tick(delta, tick, this.speed);
        }
        this.#lastTick = tick;
    }
    static #initContext(contextAttributes) {
        const canvas = this.#offscreenCanvas ?? this.#canvas;
        if (this.#offscreenCanvas) ;
        if (!canvas) {
            return;
        }
        // we may want to cleanup the contextAttributes here
        try {
            try { // first try to create a webgl2 context
                if (DISABLE_WEBGL2) ;
                this.glContext = canvas.getContext('webgl2', contextAttributes);
                if (this.glContext instanceof WebGL2RenderingContext) {
                    this.isWebGL2 = true;
                    WebGLShaderSource.isWebGL2 = true;
                    this.setIncludeCode('WEBGL2', '#define WEBGL2');
                }
                else {
                    throw 'no webgl2';
                }
            }
            catch (e) {
                this.glContext = canvas.getContext('webgl', contextAttributes);
                if (this.glContext instanceof WebGLRenderingContext) {
                    this.isWebGL = true;
                    this.setIncludeCode('WEBGL1', '#define WEBGL1');
                    //TODO: put this in a separate function and alert the user in case of failure
                    //these extensions are important
                    // activate UNSIGNED_INT indices in drawElements
                    this.getExtension('OES_element_index_uint');
                    // activate floating point textures
                    this.getExtension('OES_texture_float');
                    // activate derivatives functions
                    this.getExtension('OES_standard_derivatives');
                    //activate writing in gl_FragDepth
                    this.getExtension('EXT_frag_depth');
                    // get access to drawElementsInstancedANGLE
                    this.ANGLE_instanced_arrays = this.getExtension('ANGLE_instanced_arrays');
                    // add MIN_EXT and MAX_EXT for blendEquation in webgl1 context. MIN_EXT and MAX_EXT have the same value as MIN and MAX
                    this.getExtension('EXT_blend_minmax');
                    //Depth texture https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_depth_texture
                    this.getExtension('WEBGL_depth_texture');
                    //https://developer.mozilla.org/en-US/docs/Web/API/EXT_sRGB
                    this.getExtension('EXT_sRGB');
                    //TODO: see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getExtension
                }
            }
            // WEBGL1 / WEBGL2 extensions
            // https://developer.mozilla.org/en-US/docs/Web/API/OES_texture_float_linear
            this.OES_texture_float_linear = this.getExtension('OES_texture_float_linear');
        }
        catch (error) {
            console.error(error);
            throw error;
        }
        if (this.glContext) {
            setTextureFactoryContext(this.glContext);
        }
    }
    /**
     * @deprecated Please use `setShaderPrecision` instead.
     */
    static set shaderPrecision(shaderPrecision) {
        this.setShaderPrecision(shaderPrecision);
    }
    static setShaderPrecision(shaderPrecision) {
        switch (shaderPrecision) {
            case ShaderPrecision.Low:
                this.setIncludeCode('SHADER_PRECISION', '#define LOW_PRECISION');
                break;
            case ShaderPrecision.Medium:
                this.setIncludeCode('SHADER_PRECISION', '#define MEDIUM_PRECISION');
                break;
            case ShaderPrecision.High:
                this.setIncludeCode('SHADER_PRECISION', '#define HIGH_PRECISION');
                break;
        }
    }
    static setShaderQuality(shaderQuality) {
        this.setIncludeCode('SHADER_QUALITY', `#define SHADER_QUALITY ${shaderQuality}`);
    }
    static setShaderDebugMode(shaderDebugMode) {
        this.setIncludeCode('SHADER_DEBUG_MODE', `#define SHADER_DEBUG_MODE ${shaderDebugMode}`);
    }
    static setIncludeCode(key, code) {
        this.#includeCode.set(key, code);
        this.#refreshIncludeCode();
    }
    static removeIncludeCode(key) {
        this.#includeCode.delete(key);
        this.#refreshIncludeCode();
    }
    static #refreshIncludeCode() {
        this.#globalIncludeCode = '';
        for (const code of this.#includeCode.values()) {
            this.#globalIncludeCode += code + '\n';
        }
    }
    static getIncludeCode() {
        return this.#globalIncludeCode;
    }
    /**
     * Invalidate all shader (force recompile)
     */
    static invalidateShaders() {
        if (this.#forwardRenderer) {
            this.#forwardRenderer.invalidateShaders();
        }
        /*for (let shader of this._materialsProgram) {
            shader.invalidate();
        }*/
    }
    static clearColor(clearColor) {
        WebGLRenderingState.clearColor(clearColor);
    }
    static getClearColor(clearColor) {
        return WebGLRenderingState.getClearColor(clearColor);
    }
    static clearDepth(clearDepth) {
        WebGLRenderingState.clearDepth(clearDepth);
    }
    static clearStencil(clearStencil) {
        WebGLRenderingState.clearStencil(clearStencil);
    }
    static setColorMask(mask) {
        WebGLRenderingState.colorMask(mask);
    }
    static set autoResize(autoResize) {
        this.#autoResize = autoResize;
        if (autoResize) {
            this.checkCanvasSize();
        }
    }
    static get autoResize() {
        return this.#autoResize;
    }
    static getExtension(name) {
        if (this.glContext) {
            if (this.#extensions.has(name)) {
                return this.#extensions.get(name);
            }
            else {
                const extension = this.glContext.getExtension(name);
                this.#extensions.set(name, extension);
                return extension;
            }
        }
        return null;
    }
    static set pixelRatio(pixelRatio) {
        this.#pixelRatio = pixelRatio;
        this.#updateSize();
    }
    static get pixelRatio() {
        return this.#pixelRatio;
    }
    static setSize(width, height) {
        width = Math.max(width, 1);
        height = Math.max(height, 1);
        const previousWidth = this.#width;
        const previousHeight = this.#height;
        if (isNumeric(width)) {
            this.#width = width;
        }
        if (isNumeric(height)) {
            this.#height = height;
        }
        this.#updateSize();
        GraphicsEvents.resize(width, height);
        return [previousWidth, previousHeight];
    }
    static getSize(ret = vec2.create()) {
        ret[0] = this.#width;
        ret[1] = this.#height;
        return ret;
    }
    static #updateSize() {
        if (!this.#canvas) {
            return;
        }
        this.#canvas.width = this.#width * this.#pixelRatio;
        this.#canvas.height = this.#height * this.#pixelRatio;
        if (this.#offscreenCanvas) {
            this.#offscreenCanvas.width = this.#canvas.width;
            this.#offscreenCanvas.height = this.#canvas.height;
        }
        this.setViewport(vec4.fromValues(0, 0, this.#width, this.#height)); ///ODO: optimize
    }
    static setViewport(viewport) {
        vec4.copy(this.#viewport, viewport);
        WebGLRenderingState.viewport(viewport);
    }
    /**
     * @deprecated Please use `setViewport` instead.
     */
    static set viewport(viewport) {
        this.setViewport(viewport);
    }
    static getViewport(out) {
        return vec4.copy(out, this.#viewport);
    }
    /**
     * @deprecated Please use `getViewport` instead.
     */
    static get viewport() {
        return this.getViewport(vec4.create());
    }
    static set scissor(scissor) {
        vec4.copy(this.#scissor, scissor);
        WebGLRenderingState.scissor(scissor);
    }
    static set scissorTest(scissorTest) {
        if (scissorTest) {
            WebGLRenderingState.enable(GL_SCISSOR_TEST);
        }
        else {
            WebGLRenderingState.disable(GL_SCISSOR_TEST);
        }
    }
    static checkCanvasSize() {
        if (!this.#autoResize) {
            return;
        }
        const canvas = this.#canvas;
        if (!canvas?.parentElement) {
            return;
        }
        const width = canvas.parentElement.clientWidth;
        const height = canvas.parentElement.clientHeight;
        if (width !== this.#width
            || height !== this.#height) {
            this.setSize(width, height);
        }
    }
    static #initObserver() {
        const callback = (entries, observer) => {
            entries.forEach(entry => {
                this.checkCanvasSize();
            });
        };
        const resizeObserver = new ResizeObserver(callback);
        if (this.#canvas?.parentElement) {
            resizeObserver.observe(this.#canvas.parentElement);
        }
    }
    static play() {
        this.#running = true;
        this._tick();
    }
    static pause() {
        this.#running = false;
    }
    static isRunning() {
        return this.#running;
    }
    static createFramebuffer() {
        const frameBuffer = this.glContext.createFramebuffer();
        //this.frameBuffers.add(frameBuffer);
        return frameBuffer;
    }
    static deleteFramebuffer(frameBuffer) {
        this.glContext.deleteFramebuffer(frameBuffer);
    }
    static createRenderbuffer() {
        const renderBuffer = this.glContext.createRenderbuffer();
        if (renderBuffer) {
            this.#renderBuffers.add(renderBuffer);
        }
        return renderBuffer;
    }
    static deleteRenderbuffer(renderBuffer) {
        this.glContext.deleteRenderbuffer(renderBuffer);
    }
    /*
    setFramebuffer(framebuffer: WebGLFramebuffer) {
        framebuffer.bind();
        //this.glContext.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    }
    */
    static pushRenderTarget(renderTarget) {
        this.#renderTargetStack.push(renderTarget);
        this.#setRenderTarget(renderTarget);
    }
    static popRenderTarget() {
        this.#renderTargetStack.pop();
        const renderTarget = this.#renderTargetStack[this.#renderTargetStack.length - 1];
        this.#setRenderTarget(renderTarget);
        return renderTarget ?? null;
    }
    static #setRenderTarget(renderTarget) {
        if (!renderTarget) {
            this.glContext.bindFramebuffer(GL_FRAMEBUFFER, null);
            this.viewport = vec4.fromValues(0, 0, this.#width, this.#height);
        }
        else {
            renderTarget.bind();
        }
    }
    static savePicture(scene, camera, filename, width, height, type, quality) {
        const previousWidth = this.#width;
        const previousHeight = this.#height;
        const previousAutoResize = this.autoResize;
        try {
            this.autoResize = false;
            this.setSize(width, height);
            this.render(scene, camera, 0, { DisableToolRendering: true });
            this._savePicture(filename, type, quality);
        }
        finally {
            this.autoResize = previousAutoResize;
            this.setSize(previousWidth, previousHeight);
        }
    }
    static async savePictureAsFile(filename, type, quality) {
        return new File([await this.toBlob(type, quality) ?? new Blob()], filename);
    }
    static async toBlob(type, quality) {
        let promiseResolve;
        const promise = new Promise((resolve) => {
            promiseResolve = resolve;
        });
        const callback = function (blob) {
            promiseResolve(blob);
        };
        this.#canvas?.toBlob(callback, type, quality);
        return promise;
    }
    static async _savePicture(filename, type, quality) {
        /*
        const callback = function (blob) {
            //saveFile(filename, blob);
        };
        this.#canvas.toBlob(callback);*/
        saveFile(await this.savePictureAsFile(filename, type, quality));
    }
    static startRecording(frameRate = 60, bitsPerSecond) {
        if (this.#canvas) {
            const stream = this.#canvas.captureStream(frameRate);
            this.#mediaRecorder = new MediaRecorder(stream, { mimeType: RECORDER_MIME_TYPE, bitsPerSecond: bitsPerSecond });
            this.#mediaRecorder.start();
        }
    }
    static stopRecording(fileName = RECORDER_DEFAULT_FILENAME) {
        if (!this.#mediaRecorder) {
            return;
        }
        this.#mediaRecorder.ondataavailable = (event) => {
            const blob = new Blob([event.data], { 'type': RECORDER_MIME_TYPE });
            saveFile(new File([blob], fileName));
        };
        this.#mediaRecorder.stop();
        //Stop the canvas stream
        this.#mediaRecorder?.stream.getVideoTracks()?.[0]?.stop();
    }
    static get ready() {
        return this.#readyPromise;
    }
    static async isReady() {
        await this.#readyPromise;
    }
    static getParameter(param) {
        return this.glContext?.getParameter(param);
    }
    static cleanupGLError() {
        this.glContext?.getError(); //empty the error
    }
    static getGLError(context) {
        const glError = this.glContext?.getError() ?? 0;
        if (glError) {
            console.error(`GL Error in ${context} : `, glError);
        }
    }
    static useLogDepth(use) {
        this.setIncludeCode('LOG_DEPTH', use ? '#define USE_LOG_DEPTH' : '');
    }
    static getTime() {
        return this.#time;
    }
    static getWidth() {
        return this.#width;
    }
    static getHeight() {
        return this.#height;
    }
    static getCanvas() {
        return this.#canvas;
    }
    static getForwardRenderer() {
        return this.#forwardRenderer;
    }
}
setGraphics(Graphics);

function resizeCamera(camera) {
    const w = Graphics$1.getWidth() / 2.0;
    const h = Graphics$1.getHeight() / 2.0;
    camera.left = -w;
    camera.right = w;
    camera.bottom = -h;
    camera.top = h;
    camera.aspectRatio = w / h;
}
class ContextObserverClass {
    #observed = new Map();
    #listeners = new Map();
    static #instance;
    constructor() {
        if (ContextObserverClass.#instance) {
            return ContextObserverClass.#instance;
        }
    }
    handleEvent(event) {
        const subject = event.target;
        if (!subject) {
            return;
        }
        const dependents = this.#observed.get(subject);
        if (dependents) {
            for (const dependent of dependents) {
                ContextObserverClass.#processEvent(subject, dependent, event);
            }
        }
    }
    static #processEvent(subject, dependent, event) {
        switch (true) {
            case dependent.is('Camera'):
                resizeCamera(dependent);
                break;
            case dependent instanceof FirstPersonControl: //TODO do it for any CameraControl?
            case dependent instanceof OrbitControl:
                dependent.update();
                break;
            case dependent.isRenderTargetViewer:
                dependent.refreshPlane();
                break;
        }
    }
    #addObserver(subject, dependent) {
        if (subject.isGraphicsEvents) {
            subject = subject.eventTarget;
        }
        if (!this.#observed.has(subject)) {
            this.#observed.set(subject, new Set());
        }
        this.#createListeners(subject, dependent);
        this.#observed.get(subject)?.add(dependent);
    }
    #removeObserver(subject, dependent) {
        if (this.#observed.has(subject)) {
            this.#observed.get(subject)?.delete(dependent);
            this.#removeListeners(subject, dependent);
        }
    }
    #createListeners(subject, dependent) {
        switch (true) {
            case dependent.is('Camera'):
            case dependent instanceof FirstPersonControl: //TODO do it for any CameraControl?
            case dependent instanceof OrbitControl:
            case dependent.isRenderTargetViewer:
                //subject.addEventListener('resize', this);
                this.#addListener(subject, 'resize');
                break;
        }
    }
    #removeListeners(subject, dependent) {
        const size = this.#observed.get(subject)?.size ?? 0;
        if (size == 0) {
            const types = this.#listeners.get(subject);
            if (!types) {
                return;
            }
            for (const type of types) {
                //console.log(listener);
                this.#removeListener(subject, type);
            }
        }
    }
    #addListener(target, type) {
        if (!this.#listeners.has(target)) {
            this.#listeners.set(target, new Set());
        }
        const targetSet = this.#listeners.get(target);
        if (targetSet && !targetSet.has(type)) {
            targetSet.add(type);
            target.addEventListener(type, this);
        }
    }
    #removeListener(target, type) {
        const targetSet = this.#listeners.get(target);
        if (targetSet && targetSet.has(type)) {
            targetSet.delete(type);
            target.removeEventListener(type, this);
        }
    }
    observe(subject, dependent) {
        this.#addObserver(subject, dependent);
        switch (true) {
            case dependent.is('Camera'):
                resizeCamera(dependent);
                break;
        }
    }
    unobserve(subject, dependent) {
        this.#removeObserver(subject, dependent);
    }
}
const ContextObserver = new ContextObserverClass();

let fetchFunction = null;
function setFetchFunction(func) {
    fetchFunction = func;
}
async function customFetch(resource, options) {
    try {
        if (fetchFunction) {
            return await fetchFunction(resource, options);
        }
        else {
            return await fetch(resource, options);
        }
    }
    catch (e) {
        console.error('Error during custom fetch: ', e);
        return new Response(null, { status: 400 });
    }
}

class RgbeImporter {
    #context;
    constructor(context) {
        this.#context = context;
    }
    async fetch(url) {
        const response = await customFetch(url);
        if (!response.ok) {
            return 'error while fetching resource';
        }
        return this.import(new BinaryReader(await response.arrayBuffer()));
    }
    import(reader) {
        const rgbe = decodeRGBE(reader.getDataView());
        console.info(rgbe);
        if (!rgbe) {
            return null;
        }
        const params = {
            internalFormat: TextureFormat.Rgb_32F,
            flipY: true,
        };
        if (Graphics$1.OES_texture_float_linear) {
            params.magFilter = GL_LINEAR;
            params.minFilter = GL_LINEAR;
        }
        else {
            params.magFilter = GL_NEAREST;
            params.minFilter = GL_NEAREST;
        }
        const texture = TextureManager.createTexture(params);
        texture.setParameters(this.#context, TextureTarget.TEXTURE_2D);
        texture.texImage2D(this.#context, TextureTarget.TEXTURE_2D, rgbe.width, rgbe.height, TextureFormat.Rgb, TextureType.Float, rgbe.data);
        return texture;
    }
}

class ObjFace {
    v = [];
    n = [];
    t = [];
}
class Obj {
    #vertices = [];
    #normals = [];
    #uvs = [];
    #faces = [];
    addVertex(v) {
        this.#vertices.push(v);
    }
    addNormal(n) {
        this.#normals.push(n);
    }
    addUv(t) {
        this.#uvs.push(t);
    }
    addFace(f) {
        this.#faces.push(f);
    }
    toMesh() {
        //TODO: handle polygons and commons vertices
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        const hasNormals = this.#normals.length > 0;
        const hasUv = this.#uvs.length > 0;
        let i = 0;
        for (const f of this.#faces) {
            indices.push(i, i + 1, i + 2);
            i += 3;
            vertices.push(...this.#vertices[f.v[0]]);
            vertices.push(...this.#vertices[f.v[1]]);
            vertices.push(...this.#vertices[f.v[2]]);
            if (hasNormals) {
                normals.push(...this.#normals[f.n[0]]);
                normals.push(...this.#normals[f.n[1]]);
                normals.push(...this.#normals[f.n[2]]);
            }
            if (hasUv) {
                uvs.push(...this.#uvs[f.t[0]]);
                uvs.push(...this.#uvs[f.t[1]]);
                uvs.push(...this.#uvs[f.t[2]]);
            }
        }
        return { i: indices, v: vertices, n: normals, t: uvs };
    }
}

function readVertex(line) {
    const arr = line.split(' ');
    return vec3.fromValues(Number(arr[1] ?? 0.0), Number(arr[2] ?? 0.0), Number(arr[3] ?? 0.0) /*, arr[4] ?? 1.0*/);
}
function readVertexCoord(line) {
    const arr = line.split(' ');
    return vec2.fromValues(Number(arr[1] ?? 0.0), Number(arr[2] ?? 0));
}
function readVertexNormal(line) {
    const arr = line.split(' ');
    const v = vec3.fromValues(Number(arr[1] ?? 1.0), Number(arr[2] ?? 1), Number(arr[3] ?? 1));
    return vec3.normalize(v, v);
}
function readFace(line) {
    const arr = line.split(' ');
    const face = new ObjFace();
    for (let i = 1; i < arr.length; i++) {
        const v = arr[i];
        ///let faceVertex = [];
        if (v) {
            const v2 = v.split('/');
            //faceVertex.push(v2[0] ?? 0, v2[1] ?? 0, v2[2] ?? 0);
            face.v.push(Number(v2[0] ?? 1) - 1);
            face.t.push(Number(v2[1] ?? 1) - 1);
            face.n.push(Number(v2[2] ?? 1) - 1);
        }
        else {
            //			faceVertex.push(0, 0, 0);
            face.v.push(0);
            face.n.push(0);
            face.t.push(0);
        }
        //face.push(faceVertex);
    }
    return face;
}
function buildMesh(obj) {
    const geometry = new BufferGeometry();
    const material = new MeshBasicMaterial();
    const m = obj.toMesh();
    geometry.setIndex(new Uint32BufferAttribute(m.i, 1));
    geometry.setAttribute('aVertexPosition', new Float32BufferAttribute(m.v, 3));
    geometry.setAttribute('aVertexNormal', new Float32BufferAttribute(m.n, 3));
    geometry.setAttribute('aTextureCoord', new Float32BufferAttribute(m.t, 2));
    geometry.count = m.i.length;
    return new Mesh({ geometry: geometry, material: material });
}
class OBJImporter {
    static load(txt) {
        const lines = txt.split('\n');
        const obj = new Obj();
        for (let line of lines) {
            line = line.trim();
            line = line.replace(/\s+/g, ' ');
            if (line.startsWith('v ')) {
                //vertices.push(readVertex(line));
                obj.addVertex(readVertex(line));
            }
            else if (line.startsWith('vt ')) {
                //verticesCoords.push(readVertexCoord(line));
                obj.addUv(readVertexCoord(line));
            }
            else if (line.startsWith('vn ')) {
                //verticesNormals.push(readVertexNormal(line));
                obj.addNormal(readVertexNormal(line));
            }
            else if (line.startsWith('f ')) {
                //faces.push(readFace(line));
                obj.addFace(readFace(line));
            }
        }
        return buildMesh(obj);
        //return buildMesh(vertices, verticesNormals, verticesCoords, faces);
    }
}

class LineBasicMaterial extends Material {
    lineWidth;
    constructor(params = {}) {
        super(params);
        this.color = vec4.fromValues(1.0, 1.0, 1.0, 1.0);
        this.lineWidth = 1;
        this.setValues(params);
    }
    getShaderSource() {
        return 'meshbasic';
    }
}
Material.materialList['LineBasic'] = LineBasicMaterial;

const SPHERE_RADIUS = 1;
const RAYS_RADIUS = 3;
class PointLightHelper extends Mesh {
    constructor(params = {}) {
        params.geometry = new BufferGeometry();
        params.material = new LineBasicMaterial();
        super(params);
        this.renderMode = GL_LINES;
        this.#createVertices();
        this.material.setColorMode(MaterialColorMode.PerMesh);
        this.material.setDefine('ALWAYS_ON_TOP');
        const sphere = new Sphere({ radius: SPHERE_RADIUS, segments: 12, rings: 12 });
        sphere.material.setDefine('ALWAYS_ON_TOP');
        this.addChild(sphere);
    }
    #createVertices() {
        const indices = [];
        const vertices = [];
        vertices.push(0, 0, 0);
        const iInc = PI / 4;
        const jInc = PI / 4;
        let k = 0;
        for (let i = 0; i < TWO_PI; i += iInc) {
            for (let j = 0; j < PI; j += jInc) {
                vertices.push(RAYS_RADIUS * Math.cos(i) * Math.sin(j), RAYS_RADIUS * Math.cos(j), RAYS_RADIUS * Math.sin(i) * Math.sin(j));
                indices.push(0, ++k);
            }
        }
        const geometry = this.geometry;
        geometry.setIndex(new Uint16BufferAttribute(indices, 1));
        geometry.setAttribute('aVertexPosition', new Float32BufferAttribute(vertices, 3));
        geometry.count = indices.length;
    }
}

const DEFAULT_LIGHT_COLOR = vec3.fromValues(1, 1, 1);
let defaultTextureSize = 1024;
class Light extends Entity {
    #intensity;
    #color; // TODO: use Color instead
    #range = 1000;
    shadow;
    #shadowTextureSize = defaultTextureSize;
    isLight = true;
    constructor(parameters = {}) {
        super(parameters);
        this.#color = vec3.clone(parameters.color ?? DEFAULT_LIGHT_COLOR);
        this.#intensity = parameters.intensity ?? 1.0;
        this.castShadow = false;
        this.isRenderable = true;
    }
    set color(color) {
        vec3.copy(this.#color, color);
    }
    get color() {
        return this.#color;
    }
    set intensity(intensity) {
        this.#intensity = intensity;
    }
    get intensity() {
        return this.#intensity;
    }
    set range(range) {
        this.#range = range;
        if (this.shadow) {
            this.shadow.range = range;
        }
    }
    get range() {
        return this.#range;
    }
    set shadowTextureSize(shadowTextureSize) {
        this.#shadowTextureSize = shadowTextureSize;
        if (this.shadow) {
            this.shadow.textureSize = shadowTextureSize;
        }
    }
    get shadowTextureSize() {
        return this.#shadowTextureSize;
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), {
            Light_1: null,
            color: { i18n: '#color', f: () => { const color = prompt('Color', this.color.join(' ')); if (color !== null) {
                    this.color = stringToVec3(color);
                } } },
            intensity: { i18n: '#intensity', f: () => { const intensity = prompt('Intensity', String(this.intensity)); if (intensity !== null) {
                    this.intensity = Number(intensity);
                } } },
        }, this.shadow ? {
            texture_size: { i18n: '#texture_size', f: () => { const textureSize = prompt('Texture size', String(this.shadow?.textureSize[0] ?? defaultTextureSize)); if (textureSize !== null) {
                    this.shadowTextureSize = Number.parseFloat(textureSize);
                } } }
        } : null);
    }
    toJSON() {
        const json = super.toJSON();
        json.color = this.color;
        json.intensity = this.intensity;
        json.shadowtexturesize = this.shadowTextureSize;
        return json;
    }
    static async constructFromJSON(json) {
        return new Light(json);
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.color = json.color ?? DEFAULT_LIGHT_COLOR;
        this.intensity = json.intensity ?? 1;
        this.shadowTextureSize = json.shadowtexturesize ?? defaultTextureSize;
    }
    static set defaultTextureSize(textureSize) {
        defaultTextureSize = textureSize;
    }
    static getEntityName() {
        return 'Light';
    }
    is(s) {
        return s == 'Light';
    }
}
registerEntity(Light);

mat4.create();
class LightShadow {
    #textureSize = vec2.create();
    light;
    camera;
    shadowMatrix = mat4.create();
    viewPorts;
    viewPortsLength;
    renderTarget;
    constructor(light, camera) {
        camera.hideInExplorer = true;
        camera.serializable = false;
        light.addChild(camera);
        this.light = light;
        this.camera = camera;
        this.#textureSize = vec2.set(this.#textureSize, light.shadowTextureSize, light.shadowTextureSize);
        this.shadowMatrix = mat4.create();
        this.viewPorts = [vec4.fromValues(0, 0, 1, 1)];
        this.viewPortsLength = 1;
        this.renderTarget = new RenderTarget({ width: this.#textureSize[0], height: this.#textureSize[0], });
        this.renderTarget.resize(this.#textureSize[0], this.#textureSize[1]);
    }
    set range(range) {
    }
    set textureSize(textureSize) {
        vec2.set(this.#textureSize, textureSize, textureSize);
        this.renderTarget.resize(this.#textureSize[0], this.#textureSize[1]);
    }
    get textureSize() {
        return this.#textureSize;
    }
    computeShadowMatrix(mapIndex) {
        const shadowCamera = this.camera;
        const shadowMatrix = this.shadowMatrix;
        mat4.set(shadowMatrix, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);
        shadowCamera.dirty();
        mat4.mul(shadowMatrix, shadowMatrix, shadowCamera.projectionMatrix);
        mat4.mul(shadowMatrix, shadowMatrix, shadowCamera.worldMatrixInverse);
    }
}

class SpotLightShadow extends LightShadow {
    constructor(light) {
        super(light, new Camera()); //TODO: adjust default variables
        const textureSize = this.textureSize;
        this.aspect = textureSize[0] / textureSize[1];
        this.angle = this.light.angle;
        this.range = this.light.range;
    }
    set angle(angle) {
        this.camera.verticalFov = RAD_TO_DEG * 2.0 * angle;
    }
    set range(range) {
        this.camera.farPlane = range;
    }
    set aspect(aspect) {
        this.camera.aspectRatio = aspect;
    }
}

const DEFAULT_ANGLE = Math.PI / 4.0;
const Z_VECTOR = vec3.fromValues(0, 0, 1);
const tempQuat$8 = quat.create();
class SpotLight extends Light {
    isSpotLight = true;
    #innerAngle;
    innerAngleCos;
    #outerAngle;
    outerAngleCos;
    constructor(parameters = {}) {
        super(parameters);
        this.angle = DEFAULT_ANGLE;
        this.innerAngle = DEFAULT_ANGLE;
        this.range = 0;
    }
    set castShadow(castShadow) {
        super.castShadow = castShadow;
        if (this.castShadow) {
            this.shadow = new SpotLightShadow(this);
            this.shadow.range = this.range;
            this.shadow.angle = this.#outerAngle;
        }
    }
    get castShadow() {
        return super.castShadow;
    }
    set angle(angle) {
        this.#outerAngle = angle;
        this.outerAngleCos = Math.cos(angle);
        if (this.shadow) {
            this.shadow.angle = angle;
        }
    }
    get angle() {
        return this.#outerAngle;
    }
    set innerAngle(innerAngle) {
        this.#innerAngle = innerAngle;
        this.innerAngleCos = Math.cos(innerAngle);
    }
    get innerAngle() {
        return this.#innerAngle;
    }
    getDirection(out = vec3.create()) {
        return vec3.transformQuat(out, Z_VECTOR, this.getWorldQuaternion(tempQuat$8));
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), {
            angle: { i18n: '#angle', f: () => { const angle = prompt('Angle', String(this.angle)); if (angle !== null) {
                    this.angle = Number(angle);
                } } },
            inner_angle: { i18n: '#inner_angle', f: () => { const innerAngle = prompt('Inner angle', String(this.#innerAngle)); if (innerAngle !== null) {
                    this.innerAngle = Number(innerAngle);
                } } },
            range: { i18n: '#range', f: () => { const range = prompt('Range', String(this.range)); if (range !== null) {
                    this.range = Number(range);
                } } },
        });
    }
    static getEntityName() {
        return 'SpotLight';
    }
}
registerEntity(SpotLight);

const DIVISIONS = 32;
const tempVec4$1 = vec4.create();
class SpotLightHelper extends Mesh {
    #color = vec3.create(); // TODO: use Color instead
    #angle = 0;
    #range = 0;
    #spotLight = null;
    #vertexPositionAttribute;
    constructor(params = {}) {
        params.geometry = new BufferGeometry();
        params.material = new LineBasicMaterial();
        super(params);
        this.renderMode = GL_LINES;
        this.#createVertices();
        this.material.setMeshColor();
        this.material.setDefine('ALWAYS_ON_TOP');
        this.castShadow = false;
        GraphicsEvents.addEventListener(GraphicsEvent.Tick, event => this.update());
    }
    #createVertices() {
        const indices = [];
        const vertices = [];
        vertices.push(0, 0, 0);
        let k = 1;
        for (let i = 0; i < DIVISIONS; i += 1) {
            vertices.push(0, 0, 0);
            indices.push(0, k);
            if (k < DIVISIONS) {
                //segement til next point
                indices.push(k, ++k);
            }
        }
        //close loop
        indices.push(k, 1);
        const geometry = this.geometry;
        geometry.setIndex(new Uint16BufferAttribute(indices, 1));
        this.#vertexPositionAttribute = new Float32BufferAttribute(vertices, 3);
        geometry.setAttribute('aVertexPosition', this.#vertexPositionAttribute);
        geometry.count = indices.length;
    }
    update() {
        const spotLight = this.#spotLight;
        if (spotLight && ((this.#range != spotLight.range) || (this.#angle != spotLight.angle) || (!vec3.exactEquals(spotLight.color, this.#color)))) {
            vec3.copy(this.#color, spotLight.color);
            vec4.set(tempVec4$1, this.#color[0], this.#color[1], this.#color[2], 1.);
            this.material.setMeshColor(tempVec4$1);
            const range = spotLight.range || 1000.0;
            const radius = Math.sin(spotLight.angle) * range;
            this.#range = spotLight.range;
            this.#angle = spotLight.angle;
            const verticesArray = this.#vertexPositionAttribute._array;
            for (let i = 0; i < DIVISIONS; i += 1) {
                const angle = i * TWO_PI / DIVISIONS;
                const index = (i + 1) * 3;
                verticesArray[index + 0] = Math.cos(angle) * radius;
                verticesArray[index + 1] = Math.sin(angle) * radius;
                verticesArray[index + 2] = -range;
                verticesArray.subarray(index, index + 2);
            }
            this.#vertexPositionAttribute.dirty = true;
        }
    }
    parentChanged(parent = null) {
        if (parent instanceof SpotLight) {
            this.#spotLight = parent;
        }
        else {
            this.#spotLight = null;
        }
        this.update();
    }
}

class AmbientLight extends Light {
    isAmbientLight = true;
    constructor(params = {}) {
        super(params);
    }
    static async constructFromJSON(json) {
        return new AmbientLight(json);
    }
    static getEntityName() {
        return 'AmbientLight';
    }
    is(s) {
        if (s == 'AmbientLight') {
            return true;
        }
        else {
            return super.is(s);
        }
    }
}
registerEntity(AmbientLight);

const worldPos = vec3.create();
[
    vec3.fromValues(1, 0, 0), vec3.fromValues(-1, 0, 0), vec3.fromValues(0, 0, 1),
    vec3.fromValues(0, 0, -1), vec3.fromValues(0, 1, 0), vec3.fromValues(0, -1, 0)
];
[
    vec3.fromValues(0, 1, 0), vec3.fromValues(0, 1, 0), vec3.fromValues(0, 1, 0),
    vec3.fromValues(0, 1, 0), vec3.fromValues(0, 0, 1), vec3.fromValues(0, 0, -1)
];
const S2 = Math.SQRT1_2;
const DIRECTIONS = [
    quat.fromValues(0, -S2, 0, S2), //+x
    quat.fromValues(0, S2, 0, S2), //-x
    quat.fromValues(0, 1, 0, 0), //+z
    quat.fromValues(0, 0, 0, 1), //-z
    quat.fromValues(S2, 0, 0, S2), //+y
    quat.fromValues(-S2, 0, 0, S2), //-y
];
class PointLightShadow extends LightShadow {
    constructor(light) {
        super(light, new Camera({ nearPlane: 1, farPlane: 1000, verticalFov: 90 })); //TODO: adjust default variables
        this.range = this.light.range;
        this.viewPorts = [
            vec4.fromValues(0.5, 0.5, 0.25, 0.5),
            vec4.fromValues(0, 0.5, 0.25, 0.5),
            vec4.fromValues(0.75, 0.5, 0.25, 0.5),
            vec4.fromValues(0.25, 0.5, 0.25, 0.5),
            vec4.fromValues(0.75, 0, 0.25, 0.5),
            vec4.fromValues(0.25, 0, 0.25, 0.5),
            /*vec4.fromValues(2, 1, 1, 1),
            vec4.fromValues(0, 1, 1, 1),
            vec4.fromValues(3, 1, 1, 1),
            vec4.fromValues(1, 1, 1, 1),
            vec4.fromValues(3, 0, 1, 1),
            vec4.fromValues(1, 0, 1, 1),*/
        ];
        this.viewPortsLength = 6;
    }
    computeShadowMatrix(mapIndex) {
        const shadowCamera = this.camera;
        const shadowMatrix = this.shadowMatrix;
        const direction = DIRECTIONS[mapIndex];
        if (direction) {
            shadowCamera.setWorldQuaternion(direction);
        }
        shadowCamera.dirty();
        shadowCamera.getWorldPosition(worldPos);
        vec3.scale(worldPos, worldPos, -1);
        mat4.fromTranslation(shadowMatrix, worldPos);
    }
}

class PointLight extends Light {
    isPointLight = true;
    constructor(params = {}) {
        super(params);
        this.range = params.range ?? 100.0;
    }
    set castShadow(castShadow) {
        super.castShadow = castShadow;
        if (this.castShadow) {
            this.shadow = new PointLightShadow(this);
            this.shadow.range = this.range;
        }
    }
    get castShadow() {
        return super.castShadow;
    }
    toJSON() {
        const json = super.toJSON();
        json.range = this.range;
        return json;
    }
    static async constructFromJSON(json) {
        return new PointLight(json);
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.range = json.range ?? this.range;
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), {
            range: { i18n: '#range', f: () => { const range = prompt('Range', String(this.range)); if (range !== null) {
                    this.range = Number(range);
                } } },
        });
    }
    static getEntityName() {
        return 'PointLight';
    }
    is(s) {
        if (s == 'PointLight') {
            return true;
        }
        else {
            return super.is(s);
        }
    }
}
registerEntity(PointLight);

const loaders = new Map();
function registerLoader(name, loader) {
    loaders.set(name, loader);
}
function getLoader(name) {
    return loaders.get(name);
}

const DEFAULT_POINT = vec3.create();
class Curve {
    controlPoints = [];
    arcLength = 0;
    getPosition(t, out = vec3.create()) {
        return out;
    }
    getArcLength(divisions = 100) {
        vec3.create();
        let last = vec3.create();
        let current = vec3.create();
        let temp;
        this.getPosition(0, last);
        let length = 0;
        for (let i = 1; i <= divisions; i++) {
            this.getPosition(i / divisions, current);
            length += vec3.distance(last, current);
            temp = last;
            last = current;
            current = temp;
        }
        return length;
    }
    getPoints(divisions = 5) {
        const points = [];
        for (let i = 0; i <= divisions; i++) {
            points.push(this.getPosition(i / divisions));
        }
        return points;
    }
    getAppropriateDivision(division) {
        return division;
    }
}

class CubicBezierCurve extends Curve {
    p0 = vec3.create();
    p1 = vec3.create();
    p2 = vec3.create();
    p3 = vec3.create();
    constructor(p0 = DEFAULT_POINT, p1 = DEFAULT_POINT, p2 = DEFAULT_POINT, p3 = DEFAULT_POINT) {
        super();
        vec3.copy(this.p0, p0);
        vec3.copy(this.p1, p1);
        vec3.copy(this.p2, p2);
        vec3.copy(this.p3, p3);
        this.arcLength = this.getArcLength();
    }
    getPosition(t, out = vec3.create()) {
        //P = (1 - t)³ * P0 + 3 * (1 - t)² * t * P1 + 3 * (1 - t) * t² * P2 + t³ * P3
        const oneMinusT = 1 - t;
        const oneMinusTSqr = oneMinusT * oneMinusT;
        const tSqr = t * t;
        vec3.scale(out, this.p0, oneMinusTSqr * oneMinusT);
        vec3.scaleAndAdd(out, out, this.p1, 3 * oneMinusTSqr * t);
        vec3.scaleAndAdd(out, out, this.p2, 3 * oneMinusT * tSqr);
        vec3.scaleAndAdd(out, out, this.p3, tSqr * t);
        return out;
    }
}

class LinearBezierCurve extends Curve {
    p0 = vec3.create();
    p1 = vec3.create();
    constructor(p0 = DEFAULT_POINT, p1 = DEFAULT_POINT) {
        super();
        vec3.copy(this.p0, p0);
        vec3.copy(this.p1, p1);
        this.arcLength = this.getArcLength();
    }
    getPosition(t, out = vec3.create()) {
        if (t === 0) {
            vec3.copy(out, this.p0);
        }
        else if (t === 1) {
            vec3.copy(out, this.p1);
        }
        else {
            vec3.sub(out, this.p1, this.p0);
            vec3.scaleAndAdd(out, this.p0, out, t);
        }
        return out;
    }
    getArcLength() {
        return vec3.distance(this.p0, this.p1);
    }
    getAppropriateDivision() {
        return 1;
    }
}

class QuadraticBezierCurve extends Curve {
    p0 = vec3.create();
    p1 = vec3.create();
    p2 = vec3.create();
    constructor(p0 = DEFAULT_POINT, p1 = DEFAULT_POINT, p2 = DEFAULT_POINT) {
        super();
        vec3.copy(this.p0, p0);
        vec3.copy(this.p1, p1);
        vec3.copy(this.p2, p2);
        this.arcLength = this.getArcLength();
    }
    getPosition(t, out = vec3.create()) {
        //P = (1 - t)² * P0 + 2 * (1 - t) * t * P1 + t² * P2
        const oneMinusT = 1 - t;
        vec3.scale(out, this.p0, oneMinusT * oneMinusT);
        vec3.scaleAndAdd(out, out, this.p1, 2 * oneMinusT * t);
        vec3.scaleAndAdd(out, out, this.p2, t * t);
        return out;
    }
}

const p0$1 = vec3.create();
const p1$1 = vec3.create();
const p2$1 = vec3.create();
const p3$1 = vec3.create();
class Path extends Curve {
    looping;
    _curves = [];
    cursor = vec3.create();
    constructor(looping = false) {
        super();
        this.looping = looping;
    }
    set curves(curves) {
        this._curves.splice(0, Infinity, ...curves);
        this.arcLength = this.getArcLength();
    }
    get curves() {
        return this._curves;
    }
    addCurve(curve) {
        this._curves.push(curve);
        this.arcLength = this.getArcLength();
    }
    getArcLength(divisions) {
        let length = 0;
        for (const curve of this._curves) {
            length += curve.getArcLength(divisions);
        }
        return length;
    }
    getPosition(t, out = vec3.create()) {
        const l = this.arcLength * t;
        let accumulate = 0;
        let accumulateTmp = 0;
        for (const curve of this._curves) {
            accumulateTmp += curve.arcLength;
            if (accumulateTmp > l) {
                const t2 = (l - accumulate) / curve.arcLength;
                return curve.getPosition(t2, out);
            }
            accumulate = accumulateTmp;
        }
        return out;
    }
    moveTo(p0) {
        vec3.copy(this.cursor, p0);
    }
    lineTo(p1) {
        this.addCurve(new LinearBezierCurve(this.cursor, p1));
        vec3.copy(this.cursor, p1);
    }
    quadraticCurveTo(p1, p2) {
        this.addCurve(new QuadraticBezierCurve(this.cursor, p1, p2));
        vec3.copy(this.cursor, p2);
    }
    bezierCurveTo(p1, p2, p3) {
        const curve = new CubicBezierCurve(this.cursor, p1, p2, p3);
        this.curves.push(curve);
        vec3.copy(this.cursor, p3);
        return this;
    }
    cubicCurveTo(p1, p2, p3) {
        this.addCurve(new CubicBezierCurve(this.cursor, p1, p2, p3));
        vec3.copy(this.cursor, p3);
    }
    getPoints(divisions = 12) {
        const points = [];
        let last;
        for (let i = 0, curves = this.curves; i < curves.length; i++) {
            const curve = curves[i];
            const resolution = curve.getAppropriateDivision(divisions);
            const pts = curve.getPoints(resolution);
            for (let j = 0; j < pts.length; j++) {
                const point = pts[j];
                if (last && vec3.equals(last, point)) {
                    continue;
                }
                points.push(point);
                last = point;
            }
        }
        if (this.looping && points.length > 1 && !vec3.equals(points[0], points[points.length - 1])) {
            points.push(points[0]);
        }
        return points;
    }
    fromSvgPath(path) {
        const pathArray = path.split(' ');
        for (let i = 0, l = pathArray.length; i < l;) {
            switch (pathArray[i++]) {
                case 'm':
                    vec3.set(p0$1, Number(pathArray[i++]), Number(pathArray[i++]), 0);
                    this.moveTo(p0$1);
                    break;
                case 'l':
                    vec3.set(p1$1, Number(pathArray[i++]), Number(pathArray[i++]), 0);
                    this.lineTo(p1$1);
                    break;
                case 'q':
                    vec3.set(p2$1, Number(pathArray[i++]), Number(pathArray[i++]), 0);
                    vec3.set(p1$1, Number(pathArray[i++]), Number(pathArray[i++]), 0);
                    this.quadraticCurveTo(p1$1, p2$1);
                    break;
                case 'c':
                    vec3.set(p3$1, Number(pathArray[i++]), Number(pathArray[i++]), 0);
                    vec3.set(p1$1, Number(pathArray[i++]), Number(pathArray[i++]), 0);
                    vec3.set(p2$1, Number(pathArray[i++]), Number(pathArray[i++]), 0);
                    this.cubicCurveTo(p1$1, p2$1, p3$1);
                    break;
            }
        }
    }
}

class Shape extends Path {
    uuid = generateRandomUUID();
    type = 'Shape';
    holes = [];
    getPointsHoles(divisions) {
        const holesPts = [];
        for (let i = 0, l = this.holes.length; i < l; i++) {
            holesPts[i] = this.holes[i].getPoints(divisions);
        }
        return holesPts;
    }
    // get points of shape and holes (keypoints based on segments parameter)
    extractPoints(divisions) {
        return {
            shape: this.getPoints(divisions),
            holes: this.getPointsHoles(divisions)
        };
    }
}

/**
 * Port from https://github.com/mapbox/earcut (v2.2.2)
 */
const Earcut = {
    triangulate: function (data, holeIndices, dim = 2) {
        const hasHoles = holeIndices.length > 0;
        const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        let outerNode = linkedList(data, 0, outerLen, dim, true);
        const triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev)
            return triangles;
        let minX = 0, minY = 0, maxX, maxY, x, y, invSize = 0;
        if (hasHoles)
            outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
        if (data.length > 80 * dim) {
            minX = maxX = data[0];
            minY = maxY = data[1];
            for (let i = dim; i < outerLen; i += dim) {
                x = data[i];
                y = data[i + 1];
                if (x < minX)
                    minX = x;
                if (y < minY)
                    minY = y;
                if (x > maxX)
                    maxX = x;
                if (y > maxY)
                    maxY = y;
            }
            // minX, minY and invSize are later used to transform coords into integers for z-order calculation
            invSize = Math.max(maxX - minX, maxY - minY);
            invSize = invSize !== 0 ? 1 / invSize : 0;
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
        return triangles;
    }
};
// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    let i, last;
    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) {
            last = insertNode(i, data[i], data[i + 1], last);
        }
    }
    else {
        for (i = end - dim; i >= start; i -= dim) {
            last = insertNode(i, data[i], data[i + 1], last);
        }
    }
    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }
    return last;
}
// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) {
        return start;
    }
    if (!end) {
        end = start;
    }
    let p = start, again;
    do {
        again = false;
        if (!p.steiner && (equals(p, p.next) || area$1(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next)
                break;
            again = true;
        }
        else {
            p = p.next;
        }
    } while (again || p !== end);
    return end ?? null;
}
// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) {
        return;
    }
    // interlink polygon nodes in z-order
    if (!pass && invSize)
        indexCurve(ear, minX, minY, invSize);
    let stop = ear, prev, next;
    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);
            removeNode(ear);
            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;
            continue;
        }
        ear = next;
        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
                // if this didn't work, try curing all small self-intersections locally
            }
            else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
                // as a last resort, try splitting the remaining polygon into two
            }
            else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }
            break;
        }
    }
}
// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    const a = ear.prev, b = ear, c = ear.next;
    if (area$1(a, b, c) >= 0)
        return false; // reflex, can't be an ear
    // now make sure we don't have other points inside the potential ear
    let p = ear.next.next;
    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area$1(p.prev, p, p.next) >= 0)
            return false;
        p = p.next;
    }
    return true;
}
function isEarHashed(ear, minX, minY, invSize) {
    const a = ear.prev, b = ear, c = ear.next;
    if (area$1(a, b, c) >= 0)
        return false; // reflex, can't be an ear
    // triangle bbox; min & max are calculated like this for speed
    const minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x), minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y), maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x), maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);
    // z-order range for the current triangle bbox;
    const minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
    let p = ear.prevZ, n = ear.nextZ;
    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area$1(p.prev, p, p.next) >= 0)
            return false;
        p = p.prevZ;
        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area$1(n.prev, n, n.next) >= 0)
            return false;
        n = n.nextZ;
    }
    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area$1(p.prev, p, p.next) >= 0)
            return false;
        p = p.prevZ;
    }
    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area$1(n.prev, n, n.next) >= 0)
            return false;
        n = n.nextZ;
    }
    return true;
}
// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    let p = start;
    do {
        const a = p.prev, b = p.next.next;
        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);
            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);
            p = start = b;
        }
        p = p.next;
    } while (p !== start);
    return filterPoints(p);
}
// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    let a = start;
    do {
        let b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                let c = splitPolygon(a, b);
                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);
                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize);
                earcutLinked(c, triangles, dim, minX, minY, invSize);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}
// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    const queue = [];
    let i, len, start, end, list;
    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next)
            list.steiner = true;
        queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }
    return outerNode;
}
function compareX(a, b) {
    return a.x - b.x;
}
// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    const node = findHoleBridge(hole, outerNode);
    if (node) {
        const b = splitPolygon(node, hole);
        // filter collinear points around the cuts
        filterPoints(node, node.next);
        filterPoints(b, b.next);
    }
}
// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    let p = outerNode;
    const hx = hole.x;
    const hy = hole.y;
    let qx = -Infinity, m;
    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y)
                        return p;
                    if (hy === p.next.y)
                        return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);
    if (!m)
        return null;
    if (hx === qx)
        return m; // hole touches outer segment; pick leftmost endpoint
    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point
    const stop = m, mx = m.x, my = m.y;
    let tanMin = Infinity, tan;
    p = m;
    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
            pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
            if (locallyInside(p, hole) && (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                m = p;
                tanMin = tan;
            }
        }
        p = p.next;
    } while (p !== stop);
    return m;
}
// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area$1(m.prev, m, p.prev) < 0 && area$1(p.next, m, m.next) < 0;
}
// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    let p = start;
    do {
        if (p.z === null) {
            p.z = zOrder(p.x, p.y, minX, minY, invSize);
        }
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);
    if (p.prevZ) {
        p.prevZ.nextZ = null;
        p.prevZ = null;
    }
    sortLinked(p);
}
// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(unSortedList) {
    let i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
    do {
        p = unSortedList;
        tail = null;
        numMerges = 0;
        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q)
                    break;
            }
            qSize = inSize;
            while (pSize > 0 || (qSize > 0 && q)) {
                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                }
                else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }
                if (tail)
                    tail.nextZ = e;
                e.prevZ = tail;
                tail = e;
            }
            p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
    } while (numMerges > 1);
    return unSortedList;
}
// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;
    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;
    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;
    return x | (y << 1);
}
// find the leftmost node of a polygon ring
function getLeftmost(start) {
    let p = start, leftmost = start;
    do {
        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y))
            leftmost = p;
        p = p.next;
    } while (p !== start);
    return leftmost;
}
// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
        (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
        (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}
// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
        (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
            (area$1(a.prev, a, b.prev) !== 0 || area$1(a, b.prev, b)) !== 0 || // does not create opposite-facing sectors
            equals(a, b) && area$1(a.prev, a, a.next) > 0 && area$1(b.prev, b, b.next) > 0); // special zero-length case
}
// signed area of a triangle
function area$1(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}
// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    const o1 = sign$1(area$1(p1, q1, p2));
    const o2 = sign$1(area$1(p1, q1, q2));
    const o3 = sign$1(area$1(p2, q2, p1));
    const o4 = sign$1(area$1(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4)
        return true; // general case
    if (o1 === 0 && onSegment(p1, p2, q1))
        return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1))
        return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2))
        return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2))
        return true; // p2, q2 and q1 are collinear and q1 lies on p2q2
    return false;
}
// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign$1(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}
// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    let p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
            intersects(p, p.next, a, b))
            return true;
        p = p.next;
    } while (p !== a);
    return false;
}
// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area$1(a.prev, a, a.next) < 0 ?
        area$1(a, b, a.next) >= 0 && area$1(a, a.prev, b) >= 0 :
        area$1(a, b, a.prev) < 0 || area$1(a, a.next, b) < 0;
}
// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    let p = a, inside = false;
    const px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
            (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);
    return inside;
}
// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    const a2 = new Node$1(a.i, a.x, a.y), b2 = new Node$1(b.i, b.x, b.y), an = a.next, bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
}
// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    const p = new Node$1(i, x, y);
    if (!last) {
        p.prev = p;
        p.next = p;
    }
    else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}
function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ)
        p.prevZ.nextZ = p.nextZ;
    if (p.nextZ)
        p.nextZ.prevZ = p.prevZ;
}
let Node$1 = class Node {
    // vertex index in coordinates array
    i;
    // vertex coordinates
    x;
    y;
    // previous and next vertex nodes in a polygon ring
    prev;
    next;
    // previous and next nodes in z-order
    prevZ = null;
    nextZ = null;
    // z-order curve value
    z = null;
    // indicates whether this is a steiner point
    steiner = false;
    constructor(i, x, y) {
        // vertex index in coordinates array
        this.i = i;
        // vertex coordinates
        this.x = x;
        this.y = y;
    }
};
function signedArea(data, start, end, dim) {
    let sum = 0;
    for (let i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

class ShapeUtils {
    // calculate area of the contour polygon
    static area(contour) {
        const n = contour.length;
        let a = 0.0;
        for (let p = n - 1, q = 0; q < n; p = q++) {
            a += contour[p][0] * contour[q][1] - contour[q][0] * contour[p][1];
        }
        return a * 0.5;
    }
    static isClockWise(pts) {
        return ShapeUtils.area(pts) < 0;
    }
    static triangulateShape(contour, holes) {
        const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
        const holeIndices = []; // array of hole indices
        const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]
        removeDupEndPts(contour);
        addContour(vertices, contour);
        //
        let holeIndex = contour.length;
        holes.forEach(removeDupEndPts);
        for (let i = 0; i < holes.length; i++) {
            holeIndices.push(holeIndex);
            holeIndex += holes[i].length;
            addContour(vertices, holes[i]);
        }
        //
        const triangles = Earcut.triangulate(vertices, holeIndices);
        //
        for (let i = 0; i < triangles.length; i += 3) {
            faces.push(triangles.slice(i, i + 3));
        }
        return faces;
    }
}
function removeDupEndPts(points) {
    const l = points.length;
    if (l > 2 && vec2.equals(points[l - 1], points[0])) {
        points.pop();
    }
}
function addContour(vertices, contour) {
    for (let i = 0; i < contour.length; i++) {
        vertices.push(contour[i][0]);
        vertices.push(contour[i][1]);
    }
}

class ShapePath {
    type = 'ShapePath';
    subPaths = [];
    currentPath = null;
    moveTo(x, y) {
        this.currentPath = new Path();
        this.subPaths.push(this.currentPath);
        this.currentPath.moveTo([x, y, 0]);
        return this;
    }
    lineTo(x, y) {
        this.currentPath.lineTo([x, y, 0]);
        return this;
    }
    quadraticCurveTo(aCPx, aCPy, aX, aY) {
        this.currentPath.quadraticCurveTo([aCPx, aCPy, 0], [aX, aY, 0]);
        return this;
    }
    bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        this.currentPath.bezierCurveTo([aCP1x, aCP1y, 0], [aCP2x, aCP2y, 0], [aX, aY, 0]);
        return this;
    }
    /*
    splineThru(pts) {
        this.currentPath.splineThru(pts);
        return this;
    }
    */
    toShapes(isCCW, noHoles = false) {
        function toShapesNoHoles(inSubpaths) {
            const shapes = [];
            for (let i = 0, l = inSubpaths.length; i < l; i++) {
                const tmpPath = inSubpaths[i];
                const tmpShape = new Shape();
                tmpShape.curves = tmpPath.curves;
                shapes.push(tmpShape);
            }
            return shapes;
        }
        function isPointInsidePolygon(inPt, inPolygon) {
            const polyLen = inPolygon.length;
            // inPt on polygon contour => immediate success    or
            // toggling of inside/outside at every single! intersection point of an edge
            //  with the horizontal line through inPt, left of inPt
            //  not counting lowerY endpoints of edges and whole edges on that line
            let inside = false;
            for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {
                let edgeLowPt = inPolygon[p];
                let edgeHighPt = inPolygon[q];
                let edgeDx = edgeHighPt[0] - edgeLowPt[0];
                let edgeDy = edgeHighPt[1] - edgeLowPt[1];
                if (Math.abs(edgeDy) > Number.EPSILON) {
                    // not parallel
                    if (edgeDy < 0) {
                        edgeLowPt = inPolygon[q];
                        edgeDx = -edgeDx;
                        edgeHighPt = inPolygon[p];
                        edgeDy = -edgeDy;
                    }
                    if ((inPt[1] < edgeLowPt[1]) || (inPt[1] > edgeHighPt[1]))
                        continue;
                    if (inPt[1] === edgeLowPt[1]) {
                        if (inPt[0] === edgeLowPt[0])
                            return true; // inPt is on contour ?
                        // continue;				// no intersection or edgeLowPt => doesn't count !!!
                    }
                    else {
                        const perpEdge = edgeDy * (inPt[0] - edgeLowPt[0]) - edgeDx * (inPt[1] - edgeLowPt[1]);
                        if (perpEdge === 0)
                            return true; // inPt is on contour ?
                        if (perpEdge < 0)
                            continue;
                        inside = !inside; // true intersection left of inPt
                    }
                }
                else {
                    // parallel or collinear
                    if (inPt[1] !== edgeLowPt[1])
                        continue; // parallel
                    // edge lies on the same horizontal line as inPt
                    if (((edgeHighPt[0] <= inPt[0]) && (inPt[0] <= edgeLowPt[0])) ||
                        ((edgeLowPt[0] <= inPt[0]) && (inPt[0] <= edgeHighPt[0])))
                        return true; // inPt: Point on contour !
                    // continue;
                }
            }
            return inside;
        }
        const isClockWise = ShapeUtils.isClockWise;
        const subPaths = this.subPaths;
        if (subPaths.length === 0)
            return [];
        if (noHoles === true)
            return toShapesNoHoles(subPaths);
        let solid, tmpPath, tmpShape;
        const shapes = [];
        if (subPaths.length === 1) {
            tmpPath = subPaths[0];
            tmpShape = new Shape();
            tmpShape.curves = tmpPath.curves;
            shapes.push(tmpShape);
            return shapes;
        }
        let holesFirst = !isClockWise(subPaths[0].getPoints());
        holesFirst = isCCW ? !holesFirst : holesFirst;
        // console.log("Holes first", holesFirst);
        const betterShapeHoles = [];
        const newShapes = [];
        let newShapeHoles = [];
        let mainIdx = 0;
        let tmpPoints;
        newShapes[mainIdx] = undefined;
        newShapeHoles[mainIdx] = [];
        for (let i = 0, l = subPaths.length; i < l; i++) {
            tmpPath = subPaths[i];
            tmpPoints = tmpPath.getPoints();
            solid = isClockWise(tmpPoints);
            solid = isCCW ? !solid : solid;
            if (solid) {
                if ((!holesFirst) && (newShapes[mainIdx]))
                    mainIdx++;
                newShapes[mainIdx] = { s: new Shape(), p: tmpPoints };
                newShapes[mainIdx].s.curves = tmpPath.curves;
                if (holesFirst)
                    mainIdx++;
                newShapeHoles[mainIdx] = [];
                //console.log('cw', i);
            }
            else {
                newShapeHoles[mainIdx].push({ h: tmpPath, p: tmpPoints[0] });
                //console.log('ccw', i);
            }
        }
        // only Holes? -> probably all Shapes with wrong orientation
        if (!newShapes[0])
            return toShapesNoHoles(subPaths);
        if (newShapes.length > 1) {
            let ambiguous = false;
            const toChange = [];
            for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
                betterShapeHoles[sIdx] = [];
            }
            for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
                const sho = newShapeHoles[sIdx];
                for (let hIdx = 0; hIdx < sho.length; hIdx++) {
                    const ho = sho[hIdx];
                    let hole_unassigned = true;
                    for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
                        if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                            if (sIdx !== s2Idx)
                                toChange.push({ froms: sIdx, tos: s2Idx, hole: hIdx });
                            if (hole_unassigned) {
                                hole_unassigned = false;
                                betterShapeHoles[s2Idx].push(ho);
                            }
                            else {
                                ambiguous = true;
                            }
                        }
                    }
                    if (hole_unassigned) {
                        betterShapeHoles[sIdx].push(ho);
                    }
                }
            }
            // console.log("ambiguous: ", ambiguous);
            if (toChange.length > 0) {
                // console.log("to change: ", toChange);
                if (!ambiguous)
                    newShapeHoles = betterShapeHoles;
            }
        }
        let tmpHoles;
        for (let i = 0, il = newShapes.length; i < il; i++) {
            tmpShape = newShapes[i].s;
            shapes.push(tmpShape);
            tmpHoles = newShapeHoles[i];
            for (let j = 0, jl = tmpHoles.length; j < jl; j++) {
                tmpShape.holes.push(tmpHoles[j].h);
            }
        }
        //console.log("shape", shapes);
        return shapes;
    }
}

class Font {
    #json;
    constructor(json) {
        this.#json = json;
    }
    generateShapes(text, size = 100) {
        const shapes = [];
        const paths = this.createPaths(text, size);
        for (const path of paths) {
            shapes.push(...path.toShapes());
        }
        return shapes;
    }
    createPaths(text = '', size = 1) {
        const data = this.#json;
        const chars = Array.from(text);
        const scale = size / data.resolution;
        const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
        const paths = [];
        let offsetX = 0, offsetY = 0;
        for (const char of chars) {
            if (char === '\n') {
                offsetX = 0;
                offsetY -= line_height;
            }
            else {
                const ret = this.createPath(char, scale, offsetX, offsetY);
                offsetX += ret.offsetX;
                paths.push(ret.path);
            }
        }
        return paths;
    }
    createPath(char, scale, offsetX, offsetY) {
        const data = this.#json;
        const glyph = data.glyphs[char] ?? data.glyphs['?'];
        const path = new ShapePath();
        let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
        if (glyph.o) {
            const outline = glyph.o.split(' ');
            for (let i = 0, l = outline.length; i < l;) {
                const action = outline[i++];
                switch (action) {
                    case 'm': // moveTo
                        x = outline[i++] * scale + offsetX;
                        y = outline[i++] * scale + offsetY;
                        path.moveTo(x, y);
                        break;
                    case 'l': // lineTo
                        x = outline[i++] * scale + offsetX;
                        y = outline[i++] * scale + offsetY;
                        path.lineTo(x, y);
                        break;
                    case 'q': // quadraticCurveTo
                        cpx = outline[i++] * scale + offsetX;
                        cpy = outline[i++] * scale + offsetY;
                        cpx1 = outline[i++] * scale + offsetX;
                        cpy1 = outline[i++] * scale + offsetY;
                        path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                        break;
                    case 'b': // bezierCurveTo
                        cpx = outline[i++] * scale + offsetX;
                        cpy = outline[i++] * scale + offsetY;
                        cpx1 = outline[i++] * scale + offsetX;
                        cpy1 = outline[i++] * scale + offsetY;
                        cpx2 = outline[i++] * scale + offsetX;
                        cpy2 = outline[i++] * scale + offsetY;
                        path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                        break;
                }
            }
        }
        return { offsetX: glyph.ha * scale, path: path };
    }
}

class FontManager {
    static #fontList = new Map();
    static #fontsPath;
    static #manifestPromise;
    static setFontsPath(url) {
        this.#fontsPath = url;
    }
    static async #getManifest() {
        if (this.#manifestPromise) {
            return this.#manifestPromise;
        }
        this.#manifestPromise = new Promise(async (resolve) => {
            if (!this.#fontsPath) {
                throw 'No manifest set';
            }
            const response = await customFetch(this.#fontsPath + 'manifest.json');
            resolve(await response.json());
        });
        return this.#manifestPromise;
    }
    static async #loadFont(name, style) {
        const manifest = await this.#getManifest();
        const fonts = manifest?.fonts;
        if (fonts) {
            const font = fonts[name];
            if (font && font.styles) {
                const s = font.styles[style];
                if (s) {
                    const response = await customFetch(this.#fontsPath + s);
                    const fontFile = await response.json();
                    const font = new Font(fontFile);
                    this.#fontList.get(name).set(style, font);
                    return font;
                }
            }
        }
    }
    static async getFont(name, style = 'normal') {
        name = name.toLowerCase();
        style = style.toLowerCase();
        const fontFamilly = this.#fontList.get(name);
        if (fontFamilly) {
            const font = fontFamilly.get(style);
            if (font) {
                return font;
            }
        }
        else {
            this.#fontList.set(name, new Map());
        }
        return await this.#loadFont(name, style);
    }
    static async getFontList() {
        const list = new Map();
        const manifest = await this.#getManifest();
        const fonts = manifest?.fonts;
        if (fonts) {
            for (const fontName in fonts) {
                const font = fonts[fontName];
                const styles = new Set;
                for (const styleName in font.styles) {
                    styles.add(styleName);
                }
                list.set(fontName, styles);
            }
        }
        return list;
    }
}

class MeshBasicPbrMaterial extends Material {
    constructor(params = {}) {
        super(params);
        this.addParameter('color', MateriaParameterType.Color4, null, newValue => this.setColor4Uniform('uColor', newValue ?? DEFAULT_COLOR));
        this.addParameter('metalness', MateriaParameterType.NormalizedFloat, 0, newValue => { this.uniforms['uMetalness'] = newValue; });
        this.addParameter('roughness', MateriaParameterType.NormalizedFloat, 0, newValue => { this.uniforms['uRoughness'] = newValue; });
        this.addParameter('color_texture', MateriaParameterType.Texture, null, newValue => this.setTexture('uColorTexture', newValue, 'USE_COLOR_TEXTURE'));
        this.addParameter('normal_texture', MateriaParameterType.Texture, null, newValue => this.setTexture('uNormalTexture', newValue, 'USE_NORMAL_TEXTURE'));
        this.addParameter('metalness_texture', MateriaParameterType.Texture, null, newValue => this.setTexture('uMetalnessTexture', newValue, 'USE_METALNESS_TEXTURE'));
        this.addParameter('roughness_texture', MateriaParameterType.Texture, null, newValue => this.setTexture('uRoughnessTexture', newValue, 'USE_ROUGHNESS_TEXTURE'));
        this.setParameters(params);
    }
    setParameters(params = {}) {
        this.setColor(params.color);
        this.setMetalness(params.metalness);
        this.setRoughness(params.roughness);
        this.setColorTexture(params.colorTexture);
        this.setNormalTexture(params.normalTexture);
        this.setMetalnessTexture(params.metalnessTexture);
        this.setRoughnessTexture(params.roughnessTexture);
    }
    setColor(color /*TODO: change to Color*/) {
        this.setParameterValue('color', color);
    }
    setMetalness(metalness) {
        this.setParameterValue('metalness', metalness);
    }
    setRoughness(roughness) {
        this.setParameterValue('roughness', roughness);
    }
    setColorTexture(colorTexture) {
        this.setParameterValue('color_texture', colorTexture);
    }
    setNormalTexture(normalTexture) {
        this.setParameterValue('normal_texture', normalTexture);
    }
    setMetalnessTexture(metalnessTexture) {
        this.setParameterValue('metalness_texture', metalnessTexture);
    }
    setRoughnessTexture(roughnessTexture) {
        this.setParameterValue('roughness_texture', roughnessTexture);
    }
    get shaderSource() {
        return 'meshbasicpbr';
    }
    toJSON() {
        const json = super.toJSON();
        return json;
    }
    static async constructFromJSON(json) {
        return new MeshBasicPbrMaterial();
    }
    fromJSON(json) {
        super.fromJSON(json);
    }
    static getEntityName() {
        return 'MeshBasicPbrMaterial';
    }
}
Material.materialList['MeshBasicPbr'] = MeshBasicPbrMaterial;
registerEntity(MeshBasicPbrMaterial);

class GridMaterial extends Material {
    constructor(params = {}) {
        super(params);
        this.spacing = params.spacing ?? 1;
        this.setBlending(MATERIAL_BLENDING_NORMAL);
        this.renderFace(RenderFace.Both);
    }
    set spacing(spacing) {
        this.uniforms['uSpacing'] = spacing;
    }
    getShaderSource() {
        return 'grid';
    }
}
Material.materialList['Grid'] = GridMaterial;

class MeshFlatMaterial extends Material {
    constructor(params = {}) {
        super(params);
        this.setDefine('FLAT_SHADING');
    }
    getShaderSource() {
        return 'meshphong';
    }
}
Material.materialList['MeshFlat'] = MeshFlatMaterial;

class MeshPhongMaterial extends Material {
    map = null;
    lightMap = null;
    lightMapIntensity = 1.0;
    aoMap = null;
    aoMapIntensity = 1.0;
    specularMap = null;
    alphaMap = null;
    envMap = null;
    combine = 0 /*MultiplyOperation*/;
    reflectivity = 1;
    refractionRatio = 0.98;
    wireframe = false;
    wireframeLinewidth = 1;
    wireframeLinecap = 'round';
    wireframeLinejoin = 'round';
    skinning = false;
    morphTargets = false;
    constructor(params = {}) {
        super(params);
        this.setValues(params);
    }
    getShaderSource() {
        return 'meshphong';
    }
}
Material.materialList['MeshPhong'] = MeshPhongMaterial;

class ShaderToyMaterial extends Material {
    constructor(params = {}) {
        super(params);
        this.setTexture('noiseMap', TextureManager.createNoiseTexture(256, 256));
    }
    getShaderSource() {
        return 'shadertoy';
    }
}
Material.materialList['ShaderToy'] = ShaderToyMaterial;

function smartRound(input, precision = 0.001) {
    let mul = 1;
    for (let i = 0; i < 10; ++i) {
        let r = Math.round(mul * input) / mul;
        if (Math.abs(r - input) < precision) {
            return r;
        }
        mul *= 10;
    }
    return input;
}

function _loadWasmModule (sync, filepath, src, imports) {
  function _instantiateOrCompile(source, imports, stream) {
    var instantiateFunc = stream ? WebAssembly.instantiateStreaming : WebAssembly.instantiate;
    var compileFunc = stream ? WebAssembly.compileStreaming : WebAssembly.compile;

    if (imports) {
      return instantiateFunc(source, imports)
    } else {
      return compileFunc(source)
    }
  }

  
var buf = null;
var isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;

if (filepath && isNode) {
  
var fs = require("fs");
var path = require("path");

return new Promise((resolve, reject) => {
  fs.readFile(path.resolve(__dirname, filepath), (error, buffer) => {
    if (error != null) {
      reject(error);
    } else {
      resolve(_instantiateOrCompile(buffer, imports, false));
    }
  });
});

} else if (filepath) {
  
return _instantiateOrCompile(fetch(filepath), imports, true);

}

if (isNode) {
  
buf = Buffer.from(src, 'base64');

} else {
  
var raw = globalThis.atob(src);
var rawLength = raw.length;
buf = new Uint8Array(new ArrayBuffer(rawLength));
for(var i = 0; i < rawLength; i++) {
   buf[i] = raw.charCodeAt(i);
}

}


  if(sync) {
    var mod = new WebAssembly.Module(buf);
    return imports ? new WebAssembly.Instance(mod, imports) : mod
  } else {
    return _instantiateOrCompile(buf, imports, false)
  }
}

function loopSubdivision(imports){return _loadWasmModule(0, null, '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IAIgASgCBGsLIQAgA0EgaiQAIAALPgEBfyMAQRBrIgMkACAAKAI8IAEgAkH/AXEgA0EIahACIgAEQEGEMCAANgIACyADKQMIIQEgA0EQaiQAIAELCQAgACgCPBADC4MBAgN/AX4CQCAAQoCAgIAQVARAIAAhBQwBCwNAIAFBf2oiASAAIABCCoAiBUIKfn2nQTByOgAAIABC/////58BViECIAUhACACDQALCyAFpyICBEADQCABQX9qIgEgAiACQQpuIgNBCmxrQTByOgAAIAJBCUshBCADIQIgBA0ACwsgAQs0AQJ/QfgvKAIAIQBB8C8oAgAiAQRAIAEQBQsgAARAIAAQBQtB+C9CADcDAEHwL0IANwMACzQAIABQRQRAA0AgAUF/aiIBIACnQQ9xQfAQai0AACACcjoAACAAQgSIIgBCAFINAAsLIAELLQAgAFBFBEADQCABQX9qIgEgAKdBB3FBMHI6AAAgAEIDiCIAQgBSDQALCyABC8UCAQN/IwBB0AFrIgIkACACIAE2AswBQQAhASACQaABakEAQSgQCCACIAIoAswBNgLIAQJAQQAgAkHIAWogAkHQAGogAkGgAWoQIUEASA0AIAAoAkxBAE4EQEEBIQELIAAoAgAhAyAALABKQQBMBEAgACADQV9xNgIACyADQSBxIQQCfyAAKAIwBEAgACACQcgBaiACQdAAaiACQaABahAhDAELIABB0AA2AjAgACACQdAAajYCECAAIAI2AhwgACACNgIUIAAoAiwhAyAAIAI2AiwgACACQcgBaiACQdAAaiACQaABahAhIANFDQAaIABBAEEAIAAoAiQRBAAaIABBADYCMCAAIAM2AiwgAEEANgIcIABBADYCECAAKAIUGiAAQQA2AhRBAAsaIAAgBCAAKAIAcjYCACABRQ0ACyACQdABaiQAC4kCAAJAIAAEfyABQf8ATQ0BAkBBqC4oAgAoAgBFBEAgAUGAf3FBgL8DRg0DDAELIAFB/w9NBEAgACABQT9xQYABcjoAASAAIAFBBnZBwAFyOgAAQQIPCyABQYCwA09BACABQYBAcUGAwANHG0UEQCAAIAFBP3FBgAFyOgACIAAgAUEMdkHgAXI6AAAgACABQQZ2QT9xQYABcjoAAUEDDwsgAUGAgHxqQf//P00EQCAAIAFBP3FBgAFyOgADIAAgAUES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', imports)}

class LoopSubdivision {
    static #instance;
    #webAssembly;
    #heap;
    #heapBuffer;
    constructor() {
        if (LoopSubdivision.#instance) {
            return LoopSubdivision.#instance;
        }
        LoopSubdivision.#instance = this;
    }
    async subdivide(indices, vertices, subdivideCount = 1, tolerance = 0.001) {
        await this.#initWebAssembly();
        const api = this.#webAssembly.instance.exports;
        //const meshPointer = api.create_mesh();
        //console.log(meshPointer);
        const indicesCount = indices.length;
        const verticesCount = vertices.length;
        const indicesPointer = api.create_buffer(indicesCount * 4);
        const verticesPointer = api.create_buffer(verticesCount * 4);
        const indicesView = new Uint32Array(this.#heapBuffer, indicesPointer, indicesCount);
        indicesView.set(indices);
        const verticesView = new Float32Array(this.#heapBuffer, verticesPointer, verticesCount);
        verticesView.set(vertices);
        //console.log(indices.join(', '));
        //console.log(vertices.join(', '));
        const subdivideResult = api.subdivide(indicesPointer, indicesCount, verticesPointer, verticesCount, subdivideCount, tolerance);
        api.delete_buffer(indicesPointer);
        api.delete_buffer(verticesPointer);
        const resultView = new Uint32Array(this.#heapBuffer, subdivideResult, 4);
        const newIndicesView = new Uint32Array(new Uint32Array(this.#heapBuffer, resultView[0], resultView[1]));
        const newVerticesView = new Float32Array(new Float32Array(this.#heapBuffer, resultView[2], resultView[3]));
        api.cleanup();
        return {
            indices: newIndicesView,
            vertices: newVerticesView,
        };
    }
    async #initWebAssembly() {
        if (this.#webAssembly) {
            return this.#webAssembly;
        }
        const env = {
            'abortStackOverflow': () => { throw new Error('overflow'); },
            'emscripten_notify_memory_growth': () => {
                this.#initHeap();
            },
            'table': new WebAssembly.Table({ initial: 0, maximum: 0, element: 'anyfunc' }),
            'tableBase': 0,
            'memoryBase': 1024,
            'STACKTOP': 0,
            console_log: (ptr, size) => {
                const stringContent = new Uint8Array(this.#heapBuffer, ptr, size);
                console.log(new TextDecoder().decode(stringContent));
            },
        };
        //this.#webAssembly = await loopSubdivision({ env });
        const imports = {
            env: env,
            wasi_snapshot_preview1: {
                fd_write: (fd, iovsPtr, iovsLength, bytesWrittenPtr) => {
                    const iovs = new Uint32Array(this.#heapBuffer, iovsPtr, iovsLength * 2);
                    if (fd === 1 || fd === 2) { //stdout
                        let text = '';
                        let totalBytesWritten = 0;
                        const decoder = new TextDecoder();
                        for (let i = 0; i < iovsLength * 2; i += 2) {
                            const offset = iovs[i];
                            const length = iovs[i + 1];
                            const textChunk = decoder.decode(new Int8Array(this.#heapBuffer, offset, length));
                            text += textChunk;
                            totalBytesWritten += length;
                        }
                        const dataView = new DataView(this.#heapBuffer);
                        dataView.setInt32(bytesWrittenPtr, totalBytesWritten, true);
                        console.log(text);
                    }
                    return 0;
                },
                fd_seek: (p1, p2, p3, p4) => {
                },
                fd_read: (p1, p2, p3, p4) => {
                },
                fd_close: (p1, p2, p3, p4) => {
                },
                proc_exit: (p1) => { console.log('Exit code:', p1); },
            },
        };
        //this.#webAssembly = await WebAssembly.instantiateStreaming(fetch('loop_subdivision.wasm'), imports);
        this.#webAssembly = await loopSubdivision(imports);
        this.#initHeap();
        return this.#webAssembly;
    }
    #initHeap() {
        //this.HEAPU8 = new Uint8Array(this.webAssembly.instance.exports.memory.buffer);
        this.#heap = new Uint8Array(this.#webAssembly.instance.exports.memory.buffer);
        this.#heapBuffer = this.#heap.buffer;
    }
}

var nodeImageEditorCSS = ":host {\n\tbackground-color: #000000FF;\n\twidth: 100%;\n\theight: 100%;\n\tdisplay: flex;\n\tflex-direction: column;\n\tuser-select: none;\n}\n\n.node-image-editor-nodes {\n\toverflow: auto;\n\tposition: relative;\n\tdisplay: flex;\n\toverflow: auto;\n\tflex: 1;\n}\n\n.node-image-editor-nodes-column {\n\tdisplay: flex;\n\tflex-direction: column;\n\tmargin-left: 50px;\n\tmargin-right: 50px;\n}\n\n.node-image-editor-canvas {\n\tpointer-events: none;\n}\n\n.node-image-editor-node {\n\tbackground-color: var(--main-bg-color-bright);\n\tdisplay: flex;\n\tflex-direction: column;\n\tmargin-top: 50px;\n\tmargin-bottom: 50px;\n\tpadding: 5px;\n}\n\n.node-image-editor-node.collapsed {\n\twidth: auto;\n\tmargin-top: 1rem;\n\tmargin-bottom: 1rem;\n}\n\n.node-image-editor-node.collapsed .node-image-editor-node-content {\n\tdisplay: none;\n}\n\n.node-image-editor-node.collapsed .node-image-editor-node-preview {\n\tdisplay: none;\n}\n\n.node-image-editor-node.collapsed button {\n\tdisplay: none;\n}\n\n.node-image-editor-node-header {\n\tdisplay: flex;\n}\n\n.node-image-editor-node-title {\n\tflex: 1;\n}\n\n.node-image-editor-node-buttons {\n\tdisplay: flex;\n}\n\n.node-image-editor-node-buttons>div {\n\tcursor: pointer;\n}\n\n.node-image-editor-node-preview {\n\tposition: relative;\n\t/*height: 32px;\n\twidth: 32px;*/\n\tbackground-color: #000000FF;\n\tdisplay: inline-block;\n\twidth: min-content;\n\tdisplay: flex;\n}\n\n.node-image-editor-sticker-selector {\n\tposition: absolute;\n\tpointer-events: none;\n\ttop: 0;\n\twidth: 100%;\n\theight: 100%;\n\t--harmony-2d-manipulator-bg-color: rgba(0, 0, 0, 0);\n\t--harmony-2d-manipulator-border: 1px dashed white;\n}\n\n.node-image-editor-sticker-selector>div {\n\tposition: absolute;\n\twidth: 0.4rem;\n\theight: 0.4rem;\n\tbackground-color: black;\n\tpointer-events: all;\n}\n\n.node-image-editor-sticker-selector>.handle-move {\n\tcursor: move;\n\ttop: calc(50% - 0.2rem);\n\tleft: calc(50% - 0.2rem);\n}\n\n.node-image-editor-sticker-selector>.handle-resize {\n\tcursor: nesw-resize;\n\ttop: -0.2rem;\n\tright: 0.2rem;\n}\n\n.node-image-editor-sticker-selector>.handle-rotate {\n\tcursor: grab;\n\ttop: -0.2rem;\n\tleft: -0.2rem;\n}\n\n.node-image-editor-node-content {\n\tdisplay: flex;\n}\n\n.node-image-editor-node-ios {\n\theight: 100%;\n\tflex: 0;\n}\n\n.node-image-editor-node-io {\n\twidth: 10px;\n\theight: 10px;\n\tbackground-color: green;\n}\n\n.node-image-editor-node-params {\n\tflex: 1;\n\toverflow: hidden;\n\tpadding: 5px;\n}\n\n.node-image-editor-node-param {\n\tdisplay: flex;\n\ttext-wrap: nowrap;\n}\n\n.node-image-editor-node-param>div {\n\tflex: 1;\n\t/*overflow: auto;*/\n}\n\n.node-image-editor-node-param>input {\n\theight: 1.5rem;\n\tbox-sizing: border-box;\n\tvertical-align: middle;\n}\n\n.node-image-editor-node-change-image {\n\topacity: 0%;\n\tposition: absolute;\n\ttop: 0px;\n\tleft: 0px;\n\theight: 100%;\n\twidth: 100%;\n\t/*background-image: url('./img/icons/image_search.svg');*/\n\toverflow: hidden;\n\tbackground-size: 100%;\n\tbackground-repeat: no-repeat;\n\tbackground-position: center;\n\tbackground-color: white;\n\tborder-radius: 4px;\n\tcursor: pointer;\n}\n\n.node-image-editor-node input[type=\"file\"] {\n\topacity: 0;\n\twidth: 100%;\n\theight: 100%;\n}\n\n.copy-button {\n\twidth: 2rem;\n\theight: 2rem;\n\tdisplay: inline-block;\n\tcursor: pointer;\n}\n\ninput {\n\t/*transition: background-color 1s;*/\n\tbackground-color: #FFF;\n\n\t/* only animation-duration here is required, rest are optional (also animation-name but it will be set on hover)*/\n\tanimation-duration: 1.5s;\n\t/* same as transition duration */\n\tanimation-timing-function: linear;\n\t/* kind of same as transition timing */\n\tanimation-delay: 0ms;\n\t/* same as transition delay */\n\tanimation-iteration-count: 1;\n\t/* set to 2 to make it run twice, or Infinite to run forever!*/\n\tanimation-direction: normal;\n\t/* can be set to \"alternate\" to run animation, then run it backwards.*/\n\tanimation-fill-mode: none;\n\t/* can be used to retain keyframe styling after animation, with \"forwards\" */\n\tanimation-play-state: running;\n\t/* can be set dynamically to pause mid animation*/\n\n}\n\n.flash {\n\tanimation-name: copyAnimation;\n}\n\n@keyframes copyAnimation {\n\t0% {\n\t\tbackground-color: #ffdf5d;\n\t}\n\n\t100% {\n\t\tbackground-color: #FFF;\n\t}\n}\n\nharmony-toggle-button.sticker {\n\tmargin: 0.5rem;\n\tpadding: 0.2rem;\n\tborder-radius: 0.5rem;\n}\n\nharmony-toggle-button.sticker.on {\n\tbackground-color: green;\n}\n\nharmony-toggle-button.sticker.off {\n\tbackground-color: red;\n}\n";

const operations$1 = new Map();
function registerOperation(name, ope) {
    operations$1.set(name, ope);
}
function getOperation(name, editor, params) {
    const ope = operations$1.get(name);
    if (!ope) {
        console.warn('Unknown operation : ' + name);
        return null;
    }
    return new (ope)(editor, params);
}

const DEFAULT_TEXTURE_SIZE = 512;
var NodeImageEditorEventType;
(function (NodeImageEditorEventType) {
    NodeImageEditorEventType["Any"] = "*";
    NodeImageEditorEventType["NodeAdded"] = "nodeadded";
    NodeImageEditorEventType["NodeRemoved"] = "noderemoved";
    NodeImageEditorEventType["AllNodesRemoved"] = "allnodesremoved";
})(NodeImageEditorEventType || (NodeImageEditorEventType = {}));
class NodeImageEditor extends MyEventTarget {
    #variables = new Map();
    #scene = new Scene();
    #nodes = new Set();
    #camera = new Camera({ position: vec3.fromValues(0, 0, 100) });
    #fullScreenQuadMesh = new FullScreenQuad();
    textureSize = DEFAULT_TEXTURE_SIZE;
    constructor() {
        super();
        this.#scene.addChild(this.#fullScreenQuadMesh);
    }
    render(material) {
        this.#fullScreenQuadMesh.setMaterial(material);
        Graphics$1.render(this.#scene, this.#camera, 0, { DisableToolRendering: true });
    }
    addNode(operationName, params = {}) {
        params.textureSize = params.textureSize ?? this.textureSize;
        if (!operationName) {
            return null;
        }
        const node = getOperation(operationName, this, params);
        if (node) {
            this.textureSize = params.textureSize;
            this.#nodes.add(node);
            this.#dispatchEvent(NodeImageEditorEventType.NodeAdded, node);
        }
        return node;
    }
    /*addNewNode(operationName, params = Object.create(null)) {
        let node = this._createNode(operationName, params);
        this.addNode(node);
        return node;
    }*/
    #dispatchEvent(eventName, eventDetail) {
        this.dispatchEvent(new CustomEvent(eventName, { detail: { node: eventDetail } }));
        this.dispatchEvent(new CustomEvent(NodeImageEditorEventType.Any, { detail: { eventName: eventName } }));
    }
    /*addNode(node) {
        if (node instanceof Node && node.editor == this) {
            this.#nodes.add(node);
            this.#dispatchEvent('nodeadded', node);
        }
    }*/
    removeNode(node) {
        if (node.editor == this) {
            this.#nodes.delete(node);
            //TODO :remove all inputs / output
            this.#dispatchEvent(NodeImageEditorEventType.NodeRemoved, node);
        }
    }
    removeAllNodes() {
        this.#nodes.forEach((node) => node.dispose());
        this.#nodes.clear();
        this.#dispatchEvent(NodeImageEditorEventType.AllNodesRemoved, null);
        //TODO :remove all inputs / output
    }
    getVariable(name) {
        return this.#variables.get(name);
    }
    setVariable(name, value) {
        return this.#variables.set(name, value);
    }
    deleteVariable(name) {
        return this.#variables.delete(name);
    }
    clearVariables() {
        return this.#variables.clear();
    }
    getNodes() {
        return new Set(this.#nodes);
    }
}

const TEXTUREFLAGS_POINTSAMPLE = 0x00000001;
const TEXTUREFLAGS_TRILINEAR = 0x00000002;
const TEXTUREFLAGS_CLAMPS = 0x00000004;
const TEXTUREFLAGS_CLAMPT = 0x00000008;
const TEXTUREFLAGS_ANISOTROPIC = 0x00000010;
const TEXTUREFLAGS_HINT_DXT5 = 0x00000020;
const TEXTUREFLAGS_SRGB = 0x00000040;
const TEXTUREFLAGS_NORMAL = 0x00000080;
const TEXTUREFLAGS_NOMIP = 0x00000100;
const TEXTUREFLAGS_NOLOD = 0x00000200;
const TEXTUREFLAGS_ALL_MIPS = 0x00000400;
const TEXTUREFLAGS_PROCEDURAL = 0x00000800;
const TEXTUREFLAGS_ONEBITALPHA = 0x00001000;
const TEXTUREFLAGS_EIGHTBITALPHA = 0x00002000;
const TEXTUREFLAGS_ENVMAP = 0x00004000;
const TEXTUREFLAGS_RENDERTARGET = 0x00008000;
const TEXTUREFLAGS_DEPTHRENDERTARGET = 0x00010000;
const TEXTUREFLAGS_NODEBUGOVERRIDE = 0x00020000;
const TEXTUREFLAGS_SINGLECOPY = 0x00040000;
const TEXTUREFLAGS_NODEPTHBUFFER = 0x00800000;
const TEXTUREFLAGS_UNUSED_01000000 = 0x01000000;
const TEXTUREFLAGS_CLAMPU = 0x02000000;
const TEXTUREFLAGS_VERTEXTEXTURE = 0x04000000; // Useable as a vertex texture
const TEXTUREFLAGS_SSBUMP = 0x08000000;
// Clamp to border color on all texture coordinates
const TEXTUREFLAGS_BORDER = 0x20000000;
const TEXTUREFLAGS_UNUSED_40000000 = 0x40000000;
const TEXTUREFLAGS_UNUSED_80000000 = 0x80000000;

const LOW_RES_IMAGE = 0x01;
const HIGH_RES_IMAGE = 0x30;
class VTFResource {
    #type;
    #flag;
    #data;
    #length = 0;
    constructor(type, flag = 0) {
        this.#type = type;
        this.#flag = flag;
        this.data = null;
    }
    set data(data) {
        this.#data = data;
        if (data) {
            this.#length = data.length;
        }
        else {
            this.#length = 0;
        }
    }
    get type() {
        return this.#type;
    }
    get length() {
        return this.#length;
    }
    get flag() {
        return this.#flag;
    }
}
class VTFFile {
    #flags = 0;
    #width;
    #height;
    #frames;
    #imageFormat;
    #faces;
    #slices;
    #hasThumbnail = false;
    #hasMipMaps = false;
    #mipMaps = [[[[]]]];
    #bumpmapScale = 1.0; //todo
    #highResImageFormat = 0; //todo
    #resources = [];
    #highResResource = new VTFResource(HIGH_RES_IMAGE);
    constructor(width = 512, height = 512, imageFormat = 0 /*TODO*/, frames = 1, faces = 1, slices = 1) {
        this.#width = width;
        this.#height = height;
        this.#imageFormat = imageFormat;
        this.#frames = frames;
        this.#faces = faces;
        this.#slices = slices;
        this.addResource(this.#highResResource);
    }
    addResource(resource) {
        this.#resources.push(resource);
    }
    get height() {
        return this.#height;
    }
    get width() {
        return this.#width;
    }
    setFlag(flag) {
        this.#flags |= flag;
    }
    unsetFlag(flag) {
        this.#flags &= ~flag;
    }
    get flags() {
        return this.#flags;
    }
    get frames() {
        return 1; //TODO
    }
    get bumpmapScale() {
        return this.#bumpmapScale;
    }
    get highResImageFormat() {
        return this.#highResImageFormat;
    }
    get mipmapCount() {
        return 1; //TODO
    }
    get lowResImageFormat() {
        return -1; //TODO
    }
    get lowResImageWidth() {
        return 0; //TODO
    }
    get lowResImageHeight() {
        return 0; //TODO
    }
    get depth() {
        return 1; //TODO
    }
    get numResources() {
        return this.#resources.length; //TODO
    }
    get resources() {
        return this.#resources;
    }
    getMipMaps() {
        return this.#mipMaps;
    }
    setImageData(imageData, frame = 0, face = 0, slice = 0, mipmap = 0) {
        this.#mipMaps[mipmap] = this.#mipMaps[mipmap] ?? [];
        this.#mipMaps[mipmap][frame] = this.#mipMaps[mipmap][frame] ?? [];
        this.#mipMaps[mipmap][frame][face] = this.#mipMaps[mipmap][frame][face] ?? [];
        this.#mipMaps[mipmap][frame][face][slice] = imageData; //TODO: check values;
        this.#highResResource.data = imageData;
    }
}
class VTFWriter {
    static writeAndSave(vtffile, filename) {
        const arrayBuffer = this.write(vtffile);
        const dataView = new DataView(arrayBuffer);
        //saveFile(filename, new Blob([dataView]));
        saveFile(new File([new Blob([dataView])], filename));
    }
    static write(vtffile) {
        //TODO: check vtffile
        const writer = new BinaryReader(new Uint8Array(this.#computeLength(vtffile)));
        this.#writeHeader(writer, vtffile);
        return writer.buffer;
    }
    static #computeLength(vtffile) {
        let result = 80 + vtffile.numResources * 8;
        const resArray = vtffile.resources;
        for (const resource of resArray) {
            //	const resource = resArray[i];
            if (resource.flag != 2) {
                result += resource.length;
            }
        }
        return result;
    }
    static #writeHeader(writer, vtffile) {
        const fixedHeaderLength = 80;
        writer.seek(0);
        writer.setUint32(0x00465456); //VTF\0
        writer.setUint32(VTFWriter.majorVersion);
        writer.setUint32(VTFWriter.minorVersion);
        const headerLength = fixedHeaderLength + vtffile.numResources * 8;
        writer.setUint32(headerLength);
        writer.setUint16(vtffile.width);
        writer.setUint16(vtffile.height);
        writer.setUint32(vtffile.flags);
        writer.setUint16(vtffile.frames);
        writer.setUint16(0); //TODO ??? firstFrame
        writer.skip(4); //padding.
        writer.setFloat32(0.092801064); //TODO reflectivity vector.
        writer.setFloat32(0.092801064); //TODO reflectivity vector.
        writer.setFloat32(0.092801064); //TODO reflectivity vector.
        writer.skip(4); //padding.
        writer.setFloat32(vtffile.bumpmapScale); //TODO bumpmapScale
        //writer.writeInt32(vtffile.highResImageFormat);
        writer.setInt32(0);
        writer.setUint8(vtffile.mipmapCount);
        writer.setInt32(vtffile.lowResImageFormat);
        writer.setUint8(vtffile.lowResImageWidth);
        writer.setUint8(vtffile.lowResImageHeight);
        writer.setUint16(vtffile.depth);
        writer.skip(3);
        writer.setUint32(vtffile.numResources);
        writer.skip(8);
        const resArray = vtffile.resources;
        let dataOffset = headerLength;
        let resHeaderOffset = fixedHeaderLength;
        for (const resource of resArray) {
            writer.seek(resHeaderOffset);
            //const resource = resArray[i];
            writer.setUint32(resource.type);
            /*writer.skip(-1);
            writer.setUint8(resource.flag);*/
            if (resource.flag == 2) { // resource doesn't have data
                writer.skip(4);
                //todo writedata
            }
            else {
                writer.setUint32(dataOffset);
                this.#writeResource(writer, vtffile, resource, dataOffset);
                dataOffset += resource.length;
            }
            resHeaderOffset += 8;
        }
    }
    static #writeResource(writer, vtffile, resource, dataOffset) {
        switch (resource.type) {
            case LOW_RES_IMAGE:
                break;
            case HIGH_RES_IMAGE:
                this.#writeHighResImage(writer, vtffile, resource, dataOffset);
                break;
        }
    }
    static #writeHighResImage(writer, vtffile, resource, dataOffset) {
        writer.seek(dataOffset);
        const b = vtffile.getMipMaps()[0]?.[0]?.[0]?.[0];
        if (b) {
            writer.setBytes(b);
        }
    }
    static get majorVersion() {
        return 7;
    }
    static get minorVersion() {
        return 5;
    }
}

function imageDataToImage(imagedata, image = new Image()) {
    const canvas = createElement('canvas', { width: imagedata.width, height: imagedata.height });
    const ctx = canvas.getContext('2d');
    canvas.width = imagedata.width;
    canvas.height = imagedata.height;
    ctx.putImageData(imagedata, 0, 0);
    image.src = canvas.toDataURL();
    return image;
}
function flipPixelArray(pixelArray, width, height) {
    const rowLength = width * 4;
    const tempRow = new Uint8ClampedArray(rowLength);
    const halfHeight = height * 0.5;
    for (let row = 0; row < halfHeight; ++row) {
        const topOffset = row * rowLength;
        const bottomOffset = (height - row - 1) * rowLength;
        tempRow.set(pixelArray.subarray(topOffset, topOffset + rowLength));
        pixelArray.copyWithin(topOffset, bottomOffset, bottomOffset + rowLength);
        pixelArray.set(tempRow, bottomOffset);
    }
}

const IO_TYPE_FLOAT = 2;
const IO_TYPE_VEC2 = 3;
const IO_TYPE_COLOR = 7;
const IO_TYPE_TEXTURE_2D = 8;
const IO_TYPE_ARRAY_INT = 101;
const IO_TYPE_ARRAY_FLOAT = 102;
/*const ARRAY_START = 1000;
export const IO_TYPE_INT_ARRAY = ARRAY_START + 1;
export const IO_TYPE_FLOAT_ARRAY = ARRAY_START + 2;
export const IO_TYPE_VEC2_ARRAY = ARRAY_START + 3;
export const IO_TYPE_VEC3_ARRAY = ARRAY_START + 4;
export const IO_TYPE_VEC4_ARRAY = ARRAY_START + 5;
export const IO_TYPE_QUAT_ARRAY = ARRAY_START + 6;
export const IO_TYPE_COLOR_ARRAY = ARRAY_START + 7;
export const IO_TYPE_TEXTURE_2D_ARRAY = ARRAY_START + 8;*/
var InputOutputType;
(function (InputOutputType) {
    InputOutputType[InputOutputType["Unknown"] = 0] = "Unknown";
    InputOutputType[InputOutputType["Int"] = 1] = "Int";
    InputOutputType[InputOutputType["Float"] = 2] = "Float";
    InputOutputType[InputOutputType["Vec2"] = 3] = "Vec2";
    InputOutputType[InputOutputType["Vec3"] = 4] = "Vec3";
    InputOutputType[InputOutputType["Vec4"] = 5] = "Vec4";
    InputOutputType[InputOutputType["Quat"] = 6] = "Quat";
    InputOutputType[InputOutputType["Color"] = 7] = "Color";
    InputOutputType[InputOutputType["Texture2D"] = 8] = "Texture2D";
    InputOutputType[InputOutputType["IntArray"] = 1000] = "IntArray";
    InputOutputType[InputOutputType["FloatArray"] = 1001] = "FloatArray";
})(InputOutputType || (InputOutputType = {}));
class InputOutput {
    node;
    id;
    type;
    size;
    _value;
    _pixelArray;
    constructor(node, id, type, size = 1) {
        this.node = node;
        this.id = id;
        this.type = type;
        this.size = size;
        if (size == 1) {
            this._value = undefined;
        }
        else {
            this._value = new Array(size);
        }
    }
}

//const isUndefined = (element) => element == undefined;
class Input extends InputOutput {
    #predecessor;
    constructor(node, id, type, size = 1) {
        super(node, id, type, size);
    }
    set value(value) {
        //TODO: check the value type
        this._value = value;
        this.node.invalidate();
    }
    /*
    setArrayValue(value, index) {
        if (index == undefined) {
            index = this._value.findIndex(isUndefined)
            if (index == -1) {
                return;
            }
        }

        //TODOv3 check type / index
        this._value[index] = value;
        this.node.invalidate();
    }*/
    get value() {
        if (this.#predecessor) {
            return this.#predecessor.value;
        }
        return Promise.resolve(this._value);
    }
    setPredecessor(predecessor) {
        if (predecessor) {
            predecessor.addSuccessor(this);
        }
        if (this.#predecessor && !predecessor) {
            this.#predecessor.removeSuccessor(this);
        }
        this.#predecessor = predecessor;
        this.node.invalidate();
    }
    getPredecessor() {
        return this.#predecessor;
    }
    /* TODO:remove
    draw(glContext) {
        if (this.#predecessor) {
            this.#predecessor.draw(glContext);
        }
    }

    getInputTexture(defaultWhite) {
        if (this.#predecessor) {
            return this.#predecessor.outputTexture;
        }
    }
    */
    hasPredecessor() {
        return this.#predecessor ? true : false;
    }
    getType() {
        if (this.#predecessor) {
            return this.#predecessor.getType();
        }
        return null;
    }
    getValue() {
        if (this.#predecessor) {
            return this.#predecessor.getValue();
        }
        return null;
    }
    isValid(startingPoint) {
        if (this.#predecessor) {
            return this.#predecessor.isValid(startingPoint);
        }
        return true; //TODO: check input mandatory
    }
    async toString(tabs = '') {
        const ret = [];
        const tabs1 = tabs + '\t';
        ret.push(tabs + 'id : ' + this.id);
        if (this.#predecessor) {
            ret.push(await this.#predecessor.toString(tabs1));
        }
        else {
            console.error('no predecessor : ', this);
        }
        return ret.join('\n');
    }
}

class Output extends InputOutput {
    #successors = new Set();
    #pixelArray;
    get value() {
        return this.getValue();
    }
    getValue() {
        const valuePromise = new Promise(async (resolve) => {
            await this.node.validate();
            if (this.type == IO_TYPE_TEXTURE_2D) {
                resolve(this._value);
            }
            else {
                resolve(this._value);
            }
        });
        return valuePromise;
    }
    get pixelArray() {
        return this.getPixelArray();
    }
    getPixelArray() {
        const valuePromise = new Promise(async (resolve) => {
            await this.node.validate();
            if (this.type == InputOutputType.Texture2D) {
                resolve(this.#pixelArray ?? null);
            }
            else {
                //TODO: this should resolve to something else
                resolve(this.#pixelArray ?? null);
            }
        });
        return valuePromise;
    }
    addSuccessor(successor) {
        this.#successors.add(successor);
    }
    removeSuccessor(successor) {
        this.#successors.delete(successor);
    }
    hasSuccessor() {
        return this.#successors.size > 0;
    }
    successorsLength() {
        let max = 0;
        for (const successor of this.#successors) {
            const l = successor.node.successorsLength() + 1;
            if (l > max) {
                max = l;
            }
        }
        return max;
    }
    invalidate() {
        for (const successor of this.#successors) {
            successor.node.invalidate();
        }
    }
    /*
    draw(glContext) {
        if (this.node) {
            this.node.draw(glContext);
        }
    }
    */
    getType() {
        if (this.node) {
            return this.node.getType();
        }
        return null;
    }
    isValid(startingPoint) {
        if (this.node) {
            return this.node.isValid(startingPoint);
        }
        return false;
    }
    async toString(tabs = '') {
        return await this.node.toString(tabs);
    }
    dispose() {
        this.#pixelArray = undefined;
    }
}

var DrawState;
(function (DrawState) {
    DrawState[DrawState["Invalid"] = 0] = "Invalid";
    DrawState[DrawState["Valid"] = 1] = "Valid";
})(DrawState || (DrawState = {}));
const PREVIEW_PICTURE_SIZE = 256;
var NodeEventType;
(function (NodeEventType) {
    NodeEventType["Any"] = "*";
    NodeEventType["ParamAdded"] = "paramadded";
    NodeEventType["ParamChanged"] = "paramchanged";
})(NodeEventType || (NodeEventType = {}));
class Node extends MyEventTarget {
    #hasPreview = false;
    id = generateRandomUUID();
    editor;
    inputs = new Map();
    outputs = new Map();
    params = new Map();
    previewPic = new Image(PREVIEW_PICTURE_SIZE, PREVIEW_PICTURE_SIZE);
    previewSize = PREVIEW_PICTURE_SIZE;
    #previewRenderTarget;
    autoRedraw = false;
    #redrawState = DrawState.Invalid;
    //#operation;
    material;
    #pixelArray;
    constructor(editor, params) {
        super();
        this.editor = editor;
        this.setParams(params);
    }
    addInput(inputId, inputType /*TODO: create enum*/, size = 1) {
        const input = new Input(this, inputId, inputType, size);
        this.inputs.set(inputId, input);
        this.invalidate();
        return input;
    }
    addOutput(outputId, outputType /*TODO: create enum*/) {
        const output = new Output(this, outputId, outputType);
        this.outputs.set(outputId, output);
        this.invalidate();
        return output;
    }
    getInput(inputId) {
        return this.inputs.get(inputId);
    }
    getOutput(outputId) {
        return this.outputs.get(outputId);
    }
    async operate(context = {}) {
        throw 'This function must be overriden';
    }
    addParam(param) {
        this.params.set(param.name, param);
        this.#dispatchEvent(NodeEventType.ParamAdded, param);
    }
    getParam(paramName) {
        return this.params.get(paramName);
    }
    getValue(paramName) {
        const p = this.params.get(paramName);
        if (p) {
            return p.value;
        }
        return null;
    }
    setParams(params) {
        if (params) {
            for (const paramName in params) {
                const param = params[paramName];
                const p = this.params.get(paramName);
                if (p) {
                    p.value = param;
                }
            }
            this.invalidate();
        }
    }
    setParam(paramName, paramValue, paramIndex) {
        const p = this.params.get(paramName);
        if (p) {
            if (paramIndex !== undefined) {
                p.value[paramIndex] = paramValue;
            }
            else {
                p.value = paramValue;
            }
            this.#dispatchEvent(NodeEventType.ParamChanged, p);
        }
    }
    setPredecessor(inputId, predecessor, predecessorOutputId) {
        const input = this.inputs.get(inputId);
        const output = predecessor.outputs.get(predecessorOutputId);
        if (input && output) {
            input.setPredecessor(output);
            this.invalidate();
        }
        else {
            console.error('Error : wrong predecessor', this, inputId, predecessor, predecessorOutputId);
        }
    }
    getParams() {
        return this.params;
    }
    invalidate() {
        // Invalidate only if valid to avoid recursion
        if (this.#redrawState != DrawState.Invalid) {
            this.#redrawState = DrawState.Invalid;
            for (const output of this.outputs.values()) {
                output.invalidate();
            }
        }
        if (this.autoRedraw) {
            this.redraw();
        }
    }
    async validate() {
        if (this.#redrawState == DrawState.Invalid) {
            await this.operate();
            this.#redrawState = DrawState.Valid;
        }
    }
    async revalidate() {
        this.invalidate();
        await this.validate();
    }
    async redraw(context = {}) {
        await this.operate(context);
        this.#redrawState = DrawState.Valid;
    }
    getInputCount() {
        return this.inputs.size;
    }
    getType() {
        throw 'This function must be overriden';
    }
    ready() {
        const node = this;
        const promiseFunction = (resolve) => {
            const callback = function () {
                if (node.isValid()) {
                    resolve(true);
                }
                else {
                    setTimeout(callback, 100);
                }
            };
            callback();
        };
        return new Promise(promiseFunction);
    }
    isValid(startingPoint) {
        if (startingPoint == this) {
            return true; // handle cyclic operation
        }
        startingPoint = startingPoint || this;
        if (this.#redrawState == DrawState.Valid) {
            /*
            if (this.#operation && this.#operation.isValid) {
                return this.#operation.isValid(startingPoint);
            } else {
            */
            const inputs = this.inputs;
            for (const i of inputs.values()) {
                if (!i.isValid(startingPoint)) {
                    return false;
                }
            }
            //}
        }
        return this.#redrawState == DrawState.Valid;
    }
    hasSuccessor() {
        for (const output of this.outputs.values()) {
            if (output.hasSuccessor()) {
                return true;
            }
        }
        return false;
    }
    successorsLength() {
        let max = 0;
        for (const output of this.outputs.values()) {
            const l = output.successorsLength();
            if (l > max) {
                max = l;
            }
        }
        return max;
    }
    get title() {
        throw 'This function must be overriden';
    }
    #dispatchEvent(eventName, eventDetail) {
        this.dispatchEvent(new CustomEvent(eventName, { detail: { value: eventDetail } }));
        this.dispatchEvent(new CustomEvent(NodeEventType.Any, { detail: { eventName: eventName } }));
    }
    updatePreview(context = {}) {
        const previewSize = context.previewSize ?? this.previewSize;
        const renderTarget2 = this.#previewRenderTarget ?? new RenderTarget({ width: previewSize, height: previewSize, depthBuffer: false, stencilBuffer: false });
        if (this.#previewRenderTarget) {
            renderTarget2.resize(previewSize, previewSize);
        }
        this.#previewRenderTarget = renderTarget2;
        Graphics$1.pushRenderTarget(renderTarget2);
        if (this.material) {
            this.editor.render(this.material);
        }
        const pixelArray = new Uint8ClampedArray(previewSize * previewSize * 4);
        Graphics$1.glContext.readPixels(0, 0, previewSize, previewSize, GL_RGBA, GL_UNSIGNED_BYTE, pixelArray);
        this.#pixelArray = new Uint8ClampedArray(pixelArray);
        //set alpha to 1
        for (let i = 3; i < pixelArray.length; i += 4) {
            pixelArray[i] = 255;
        }
        const imageData = new ImageData(pixelArray, previewSize, previewSize);
        try {
            imageDataToImage(imageData, this.previewPic);
        }
        catch (e) { }
        this.previewPic.width = previewSize;
        this.previewPic.height = previewSize;
        Graphics$1.popRenderTarget();
    }
    async savePicture(filename = 'texture.png') {
        await this.redraw({ previewSize: 2048 });
        const image = this.previewPic;
        const canvas = createElement('canvas', { width: image.width, height: image.height });
        const ctx = canvas.getContext('2d');
        if (!ctx) {
            return;
        }
        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
        canvas.toBlob((blob) => {
            if (blob) {
                saveFile(new File([blob], filename));
            }
        }); //toDataURL
        //		saveFile(new File([blob], 'texture.png'));
        this.previewPic.width = PREVIEW_PICTURE_SIZE;
        this.previewPic.height = PREVIEW_PICTURE_SIZE;
    }
    async saveVTF(filename = 'texture.vtf') {
        if (!this.#pixelArray) {
            return;
        }
        const vtfFile = new VTFFile(2048, 2048);
        vtfFile.setFlag(TEXTUREFLAGS_EIGHTBITALPHA | TEXTUREFLAGS_NOMIP);
        await this.redraw({ previewSize: 2048 });
        vtfFile.setImageData(this.#pixelArray);
        VTFWriter.writeAndSave(vtfFile, filename);
        this.previewPic.width = PREVIEW_PICTURE_SIZE;
        this.previewPic.height = PREVIEW_PICTURE_SIZE;
    }
    async toString(tabs = '') {
        const ret = [];
        const tabs1 = tabs + '\t';
        ret.push(tabs + this.constructor.name);
        for (const input of this.inputs.values()) {
            if (input.getPredecessor()) {
                ret.push(await input.toString(tabs1));
            }
        }
        return ret.join('\n');
    }
    dispose() {
        if (this.#previewRenderTarget) {
            this.#previewRenderTarget.dispose();
        }
        this.outputs.forEach((output) => output.dispose());
        this.outputs.clear();
    }
    set hasPreview(hasPreview) {
        this.#hasPreview = hasPreview;
    }
    get hasPreview() {
        return this.#hasPreview;
    }
}

var NodeParamType;
(function (NodeParamType) {
    NodeParamType[NodeParamType["Unknown"] = 0] = "Unknown";
    NodeParamType[NodeParamType["Int"] = 1] = "Int";
    NodeParamType[NodeParamType["Bool"] = 2] = "Bool";
    NodeParamType[NodeParamType["Float"] = 3] = "Float";
    NodeParamType[NodeParamType["Radian"] = 4] = "Radian";
    NodeParamType[NodeParamType["Degree"] = 5] = "Degree";
    NodeParamType[NodeParamType["String"] = 6] = "String";
    NodeParamType[NodeParamType["Vec2"] = 7] = "Vec2";
    NodeParamType[NodeParamType["StickerAdjust"] = 8] = "StickerAdjust";
})(NodeParamType || (NodeParamType = {}));
class NodeParam {
    name;
    type;
    value;
    length;
    constructor(name, type, value, length) {
        this.name = name;
        this.type = type;
        this.value = value;
        this.length = length;
    }
}

class NodeImageEditorMaterial extends Material {
    shaderName = '';
    constructor(params) {
        super(params);
        this.shaderName = params?.shaderName;
    }
    getShaderSource() {
        return this.shaderName;
    }
}

vec2.create();
mat3.create();
class ApplySticker extends Node {
    #renderTarget;
    #textureSize;
    inputTexture = null;
    constructor(editor, params) {
        super(editor, params);
        this.hasPreview = true;
        this.addInput('input', IO_TYPE_TEXTURE_2D);
        this.addInput('sticker', IO_TYPE_TEXTURE_2D);
        this.addInput('specular', IO_TYPE_TEXTURE_2D);
        this.addOutput('output', IO_TYPE_TEXTURE_2D);
        this.material = new NodeImageEditorMaterial({ shaderName: 'applysticker' });
        this.material.setDefine('TRANSFORM_TEX_COORD');
        this.material.setDefine('NEED_TWO_TEX_COORDS');
        this.material.addUser(this);
        this.#textureSize = params.textureSize;
        this.addParam(new NodeParam('adjust black', NodeParamType.Float, 0.0));
        this.addParam(new NodeParam('adjust white', NodeParamType.Float, 1.0));
        this.addParam(new NodeParam('adjust gamma', NodeParamType.Float, 1.0));
        this.addParam(new NodeParam('top left', NodeParamType.Vec2, vec2.create()));
        this.addParam(new NodeParam('top right', NodeParamType.Vec2, vec2.create()));
        this.addParam(new NodeParam('bottom left', NodeParamType.Vec2, vec2.create()));
        this.addParam(new NodeParam('path', NodeParamType.String, ''));
        this.addParam(new NodeParam('sticker', NodeParamType.StickerAdjust, vec2.create()));
    }
    async operate(context = {}) {
        if (!this.material) {
            return;
        }
        this.params;
        this.material.setTexture('uSticker', this.inputTexture);
        this.material.setTexture('uStickerSpecular', await this.getInput('specular')?.value);
        this.material.setTexture('uInput', await this.getInput('input')?.value);
        this.material.uniforms['uAdjustLevels'] = vec4.fromValues(this.getValue('adjust black'), this.getValue('adjust white'), this.getValue('adjust gamma'), 0.0);
        const texTransform = mat3.create();
        ComputeTextureMatrixFromRectangle(texTransform, this.getValue('bottom left'), this.getValue('top left'), this.getValue('top right'));
        this.material.uniforms['uTransformTexCoord0'] = texTransform;
        /*texTransform = mat3.identity(texTransform);
        mat3.rotate(texTransform, texTransform, this.params.rotation);
        mat3.translate(texTransform, texTransform, vec2.set(tempVec2, this.params.translateU, this.params.translateV));
        mat3.scale(texTransform, texTransform, vec2.set(tempVec2, this.params.scaleUV, this.params.scaleUV));
        this.material.uniforms['uTransformTexCoord0'] = texTransform;*/
        /*let textureArray = [];
        let usedArray = [];
        for (let i = 0; i < 8; ++i) {
            //let inputName = 'uInput' + i;
            //this.material.uniforms['uInput' + i] = await this.getInput('input' + i).value;
            let texture = await this.getInput('input' + i).value;
            textureArray.push(texture);
            usedArray.push(texture != undefined);
        }

        //this.material.uniforms['uInput[0]'] = await this.getInput('input').value;
        this.material.uniforms['uInput[0]'] = textureArray;
        this.material.uniforms['uUsed[0]'] = usedArray;*/
        //this.material.uniforms['uInput'] = this.inputTexture;
        if (!this.#renderTarget) {
            this.#renderTarget = new RenderTarget({ width: this.#textureSize, height: this.#textureSize, depthBuffer: false, stencilBuffer: false, texture: this.getOutput('output')?._value });
        }
        Graphics$1.pushRenderTarget(this.#renderTarget);
        this.editor.render(this.material);
        /*let pixelArray = new Uint8Array(this.#textureSize * this.#textureSize * 4);
        Graphics.glContext.readPixels(0, 0, this.#textureSize, this.#textureSize, GL_RGBA, GL_UNSIGNED_BYTE, pixelArray);
        Graphics.popRenderTarget();*/
        Graphics$1.popRenderTarget();
        this.updatePreview(context);
        const output = this.getOutput('output');
        if (output) {
            output._value = this.#renderTarget.getTexture();
        }
        //this.getOutput('output')._pixelArray = pixelArray;
    }
    get title() {
        return 'apply sticker';
    }
    async toString(tabs = '') {
        const ret = [];
        const tabs1 = tabs + '\t';
        ret.push(tabs + this.constructor.name);
        for (const input of this.inputs.values()) {
            if (input.getPredecessor()) {
                ret.push(await input.toString(tabs1));
            }
        }
        return ret.join('\n');
    }
    dispose() {
        super.dispose();
        if (this.#renderTarget) {
            this.#renderTarget.dispose();
        }
        if (this.material) {
            this.material.removeUser(this);
        }
    }
}
registerOperation('apply_sticker', ApplySticker);
//void ComputeTextureMatrixFromRectangle( VMatrix* pOutMat, const Vector2D& bl, const Vector2D& tl, const Vector2D& tr )
function ComputeTextureMatrixFromRectangle(out, bl, tl, tr) {
    const tempVec2 = vec2.create();
    const leftEdge = vec2.sub(vec2.create(), bl, tl);
    const topEdge = vec2.sub(vec2.create(), tr, tl);
    const topEdgePerpLeft = vec2.fromValues(-topEdge[1], topEdge[0]);
    const magLeftEdge = vec2.length(leftEdge);
    const magTopEdge = vec2.length(topEdge);
    const xScalar = (vec2.dot(topEdgePerpLeft, leftEdge) > 0) ? 1 : -1;
    // Simplification of acos( ( A . L ) / ( mag( A ) * mag( L ) )
    // Because A is ( 0, 1), which means A . L is just L.y
    // and mag( A ) * mag( L ) is just mag( L )
    const rotationD = Math.acos(leftEdge[1] / magLeftEdge)
        * (leftEdge[0] < 0 ? 1 : -1);
    const texTransform = mat3.create();
    mat3.translate(texTransform, texTransform, tl);
    mat3.rotate(texTransform, texTransform, rotationD);
    mat3.scale(texTransform, texTransform, vec2.set(tempVec2, xScalar * magTopEdge, magLeftEdge));
    mat3.invert(out, texTransform);
}

const tempVec2$2 = vec2.create();
class TextureLookup extends Node {
    #renderTarget;
    #textureSize;
    inputTexture = null;
    constructor(editor, params) {
        super(editor, params);
        this.hasPreview = true;
        this.addOutput('output', IO_TYPE_TEXTURE_2D);
        this.material = new NodeImageEditorMaterial({ shaderName: 'texturelookup' });
        this.material.setDefine('TRANSFORM_TEX_COORD');
        this.material.addUser(this);
        this.#textureSize = params.textureSize;
        /*this.params.adjustBlack = 0;
        this.params.adjustWhite = 1.0;
        this.params.adjustGamma = 1.0;
        this.params.rotation = 0.0;
        this.params.translateU = 0.0;
        this.params.translateV = 0.0;
        this.params.scaleU = 1.0;
        this.params.scaleV = 1.0;*/
        this.addParam(new NodeParam('adjust black', NodeParamType.Float, 0.0));
        this.addParam(new NodeParam('adjust white', NodeParamType.Float, 1.0));
        this.addParam(new NodeParam('adjust gamma', NodeParamType.Float, 1.0));
        this.addParam(new NodeParam('rotation', NodeParamType.Radian, 0.0));
        this.addParam(new NodeParam('translate u', NodeParamType.Float, 0.0));
        this.addParam(new NodeParam('translate v', NodeParamType.Float, 0.0));
        this.addParam(new NodeParam('scale u', NodeParamType.Float, 1.0));
        this.addParam(new NodeParam('scale v', NodeParamType.Float, 1.0));
        this.addParam(new NodeParam('path', NodeParamType.String, ''));
    }
    async operate(context = {}) {
        if (!this.material) {
            return;
        }
        this.material.setTexture('uInput', this.inputTexture);
        this.material.uniforms['uAdjustLevels'] = vec4.fromValues(this.getValue('adjust black'), this.getValue('adjust white'), this.getValue('adjust gamma'), 0.0);
        const texTransform = mat3.create();
        mat3.rotate(texTransform, texTransform, this.getValue('rotation'));
        mat3.scale(texTransform, texTransform, vec2.set(tempVec2$2, this.getValue('scale u'), this.getValue('scale v')));
        mat3.translate(texTransform, texTransform, vec2.set(tempVec2$2, this.getValue('translate u'), this.getValue('translate v')));
        this.material.uniforms['uTransformTexCoord0'] = texTransform;
        //console.error(this.params, this.testing);
        if (!this.#renderTarget) {
            this.#renderTarget = new RenderTarget({ width: this.#textureSize, height: this.#textureSize, depthBuffer: false, stencilBuffer: false });
        }
        Graphics$1.pushRenderTarget(this.#renderTarget);
        this.editor.render(this.material);
        const pixelArray = new Uint8Array(this.#textureSize * this.#textureSize * 4);
        Graphics$1.glContext.readPixels(0, 0, this.#textureSize, this.#textureSize, GL_RGBA, GL_UNSIGNED_BYTE, pixelArray);
        Graphics$1.popRenderTarget();
        this.updatePreview(context);
        const output = this.getOutput('output');
        if (output) {
            output._value = this.#renderTarget.getTexture();
            output._pixelArray = pixelArray;
        }
    }
    get title() {
        return 'texture lookup';
    }
    async toString(tabs = '') {
        const ret = [];
        const tabs1 = tabs + '\t';
        ret.push(tabs + this.constructor.name);
        for (const input of this.inputs.values()) {
            if (input.getPredecessor()) {
                ret.push(await input.toString(tabs1));
            }
        }
        ret.push(tabs1 + `black : ${this.getValue('adjust black')}, white : ${this.getValue('adjust white')}, gamma : ${this.getValue('adjust gamma')}`);
        return ret.join('\n');
    }
    dispose() {
        super.dispose();
        if (this.#renderTarget) {
            this.#renderTarget.dispose();
        }
    }
}
registerOperation('texture lookup', TextureLookup);

const DELAY_BEFORE_REFRESH = 100;
const FLOAT_VALUE_DECIMALS = 3;
function dropFiles(evt, node) {
    const files = evt.target.files; // FileList object
    if (!files) {
        return;
    }
    // Loop through the FileList and render image files as thumbnails.
    for (let i = 0, f; f = files[i]; i++) {
        // Only process image files.
        if (!f.type.match('image.*')) {
            continue;
        }
        const reader = new FileReader();
        // Closure to capture the file information.
        reader.onload = (function (theFile) {
            return function (e) {
                const texture = TextureManager.createTexture({ minFilter: GL_LINEAR });
                if (node instanceof ApplySticker) {
                    texture.wrapS = GL_CLAMP_TO_EDGE;
                    texture.wrapT = GL_CLAMP_TO_EDGE;
                }
                texture.setParameters(Graphics$1.glContext, GL_TEXTURE_2D);
                const image = new Image();
                image.onload = () => {
                    TextureManager.fillTextureWithImage(texture, image);
                    node.inputTexture = texture;
                    node.invalidate();
                    node.validate();
                };
                image.src = e.target.result?.toString() ?? '';
            };
        })();
        // Read in the image file as a data URL.
        reader.readAsDataURL(f);
    }
}
function dropFilesSpecular(evt, node) {
    const files = evt.target.files; // FileList object
    if (!files) {
        return;
    }
    // Loop through the FileList and render image files as thumbnails.
    for (let i = 0, f; f = files[i]; i++) {
        // Only process image files.
        if (!f.type.match('image.*')) {
            continue;
        }
        const reader = new FileReader();
        // Closure to capture the file information.
        reader.onload = (function (theFile) {
            return function (e) {
                const texture = TextureManager.createTexture({ minFilter: GL_LINEAR });
                if (node instanceof ApplySticker) {
                    texture.wrapS = GL_CLAMP_TO_EDGE;
                    texture.wrapT = GL_CLAMP_TO_EDGE;
                }
                texture.setParameters(Graphics$1.glContext, GL_TEXTURE_2D);
                const image = new Image();
                image.onload = () => {
                    TextureManager.fillTextureWithImage(texture, image);
                    const specular = node.getInput('specular');
                    if (specular) {
                        specular.value = texture;
                    }
                    //node.invalidate();
                    node.validate();
                };
                image.src = e.target.result?.toString() ?? '';
            };
        })();
        // Read in the image file as a data URL.
        reader.readAsDataURL(f);
    }
}
var FlipDirection;
(function (FlipDirection) {
    FlipDirection[FlipDirection["FlipUp"] = 0] = "FlipUp";
    FlipDirection[FlipDirection["FlipDown"] = 1] = "FlipDown";
    FlipDirection[FlipDirection["FlipLeft"] = 2] = "FlipLeft";
    FlipDirection[FlipDirection["FlipRight"] = 3] = "FlipRight";
    FlipDirection[FlipDirection["FlipX"] = 4] = "FlipX";
    FlipDirection[FlipDirection["FlipY"] = 5] = "FlipY";
})(FlipDirection || (FlipDirection = {}));
class NodeGui {
    #expanded = true;
    #html;
    #htmlPreview;
    #htmlRectSelector;
    #drag = '';
    #htmlParamsContainer;
    _ioGui = new Map(); // TODO: set private
    #refreshTimeout = 0;
    #nodeChanged;
    #node;
    #nodeImageEditorGui;
    #dragStartClientX = 0;
    #dragStartClientY = 0;
    #htmlParams = new Map();
    #htmlParamsValue = new Map();
    constructor(nodeImageEditorGui, node) {
        this.#nodeChanged = () => {
            clearTimeout(this.#refreshTimeout);
            this.#refreshTimeout = setTimeout(() => this.#refreshHtml(), DELAY_BEFORE_REFRESH);
        };
        this.#nodeImageEditorGui = nodeImageEditorGui;
        this.#node = node;
        this.#initHtml();
        this.#node.addEventListener(NodeEventType.Any, this.#nodeChanged);
    }
    set expanded(expanded) {
        this.#expanded = expanded;
        this.#html.classList[!expanded ? 'add' : 'remove']('collapsed');
    }
    get expanded() {
        return this.#expanded;
    }
    get node() {
        return this.#node;
    }
    get html() {
        return this.#html;
    }
    set nodeImageEditorGui(nodeImageEditorGui) {
        this.#nodeImageEditorGui = nodeImageEditorGui;
    }
    #handlePreviewDragOver(event) {
        event.preventDefault();
        console.log(event);
        switch (this.#drag) {
            case 'move':
                this.#htmlRectSelector.style.top = event.offsetY - this.#dragStartClientY + 'px';
                this.#htmlRectSelector.style.left = event.offsetX - this.#dragStartClientX + 'px';
                break;
        }
    }
    #increasePreviewSize() {
        if (this.#node) {
            this.#node.previewSize *= 2;
            this.#node.updatePreview();
            this.#nodeImageEditorGui.refresh();
        }
    }
    #decreasePreviewSize() {
        if (this.#node) {
            this.#node.previewSize /= 2;
            this.#node.updatePreview();
            this.#nodeImageEditorGui.refresh();
        }
    }
    #initHtml() {
        let htmlInputs;
        let htmlOutputs;
        this.#html = createElement('div', {
            class: 'node-image-editor-node',
            childs: [
                createElement('div', {
                    class: 'node-image-editor-node-header',
                    childs: [
                        createElement('div', { class: 'node-image-editor-node-title', innerText: this.#node.title }),
                        createElement('div', {
                            class: 'node-image-editor-node-buttons',
                            childs: [
                                createElement('div', {
                                    innerHTML: zoomOutSVG,
                                    events: {
                                        click: () => this.#decreasePreviewSize(),
                                    }
                                }),
                                createElement('div', {
                                    innerHTML: zoomInSVG,
                                    events: {
                                        click: () => this.#increasePreviewSize(),
                                    }
                                }),
                            ]
                        }),
                    ],
                }),
                createElement('div', {
                    class: 'node-image-editor-node-content',
                    childs: [
                        htmlInputs = createElement('div', { class: 'node-image-editor-node-ios' }),
                        this.#htmlParamsContainer = createElement('div', { class: 'node-image-editor-node-params' }),
                        htmlOutputs = createElement('div', { class: 'node-image-editor-node-ios' }),
                    ],
                }),
            ]
        });
        this.#htmlPreview = createElement('div', {
            class: 'node-image-editor-node-preview',
            child: this.#node.previewPic,
            events: {
                dragover: (event) => this.#handlePreviewDragOver(event),
            }
        });
        if (this.#node.hasPreview) {
            this.#html.append(this.#htmlPreview);
        }
        for (const input of this.#node.inputs.values()) {
            htmlInputs.append(this.#createIo(input));
        }
        for (const output of this.#node.outputs.values()) {
            htmlOutputs.append(this.#createIo(output));
        }
        if (this.#node.hasPreview) {
            const htmlSavePicture = createElement('button', { i18n: '#save_picture' });
            htmlSavePicture.addEventListener('click', () => this.#node.savePicture());
            this.#html.append(htmlSavePicture);
            const htmlSaveVTF = createElement('button', { i18n: '#save_vtf' });
            htmlSaveVTF.addEventListener('click', () => this.#node.saveVTF());
            this.#html.append(htmlSaveVTF);
        }
        if ((this.#node instanceof TextureLookup) || this.#node instanceof ApplySticker) {
            const inputImage = createElement('input', { type: 'file', accept: 'image/*' });
            inputImage.addEventListener('input', (event) => dropFiles(event, this.#node));
            this.#htmlPreview.addEventListener('click', (event) => { if (event.target == this.#node.previewPic) {
                inputImage.click();
            } });
        }
        if (this.#node instanceof ApplySticker) {
            const htmlLoadStickerSpecular = createElement('button', { i18n: '#load_sticker_specular' });
            this.#html.append(htmlLoadStickerSpecular);
            const inputImage = createElement('input', { type: 'file', accept: 'image/*' });
            inputImage.addEventListener('input', (event) => dropFilesSpecular(event, this.#node));
            htmlLoadStickerSpecular.addEventListener('click', () => inputImage.click());
        }
        this.#refreshHtml();
        this.#initResizeObserver();
    }
    #initResizeObserver() {
        const callback = (entries, observer) => {
            entries.forEach(entry => {
                this.#updateManipulator();
            });
        };
        const resizeObserver = new ResizeObserver(callback);
        resizeObserver.observe(this.#htmlPreview);
    }
    #refreshHtml() {
        this.#htmlParamsContainer.innerText = '';
        for (const [_, param] of this.#node.params) {
            if (param.length && param.length > 1) {
                for (let i = 0; i < param.length; ++i) {
                    this.#htmlParamsContainer.append(this.#getParamHTML(param, i));
                }
            }
            else {
                this.#htmlParamsContainer.append(this.#getParamHTML(param));
            }
        }
    }
    #getParamHTML(param, index) {
        let paramHtml;
        if (index === undefined) {
            paramHtml = this.#htmlParams.get(param.name) ?? this.#createParamHTML(param, index);
        }
        else {
            paramHtml = this.#htmlParams.get(param.name)?.[index] ?? this.#createParamHTML(param, index);
        }
        if (Array.isArray(paramHtml)) {
            paramHtml = paramHtml[index];
        }
        let value;
        if (index !== undefined) {
            value = param.value[index];
        }
        else {
            value = param.value;
        }
        const valueHtml = this.#htmlParamsValue.get(paramHtml);
        switch (param.type) {
            case NodeParamType.Float:
            case NodeParamType.Degree:
                value = Number(value).toFixed(FLOAT_VALUE_DECIMALS);
                break;
            case NodeParamType.Radian:
                value = Number(value * RAD_TO_DEG).toFixed(FLOAT_VALUE_DECIMALS);
                break;
            case NodeParamType.Vec2:
                value = `${Number(value[0]).toFixed(FLOAT_VALUE_DECIMALS)} ${Number(value[1]).toFixed(FLOAT_VALUE_DECIMALS)}`;
                break;
            case NodeParamType.StickerAdjust:
                this.#updateManipulator();
                break;
        }
        if (valueHtml) {
            valueHtml.value = value;
        }
        return paramHtml;
    }
    #createParamHTML(param, index) {
        const paramHtml = createElement('div', { class: 'node-image-editor-node-param' });
        const nameHtml = createElement('div', { parent: paramHtml, class: 'name' });
        let valueHtml;
        if (param.type != NodeParamType.StickerAdjust) {
            valueHtml = createElement('input', {
                parent: paramHtml,
                events: {
                    change: (event) => this.#setParamValue(param, event.target.value, index)
                }
            });
            createElement('span', {
                class: 'copy-button',
                parent: paramHtml,
                innerHTML: contentCopySVG,
                events: {
                    click: async () => {
                        await navigator.clipboard.writeText(valueHtml.value);
                        valueHtml.classList.add('flash');
                        await setTimeoutPromise(1500);
                        valueHtml.classList.remove('flash');
                    },
                }
            });
            this.#htmlParamsValue.set(paramHtml, valueHtml);
        }
        nameHtml.innerText = param.name;
        if (param.type == NodeParamType.StickerAdjust) {
            defineHarmony2dManipulator();
            defineHarmonyToggleButton();
            createElement('div', {
                parent: paramHtml,
                childs: [
                    createElement('div', {
                        childs: [
                            createElement('div', {
                                childs: [
                                    createElement('button', {
                                        i18n: '#flip_up',
                                        class: 'sticker',
                                        $click: () => this.#flipSticker(FlipDirection.FlipUp),
                                    }),
                                    createElement('button', {
                                        i18n: '#flip_down',
                                        class: 'sticker',
                                        $click: () => this.#flipSticker(FlipDirection.FlipDown),
                                    }),
                                ],
                            }),
                            createElement('div', {
                                childs: [
                                    createElement('button', {
                                        i18n: '#flip_left',
                                        class: 'sticker',
                                        $click: () => this.#flipSticker(FlipDirection.FlipLeft),
                                    }),
                                    createElement('button', {
                                        i18n: '#flip_right',
                                        class: 'sticker',
                                        $click: () => this.#flipSticker(FlipDirection.FlipRight),
                                    }),
                                ]
                            }),
                        ],
                    }),
                    createElement('div', {
                        childs: [
                            createElement('harmony-toggle-button', {
                                class: 'sticker',
                                parent: paramHtml,
                                state: true,
                                childs: [
                                    createElement('div', {
                                        slot: 'off',
                                        innerHTML: dragPanSVG,
                                    }),
                                    createElement('div', {
                                        slot: 'on',
                                        innerHTML: dragPanSVG,
                                    }),
                                ],
                                events: {
                                    change: (event) => this.#htmlRectSelector.setMode({ translation: event.target.state ? ManipulatorDirection.All : ManipulatorDirection.None }),
                                }
                            }),
                            createElement('harmony-toggle-button', {
                                class: 'sticker',
                                parent: paramHtml,
                                state: true,
                                childs: [
                                    createElement('div', {
                                        slot: 'off',
                                        innerHTML: panZoomSVG,
                                    }),
                                    createElement('div', {
                                        slot: 'on',
                                        innerHTML: panZoomSVG,
                                    }),
                                ],
                                events: {
                                    change: (event) => this.#htmlRectSelector.setMode({
                                        resize: event.target.state ? ManipulatorDirection.All : ManipulatorDirection.None,
                                        scale: event.target.state ? ManipulatorDirection.All : ManipulatorDirection.None,
                                    }),
                                }
                            }),
                            createElement('harmony-toggle-button', {
                                class: 'sticker',
                                parent: paramHtml,
                                state: true,
                                childs: [
                                    createElement('div', {
                                        slot: 'off',
                                        innerHTML: rotateSVG,
                                    }),
                                    createElement('div', {
                                        slot: 'on',
                                        innerHTML: rotateSVG,
                                    }),
                                ],
                                events: {
                                    change: (event) => this.#htmlRectSelector.setMode({ rotation: event.target.state }),
                                }
                            }),
                        ],
                    }),
                ],
            });
            this.#htmlRectSelector = this.#htmlRectSelector ?? createElement('harmony-2d-manipulator', {
                class: 'node-image-editor-sticker-selector',
                parent: this.#htmlPreview,
                events: {
                    updateend: (event) => {
                        const parameters = { 'top left': 0, 'bottom left': 2, 'top right': 1 };
                        const manipulator = event.target;
                        for (const name in parameters) {
                            const param = this.#node.getParam(name);
                            if (param) {
                                const rect = this.#htmlPreview.getBoundingClientRect();
                                const corner = manipulator.getCorner(parameters[name]);
                                this.#setParamValue(param, `${corner.x / rect.width} ${corner.y / rect.width}`, undefined, false);
                            }
                        }
                    },
                },
                attributes: {
                    'min-width': "-Infinity",
                    'min-height': "-Infinity",
                }
            });
            this.#updateManipulator();
        }
        if (index === undefined) {
            this.#htmlParams.set(param.name, paramHtml);
        }
        else {
            if (!this.#htmlParams.has(param.name)) {
                this.#htmlParams.set(param.name, []);
            }
            this.#htmlParams.get(param.name)[index] = paramHtml;
        }
        return paramHtml;
    }
    #updateManipulator() {
        const rect = this.#htmlPreview.getBoundingClientRect();
        const A = this.#node.getValue('top left');
        const D = this.#node.getValue('bottom left');
        const C = this.#node.getValue('top right');
        if (!A || !D || !C) {
            return;
        }
        const AC = vec2.sub(vec2.create(), C, A);
        const AD = vec2.sub(vec2.create(), D, A);
        const B = vec2.add(vec2.create(), AC, D);
        const a1 = B[0] - A[0];
        const a2 = B[1] - A[1];
        const c1 = D[0] - C[0];
        const c2 = D[1] - C[1];
        const t = (a2 * C[0] - a2 * A[0] - a1 * C[1] + a1 * A[1]) / (-a2 * c1 + a1 * c2);
        const cross = vec2.cross(vec3.create(), AD, AC);
        const flip = cross[2] > 0;
        const center = vec2.fromValues((C[0] + c1 * t) * rect.width, (C[1] + c2 * t) * rect.height);
        const width = vec2.len(AC) * rect.width * (flip ? -1 : 1);
        const height = vec2.len(AD) * rect.height;
        const angle = Math.atan2(AC[1], AC[0]) + (flip ? Math.PI : 0);
        this.#htmlRectSelector.set({
            rotation: angle,
            left: center[0],
            top: center[1],
            width: width,
            height: height
        });
    }
    #setParamValue(param, stringValue, index, updateManipulator = true) {
        const node = this.#node;
        let value;
        switch (param.type) {
            case NodeParamType.Float:
            case NodeParamType.Degree:
                value = Number(Number(stringValue).toFixed(FLOAT_VALUE_DECIMALS));
                break;
            case NodeParamType.Radian:
                value = Number(stringValue) * DEG_TO_RAD;
                break;
            case NodeParamType.Vec2:
                const arr = stringValue.split(' ');
                value = vec2.fromValues(Number(arr[0]), Number(arr[1]));
                break;
            default:
                value = Number(stringValue);
        }
        if (updateManipulator && (param.name == 'top left' || param.name == 'bottom left' || param.name == 'top right')) {
            this.#updateManipulator();
        }
        node.setParam(param.name, value, index);
        node.revalidate();
    }
    #createIo(io) {
        const html = createElement('div', { class: 'node-image-editor-node-io' });
        this._ioGui.set(io, html);
        return html;
    }
    #flipSticker(flip) {
        const topLeft = vec2.copy(vec2.create(), this.#node.getValue('top left'));
        const bottomLeft = vec2.copy(vec2.create(), this.#node.getValue('bottom left'));
        const topRight = vec2.copy(vec2.create(), this.#node.getValue('top right'));
        const newTopLeft = vec2.copy(vec2.create(), topLeft);
        const newBottomLeft = vec2.copy(vec2.create(), bottomLeft);
        const newTopRight = vec2.copy(vec2.create(), topRight);
        const top = vec2.sub(vec2.create(), topRight, topLeft);
        const left = vec2.sub(vec2.create(), bottomLeft, topLeft);
        const bottomRight = vec2.add(vec2.create(), top, bottomLeft);
        const topN = vec2.normalize(vec2.create(), top);
        const leftN = vec2.normalize(vec2.create(), left);
        switch (flip) {
            case FlipDirection.FlipUp:
                //delta = bottomLeft[1] - topLeft[1];
                //newBottomLeft[1] = topLeft[1] - delta;
                const DA = vec2.sub(vec2.create(), topLeft, bottomLeft);
                //const n1 = vec2.multiply(vec2.create(), vec2.dot(DA, topN));
                const v = vec2.scaleAndAdd(vec2.create(), DA, topN, -2 * vec2.dot(DA, topN));
                vec2.add(newBottomLeft, topLeft, v);
                //newBottomLeft[1] = topLeft[1] - delta;
                break;
            case FlipDirection.FlipDown:
                const AD = vec2.sub(vec2.create(), bottomLeft, topLeft);
                const v1 = vec2.scaleAndAdd(vec2.create(), AD, topN, -2 * vec2.dot(AD, topN));
                vec2.add(newTopLeft, bottomLeft, v1);
                vec2.add(newTopRight, bottomRight, v1);
                /*
                delta = bottomLeft[1] - topLeft[1];
                newTopLeft[1] = bottomLeft[1] + delta;
                newTopRight[1] = bottomLeft[1] + delta;
                */
                break;
            case FlipDirection.FlipLeft:
                const CA = vec2.sub(vec2.create(), topLeft, topRight);
                const v2 = vec2.scaleAndAdd(vec2.create(), CA, leftN, -2 * vec2.dot(CA, leftN));
                vec2.add(newTopRight, topLeft, v2);
                //vec2.add(newTopRight, bottomRight, v1);
                break;
            case FlipDirection.FlipRight:
                const AC = vec2.sub(vec2.create(), topRight, topLeft);
                const v3 = vec2.scaleAndAdd(vec2.create(), AC, leftN, -2 * vec2.dot(AC, leftN));
                vec2.add(newTopLeft, topRight, v3);
                vec2.add(newBottomLeft, bottomRight, v3);
                break;
        }
        /*

                newTopLeft[1] = bottomLeft[1];
                newBottomLeft[1] = topLeft[1];
                newTopRight[1] = bottomLeft[1];
                */
        //this.#setParamValue(param, `${corner.x / rect.width} ${corner.y / rect.width}`, undefined, false);
        const node = this.#node;
        node.setParam('top left', newTopLeft);
        node.setParam('bottom left', newBottomLeft);
        node.setParam('top right', newTopRight);
        this.#updateManipulator();
        node.revalidate();
        /*

        this.#htmlRectSelector.set({
            width: -0.06,
        });
        */
    }
}

class NodeImageEditorGui {
    #filter = {};
    #shadowRoot;
    #imageEditorChanged;
    #refreshTimeout = 0;
    #nodesGui = new Map();
    #nodeImageEditor;
    #htmlNodeFilter;
    #htmlNodes;
    #canvas;
    #context;
    constructor(nodeImageEditor) {
        this.#imageEditorChanged = () => {
            clearTimeout(this.#refreshTimeout);
            this.#refreshTimeout = setTimeout(() => this.#refreshHtml(), DELAY_BEFORE_REFRESH);
        };
        this.setNodeImageEditor(nodeImageEditor);
        this.#shadowRoot = createShadowRoot('node-image-editor', {
            adoptStyle: nodeImageEditorCSS,
        });
        I18n.observeElement(this.#shadowRoot);
        createElement('div', {
            class: 'node-image-editor-header',
            parent: this.#shadowRoot,
            childs: [
                this.#htmlNodeFilter = createElement('input', {
                    class: 'node-image-editor-node-filter',
                    events: {
                        input: (event) => { this.#filter.node = event.target.value; this.#refreshFilter(); },
                    }
                }),
            ]
        });
        this.#htmlNodes = createElement('div', {
            class: 'node-image-editor-nodes',
            parent: this.#shadowRoot,
        });
        this.#canvas = createElement('canvas', {
            class: 'node-image-editor-canvas',
            style: 'z-index:1000;position:absolute;',
            parent: this.#htmlNodes,
        });
        this.#context = this.#canvas.getContext('2d');
        this.#initResizeObserver();
        this.#setCanvasSize();
    }
    /**
     * @deprecated Please use `setNodeImageEditor` instead.
     */
    set nodeImageEditor(nodeImageEditor) {
        console.warn('set nodeImageEditor is deprecated, use setNodeImageEditor instead');
        this.setNodeImageEditor(nodeImageEditor);
    }
    setNodeImageEditor(nodeImageEditor) {
        if (this.#nodeImageEditor == nodeImageEditor) {
            return;
        }
        if (this.#nodeImageEditor) {
            this.#nodeImageEditor.removeEventListener(NodeImageEditorEventType.Any, this.#imageEditorChanged);
        }
        this.#nodeImageEditor = nodeImageEditor;
        this.#nodeImageEditor?.addEventListener(NodeImageEditorEventType.Any, this.#imageEditorChanged);
    }
    get htmlElement() {
        return this.#shadowRoot.host;
    }
    #setCanvasSize() {
        this.#canvas.height = 0;
        this.#canvas.width = 0;
        this.#canvas.height = this.#htmlNodes.scrollHeight;
        this.#canvas.width = this.#htmlNodes.scrollWidth;
        this.#drawLinks();
    }
    #initResizeObserver() {
        const callback = (entries, observer) => {
            entries.forEach(entry => {
                this.#setCanvasSize();
            });
        };
        const resizeObserver = new ResizeObserver(callback);
        resizeObserver.observe(this.#htmlNodes);
    }
    #refreshHtml() {
        this.#htmlNodes.innerText = '';
        this.#htmlNodes.append(this.#canvas);
        if (this.#nodeImageEditor) {
            for (const node of this.#nodeImageEditor.getNodes()) {
                let nodeGui = this.#nodesGui.get(node);
                if (!nodeGui) {
                    nodeGui = new NodeGui(this, node);
                    this.#nodesGui.set(node, nodeGui);
                }
                this.#htmlNodes.append(nodeGui.html);
            }
        }
        //TODO: remove old nodes from this.#nodesGui
        this.#refreshFilter();
    }
    #organizeNodes() {
        this.#htmlNodes.innerText = '';
        this.#htmlNodes.append(this.#canvas);
        const nodes = new Map();
        if (this.#nodeImageEditor) {
            for (const node of this.#nodeImageEditor.getNodes()) {
                const nodeGui = this.#nodesGui.get(node);
                const l = node.successorsLength();
                //nodeGui.html.style.right = l * WIDTH + 'px';
                let s = nodes.get(l);
                if (!s) {
                    s = [];
                    nodes.set(l, s);
                }
                if (nodeGui) {
                    s.push(nodeGui);
                }
            }
        }
        nodes[Symbol.iterator] = function* () {
            yield* [...this.entries()].sort((a, b) => {
                return a[0] < b[0] ? -1 : 1;
            });
        };
        for (const [s, n] of nodes) {
            const column = createElement('div', { class: 'node-image-editor-nodes-column' });
            this.#htmlNodes.prepend(column);
            for (let i = 0; i < n.length; ++i) {
                const nodeGui = n[i];
                //nodeGui.html.style.top = i * HEIGHT + 'px';
                nodeGui.html.getBoundingClientRect();
                //maxHeight = Math.max(maxHeight, rect.bottom);
                column.append(nodeGui.html);
            }
        }
        //this.#htmlNodes.style.height = maxHeight + 'px';;
    }
    #drawLink(p1, p2) {
        if (p1 && p2) {
            const context = this.#context;
            let p1BoundingRect = p1.getBoundingClientRect();
            let p2BoundingRect = p2.getBoundingClientRect();
            let p1Weight = 1;
            let p2Weight = 1;
            if (p1BoundingRect.height == 0 || p1BoundingRect.width == 0) {
                p1BoundingRect = p1?.parentNode?.parentNode?.parentNode?.getBoundingClientRect();
                p1Weight = 2;
            }
            if (p2BoundingRect.height == 0 || p2BoundingRect.width == 0) {
                p2BoundingRect = p2?.parentNode?.parentNode?.parentNode?.getBoundingClientRect();
                p2Weight = 0;
            }
            const panelBoundingRect = this.#canvas.getBoundingClientRect();
            const x1 = p1BoundingRect.left + p1BoundingRect.width / 2 * p1Weight - panelBoundingRect.left;
            const y1 = p1BoundingRect.top + p1BoundingRect.height / 2 - panelBoundingRect.top;
            const x2 = p2BoundingRect.left + p2BoundingRect.width / 2 * p2Weight - panelBoundingRect.left;
            const y2 = p2BoundingRect.top + p2BoundingRect.height / 2 - panelBoundingRect.top;
            context.beginPath();
            context.moveTo(x1, y1);
            //context.bezierCurveTo(Math.max(x2, x1 + max),y1,Math.min(x1, x2 - max),y2,x2,y2);
            let xa, xb;
            if (x2 > x1) {
                xa = (x1 + x2) / 2;
                xb = (x1 + x2) / 2;
            }
            else {
                xa = x1 + 100;
                xb = x2 - 100;
            }
            context.bezierCurveTo(xa, y1, xb, y2, x2, y2);
            context.lineWidth = 2;
            context.strokeStyle = '#EEEEEE';
            context.stroke();
        }
    }
    #drawLinks() {
        this.#context.clearRect(0, 0, this.#canvas.clientWidth, this.#canvas.clientHeight);
        if (this.#nodeImageEditor) {
            for (const node of this.#nodeImageEditor.getNodes()) {
                const nodeGui = this.#nodesGui.get(node);
                const inputs = node.inputs;
                for (const input of inputs.values()) {
                    if (input.getPredecessor()) {
                        const predecessorNode = input.getPredecessor()?.node;
                        if (!predecessorNode) {
                            continue;
                        }
                        const nodeGui2 = this.#nodesGui.get(predecessorNode);
                        if (nodeGui && nodeGui2) {
                            const inputGui = nodeGui._ioGui.get(input);
                            const predecessor = input.getPredecessor();
                            if (predecessor) {
                                const outputGui = nodeGui2._ioGui.get(predecessor);
                                if (outputGui && inputGui) {
                                    this.#drawLink(outputGui, inputGui);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    #refreshFilter() {
        if (this.#nodeImageEditor) {
            for (const node of this.#nodeImageEditor.getNodes()) {
                const nodeGui = this.#nodesGui.get(node);
                if (nodeGui) {
                    this.#matchFilter(nodeGui);
                }
            }
        }
        this.refresh();
    }
    refresh() {
        this.#organizeNodes();
        this.#drawLinks();
    }
    #matchFilter(nodeGUI) {
        let expanded = true;
        if (this.#filter.node) {
            if (!nodeGUI.node.title.includes(this.#filter.node)) {
                expanded = false;
            }
        }
        nodeGUI.expanded = expanded;
    }
    setNodeFilter(nodeName) {
        this.#htmlNodeFilter.value = nodeName;
        this.#filter.node = nodeName;
        this.#refreshFilter();
    }
    getNodeFilter() {
        return this.#filter.node ?? '';
    }
}

var nodeimageeditor_declare_functions = `
#define SKIP_SRGB_ENC_DEC

float4 invlerp( float x, float y, float4 r )
{
	return ( r - x ) / ( y - x );
}


float4 ConvertLinearTosRGB( float4 lin )
{
	#ifdef SKIP_SRGB_ENC_DEC
		return lin;
	#else
		float3 col_lin = lin.xyz;
		float3 col_srgb;
		for (int i = 0; i < 3; ++i)
		{
			if ( col_lin[i] <= 0.0031308 )
				col_srgb[i] = 12.92 * col_lin[i];
			else
				col_srgb[i] = 1.055 * pow( col_lin[i], 1.0 / 2.4 ) - 0.055;
		}

		return float4( col_srgb.xyz, lin.a );
	#endif
}

float4 ConvertsRGBToLinear( float4 srgb )
{
	#ifdef SKIP_SRGB_ENC_DEC
		return srgb;
	#else
		float3 col_srgb = srgb.xyz;
		float3 col_lin;

		for (int i = 0; i < 3; ++i)
		{
			if ( col_srgb[i] <= 0.04045 )
				col_lin[i] = col_srgb[i] / 12.92;
			else
				col_lin[i] = pow( ( col_srgb[i] + 0.055 ) / 1.055, 2.4 );
		}

		return float4( col_lin.xyz, srgb.a );
	#endif
}

// Uses photoshop math to perform level adjustment.
// Note: Photoshop does this math in sRGB space, even though that is mathematically wrong.
// To match photoshop, we have to convert our textures from linear space (they're always linear in the shader)
// to sRGB, perform the calculations and then return to linear space for output from the shader.
// Yuck.
/*float AdjustLevels( float inSrc, float inBlackPoint, float inWhitePoint, float inGammaValue )
{
	if ( inBlackPoint == 0.0 && inWhitePoint == 1.0 && inGammaValue == 1.0 )
		return inSrc;
	else
	{
		inSrc = ConvertLinearTosRGB( inSrc );

		float pcg = saturate( invlerp( inBlackPoint, inWhitePoint, inSrc ) );
		float gammaAdjusted = pow( pcg, inGammaValue );

		gammaAdjusted = ConvertsRGBToLinear( gammaAdjusted );

		return saturate( gammaAdjusted );
	}
}*/

float4 AdjustLevels( float4 inSrc, float inBlackPoint, float inWhitePoint, float inGammaValue )
{
	if ( inBlackPoint == 0.0 && inWhitePoint == 1.0 && inGammaValue == 1.0 )
		return inSrc;
	else
	{
		inSrc = ConvertLinearTosRGB( inSrc );

		float4 pcg = saturate( invlerp( inBlackPoint, inWhitePoint, inSrc ) );
		float4 gammaAdjusted = pow( pcg, vec4(inGammaValue) );

		gammaAdjusted = ConvertsRGBToLinear( gammaAdjusted );

		return saturate( gammaAdjusted );
	}
}

`;

var nodeimageeditor_imageeditor_vs = `
attribute vec3 aVertexPosition;
attribute vec2 aTextureCoord;

#ifdef NEED_TWO_TEX_COORDS
varying vec4 vTextureCoord;
#else
varying vec2 vTextureCoord;
#endif

#ifdef TRANSFORM_TEX_COORD
	uniform mat3 uTransformTexCoord0;
#endif

/*imageeditor.vs*/
void main(void) {
	//gl_Position = vec4(aVertexPosition, 1.0);
	#include compute_vertex_projection
#ifdef TRANSFORM_TEX_COORD
	vTextureCoord.xy = vec3(uTransformTexCoord0 * vec3(aTextureCoord, 1.0)).xy;
	#ifdef NEED_TWO_TEX_COORDS
		vTextureCoord.zw = aTextureCoord.xy;
	#endif
#else
	vTextureCoord = aTextureCoord;
#endif

}
`;

Includes['nodeimageeditor_declare_functions'] = nodeimageeditor_declare_functions;
Includes['nodeimageeditor_imageeditor_vs'] = nodeimageeditor_imageeditor_vs;

class ParametersNode extends Node {
    isParametersNode = true;
}

class FloatArrayNode extends ParametersNode {
    #length;
    #array = [];
    constructor(editor, params) {
        super(editor, params);
        this.#length = params.length ?? 0;
        this.addOutput('output', IO_TYPE_ARRAY_FLOAT);
        for (let i = 0; i < this.#length; ++i) {
            this.#array.push(0);
        }
        this.addParam(new NodeParam('value', NodeParamType.Float, this.#array, this.#length));
    }
    async operate(context = {}) {
        const output = this.getOutput('output');
        if (output) {
            output._value = this.#array;
        }
    }
    get title() {
        return 'float array';
    }
    setValue(index, value) {
        if (index >= this.#length) {
            throw 'wrong index';
        }
        this.#array[index] = value;
        this.invalidate();
    }
}
registerOperation('float array', FloatArrayNode);

class IntArrayNode extends ParametersNode {
    #length;
    #array = [];
    constructor(editor, params) {
        super(editor, params);
        this.#length = params.length ?? 0;
        this.addOutput('output', IO_TYPE_ARRAY_INT);
        for (let i = 0; i < this.#length; ++i) {
            this.#array.push(0);
        }
        this.addParam(new NodeParam('value', NodeParamType.Int, this.#array, this.#length));
    }
    async operate(context = {}) {
        const output = this.getOutput('output');
        if (output) {
            output._value = this.#array;
        }
    }
    get title() {
        return 'int array';
    }
    setValue(index, value) {
        if (index >= this.#length) {
            throw 'wrong index';
        }
        this.#array[index] = value;
        this.invalidate();
    }
}
registerOperation('int array', IntArrayNode);

class DrawCircle extends Node {
    #renderTarget;
    #textureSize;
    constructor(editor, params) {
        super(editor, params);
        this.hasPreview = true;
        this.addInput('center', IO_TYPE_VEC2)._value = vec2.create();
        this.addInput('radius', IO_TYPE_FLOAT)._value = 10.0;
        this.addInput('border', IO_TYPE_FLOAT)._value = 1.0;
        this.addInput('bordercolor', IO_TYPE_COLOR)._value = vec4.fromValues(1.0, 1.0, 1.0, 1.0);
        this.addInput('fillcolor', IO_TYPE_COLOR)._value = vec4.fromValues(1.0, 1.0, 1.0, 1.0);
        this.addOutput('output', IO_TYPE_TEXTURE_2D);
        this.addOutput('perimeter', IO_TYPE_FLOAT);
        this.addOutput('area', IO_TYPE_FLOAT);
        this.material = new NodeImageEditorMaterial({ shaderName: 'drawcircle' });
        this.material.addUser(this);
        this.#textureSize = params.textureSize;
    }
    async operate(context = {}) {
        if (!this.material) {
            return;
        }
        const center = await this.getInput('center')?.value;
        const radius = await this.getInput('radius')?.value;
        const borderColor = await this.getInput('bordercolor')?.value;
        const fillColor = await this.getInput('fillcolor')?.value;
        const border = await this.getInput('border')?.value;
        const perimeter = this.getOutput('perimeter');
        if (perimeter) {
            perimeter._value = Math.PI * radius * 2;
        }
        const area = this.getOutput('area');
        if (area) {
            area._value = Math.PI * radius ** 2;
        }
        this.material.uniforms['uRadius'] = radius;
        this.material.uniforms['uCenter'] = center;
        this.material.uniforms['uBorderColor'] = borderColor;
        this.material.uniforms['uFillColor'] = fillColor;
        this.material.uniforms['uBorder'] = border;
        if (!this.#renderTarget) {
            this.#renderTarget = new RenderTarget({ width: this.#textureSize, height: this.#textureSize, depthBuffer: false, stencilBuffer: false });
        }
        Graphics$1.pushRenderTarget(this.#renderTarget);
        this.editor.render(this.material);
        const pixelArray = new Uint8Array(this.#textureSize * this.#textureSize * 4);
        Graphics$1.glContext.readPixels(0, 0, this.#textureSize, this.#textureSize, GL_RGBA, GL_UNSIGNED_BYTE, pixelArray);
        Graphics$1.popRenderTarget();
        const output = this.getOutput('output');
        if (output) {
            output._value = this.#renderTarget.getTexture();
            output._pixelArray = pixelArray;
        }
    }
    get title() {
        return 'draw circle';
    }
    dispose() {
        super.dispose();
        if (this.#renderTarget) {
            this.#renderTarget.dispose();
        }
        if (this.material) {
            this.material.removeUser(this);
        }
    }
}
registerOperation('draw_circle', DrawCircle);

class CombineAdd extends Node {
    #renderTarget;
    #textureSize;
    constructor(editor, params) {
        super(editor, params);
        this.hasPreview = true;
        for (let i = 0; i < 8; ++i) {
            this.addInput('input' + i, IO_TYPE_TEXTURE_2D);
        }
        //this.addInput('input', IO_TYPE_TEXTURE_2D, 8);
        this.addOutput('output', IO_TYPE_TEXTURE_2D);
        this.material = new NodeImageEditorMaterial({ shaderName: 'combine_add' });
        this.material.addUser(this);
        this.#textureSize = params.textureSize;
    }
    async operate(context = {}) {
        if (!this.material) {
            return;
        }
        /*let input1 = this.getInput('input1').value;
        let input2 = this.getInput('input2').value;
        let input3 = this.getInput('input3').value;
        let input4 = this.getInput('input4').value;
        let input5 = this.getInput('input5').value;*/
        /*this.material.uniforms['uInput1'] = input1;
        this.material.uniforms['uInput2'] = input2;
        this.material.uniforms['uInput3'] = input3;
        this.material.uniforms['uInput4'] = input4;
        this.material.uniforms['uInput5'] = input5;*/
        //this.material.uniforms['uInput[0]'] = await this.getInput('input').value;
        const textureArray = [];
        for (let i = 0; i < 8; ++i) {
            textureArray.push(await this.getInput('input' + i)?.value);
        }
        this.material.setTextureArray('uInput[0]', textureArray);
        if (!this.#renderTarget) {
            this.#renderTarget = new RenderTarget({ width: this.#textureSize, height: this.#textureSize, depthBuffer: false, stencilBuffer: false });
        }
        Graphics$1.pushRenderTarget(this.#renderTarget);
        this.editor.render(this.material);
        const pixelArray = new Uint8Array(this.#textureSize * this.#textureSize * 4);
        Graphics$1.glContext.readPixels(0, 0, this.#textureSize, this.#textureSize, GL_RGBA, GL_UNSIGNED_BYTE, pixelArray);
        Graphics$1.popRenderTarget();
        this.updatePreview(context);
        const output = this.getOutput('output');
        if (output) {
            output._value = this.#renderTarget.getTexture();
            output._pixelArray = pixelArray;
        }
    }
    get title() {
        return 'combine add';
    }
    dispose() {
        super.dispose();
        if (this.#renderTarget) {
            this.#renderTarget.dispose();
        }
        if (this.material) {
            this.material.removeUser(this);
        }
    }
}
registerOperation('combine_add', CombineAdd);

class CombineLerp extends Node {
    #renderTarget;
    #textureSize;
    constructor(editor, params) {
        super(editor, params);
        this.hasPreview = true;
        this.addInput('input0', IO_TYPE_TEXTURE_2D);
        this.addInput('input1', IO_TYPE_TEXTURE_2D);
        this.addInput('weight', IO_TYPE_TEXTURE_2D);
        this.addOutput('output', IO_TYPE_TEXTURE_2D);
        this.material = new NodeImageEditorMaterial({ shaderName: 'combine_lerp' });
        this.material.addUser(this);
        this.#textureSize = params.textureSize;
        this.addParam(new NodeParam('adjust black', NodeParamType.Float, 0.0));
        this.addParam(new NodeParam('adjust white', NodeParamType.Float, 1.0));
        this.addParam(new NodeParam('adjust gamma', NodeParamType.Float, 1.0));
    }
    async operate(context = {}) {
        if (!this.material) {
            return;
        }
        this.material.setTexture('uInput0', await this.getInput('input0')?.value);
        this.material.setTexture('uInput1', await this.getInput('input1')?.value);
        this.material.setTexture('uInputWeight', await this.getInput('weight')?.value);
        if (!this.#renderTarget) {
            this.#renderTarget = new RenderTarget({ width: this.#textureSize, height: this.#textureSize, depthBuffer: false, stencilBuffer: false });
        }
        Graphics$1.pushRenderTarget(this.#renderTarget);
        this.editor.render(this.material);
        const pixelArray = new Uint8Array(this.#textureSize * this.#textureSize * 4);
        Graphics$1.glContext.readPixels(0, 0, this.#textureSize, this.#textureSize, GL_RGBA, GL_UNSIGNED_BYTE, pixelArray);
        Graphics$1.popRenderTarget();
        this.updatePreview(context);
        const output = this.getOutput('output');
        if (output) {
            output._value = this.#renderTarget.getTexture();
            output._pixelArray = pixelArray;
        }
    }
    get title() {
        return 'combine lerp';
    }
    dispose() {
        super.dispose();
        if (this.#renderTarget) {
            this.#renderTarget.dispose();
        }
        if (this.material) {
            this.material.removeUser(this);
        }
    }
}
registerOperation('combine_lerp', CombineLerp);

let Multiply$1 = class Multiply extends Node {
    #renderTarget;
    #textureSize;
    constructor(editor, params) {
        super(editor, params);
        this.hasPreview = true;
        for (let i = 0; i < 8; ++i) {
            this.addInput('input' + i, IO_TYPE_TEXTURE_2D);
        }
        //this.addInput('input', IO_TYPE_TEXTURE_2D, 8);
        this.addOutput('output', IO_TYPE_TEXTURE_2D);
        this.material = new NodeImageEditorMaterial({ shaderName: 'multiply' });
        this.material.addUser(this);
        this.#textureSize = params.textureSize;
    }
    async operate(context = {}) {
        if (!this.material) {
            return;
        }
        const textureArray = [];
        const usedArray = [];
        for (let i = 0; i < 8; ++i) {
            //let inputName = 'uInput' + i;
            //this.material.uniforms['uInput' + i] = await this.getInput('input' + i).value;
            const texture = await this.getInput('input' + i)?.value;
            textureArray.push(texture);
            usedArray.push(texture != undefined);
        }
        //this.material.uniforms['uInput[0]'] = await this.getInput('input').value;
        this.material.setTextureArray('uInput[0]', textureArray);
        this.material.uniforms['uUsed[0]'] = usedArray;
        //this.material.uniforms['uInput1'] = await this.getInput('input1').value;
        if (!this.#renderTarget) {
            this.#renderTarget = new RenderTarget({ width: this.#textureSize, height: this.#textureSize, depthBuffer: false, stencilBuffer: false, texture: this.getOutput('output')?._value });
        }
        Graphics$1.pushRenderTarget(this.#renderTarget);
        this.editor.render(this.material);
        //let pixelArray = new Uint8Array(this.#textureSize * this.#textureSize * 4);
        //Graphics.glContext.readPixels(0, 0, this.#textureSize, this.#textureSize, GL_RGBA, GL_UNSIGNED_BYTE, pixelArray);
        Graphics$1.popRenderTarget();
        this.updatePreview(context);
        const output = this.getOutput('output');
        if (output) {
            output._value = this.#renderTarget.getTexture();
        }
    }
    get title() {
        return 'multiply';
    }
    dispose() {
        super.dispose();
        if (this.#renderTarget) {
            this.#renderTarget.dispose();
        }
        if (this.material) {
            this.material.removeUser(this);
        }
    }
};
registerOperation('multiply', Multiply$1);

const MAX_SELECTORS = 16;
class Select extends Node {
    #renderTarget;
    #textureSize;
    constructor(editor, params) {
        super(editor, params);
        this.hasPreview = true;
        this.addInput('input', IO_TYPE_TEXTURE_2D);
        this.addInput('selectvalues', IO_TYPE_FLOAT, MAX_SELECTORS);
        this.addOutput('output', IO_TYPE_TEXTURE_2D);
        this.material = new NodeImageEditorMaterial({ shaderName: 'select' });
        this.material.setDefine('MAX_SELECTORS', String(MAX_SELECTORS));
        this.material.addUser(this);
        this.#textureSize = params.textureSize;
    }
    async operate(context = {}) {
        if (!this.material) {
            return;
        }
        this.material.setTexture('uInputTexture', await this.getInput('input')?.value);
        this.material.uniforms['uSelect[0]'] = await this.getInput('selectvalues')?.value;
        if (!this.#renderTarget) {
            this.#renderTarget = new RenderTarget({ width: this.#textureSize, height: this.#textureSize, depthBuffer: false, stencilBuffer: false });
        }
        Graphics$1.pushRenderTarget(this.#renderTarget);
        this.editor.render(this.material);
        const pixelArray = new Uint8Array(this.#textureSize * this.#textureSize * 4);
        Graphics$1.glContext.readPixels(0, 0, this.#textureSize, this.#textureSize, GL_RGBA, GL_UNSIGNED_BYTE, pixelArray);
        Graphics$1.popRenderTarget();
        this.updatePreview(context);
        const output = this.getOutput('output');
        if (output) {
            output._value = this.#renderTarget.getTexture();
            output._pixelArray = pixelArray;
        }
    }
    get title() {
        return 'select';
    }
    async toString(tabs = '') {
        const ret = [];
        const tabs1 = tabs + '\t';
        ret.push(tabs + this.constructor.name);
        for (const input of this.inputs.values()) {
            if (input.getPredecessor()) {
                ret.push(await input.toString(tabs1));
            }
        }
        const selectvalues = await this.getInput('selectvalues')?.value;
        const a = [];
        for (const v of selectvalues) {
            if (v) {
                a.push(v);
            }
        }
        ret.push(tabs1 + 'values : ' + a.join(' '));
        return ret.join('\n');
    }
    dispose() {
        super.dispose();
        if (this.#renderTarget) {
            this.#renderTarget.dispose();
        }
        if (this.material) {
            this.material.removeUser(this);
        }
    }
}
registerOperation('select', Select);

var applysticker_fs = `
varying vec4 vTextureCoord;
uniform sampler2D uSticker;
uniform sampler2D uStickerSpecular;
uniform sampler2D uInput;

/*applysticker.fs*/
void main(void) {
	vec4 inputColor = texture2D(uInput, vTextureCoord.zw);
	vec4 stickerColor = texture2D(uSticker, vTextureCoord.xy);
	vec4 specularColor = texture2D(uStickerSpecular, vTextureCoord.xy);
	gl_FragColor = vec4((1.0 - stickerColor.a) * inputColor.xyz + stickerColor.a * stickerColor.xyz,
						(1.0 - stickerColor.a) * inputColor.a + stickerColor.a * specularColor.r);
}
`;

//TODO: sticker specular
/*
				float3 tmpColor = ( 1.0 - color1.a ) * color0.xyz
								+ ( color1.a )       * color1.xyz;

				float tmpSpecular = ( 1.0 - color1.a ) * color0.w
				                  + ( color1.a )       * srcSpecular;

				return float4( tmpColor.xyz, tmpSpecular );
				*/

var applysticker_vs = `
#include nodeimageeditor_imageeditor_vs
`;

var combine_add_fs = `
varying vec2 vTextureCoord;

uniform sampler2D uInput[8];
/*combine_add.fs*/
void main(void) {
	gl_FragColor = vec4(0.0);
	gl_FragColor += texture2D(uInput[0], vTextureCoord);
	gl_FragColor += texture2D(uInput[1], vTextureCoord);
	gl_FragColor += texture2D(uInput[2], vTextureCoord);
	gl_FragColor += texture2D(uInput[3], vTextureCoord);
	gl_FragColor += texture2D(uInput[4], vTextureCoord);
	gl_FragColor += texture2D(uInput[5], vTextureCoord);
	gl_FragColor += texture2D(uInput[6], vTextureCoord);
	gl_FragColor += texture2D(uInput[7], vTextureCoord);
}
`;

var combine_add_vs = `
#include nodeimageeditor_imageeditor_vs
`;

var combine_lerp_fs = `
varying vec2 vTextureCoord;

uniform sampler2D uInput0;
uniform sampler2D uInput1;
uniform sampler2D uInputWeight;

/*combine_lerp.fs*/
void main(void) {
	vec4 color1 = texture2D(uInput0, vTextureCoord);
	vec4 color2 = texture2D(uInput1, vTextureCoord);
	vec4 color3 = texture2D(uInputWeight, vTextureCoord);
	gl_FragColor = mix(color1, color2, color3.rrrr);
}
`;

var combine_lerp_vs = `
#include nodeimageeditor_imageeditor_vs
`;

var drawcircle_fs = `
varying vec2 vTextureCoord;

uniform float uBorder;
uniform float uRadius;
uniform vec4 uBorderColor;
uniform vec4 uFillColor;
uniform vec2 uCenter;

uniform sampler2D backGround;
uniform sampler2D uMaskTexture;

/* hack to avoid smoothstep undefined behavior when uBorder = 0*/
const float epsilon = 0.000001;

/*drawcircle.fs*/
void main(void) {
	vec4 maskColor = texture2D(uMaskTexture, vTextureCoord);
	vec4 fillColor = vec4(1.0, 0.0, 0.0, 0.0);
	vec2 uv = gl_FragCoord.xy - uCenter;
	float dist = sqrt(dot(uv, uv));
	float t = smoothstep(uRadius-uBorder, uRadius, dist)
			- smoothstep(uRadius, uRadius+uBorder, dist);
	//float t2 = smoothstep(uRadius+uBorder, uRadius-uBorder-epsilon, dist);
	float t2 = 1.0 - smoothstep(uRadius - uBorder, uRadius + uBorder + epsilon, dist);
	//gl_FragColor = (uBorderColor * t + uFillColor * t2) * maskColor;
	gl_FragColor.rgb = (uBorderColor.rgb * t + uFillColor.rgb * t2);
	gl_FragColor.a = 1.0;
	/*gl_FragColor = vec4(1.0, 0.5, 0.25, 0.0);*/
	/*gl_FragColor = vec4(length(gl_FragCoord.xy/8.0));*/
	//gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
	//gl_FragColor = vec4(abs(uv) / 100.0, 0.0, 1.0);
	//gl_FragColor = vec4(uv, 0.0, 1.0);
	//gl_FragColor = vec4(dist / 100.0, 0.0, 0.0, 1.0);
	//gl_FragColor = vec4(t2, 0.0, 0.0, 1.0);
	//gl_FragColor = vec4(1.0, 0.5, 0.25, 1.0);
	//gl_FragColor.r += 0.5;
	//gl_FragColor = vec4(dist / 1000.0, 0.0, 0.0, 1.0);
	//gl_FragColor = vec4(t2);
}
`;

var drawcircle_vs = `
#include nodeimageeditor_imageeditor_vs
`;

var multiply_fs = `
#define INPUT_COUNT 8

varying vec2 vTextureCoord;

uniform sampler2D uInput[INPUT_COUNT];
uniform bool uUsed[INPUT_COUNT];
/*multiply.fs*/
void main(void) {
	gl_FragColor = vec4(1.0);
	if (uUsed[0]) {
		gl_FragColor *= texture2D(uInput[0], vTextureCoord);
	}
	if (uUsed[1]) {
		gl_FragColor *= texture2D(uInput[1], vTextureCoord);
	}
	if (uUsed[2]) {
		gl_FragColor *= texture2D(uInput[2], vTextureCoord);
	}
	if (uUsed[3]) {
		gl_FragColor *= texture2D(uInput[3], vTextureCoord);
	}
	if (uUsed[4]) {
		gl_FragColor *= texture2D(uInput[4], vTextureCoord);
	}
	if (uUsed[5]) {
		gl_FragColor *= texture2D(uInput[5], vTextureCoord);
	}
	if (uUsed[6]) {
		gl_FragColor *= texture2D(uInput[6], vTextureCoord);
	}
	if (uUsed[7]) {
		gl_FragColor *= texture2D(uInput[7], vTextureCoord);
	}
}
`;

var multiply_vs = `
#include nodeimageeditor_imageeditor_vs
`;

var select_fs = `
varying vec2 vTextureCoord;

uniform sampler2D 	uInputTexture;
uniform float		uSelect[MAX_SELECTORS];

/*select.fs*/
void main(void) {
	vec4 color = texture2D(uInputTexture, vTextureCoord);

	gl_FragColor = vec4(0.0);
	for (int i=0; i < MAX_SELECTORS; i++) {
		if (uSelect[i] > 0.0) {
			if (abs(color.r * 255.0 - uSelect[i]) < 8.0) {
				gl_FragColor = vec4(1.0);
			}
		}
	}
}
`;

var select_vs = `
#include nodeimageeditor_imageeditor_vs
`;

var texturelookup_fs = `
varying vec2 vTextureCoord;

uniform sampler2D uInput;
uniform float uRotateAngle;
uniform vec2 uUVTranslate;
uniform vec2 uUVScale;


uniform vec4 uAdjustLevels;
#define g_AdjustInBlack(n)		uAdjustLevels.x
#define g_AdjustInWhite(n)		uAdjustLevels.y
#define g_AdjustGamma(n)		uAdjustLevels.z

#include nodeimageeditor_declare_functions

/*texturelookup.fs*/
void main(void) {
	vec4 color0 = texture2D(uInput, vTextureCoord);
	gl_FragColor = AdjustLevels(color0, g_AdjustInBlack(0), g_AdjustInWhite(0), g_AdjustGamma(0));
	//gl_FragColor = vec4(g_AdjustInWhite(0));
}
`;

var texturelookup_vs = `
#include nodeimageeditor_imageeditor_vs
`;

Shaders['applysticker.fs'] = applysticker_fs;
Shaders['applysticker.vs'] = applysticker_vs;
Shaders['combine_add.fs'] = combine_add_fs;
Shaders['combine_add.vs'] = combine_add_vs;
Shaders['combine_lerp.fs'] = combine_lerp_fs;
Shaders['combine_lerp.vs'] = combine_lerp_vs;
Shaders['drawcircle.fs'] = drawcircle_fs;
Shaders['drawcircle.vs'] = drawcircle_vs;
Shaders['multiply.fs'] = multiply_fs;
Shaders['multiply.vs'] = multiply_vs;
Shaders['select.fs'] = select_fs;
Shaders['select.vs'] = select_vs;
Shaders['texturelookup.fs'] = texturelookup_fs;
Shaders['texturelookup.vs'] = texturelookup_vs;

var imageeditor_fs = `
varying vec2 vTextureCoord;

uniform sampler2D uFinalTexture;

/*imageeditor.fs*/
void main(void) {
	gl_FragColor = texture2D(uFinalTexture, vTextureCoord);
}
`;

var imageeditor_vs = `
#include nodeimageeditor_imageeditor_vs
`;

Shaders['imageeditor.fs'] = imageeditor_fs;
Shaders['imageeditor.vs'] = imageeditor_vs;

const tempVec3$o = vec3.create();
class BoundingBoxHelper extends Box {
    boundingBox = new BoundingBox();
    constructor(params = {}) {
        super(params);
        this.wireframe = 0;
    }
    update() {
        if (this._parent) {
            this._parent.getBoundingBox(this.boundingBox);
            this.boundingBox.getCenter(this._position);
            this.boundingBox.getSize(tempVec3$o);
            this.setSize(tempVec3$o[0], tempVec3$o[1], tempVec3$o[2]);
        }
    }
    getWorldPosition(vec = vec3.create()) {
        return vec3.copy(vec, this._position);
    }
    getWorldQuaternion(q = quat.create()) {
        return quat.identity(q);
    }
    getBoundingBox(boundingBox = new BoundingBox()) {
        boundingBox.reset();
        return boundingBox;
    }
}

const BASE_COLOR = [1, 1, 1, 1];
const FRUSTRUM_COLOR = [1, 0, 0, 1];
const AXIS_COLOR = [1, 1, 0, 1];
const tempVec3$n = vec3.create();
const Points = [
    //Base Points
    { p: vec3.fromValues(0, 0, 0), c: BASE_COLOR },
    { p: vec3.fromValues(0, 0, 0), c: AXIS_COLOR },
    // Base pyramid
    { p: vec3.fromValues(-1, -1, -1), c: BASE_COLOR },
    { p: vec3.fromValues(-1, +1, -1), c: BASE_COLOR },
    { p: vec3.fromValues(+1, -1, -1), c: BASE_COLOR },
    { p: vec3.fromValues(+1, +1, -1), c: BASE_COLOR },
    // near plane
    { p: vec3.fromValues(-1, -1, -1), c: FRUSTRUM_COLOR },
    { p: vec3.fromValues(-1, +1, -1), c: FRUSTRUM_COLOR },
    { p: vec3.fromValues(+1, -1, -1), c: FRUSTRUM_COLOR },
    { p: vec3.fromValues(+1, +1, -1), c: FRUSTRUM_COLOR },
    // far plane
    { p: vec3.fromValues(-1, -1, 1), c: FRUSTRUM_COLOR },
    { p: vec3.fromValues(-1, +1, 1), c: FRUSTRUM_COLOR },
    { p: vec3.fromValues(+1, -1, 1), c: FRUSTRUM_COLOR },
    { p: vec3.fromValues(+1, +1, 1), c: FRUSTRUM_COLOR },
    //Axis line
    { p: vec3.fromValues(0, 0, 1), c: AXIS_COLOR },
    //Near plane axis
    { p: vec3.fromValues(-1, 0, -1), c: AXIS_COLOR },
    { p: vec3.fromValues(+1, 0, -1), c: AXIS_COLOR },
    { p: vec3.fromValues(0, -1, -1), c: AXIS_COLOR },
    { p: vec3.fromValues(0, +1, -1), c: AXIS_COLOR },
    //Far plane axis
    { p: vec3.fromValues(-1, 0, 1), c: AXIS_COLOR },
    { p: vec3.fromValues(+1, 0, 1), c: AXIS_COLOR },
    { p: vec3.fromValues(0, -1, 1), c: AXIS_COLOR },
    { p: vec3.fromValues(0, +1, 1), c: AXIS_COLOR },
];
const Lines = [
    0, 2,
    0, 3,
    0, 4,
    0, 5,
    // near plane
    6, 7,
    6, 8,
    7, 9,
    8, 9,
    6, 10,
    7, 11,
    8, 12,
    9, 13,
    // far plane
    10, 11,
    10, 12,
    11, 13,
    12, 13,
    //center axis
    1, 14,
    //near plane axis
    15, 16,
    17, 18,
    //far plane axis
    19, 20,
    21, 22,
    //near / far plane junction
    /*15, 19,
    16, 20,
    17, 21,
    18, 22,*/
];
class CameraFrustum extends Mesh {
    #camera = null;
    #vertexPositionAttribute;
    constructor(params = {}) {
        params.geometry = new BufferGeometry();
        params.material = new LineBasicMaterial();
        super(params);
        this.renderMode = GL_LINES;
        this.#createVertices();
        this.getMaterial().setColorMode(MaterialColorMode.PerVertex);
        this.castShadow = false;
        GraphicsEvents.addEventListener(GraphicsEvent.Tick, () => this.update());
    }
    #createVertices() {
        const indices = Lines;
        const vertices = [];
        const colors = [];
        for (const point of Points) {
            vertices.push(...point.p);
            colors.push(...point.c);
        }
        const geometry = this.geometry;
        geometry.setIndex(new Uint16BufferAttribute(indices, 1));
        this.#vertexPositionAttribute = new Float32BufferAttribute(vertices, 3);
        geometry.setAttribute('aVertexPosition', this.#vertexPositionAttribute);
        geometry.setAttribute('aVertexColor', new Uint8BufferAttribute(colors, 4));
        geometry.count = indices.length;
    }
    update() {
        if (this.#camera) {
            let index = 0;
            const verticesArray = this.#vertexPositionAttribute._array;
            for (const point of Points) {
                if (index > 3) { //Skip the base point
                    vec3.copy(tempVec3$n, point.p);
                    this.#camera.invertProjection(tempVec3$n);
                    verticesArray.set(tempVec3$n, index);
                }
                index += 3;
            }
            this.#vertexPositionAttribute.dirty = true;
        }
    }
    parentChanged(parent) {
        if (parent?.is('Camera')) {
            this.#camera = parent;
        }
        else {
            this.#camera = null;
        }
        this.update();
    }
}

class Grid extends Mesh {
    #size;
    #spacing;
    #normal;
    constructor(params = {}) {
        const spacing = params.spacing ?? 10;
        params.geometry = new PlaneBufferGeometry();
        params.material = new GridMaterial({ spacing: spacing });
        super(params);
        this.#size = params.size ?? 100;
        this.#spacing = spacing;
        this.#normal = params.normal ?? 2;
        this.#updateGeometry();
    }
    #updateGeometry() {
        this.geometry.updateGeometry(this.#size, this.#size, 1, 1);
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), {
            Grid_1: null,
            size: { i18n: '#size', f: () => { const size = prompt('Size', String(this.#size)); if (size) {
                    this.#size = Number(size);
                    this.#updateGeometry();
                } } },
            spacing: { i18n: '#spacing', f: () => { const spacing = prompt('Spacing', String(this.#spacing)); if (spacing) {
                    this.#spacing = this.material.spacing = Number(spacing);
                } } }
        });
    }
}

function getHelper(type) {
    switch (type.constructor.name) {
        case 'PointLight':
            return new PointLightHelper();
        case 'SpotLight':
            return new SpotLightHelper();
        case 'Scene':
            return new Grid();
    }
    if (type instanceof Camera) {
        return new CameraFrustum();
    }
}

const tempVec3$m = vec3.create();
let boxMaterial;
class HitboxHelper extends Entity {
    #hitboxes = [];
    constructor() {
        super();
        if (!boxMaterial) {
            boxMaterial = new MeshBasicMaterial();
            boxMaterial.setMeshColor([0.5, 0.5, 0.5, 0.1]);
            boxMaterial.setBlending(MATERIAL_BLENDING_NORMAL);
        }
    }
    parentChanged(parent) {
        this.removeBoxes();
        if (parent && parent.getHitboxes) {
            const hitboxes = parent.getHitboxes();
            for (const hitbox of hitboxes) {
                vec3.sub(tempVec3$m, hitbox.boundingBoxMax, hitbox.boundingBoxMin);
                const box = new Box({ width: tempVec3$m[0], height: tempVec3$m[1], depth: tempVec3$m[2], material: boxMaterial });
                box.serializable = false;
                vec3.lerp(tempVec3$m, hitbox.boundingBoxMin, hitbox.boundingBoxMax, 0.5);
                box.position = tempVec3$m;
                if (hitbox.parent) {
                    hitbox.parent.addChild(box);
                }
                else {
                    this.addChild(box);
                }
                this.#hitboxes.push(box);
            }
        }
    }
    removeBoxes() {
        this.#hitboxes.forEach(hitbox => hitbox.dispose());
        this.#hitboxes = [];
    }
    static async constructFromJSON() {
        return new HitboxHelper();
    }
    static getEntityName() {
        return 'HitboxHelper';
    }
}
registerEntity(HitboxHelper);

vec3.create();
class Line extends Mesh {
    isLine = true;
    #start = vec3.create();
    #end = vec3.create();
    constructor(params = {}) {
        params.geometry = new LineSegmentsGeometry();
        params.material = params.material ?? new LineMaterial();
        super(params);
        if (params.start) {
            vec3.copy(this.#start, params.start);
        }
        if (params.end) {
            vec3.copy(this.#end, params.end);
        }
        this.#updateGeometry();
    }
    set start(start) {
        vec3.copy(this.#start, start);
        this.#updateGeometry();
    }
    getStart(start = vec3.create()) {
        return vec3.copy(start, this.#start);
    }
    set end(end) {
        vec3.copy(this.#end, end);
        this.#updateGeometry();
    }
    getEnd(end = vec3.create()) {
        return vec3.copy(end, this.#end);
    }
    #updateGeometry() {
        this.geometry.setSegments([...this.#start, ...this.#end], [], false);
    }
    raycast(raycaster, intersections) {
        const interSegment = vec3.create();
        const interRay = vec3.create();
        const ray = raycaster.ray;
        const sqrDist = ray.distanceSqToSegment(this.#start, this.#end, interRay, interSegment);
        if (sqrDist < 10) { //TODO: variable
            intersections.push(ray.createIntersection(interRay, null, null, this, sqrDist));
        }
    }
    toJSON() {
        const json = super.toJSON();
        json.start = vec3.clone(this.start);
        json.end = vec3.clone(this.end);
        json.material = this.getMaterial().toJSON();
        return json;
    }
    static async constructFromJSON(json, entities, loadedPromise) {
        const material = await JSONLoader.loadEntity(json.material, entities, loadedPromise);
        return new Line({ start: json.start, end: json.end, material: material });
    }
    static getEntityName() {
        return 'Line';
    }
}
registerEntity(Line);

const a$7 = vec3.create();
const b$4 = vec3.create();
const c$1 = vec3.create();
class Raycaster {
    near;
    far;
    ray = new Ray();
    constructor(near = 0, far = Infinity) {
        this.near = near;
        this.far = far;
    }
    castRay(origin, direction, entities, recursive) {
        this.ray.set(origin, direction);
        const intersections = [];
        for (const entity of entities) {
            this.intersectEntity(entity, intersections, recursive);
        }
        return intersections;
    }
    castCameraRay(camera, normalizedX, normalizedY, entities, recursive) {
        const projectionMatrixInverse = camera.projectionMatrixInverse;
        const nearP = vec3.set(a$7, normalizedX, normalizedY, -1);
        const farP = vec3.set(b$4, normalizedX, normalizedY, 1);
        vec3.transformMat4(nearP, nearP, projectionMatrixInverse);
        vec3.transformMat4(farP, farP, projectionMatrixInverse);
        vec3.transformQuat(nearP, nearP, camera.quaternion);
        vec3.transformQuat(farP, farP, camera.quaternion);
        const rayDirection = vec3.sub(c$1, farP, nearP);
        vec3.normalize(rayDirection, rayDirection);
        return this.castRay(camera.position, rayDirection, entities, recursive);
    }
    intersectEntity(entity, intersections, recursive) {
        if (!entity.visible) {
            return;
        }
        entity.raycast(this, intersections);
        if (recursive) {
            for (const child of entity.children) {
                this.intersectEntity(child, intersections, recursive);
            }
        }
    }
}

const SceneExplorerEvents = new EventTarget();

const tempVec3$l = vec3.create();
class SkeletonHelper extends Entity {
    #skeleton = null;
    #lines = new Map();
    #lineMaterial;
    #highlitLineMaterial;
    #boneTipMaterial;
    #raycaster;
    #highlitLine;
    #boneStart;
    #boneEnd;
    enumerable = false;
    #displayJoints = true;
    constructor(parameters) {
        super(parameters);
        this.#lineMaterial = new LineMaterial();
        this.#lineMaterial.addUser(this);
        this.#lineMaterial.setDefine('ALWAYS_ON_TOP');
        this.#lineMaterial.lineWidth = 3;
        this.#highlitLineMaterial = new LineMaterial();
        this.#highlitLineMaterial.addUser(this);
        this.#highlitLineMaterial.setDefine('ALWAYS_ON_TOP');
        this.#highlitLineMaterial.lineWidth = 3;
        this.#highlitLineMaterial.setMeshColor([1, 0, 0, 1]);
        this.#boneTipMaterial = new MeshBasicMaterial();
        this.#boneTipMaterial.addUser(this);
        this.#boneTipMaterial.setDefine('ALWAYS_ON_TOP');
        this.#boneTipMaterial.setMeshColor([1, 0, 1, 1]);
        this.hideInExplorer = true;
        this.#skeleton = parameters?.skeleton ?? null;
        this.#raycaster = new Raycaster();
        this.#boneStart = new Sphere({ radius: 1, material: this.#boneTipMaterial });
        this.#boneEnd = new Sphere({ radius: 1, material: this.#boneTipMaterial });
        this.addChilds(this.#boneStart, this.#boneEnd);
        this.#initListeners();
    }
    parentChanged(parent) {
        if (!parent) {
            return;
        }
        this.#clearSkeleton();
        if (parent.isSkeleton) {
            this.#skeleton = parent;
        }
        else if (parent.skeleton) {
            this.#skeleton = parent.skeleton;
        }
        else {
            this.#skeleton = null;
        }
    }
    #clearSkeleton() {
        this.#lines.forEach(value => value.dispose());
        this.#lines.clear();
        this.#boneStart.setVisible(false);
        this.#boneEnd.setVisible(false);
    }
    /*
        set skeleton(skeleton) {
            this.#skeleton = skeleton;
        }

        get skeleton() {
            return this.#skeleton;
        }*/
    getWorldPosition(vec = vec3.create()) {
        return vec3.copy(vec, this._position);
    }
    getWorldQuaternion(q = quat.create()) {
        return quat.identity(q);
    }
    #update() {
        if (!this.#skeleton) {
            return;
        }
        for (const bone of this.#skeleton.bones) {
            let boneLine = this.#lines.get(bone);
            if (!boneLine) {
                boneLine = new Line({ material: this.#lineMaterial, parent: this });
                boneLine.properties.setObject('bone', bone);
                this.#lines.set(bone, boneLine);
                this.addChild(boneLine);
            }
            //boneLine.position = bone.worldPos;
            boneLine.start = bone.worldPos;
            boneLine.end = bone.worldPos;
            const boneParent = bone.parent;
            if (boneParent?.isBone) {
                boneLine.start = boneParent.getWorldPosition( /*TODO: optimize*/);
                boneLine.properties.setObject('boneParent', boneParent);
            }
        }
    }
    get wireframe() {
        return 0;
    }
    #initListeners() {
        GraphicsEvents.addEventListener(GraphicsEvent.Tick, () => {
            if (!this.isVisible()) {
                return;
            }
            this.#update();
        });
        GraphicsEvents.addEventListener(GraphicsEvent.MouseMove, (event) => {
            this.#mouseMoved(event);
        });
        GraphicsEvents.addEventListener(GraphicsEvent.MouseUp, (event) => {
            this.#mouseUp(event);
        });
    }
    #mouseMoved(event) {
        const picked = this.#pickBone(event);
        if (picked) {
            this.#highlit(picked);
        }
    }
    #mouseUp(event) {
        const closest = this.#pickBone(event);
        if (closest) {
            let bone = closest.properties.getObject('bone');
            if (closest.isLine) {
                this.#highlit(closest);
                bone = bone?.parent /*TODO case where parent is not Bone*/ ?? bone;
            }
            SceneExplorerEvents.dispatchEvent(new CustomEvent('bonepicked', { detail: { bone: bone } }));
        }
    }
    displayBoneJoints(display) {
        this.#boneStart.setVisible(this.#highlitLine && display);
        this.#boneEnd.setVisible(this.#highlitLine && display);
        this.#displayJoints = display;
    }
    setJointsRadius(radius) {
        this.#boneStart.setRadius(radius);
        this.#boneEnd.setRadius(radius);
    }
    #pickBone(event) {
        if (!this.isVisible()) {
            return null;
        }
        const normalizedX = (event.detail.x / Graphics$1.getWidth()) * 2 - 1;
        const normalizedY = 1 - (event.detail.y / Graphics$1.getHeight()) * 2;
        const scene = this.root; // TODO: imbricated scenes
        if (!scene.is('Scene') || !scene.activeCamera) {
            return null;
        }
        const intersections = this.#raycaster.castCameraRay(scene.activeCamera, normalizedX, normalizedY, [this], true);
        if (intersections.length) {
            let closest = null;
            let closestDist = Infinity;
            for (const intersection of intersections) {
                const entity = intersection.entity;
                if (entity.isLine) {
                    if (intersection.distanceFromRay < closestDist) {
                        closest = entity;
                        closestDist = intersection.distanceFromRay;
                    }
                }
                else if (entity.isSphere) {
                    if (intersection.distanceFromRay < closestDist) {
                        if (entity == this.#boneStart || entity == this.#boneEnd) {
                            closest = entity;
                            closestDist = intersection.distanceFromRay;
                        }
                    }
                }
            }
            return closest;
        }
        return null;
    }
    #highlit(line) {
        if (!line?.isLine) {
            return;
        }
        if (this.#highlitLine) {
            this.#highlitLine.material = this.#lineMaterial;
        }
        if (line) {
            line.setMaterial(this.#highlitLineMaterial);
            this.#boneStart.setPosition(line.getStart(tempVec3$l));
            this.#boneEnd.setPosition(line.getEnd(tempVec3$l));
            this.#boneStart.setVisible(this.#displayJoints);
            this.#boneEnd.setVisible(this.#displayJoints);
            this.#boneStart.properties.set('bone', line.properties.get('boneParent'));
            this.#boneEnd.properties.set('bone', line.properties.get('bone'));
        }
        this.#highlitLine = line;
    }
    dispose() {
        this.#clearSkeleton();
        this.#lineMaterial.removeUser(this);
        this.#highlitLineMaterial.removeUser(this);
    }
}

const tempWorldMat = mat4.create();
const tempWorldQuat = quat.create();
const tempWorldVec3 = vec3.create();
const tempWorldScale = vec3.create();
const tempPosition = vec3.create();
const tempQuat1 = quat.create();
const tempVec1 = vec3.create();
class Bone extends Entity {
    isBone = true;
    isLockable = true;
    #boneId;
    #poseToBone = mat4.create();
    #boneMat = mat4.create();
    #worldPos = vec3.create();
    #worldQuat = quat.create();
    #worldScale = vec3.fromValues(1, 1, 1);
    #parentSkeletonBone = null;
    #skeleton;
    #refPosition = vec3.create();
    #refQuaternion = quat.create();
    dirty = true;
    lastComputed = 0;
    tempPosition = vec3.create();
    tempQuaternion = quat.create();
    _initialQuaternion = quat.create();
    _initialPosition = vec3.create();
    constructor(params /*TODO: improve type*/) {
        super(params);
        this.#boneId = params.boneId ?? -1;
        this.#skeleton = params.skeleton;
    }
    set position(position) {
        super.position = position;
        this.dirty = true;
    }
    get position() {
        return vec3.clone(this._position);
    }
    setWorldPosition(position) {
        super.setWorldPosition(position);
        this.dirty = true;
    }
    set refPosition(refPosition) {
        vec3.copy(this.#refPosition, refPosition);
    }
    get refPosition() {
        return vec3.clone(this.#refPosition);
    }
    getTotalRefPosition(position = vec3.create()) {
        const parent = this._parent;
        if (parent && parent.isBone) {
            parent.getTotalRefPosition(position);
            parent.getTotalRefQuaternion(tempQuat1);
            vec3.transformQuat(tempVec1, this.#refPosition, tempQuat1);
            vec3.add(position, position, tempVec1);
        }
        else {
            vec3.copy(position, this.#refPosition);
        }
        return position;
    }
    getTotalRefQuaternion(quaternion = quat.create()) {
        const parent = this._parent;
        if (parent && parent.isBone) {
            parent.getTotalRefQuaternion(tempQuat1);
            quat.multiply(quaternion, tempQuat1, this.#refQuaternion);
        }
        else {
            quat.copy(quaternion, this.#refQuaternion);
        }
        return quaternion;
    }
    set quaternion(quaternion) {
        super.quaternion = quaternion;
        this.dirty = true;
    }
    get quaternion() {
        return quat.clone(this._quaternion);
    }
    set refQuaternion(refQuaternion) {
        quat.copy(this.#refQuaternion, refQuaternion);
    }
    get refQuaternion() {
        return quat.clone(this.#refQuaternion);
    }
    set scale(scale) {
        vec3.copy(this._scale, scale);
        this.dirty = true;
    }
    get scale() {
        return vec3.clone(this._scale);
    }
    set parent(parent) {
        this._parent = parent;
        this.dirty = true;
    }
    get parent() {
        return this._parent;
    }
    set skeleton(skeleton) {
        this.#skeleton = skeleton;
        this.dirty = true;
    }
    get skeleton() {
        return this.#skeleton;
    }
    set parentSkeletonBone(parentSkeletonBone) {
        if (parentSkeletonBone == this) {
            // TODO: check ancestry as well ?
            return;
        }
        if (this.#parentSkeletonBone != parentSkeletonBone) {
            this.#parentSkeletonBone = parentSkeletonBone;
            this.dirty = true;
        }
    }
    get parentSkeletonBone() {
        return this.#parentSkeletonBone;
    }
    get boneMat() {
        if (this.dirty
            || (this._parent && this._parent.lastComputed > this.lastComputed)
            || (this.#parentSkeletonBone && this.#parentSkeletonBone.lastComputed > this.lastComputed)
            || ((this._parent == undefined) && (true )) //TODOv3: remove true
        ) {
            this.#compute();
        }
        return this.#boneMat;
    }
    get worldPos() {
        if (this.dirty
            || (this._parent && this._parent.lastComputed > this.lastComputed)
            || (this.#parentSkeletonBone && this.#parentSkeletonBone.lastComputed > this.lastComputed)
            || ((this._parent == undefined) && (true )) //TODOv3: remove true
        ) {
            this.#compute();
        }
        return this.#worldPos;
    }
    get worldQuat() {
        if (this.dirty
            || (this._parent && this._parent.lastComputed > this.lastComputed)
            || (this.#parentSkeletonBone && this.#parentSkeletonBone.lastComputed > this.lastComputed)
            || ((this._parent == undefined) && (true )) //TODOv3: remove true
        ) {
            this.#compute();
        }
        return this.#worldQuat;
    }
    get worldScale() {
        if (this.dirty
            || (this._parent && this._parent.lastComputed > this.lastComputed)
            || (this.#parentSkeletonBone && this.#parentSkeletonBone.lastComputed > this.lastComputed)
            || ((this._parent == undefined) && (true )) //TODOv3: remove true
        ) {
            this.#compute();
        }
        return this.#worldScale;
    }
    getWorldPosition(vec = vec3.create()) {
        return vec3.copy(vec, this.worldPos);
    }
    getWorldQuaternion(q = quat.create()) {
        return quat.copy(q, this.worldQuat);
    }
    getWorldScale(vec = vec3.create()) {
        return vec3.copy(vec, this.worldScale);
    }
    getWorldPosOffset(offset, out = vec3.create()) {
        vec3.transformQuat(out, offset, this.worldQuat);
        vec3.add(out, this.worldPos, out);
        return out;
    }
    set poseToBone(poseToBone) {
        mat4.copy(this.#poseToBone, poseToBone);
    }
    get poseToBone() {
        return mat4.clone(this.#poseToBone);
    }
    #compute() {
        const parent = this._parent;
        this.#parentSkeletonBone;
        if (!this.#parentSkeletonBone) {
            if (parent) {
                const parentWorldQuaternion = parent.getWorldQuaternion(tempWorldQuat);
                vec3.mul(this.#worldScale, parent.getWorldScale(tempWorldScale), this._scale);
                vec3.mul(tempPosition, this._position, tempWorldScale);
                vec3.transformQuat(this.#worldPos, tempPosition, parentWorldQuaternion);
                vec3.add(this.#worldPos, this.#worldPos, parent.getWorldPosition(tempWorldVec3));
                quat.multiply(this.#worldQuat, parentWorldQuaternion, this._quaternion);
            }
            else {
                if (this.#skeleton) {
                    this.#skeleton.getWorldPosition(tempWorldVec3);
                    this.#skeleton.getWorldQuaternion(tempWorldQuat);
                    vec3.transformQuat(this.#worldPos, this._position, tempWorldQuat);
                    vec3.add(this.#worldPos, this.#worldPos, tempWorldVec3);
                    quat.multiply(this.#worldQuat, tempWorldQuat, this._quaternion);
                    vec3.mul(this.#worldScale, this.#skeleton.getWorldScale(tempWorldScale), this._scale);
                }
                else {
                    vec3.copy(this.#worldPos, this._position);
                    quat.copy(this.#worldQuat, this._quaternion);
                    vec3.copy(this.#worldScale, this._scale);
                }
            }
        }
        else {
            quat.copy(this.#worldQuat, this.#parentSkeletonBone.worldQuat);
            vec3.copy(this.#worldPos, this.#parentSkeletonBone.worldPos);
            vec3.copy(this.#worldScale, this.#parentSkeletonBone.worldScale);
            /*vec3.transformQuat(this.#worldPos, this._position, this.#parentSkeletonBone.worldQuat);
            vec3.add(this.#worldPos, this.#worldPos, this.#parentSkeletonBone.worldPos);

            quat.multiply(this.#worldQuat, this.#parentSkeletonBone.worldQuat, this._quaternion);*/
        }
        mat4.fromRotationTranslationScale(tempWorldMat, this.#worldQuat, this.#worldPos, this.#worldScale);
        mat4.multiply(this.#boneMat, tempWorldMat, this.#poseToBone);
        if (this.isProcedural()) {
            if (this._parent) {
                mat4.copy(this.#boneMat, this._parent.#boneMat);
            }
            else {
                mat4.identity(this.#boneMat);
            }
        }
        this.dirty = false;
        this.lastComputed = Graphics$1.currentTick;
    }
    set boneId(boneId) {
        this.#boneId = boneId;
    }
    get boneId() {
        return this.#boneId;
    }
    isProcedural() {
        return false;
        //return (this.flags & BONE_ALWAYS_PROCEDURAL) == BONE_ALWAYS_PROCEDURAL;
    }
    setLocked(locked) {
        this.lockPosition = locked;
        this.lockRotation = locked;
        this.lockScale = locked;
    }
    isLocked() {
        return this.lockPosition && this.lockRotation && this.lockScale;
    }
    reset() {
        vec3.zero(this._position);
        quat.identity(this._quaternion);
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), this.locked ? {
            Bone_1: null,
            unlock: { i18n: '#unlock', f: (entity) => entity.locked = false },
        } : null);
    }
    toJSON() {
        const json = super.toJSON();
        json.posetobone = mat4.clone(this.#poseToBone);
        json.refposition = vec3.clone(this.#refPosition);
        json.refquaternion = quat.clone(this.#refQuaternion);
        json.boneid = this.boneId;
        return json;
    }
    static async constructFromJSON(json) {
        return new Bone({ name: json.name });
    }
    fromJSON(json) {
        super.fromJSON(json);
        mat4.copy(this.#poseToBone, json.posetobone ?? mat4.create());
        vec3.copy(this.#refPosition, json.refposition ?? vec3.create());
        quat.copy(this.#refQuaternion, json.refquaternion ?? quat.create());
        this.boneId = json.boneid;
    }
    static getEntityName() {
        return 'Bone';
    }
}
registerEntity(Bone);

const DEFAULT_SIZE$1 = vec3.fromValues(1, 1, 1);
class Decal extends Mesh {
    #size = vec3.create();
    constructor(params = {}) {
        params.geometry = new DecalGeometry();
        params.material = params.material ?? new MeshBasicMaterial({ polygonOffset: true });
        super(params);
        this.setSize(params.size ?? DEFAULT_SIZE$1);
    }
    set position(position) {
        super.position = position;
        this.refreshGeometry();
    }
    get position() {
        return super.position;
    }
    parentChanged() {
        this.refreshGeometry();
    }
    setSize(size) {
        vec3.copy(this.#size, size);
        this.refreshGeometry();
    }
    get size() {
        return this.#size;
    }
    refreshGeometry() {
        if (this.parent && this.parent.is('Mesh')) {
            this.getGeometry().applyTo(this.parent, this.worldMatrix, this.#size);
        }
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), {
            StaticDecal_1: null,
            size: { i18n: '#size', f: () => { const v = prompt('Size', this.size.join(' ')); if (v !== null) {
                    this.setSize(stringToVec3(v));
                } } },
            refresh: { i18n: '#refresh', f: () => this.refreshGeometry() },
        });
    }
    static async constructFromJSON(json, entities, loadedPromise) {
        return new Decal(json);
    }
    static getEntityName() {
        return 'Decal';
    }
}
registerEntity(Decal);
class DecalGeometry extends BufferGeometry {
    applyTo(mesh, projectorMatrix, size) {
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        this.#generate(mesh, projectorMatrix, size, indices, vertices, normals, uvs);
        //console.log(uvs);
        this.setIndex(new Uint16BufferAttribute(indices, 1));
        this.setAttribute('aVertexPosition', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('aVertexNormal', new Float32BufferAttribute(normals, 3));
        this.setAttribute('aTextureCoord', new Float32BufferAttribute(uvs, 2));
        this.count = indices.length;
    }
    #generate(mesh, projectorMatrix, size, indices, vertices, normals, uvs) {
        let decalVertices = [];
        const projectorMatrixInverse = mat4.invert(mat4.create(), projectorMatrix);
        const vertex = vec3.create();
        const normal = vec3.create();
        const geometry = mesh.getGeometry();
        if (!geometry) {
            return;
        }
        const indexAttribute = geometry.attributes.get('index');
        const indexArray = indexAttribute._array;
        let posArray;
        let normalArray;
        if (!mesh.isSkeletalMesh) {
            posArray = geometry.attributes.get('aVertexPosition')._array;
            normalArray = geometry.attributes.get('aVertexNormal')._array;
        }
        else {
            [posArray, normalArray] = mesh.getSkinnedVertex();
        }
        for (let i = 0, l = indexAttribute.count; i < l; ++i) {
            const index = indexArray[i];
            vertex[0] = posArray[index * 3];
            vertex[1] = posArray[index * 3 + 1];
            vertex[2] = posArray[index * 3 + 2];
            normal[0] = normalArray[index * 3];
            normal[1] = normalArray[index * 3 + 1];
            normal[2] = normalArray[index * 3 + 2];
            vec3.transformMat4(vertex, vertex, mesh.worldMatrix);
            vec3.transformMat4(vertex, vertex, projectorMatrixInverse);
            decalVertices.push([vec3.clone(vertex), vec3.clone(normal)]);
        }
        decalVertices = this.#clipGeometry(decalVertices, size, [1, 0, 0]);
        decalVertices = this.#clipGeometry(decalVertices, size, [-1, 0, 0]);
        decalVertices = this.#clipGeometry(decalVertices, size, [0, 1, 0]);
        decalVertices = this.#clipGeometry(decalVertices, size, [0, -1, 0]);
        decalVertices = this.#clipGeometry(decalVertices, size, [0, 0, 1]);
        decalVertices = this.#clipGeometry(decalVertices, size, [0, 0, -1]);
        for (let i = 0; i < decalVertices.length; i++) {
            const decalVertex = decalVertices[i];
            // create texture coordinates (we are still in projector space)
            uvs.push(0.5 + (decalVertex[0][0] / size[0]), 0.5 + (decalVertex[0][1] / size[1]));
            // transform the vertex back to world space
            decalVertex[0];
            //vec3.transformMat4(v, v, projectorMatrix);
            vertices.push(...decalVertex[0]);
            normals.push(...decalVertex[1]);
            indices.push(i);
        }
    }
    #clipGeometry(inVertices, size, plane) {
        const outVertices = [];
        const s = 0.5 * Math.abs(vec3.dot(size, plane));
        // a single iteration clips one face,
        // which consists of three consecutive 'DecalVertex' objects
        for (let i = 0; i < inVertices.length; i += 3) {
            let total = 0;
            let nV1;
            let nV2;
            let nV3;
            let nV4;
            const d1 = vec3.dot(inVertices[i + 0][0], plane) - s;
            const d2 = vec3.dot(inVertices[i + 1][0], plane) - s;
            const d3 = vec3.dot(inVertices[i + 2][0], plane) - s;
            const v1Out = d1 > 0;
            const v2Out = d2 > 0;
            const v3Out = d3 > 0;
            // calculate, how many vertices of the face lie outside of the clipping plane
            total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);
            switch (total) {
                case 0: {
                    // the entire face lies inside of the plane, no clipping needed
                    outVertices.push(inVertices[i]);
                    outVertices.push(inVertices[i + 1]);
                    outVertices.push(inVertices[i + 2]);
                    break;
                }
                case 1: {
                    // one vertex lies outside of the plane, perform clipping
                    if (v1Out) {
                        nV1 = inVertices[i + 1];
                        nV2 = inVertices[i + 2];
                        nV3 = this.#clip(inVertices[i], nV1, plane, s);
                        nV4 = this.#clip(inVertices[i], nV2, plane, s);
                    }
                    if (v2Out) {
                        nV1 = inVertices[i];
                        nV2 = inVertices[i + 2];
                        nV3 = this.#clip(inVertices[i + 1], nV1, plane, s);
                        nV4 = this.#clip(inVertices[i + 1], nV2, plane, s);
                        outVertices.push(nV3);
                        outVertices.push([vec3.clone(nV2[0]), vec3.clone(nV2[1])]); //outVertices.push( nV2.clone() );
                        outVertices.push([vec3.clone(nV1[0]), vec3.clone(nV1[1])]); //outVertices.push( nV1.clone() );
                        outVertices.push([vec3.clone(nV2[0]), vec3.clone(nV2[1])]); //outVertices.push( nV2.clone() );
                        outVertices.push([vec3.clone(nV3[0]), vec3.clone(nV3[1])]); //outVertices.push( nV3.clone() );
                        outVertices.push(nV4);
                        break;
                    }
                    if (v3Out) {
                        nV1 = inVertices[i];
                        nV2 = inVertices[i + 1];
                        nV3 = this.#clip(inVertices[i + 2], nV1, plane, s);
                        nV4 = this.#clip(inVertices[i + 2], nV2, plane, s);
                    }
                    outVertices.push([vec3.clone(nV1[0]), vec3.clone(nV1[1])]); //outVertices.push( nV1.clone() );
                    outVertices.push([vec3.clone(nV2[0]), vec3.clone(nV2[1])]); //outVertices.push( nV2.clone() );
                    outVertices.push(nV3);
                    outVertices.push(nV4);
                    outVertices.push([vec3.clone(nV3[0]), vec3.clone(nV3[1])]); //outVertices.push( nV3.clone() );
                    outVertices.push([vec3.clone(nV2[0]), vec3.clone(nV2[1])]); //outVertices.push( nV2.clone() );
                    break;
                }
                case 2: {
                    // two vertices lies outside of the plane, perform clipping
                    if (!v1Out) {
                        nV1 = [vec3.clone(inVertices[i][0]), vec3.clone(inVertices[i][1])]; //inVertices[ i ].clone();
                        nV2 = this.#clip(nV1, inVertices[i + 1], plane, s);
                        nV3 = this.#clip(nV1, inVertices[i + 2], plane, s);
                        outVertices.push(nV1);
                        outVertices.push(nV2);
                        outVertices.push(nV3);
                    }
                    if (!v2Out) {
                        nV1 = [vec3.clone(inVertices[i + 1][0]), vec3.clone(inVertices[i + 1][1])]; //inVertices[ i + 1 ].clone();
                        nV2 = this.#clip(nV1, inVertices[i + 2], plane, s);
                        nV3 = this.#clip(nV1, inVertices[i], plane, s);
                        outVertices.push(nV1);
                        outVertices.push(nV2);
                        outVertices.push(nV3);
                    }
                    if (!v3Out) {
                        nV1 = [vec3.clone(inVertices[i + 2][0]), vec3.clone(inVertices[i + 2][1])]; //inVertices[ i + 2 ].clone();
                        nV2 = this.#clip(nV1, inVertices[i], plane, s);
                        nV3 = this.#clip(nV1, inVertices[i + 1], plane, s);
                        outVertices.push(nV1);
                        outVertices.push(nV2);
                        outVertices.push(nV3);
                    }
                    break;
                }
            }
        }
        return outVertices;
    }
    #clip(v0, v1, plane, s) {
        const v0Pos = v0[0];
        const v1Pos = v1[0];
        const v0Norm = v0[1];
        const v1Norm = v1[1];
        const d0 = vec3.dot(v0Pos, plane) - s;
        const d1 = vec3.dot(v1Pos, plane) - s;
        const s0 = d0 / (d0 - d1);
        // need to clip more values (texture coordinates)? do it this way:
        // intersectpoint.value = a.value + s * ( b.value - a.value );
        return [
            [
                v0Pos[0] + s0 * (v1Pos[0] - v0Pos[0]),
                v0Pos[1] + s0 * (v1Pos[1] - v0Pos[1]),
                v0Pos[2] + s0 * (v1Pos[2] - v0Pos[2])
            ],
            [
                v0Norm[0] + s0 * (v1Norm[0] - v0Norm[0]),
                v0Norm[1] + s0 * (v1Norm[1] - v0Norm[1]),
                v0Norm[2] + s0 * (v1Norm[2] - v0Norm[2])
            ]
        ];
    }
}

// It is just a basic entity
class Group extends Entity {
    static async constructFromJSON(json) {
        return new Group({ name: json.name });
    }
    static getEntityName() {
        return 'Group';
    }
}
registerEntity(Group);

const IDENTITY_MAT4$4 = mat4.create();
const v1$1 = vec3.create();
const v2 = vec3.create();
const v3 = vec3.create();
const n1 = vec3.create();
const n2 = vec3.create();
const n3 = vec3.create();
const uv1 = vec2.create();
const uv2 = vec2.create();
const uv3 = vec2.create();
const intersectionPoint = vec3.create();
const intersectionNormal = vec3.create();
const ray$1 = new Ray();
const uv$1 = vec2.create();
class SkeletalMesh extends Mesh {
    isSkeletalMesh = true;
    #bonesPerVertex = 3;
    skeleton;
    #skinnedVertexPosition;
    #skinnedVertexNormal;
    constructor(params) {
        super(params);
        this.skeleton = params.skeleton;
        this.setUniform('uBoneMatrix', this.skeleton.getTexture());
        this.setDefine('HARDWARE_SKINNING'); //TODOv3 proper defines
        this.setDefine('SKELETAL_MESH');
    }
    set bonesPerVertex(bonesPerVertex) {
        this.#bonesPerVertex = bonesPerVertex;
    }
    get bonesPerVertex() {
        return this.#bonesPerVertex;
    }
    exportObj() {
        const ret = {};
        const skeletonBones = this.skeleton._bones;
        const attributes = { f: 'index', v: 'aVertexPosition', vn: 'aVertexNormal', vt: 'aTextureCoord' };
        const geometry = this.getGeometry();
        const vertexCount = geometry.getAttribute('aVertexPosition').count;
        const skinnedVertexPosition = new Float32Array(vertexCount * 3);
        const skinnedVertexNormal = new Float32Array(vertexCount * 3);
        const vertexPosition = geometry.getAttribute('aVertexPosition')._array;
        const vertexNormal = geometry.getAttribute('aVertexNormal')._array;
        const vertexBoneIndice = geometry.getAttribute('aBoneIndices')._array;
        const vertexBoneWeight = geometry.getAttribute('aBoneWeight')._array;
        const boneCount = geometry.getAttribute('aBoneIndices').itemSize;
        const tempVertex = vec3.create();
        const tempVertexNormal = vec3.create();
        const accumulateMat = mat4.create();
        if (vertexPosition && vertexBoneIndice && vertexBoneWeight) {
            for (let vertexIndex = 0; vertexIndex < vertexCount; ++vertexIndex) {
                const vertexArrayIndex = vertexIndex * 3;
                const boneArrayIndex = vertexIndex * boneCount;
                accumulateMat[0] = 0;
                accumulateMat[1] = 0;
                accumulateMat[2] = 0;
                accumulateMat[4] = 0;
                accumulateMat[5] = 0;
                accumulateMat[6] = 0;
                accumulateMat[8] = 0;
                accumulateMat[9] = 0;
                accumulateMat[10] = 0;
                accumulateMat[12] = 0;
                accumulateMat[13] = 0;
                accumulateMat[14] = 0;
                tempVertex[0] = vertexPosition[vertexArrayIndex + 0];
                tempVertex[1] = vertexPosition[vertexArrayIndex + 1];
                tempVertex[2] = vertexPosition[vertexArrayIndex + 2];
                tempVertexNormal[0] = vertexNormal[vertexArrayIndex + 0];
                tempVertexNormal[1] = vertexNormal[vertexArrayIndex + 1];
                tempVertexNormal[2] = vertexNormal[vertexArrayIndex + 2];
                for (let boneIndex = 0; boneIndex < boneCount; ++boneIndex) {
                    const boneArrayIndex2 = boneArrayIndex + boneIndex;
                    const bone = skeletonBones[vertexBoneIndice[boneArrayIndex2]];
                    const boneMat = bone ? bone.boneMat : IDENTITY_MAT4$4;
                    const boneWeight = vertexBoneWeight[boneArrayIndex2];
                    if (boneWeight && boneMat) {
                        accumulateMat[0] += boneWeight * boneMat[0];
                        accumulateMat[1] += boneWeight * boneMat[1];
                        accumulateMat[2] += boneWeight * boneMat[2];
                        accumulateMat[4] += boneWeight * boneMat[4];
                        accumulateMat[5] += boneWeight * boneMat[5];
                        accumulateMat[6] += boneWeight * boneMat[6];
                        accumulateMat[8] += boneWeight * boneMat[8];
                        accumulateMat[9] += boneWeight * boneMat[9];
                        accumulateMat[10] += boneWeight * boneMat[10];
                        accumulateMat[12] += boneWeight * boneMat[12];
                        accumulateMat[13] += boneWeight * boneMat[13];
                        accumulateMat[14] += boneWeight * boneMat[14];
                    }
                }
                vec3.transformMat4(tempVertex, tempVertex, accumulateMat);
                accumulateMat[12] = 0;
                accumulateMat[13] = 0;
                accumulateMat[14] = 0;
                vec3.transformMat4(tempVertexNormal, tempVertexNormal, accumulateMat);
                skinnedVertexPosition[vertexArrayIndex + 0] = tempVertex[0];
                skinnedVertexPosition[vertexArrayIndex + 1] = tempVertex[1];
                skinnedVertexPosition[vertexArrayIndex + 2] = tempVertex[2];
                skinnedVertexNormal[vertexArrayIndex + 0] = tempVertexNormal[0];
                skinnedVertexNormal[vertexArrayIndex + 1] = tempVertexNormal[1];
                skinnedVertexNormal[vertexArrayIndex + 2] = tempVertexNormal[2];
            }
        }
        for (const objAttribute in attributes) {
            const geometryAttribute = attributes[objAttribute];
            if (geometry.getAttribute(geometryAttribute)) {
                if (geometryAttribute == 'aVertexPosition') {
                    ret[objAttribute] = skinnedVertexPosition;
                }
                else if (geometryAttribute == 'aVertexNormal') {
                    ret[objAttribute] = skinnedVertexNormal;
                }
                else {
                    const webglAttrib = geometry.getAttribute(geometryAttribute);
                    if (webglAttrib) {
                        ret[objAttribute] = webglAttrib._array;
                    }
                }
            }
            else {
                ret[objAttribute] = [];
            }
        }
        return ret;
    }
    getRandomPointOnModel(vec, initialVec, bones) {
        const ret = {};
        const skeletonBones = this.skeleton._bones;
        //let attributes = {f:'index',v:'aVertexPosition',vn:'aVertexNormal',vt:'aTextureCoord'};
        const geometry = this.getGeometry();
        const vertexCount = geometry.getAttribute('aVertexPosition').count;
        const vertexPosition = geometry.getAttribute('aVertexPosition')._array;
        const vertexBoneIndice = geometry.getAttribute('aBoneIndices')._array;
        const vertexBoneWeight = geometry.getAttribute('aBoneWeight')._array;
        const boneCount = geometry.getAttribute('aBoneIndices').itemSize;
        vec3.create();
        const accumulateMat = mat4.create();
        function RandomInt(max) {
            return Math.floor(Math.random() * max);
        }
        const vertexIndex = RandomInt(vertexCount);
        vec[0] = 0;
        vec[1] = 0;
        vec[2] = 0;
        if (vertexPosition && vertexBoneIndice && vertexBoneWeight) {
            //for (let vertexIndex = 0; vertexIndex < vertexCount; ++vertexIndex)
            {
                const vertexArrayIndex = vertexIndex * 3;
                const boneArrayIndex = vertexIndex * boneCount;
                accumulateMat[0] = 0;
                accumulateMat[1] = 0;
                accumulateMat[2] = 0;
                accumulateMat[4] = 0;
                accumulateMat[5] = 0;
                accumulateMat[6] = 0;
                accumulateMat[8] = 0;
                accumulateMat[9] = 0;
                accumulateMat[10] = 0;
                accumulateMat[12] = 0;
                accumulateMat[13] = 0;
                accumulateMat[14] = 0;
                vec[0] = vertexPosition[vertexArrayIndex + 0];
                vec[1] = vertexPosition[vertexArrayIndex + 1];
                vec[2] = vertexPosition[vertexArrayIndex + 2];
                vec3.copy(initialVec, vec);
                for (let boneIndex = 0; boneIndex < boneCount; ++boneIndex) {
                    const boneArrayIndex2 = boneArrayIndex + boneIndex;
                    const bone = skeletonBones[vertexBoneIndice[boneArrayIndex2]];
                    const boneMat = bone ? bone.boneMat : IDENTITY_MAT4$4;
                    const boneWeight = vertexBoneWeight[boneArrayIndex2];
                    if (bones && bone) {
                        bones.push([bone, boneWeight]);
                    }
                    if (boneWeight && boneMat) {
                        accumulateMat[0] += boneWeight * boneMat[0];
                        accumulateMat[1] += boneWeight * boneMat[1];
                        accumulateMat[2] += boneWeight * boneMat[2];
                        accumulateMat[4] += boneWeight * boneMat[4];
                        accumulateMat[5] += boneWeight * boneMat[5];
                        accumulateMat[6] += boneWeight * boneMat[6];
                        accumulateMat[8] += boneWeight * boneMat[8];
                        accumulateMat[9] += boneWeight * boneMat[9];
                        accumulateMat[10] += boneWeight * boneMat[10];
                        accumulateMat[12] += boneWeight * boneMat[12];
                        accumulateMat[13] += boneWeight * boneMat[13];
                        accumulateMat[14] += boneWeight * boneMat[14];
                    }
                }
                vec3.transformMat4(vec, vec, accumulateMat);
            }
        }
        return ret;
    }
    getBoundingBox(boundingBox = new BoundingBox()) {
        const skeletonBones = this.skeleton._bones;
        const geometry = this.getGeometry();
        const indexAttribute = geometry.getAttribute('index' /*TODO: create a constant*/);
        const vertexAttribute = geometry.getAttribute('aVertexPosition');
        const indexCount = indexAttribute.count;
        const vertexCount = vertexAttribute.count;
        const skinnedVertexPosition = new Float32Array(vertexCount * 3);
        const indexValue = indexAttribute._array;
        const vertexPosition = vertexAttribute._array;
        geometry.getAttribute('aVertexNormal')._array;
        const vertexBoneIndice = geometry.getAttribute('aBoneIndices')._array;
        const vertexBoneWeight = geometry.getAttribute('aBoneWeight')._array;
        const boneCount = geometry.getAttribute('aBoneIndices').itemSize;
        const tempVertex = vec3.create();
        const accumulateMat = mat4.create();
        if (vertexPosition && vertexBoneIndice && vertexBoneWeight) {
            for (let index = 0; index < indexCount; ++index) {
                const vertexIndex = indexValue[index];
                const vertexArrayIndex = vertexIndex * 3;
                const boneArrayIndex = vertexIndex * boneCount;
                accumulateMat[0] = 0;
                accumulateMat[1] = 0;
                accumulateMat[2] = 0;
                accumulateMat[4] = 0;
                accumulateMat[5] = 0;
                accumulateMat[6] = 0;
                accumulateMat[8] = 0;
                accumulateMat[9] = 0;
                accumulateMat[10] = 0;
                accumulateMat[12] = 0;
                accumulateMat[13] = 0;
                accumulateMat[14] = 0;
                tempVertex[0] = vertexPosition[vertexArrayIndex + 0];
                tempVertex[1] = vertexPosition[vertexArrayIndex + 1];
                tempVertex[2] = vertexPosition[vertexArrayIndex + 2];
                for (let boneIndex = 0; boneIndex < boneCount; ++boneIndex) {
                    const boneArrayIndex2 = boneArrayIndex + boneIndex;
                    const bone = skeletonBones[vertexBoneIndice[boneArrayIndex2]];
                    const boneMat = bone ? bone.boneMat : IDENTITY_MAT4$4;
                    const boneWeight = vertexBoneWeight[boneArrayIndex2];
                    if (boneWeight && boneMat) {
                        accumulateMat[0] += boneWeight * boneMat[0];
                        accumulateMat[1] += boneWeight * boneMat[1];
                        accumulateMat[2] += boneWeight * boneMat[2];
                        accumulateMat[4] += boneWeight * boneMat[4];
                        accumulateMat[5] += boneWeight * boneMat[5];
                        accumulateMat[6] += boneWeight * boneMat[6];
                        accumulateMat[8] += boneWeight * boneMat[8];
                        accumulateMat[9] += boneWeight * boneMat[9];
                        accumulateMat[10] += boneWeight * boneMat[10];
                        accumulateMat[12] += boneWeight * boneMat[12];
                        accumulateMat[13] += boneWeight * boneMat[13];
                        accumulateMat[14] += boneWeight * boneMat[14];
                    }
                }
                vec3.transformMat4(tempVertex, tempVertex, accumulateMat);
                skinnedVertexPosition[vertexArrayIndex + 0] = tempVertex[0];
                skinnedVertexPosition[vertexArrayIndex + 1] = tempVertex[1];
                skinnedVertexPosition[vertexArrayIndex + 2] = tempVertex[2];
            }
        }
        boundingBox.setPoints(skinnedVertexPosition);
        return boundingBox;
    }
    toString() {
        return 'SkeletalMesh ' + super.toString();
    }
    prepareRayCasting() {
        const skeletonBones = this.skeleton._bones;
        const geometry = this.getGeometry();
        const vertexCount = geometry.getAttribute('aVertexPosition').count;
        const skinnedVertexPosition = new Float32Array(vertexCount * 3);
        const skinnedVertexNormal = new Float32Array(vertexCount * 3);
        const vertexPosition = geometry.getAttribute('aVertexPosition')._array;
        const vertexNormal = geometry.getAttribute('aVertexNormal')._array;
        const vertexBoneIndice = geometry.getAttribute('aBoneIndices')._array;
        const vertexBoneWeight = geometry.getAttribute('aBoneWeight')._array;
        const boneCount = geometry.getAttribute('aBoneIndices').itemSize;
        const tempVertex = vec3.create();
        const tempVertexNormal = vec3.create();
        const accumulateMat = mat4.create();
        if (vertexPosition && vertexBoneIndice && vertexBoneWeight) {
            for (let vertexIndex = 0; vertexIndex < vertexCount; ++vertexIndex) {
                const vertexArrayIndex = vertexIndex * 3;
                const boneArrayIndex = vertexIndex * boneCount;
                accumulateMat[0] = 0;
                accumulateMat[1] = 0;
                accumulateMat[2] = 0;
                accumulateMat[4] = 0;
                accumulateMat[5] = 0;
                accumulateMat[6] = 0;
                accumulateMat[8] = 0;
                accumulateMat[9] = 0;
                accumulateMat[10] = 0;
                accumulateMat[12] = 0;
                accumulateMat[13] = 0;
                accumulateMat[14] = 0;
                tempVertex[0] = vertexPosition[vertexArrayIndex + 0];
                tempVertex[1] = vertexPosition[vertexArrayIndex + 1];
                tempVertex[2] = vertexPosition[vertexArrayIndex + 2];
                const tempVertexNormalX = vertexNormal[vertexArrayIndex + 0];
                const tempVertexNormalY = vertexNormal[vertexArrayIndex + 1];
                const tempVertexNormalZ = vertexNormal[vertexArrayIndex + 2];
                for (let boneIndex = 0; boneIndex < boneCount; ++boneIndex) {
                    const boneArrayIndex2 = boneArrayIndex + boneIndex;
                    const bone = skeletonBones[vertexBoneIndice[boneArrayIndex2]];
                    const boneMat = bone ? bone.boneMat : IDENTITY_MAT4$4;
                    const boneWeight = vertexBoneWeight[boneArrayIndex2];
                    if (boneWeight && boneMat) {
                        accumulateMat[0] += boneWeight * boneMat[0];
                        accumulateMat[1] += boneWeight * boneMat[1];
                        accumulateMat[2] += boneWeight * boneMat[2];
                        accumulateMat[4] += boneWeight * boneMat[4];
                        accumulateMat[5] += boneWeight * boneMat[5];
                        accumulateMat[6] += boneWeight * boneMat[6];
                        accumulateMat[8] += boneWeight * boneMat[8];
                        accumulateMat[9] += boneWeight * boneMat[9];
                        accumulateMat[10] += boneWeight * boneMat[10];
                        accumulateMat[12] += boneWeight * boneMat[12];
                        accumulateMat[13] += boneWeight * boneMat[13];
                        accumulateMat[14] += boneWeight * boneMat[14];
                    }
                }
                vec3.transformMat4(tempVertex, tempVertex, accumulateMat);
                tempVertexNormal[0] = accumulateMat[0] * tempVertexNormalX + accumulateMat[4] * tempVertexNormalY + accumulateMat[8] * tempVertexNormalZ;
                tempVertexNormal[1] = accumulateMat[1] * tempVertexNormalX + accumulateMat[5] * tempVertexNormalY + accumulateMat[9] * tempVertexNormalZ;
                tempVertexNormal[2] = accumulateMat[2] * tempVertexNormalX + accumulateMat[6] * tempVertexNormalY + accumulateMat[10] * tempVertexNormalZ;
                skinnedVertexPosition[vertexArrayIndex + 0] = tempVertex[0];
                skinnedVertexPosition[vertexArrayIndex + 1] = tempVertex[1];
                skinnedVertexPosition[vertexArrayIndex + 2] = tempVertex[2];
                skinnedVertexNormal[vertexArrayIndex + 0] = tempVertexNormal[0];
                skinnedVertexNormal[vertexArrayIndex + 1] = tempVertexNormal[1];
                skinnedVertexNormal[vertexArrayIndex + 2] = tempVertexNormal[2];
            }
        }
        this.#skinnedVertexPosition = skinnedVertexPosition;
        this.#skinnedVertexNormal = skinnedVertexNormal;
    }
    raycast(raycaster, intersections) {
        //TODO: case when normals are not provided
        const skeletonBones = this.skeleton._bones;
        const geometry = this.getGeometry();
        const indices = geometry.getAttribute('index')._array;
        //let normals = geometry.getAttribute('aVertexNormal')._array;
        const vertexCount = geometry.getAttribute('aVertexPosition').count;
        const skinnedVertexPosition = new Float32Array(vertexCount * 3);
        const skinnedVertexNormal = new Float32Array(vertexCount * 3);
        const textureCoords = geometry.getAttribute('aTextureCoord')._array;
        const worldMatrix = this.worldMatrix;
        ray$1.copyTransform(raycaster.ray, worldMatrix);
        const vertexPosition = geometry.getAttribute('aVertexPosition')._array;
        const vertexNormal = geometry.getAttribute('aVertexNormal')._array;
        const vertexBoneIndice = geometry.getAttribute('aBoneIndices')._array;
        const vertexBoneWeight = geometry.getAttribute('aBoneWeight')._array;
        const boneCount = geometry.getAttribute('aBoneIndices').itemSize;
        const tempVertex = vec3.create();
        const tempVertexNormal = vec3.create();
        const accumulateMat = mat4.create();
        if (vertexPosition && vertexBoneIndice && vertexBoneWeight) {
            for (let vertexIndex = 0; vertexIndex < vertexCount; ++vertexIndex) {
                const vertexArrayIndex = vertexIndex * 3;
                const boneArrayIndex = vertexIndex * boneCount;
                accumulateMat[0] = 0;
                accumulateMat[1] = 0;
                accumulateMat[2] = 0;
                accumulateMat[4] = 0;
                accumulateMat[5] = 0;
                accumulateMat[6] = 0;
                accumulateMat[8] = 0;
                accumulateMat[9] = 0;
                accumulateMat[10] = 0;
                accumulateMat[12] = 0;
                accumulateMat[13] = 0;
                accumulateMat[14] = 0;
                tempVertex[0] = vertexPosition[vertexArrayIndex + 0];
                tempVertex[1] = vertexPosition[vertexArrayIndex + 1];
                tempVertex[2] = vertexPosition[vertexArrayIndex + 2];
                tempVertexNormal[0] = vertexNormal[vertexArrayIndex + 0];
                tempVertexNormal[1] = vertexNormal[vertexArrayIndex + 1];
                tempVertexNormal[2] = vertexNormal[vertexArrayIndex + 2];
                for (let boneIndex = 0; boneIndex < boneCount; ++boneIndex) {
                    const boneArrayIndex2 = boneArrayIndex + boneIndex;
                    const bone = skeletonBones[vertexBoneIndice[boneArrayIndex2]];
                    const boneMat = bone ? bone.boneMat : IDENTITY_MAT4$4;
                    const boneWeight = vertexBoneWeight[boneArrayIndex2];
                    if (boneWeight && boneMat) {
                        accumulateMat[0] += boneWeight * boneMat[0];
                        accumulateMat[1] += boneWeight * boneMat[1];
                        accumulateMat[2] += boneWeight * boneMat[2];
                        accumulateMat[4] += boneWeight * boneMat[4];
                        accumulateMat[5] += boneWeight * boneMat[5];
                        accumulateMat[6] += boneWeight * boneMat[6];
                        accumulateMat[8] += boneWeight * boneMat[8];
                        accumulateMat[9] += boneWeight * boneMat[9];
                        accumulateMat[10] += boneWeight * boneMat[10];
                        accumulateMat[12] += boneWeight * boneMat[12];
                        accumulateMat[13] += boneWeight * boneMat[13];
                        accumulateMat[14] += boneWeight * boneMat[14];
                    }
                }
                vec3.transformMat4(tempVertex, tempVertex, accumulateMat);
                accumulateMat[12] = 0;
                accumulateMat[13] = 0;
                accumulateMat[14] = 0;
                vec3.transformMat4(tempVertexNormal, tempVertexNormal, accumulateMat);
                skinnedVertexPosition[vertexArrayIndex + 0] = tempVertex[0];
                skinnedVertexPosition[vertexArrayIndex + 1] = tempVertex[1];
                skinnedVertexPosition[vertexArrayIndex + 2] = tempVertex[2];
                skinnedVertexNormal[vertexArrayIndex + 0] = tempVertexNormal[0];
                skinnedVertexNormal[vertexArrayIndex + 1] = tempVertexNormal[1];
                skinnedVertexNormal[vertexArrayIndex + 2] = tempVertexNormal[2];
            }
        }
        for (let i = 0, l = indices.length; i < l; i += 3) {
            let i1 = 3 * indices[i];
            let i2 = 3 * indices[i + 1];
            let i3 = 3 * indices[i + 2];
            vec3.set(v1$1, skinnedVertexPosition[i1] ?? 0, skinnedVertexPosition[i1 + 1] ?? 0, skinnedVertexPosition[i1 + 2] ?? 0);
            vec3.set(v2, skinnedVertexPosition[i2] ?? 0, skinnedVertexPosition[i2 + 1] ?? 0, skinnedVertexPosition[i2 + 2] ?? 0);
            vec3.set(v3, skinnedVertexPosition[i3] ?? 0, skinnedVertexPosition[i3 + 1] ?? 0, skinnedVertexPosition[i3 + 2] ?? 0);
            if (ray$1.intersectTriangle(v1$1, v2, v3, intersectionPoint)) {
                vec3.set(n1, skinnedVertexNormal[i1] ?? 0, skinnedVertexNormal[i1 + 1] ?? 0, skinnedVertexNormal[i1 + 2] ?? 0);
                vec3.set(n2, skinnedVertexNormal[i2] ?? 0, skinnedVertexNormal[i2 + 1] ?? 0, skinnedVertexNormal[i2 + 2] ?? 0);
                vec3.set(n3, skinnedVertexNormal[i3] ?? 0, skinnedVertexNormal[i3 + 1] ?? 0, skinnedVertexNormal[i3 + 2] ?? 0);
                i1 = 2 * indices[i];
                i2 = 2 * indices[i + 1];
                i3 = 2 * indices[i + 2];
                vec2.set(uv1, textureCoords[i1], textureCoords[i1 + 1]);
                vec2.set(uv2, textureCoords[i2], textureCoords[i2 + 1]);
                vec2.set(uv3, textureCoords[i3], textureCoords[i3 + 1]);
                getUV(uv$1, intersectionPoint, v1$1, v2, v3, uv1, uv2, uv3);
                getNormal(intersectionNormal, intersectionPoint, v1$1, v2, v3, n1, n2, n3);
                const x = intersectionNormal[0];
                const y = intersectionNormal[1];
                const z = intersectionNormal[2];
                //Tranform the normal with the world matrix
                intersectionNormal[0] = worldMatrix[0] * x + worldMatrix[4] * y + worldMatrix[8] * z;
                intersectionNormal[1] = worldMatrix[1] * x + worldMatrix[5] * y + worldMatrix[9] * z;
                intersectionNormal[2] = worldMatrix[2] * x + worldMatrix[6] * y + worldMatrix[10] * z;
                vec3.transformMat4(intersectionPoint, intersectionPoint, worldMatrix);
                intersections.push(ray$1.createIntersection(intersectionPoint, intersectionNormal, uv$1, this, 0));
            }
        }
    }
    getSkinnedVertex() {
        this.prepareRayCasting();
        return [this.#skinnedVertexPosition, this.#skinnedVertexNormal];
    }
    static getEntityName() {
        return 'Skeletal mesh';
    }
}

mat4.create();
class Skeleton extends Entity {
    isSkeleton = true;
    #bonesByName = new Map();
    #rootBone = new Bone({ name: 'root', boneId: 0, skeleton: this });
    _bones = []; //TODOv3: rename set private
    _dirty = true;
    #imgData;
    #texture;
    lastComputed = 0;
    constructor(params /*TODO: improve type*/) {
        super(params);
        //this.bones = Object.create(null);//TODOv3: rename
        this.#createBoneMatrixArray();
        this.#createBoneMatrixTexture();
        this.dirty();
    }
    dirty() {
        this._dirty = true;
        for (const bone of this._bones) {
            bone.dirty = true;
        }
        /*if (this._bones[0]) {
            this._bones[0].dirty = true;
        }*/
    }
    getTexture() {
        return this.#texture;
    }
    #createBoneMatrixArray() {
        this.#imgData = new Float32Array(MAX_HARDWARE_BONES * 4 * 4);
        mat4.identity(this.#imgData);
        for (let i = 1; i < MAX_HARDWARE_BONES; ++i) {
            this.#imgData.copyWithin(i * 16, 0, 16);
        }
    }
    #createBoneMatrixTexture() {
        this.#texture = TextureManager.createTexture();
        const gl = Graphics$1.glContext; //TODO
        gl.bindTexture(GL_TEXTURE_2D, this.#texture.texture); //TODOv3: pass param to texture and remove this
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        gl.bindTexture(GL_TEXTURE_2D, null);
    }
    #updateBoneMatrixTexture() {
        const gl = Graphics$1.glContext; //TODO
        gl.bindTexture(GL_TEXTURE_2D, this.#texture.texture);
        if (Graphics$1.isWebGL2) {
            gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA32F, 4, MAX_HARDWARE_BONES, 0, GL_RGBA, GL_FLOAT, this.#imgData);
        }
        else {
            gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 4, MAX_HARDWARE_BONES, 0, GL_RGBA, GL_FLOAT, this.#imgData);
        }
        gl.bindTexture(GL_TEXTURE_2D, null);
    }
    setBonesMatrix() {
        let index = 0;
        const bones = this._bones;
        const imgData = this.#imgData;
        let pose;
        if (bones.length == 0) {
            pose = this.#rootBone.boneMat;
            for (let k = 0; k < 16; ++k) {
                imgData[index++] = pose[k];
            }
        }
        for (const bone of bones) {
            pose = bone.boneMat;
            for (let k = 0; k < 16; ++k) {
                imgData[index++] = pose[k];
            }
        }
        this.#updateBoneMatrixTexture();
    }
    set position(position) {
        super.position = position;
    }
    get position() {
        if (this._parent) {
            return vec3.clone(this._parent._position);
        }
        else {
            return vec3.clone(this._position);
        }
    }
    set quaternion(quaternion) {
        super.quaternion = quaternion;
    }
    get quaternion() {
        if (this._parent) {
            return quat.clone(this._parent._quaternion);
        }
        else {
            return quat.clone(this._quaternion);
        }
    }
    addBone(boneId, boneName) {
        const boneNameLowerCase = boneName.toLowerCase();
        let bone = this.#bonesByName.get(boneNameLowerCase);
        if (!bone) {
            const bone = new Bone({ name: boneName, boneId: boneId });
            bone.skeleton = this;
            //this.addChild(bone);
            this._bones[boneId] = bone;
            this.#bonesByName.set(boneNameLowerCase, bone);
            return bone;
        }
        else {
            this._bones[boneId] = bone;
            return bone;
        }
    }
    async setParentSkeleton(skeleton) {
        await this.loadedPromise;
        if (skeleton) {
            await skeleton.loadedPromise;
        }
        const bones = this.#bonesByName;
        for (const [boneName, bone] of bones) {
            bone.parentSkeletonBone = skeleton?.getBoneByName(boneName) ?? null;
        }
    }
    getBoneByName(boneName) {
        return this.#bonesByName.get(boneName.toLowerCase());
    }
    getBoneById(boneId) {
        return this._bones[boneId];
    }
    toString() {
        return 'Skeleton ' + super.toString();
    }
    getBoundingBox(boundingBox = new BoundingBox()) {
        boundingBox.reset();
        return boundingBox;
    }
    get bones() {
        return this._bones;
    }
    reset() {
        for (const bone of this._bones) {
            bone.reset();
        }
    }
    toJSON() {
        const json = super.toJSON();
        const jBones = [];
        const bones = this._bones;
        for (let i = 0; i < bones.length; ++i) {
            jBones.push(bones[i]?.id);
        }
        json.bones = jBones;
        return json;
    }
    static async constructFromJSON(json, entities, loadedPromise) {
        const entity = new Skeleton({ name: json.name });
        let loadedPromiseResolve;
        entity.loadedPromise = new Promise((resolve) => loadedPromiseResolve = resolve);
        loadedPromise.then(() => {
            const jBones = json.bones;
            if (jBones) {
                for (let i = 0; i < jBones.length; ++i) {
                    const boneEntity = entities.get(jBones[i] ?? '');
                    if (boneEntity) {
                        entity._bones[i] = boneEntity;
                        entity.#bonesByName.set(boneEntity.name.toLowerCase(), boneEntity);
                    }
                }
            }
            loadedPromiseResolve(true);
        });
        return entity;
    }
    dispose() {
        super.dispose();
        this.#texture.dispose();
    }
    static getEntityName() {
        return 'Skeleton';
    }
}
registerEntity(Skeleton);

class ExtrudeGeometry extends BufferGeometry {
    parameters;
    createGeometry(shapes, options) {
        this.parameters = {
            shapes: shapes,
            options: options
        };
        shapes = Array.isArray(shapes) ? shapes : [shapes];
        const scope = this;
        const indicesArray = [];
        const verticesArray = [];
        const uvArray = [];
        for (let i = 0, l = shapes.length; i < l; i++) {
            addShape(shapes[i]);
        }
        // build geometry
        this.setIndex(new Uint32BufferAttribute(indicesArray, 1));
        this.setAttribute('aVertexPosition', new Float32BufferAttribute(verticesArray, 3));
        this.setAttribute('aTextureCoord', new Float32BufferAttribute(uvArray, 2));
        this.count = indicesArray.length;
        this.computeVertexNormals();
        // functions
        function addShape(shape) {
            const placeholder = [];
            verticesArray.length / 3;
            // options
            const curveSegments = options.curveSegments ?? 12;
            const steps = options.steps ?? 1;
            const depth = options.depth ?? 100;
            let bevelEnabled = options.bevelEnabled ?? true;
            let bevelThickness = options.bevelThickness ?? 6;
            let bevelSize = options.bevelSize ?? bevelThickness - 2;
            let bevelOffset = options.bevelOffset ?? 0;
            let bevelSegments = options.bevelSegments ?? 3;
            options.extrudePath;
            const uvgen = options.uvGenerator ?? WorldUVGenerator;
            // TODO
            /*
            if (extrudePath) {

                extrudePts = extrudePath.getSpacedPoints(steps);

                extrudeByPath = true;
                bevelEnabled = false; // bevels not supported for path extrusion

                // SETUP TNB variables

                // TODO1 - have a .isClosed in spline?

                splineTube = extrudePath.computeFrenetFrames(steps, false);

                // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

                binormal = vec3.create();
                normal = vec3.create();
                position2 = vec3.create();

            }
            */
            // Safeguards if bevels are not enabled
            if (!bevelEnabled) {
                bevelSegments = 0;
                bevelThickness = 0;
                bevelSize = 0;
                bevelOffset = 0;
            }
            // Variables initialization
            const shapePoints = shape.extractPoints(curveSegments);
            let vertices = shapePoints.shape;
            const holes = shapePoints.holes;
            const reverse = !ShapeUtils.isClockWise(vertices);
            if (reverse) {
                vertices = vertices.reverse();
                // Maybe we should also check if holes are in the opposite direction, just to be safe ...
                for (let h = 0, hl = holes.length; h < hl; h++) {
                    const ahole = holes[h];
                    if (ShapeUtils.isClockWise(ahole)) {
                        holes[h] = ahole.reverse();
                    }
                }
            }
            const faces = ShapeUtils.triangulateShape(vertices, holes);
            /* Vertices */
            const contour = vertices; // vertices has all points but contour has only points of circumference
            for (let h = 0, hl = holes.length; h < hl; h++) {
                const ahole = holes[h];
                vertices = vertices.concat(ahole);
            }
            function scalePt2(pt, vec, size) {
                return vec2.scaleAndAdd(vec2.create(), pt, vec, size);
            }
            const vlen = vertices.length, flen = faces.length;
            // Find directions for point movement
            function getBevelVec(inPt, inPrev, inNext) {
                // computes for inPt the corresponding point inPt' on a new contour
                //   shifted by 1 unit (length of normalized vector) to the left
                // if we walk along contour clockwise, this new contour is outside the old one
                //
                // inPt' is the intersection of the two lines parallel to the two
                //  adjacent edges of inPt at a distance of 1 unit on the left side.
                let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt
                // good reading for geometry algorithms (here: line-line intersection)
                // http://geomalgorithms.com/a05-_intersect-1.html
                const v_prev_x = inPt[0] - inPrev[0], v_prev_y = inPt[1] - inPrev[1];
                const v_next_x = inNext[0] - inPt[0], v_next_y = inNext[1] - inPt[1];
                const v_prev_lensq = (v_prev_x * v_prev_x + v_prev_y * v_prev_y);
                // check for collinear edges
                const collinear0 = (v_prev_x * v_next_y - v_prev_y * v_next_x);
                if (Math.abs(collinear0) > Number.EPSILON) {
                    // not collinear
                    // length of vectors for normalizing
                    const v_prev_len = Math.sqrt(v_prev_lensq);
                    const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
                    // shift adjacent points by unit vectors to the left
                    const ptPrevShift_x = (inPrev[0] - v_prev_y / v_prev_len);
                    const ptPrevShift_y = (inPrev[1] + v_prev_x / v_prev_len);
                    const ptNextShift_x = (inNext[0] - v_next_y / v_next_len);
                    const ptNextShift_y = (inNext[1] + v_next_x / v_next_len);
                    // scaling factor for v_prev to intersection point
                    const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y -
                        (ptNextShift_y - ptPrevShift_y) * v_next_x) /
                        (v_prev_x * v_next_y - v_prev_y * v_next_x);
                    // vector from inPt to intersection point
                    v_trans_x = (ptPrevShift_x + v_prev_x * sf - inPt[0]);
                    v_trans_y = (ptPrevShift_y + v_prev_y * sf - inPt[1]);
                    // Don't normalize!, otherwise sharp corners become ugly
                    //  but prevent crazy spikes
                    const v_trans_lensq = (v_trans_x * v_trans_x + v_trans_y * v_trans_y);
                    if (v_trans_lensq <= 2) {
                        return vec2.fromValues(v_trans_x, v_trans_y);
                    }
                    else {
                        shrink_by = Math.sqrt(v_trans_lensq / 2);
                    }
                }
                else {
                    // handle special case of collinear edges
                    let direction_eq = false; // assumes: opposite
                    if (v_prev_x > Number.EPSILON) {
                        if (v_next_x > Number.EPSILON) {
                            direction_eq = true;
                        }
                    }
                    else {
                        if (v_prev_x < -Number.EPSILON) {
                            if (v_next_x < -Number.EPSILON) {
                                direction_eq = true;
                            }
                        }
                        else {
                            if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                                direction_eq = true;
                            }
                        }
                    }
                    if (direction_eq) {
                        // console.log("Warning: lines are a straight sequence");
                        v_trans_x = -v_prev_y;
                        v_trans_y = v_prev_x;
                        shrink_by = Math.sqrt(v_prev_lensq);
                    }
                    else {
                        // console.log("Warning: lines are a straight spike");
                        v_trans_x = v_prev_x;
                        v_trans_y = v_prev_y;
                        shrink_by = Math.sqrt(v_prev_lensq / 2);
                    }
                }
                return vec2.fromValues(v_trans_x / shrink_by, v_trans_y / shrink_by);
            }
            const contourMovements = [];
            for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
                if (j === il)
                    j = 0;
                if (k === il)
                    k = 0;
                //  (j)---(i)---(k)
                // console.log('i,j,k', i, j , k)
                contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
            }
            const holesMovements = [];
            let oneHoleMovements, verticesMovements = contourMovements.concat();
            for (let h = 0, hl = holes.length; h < hl; h++) {
                const ahole = holes[h];
                oneHoleMovements = [];
                for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
                    if (j === il)
                        j = 0;
                    if (k === il)
                        k = 0;
                    //  (j)---(i)---(k)
                    oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
                }
                holesMovements.push(oneHoleMovements);
                verticesMovements = verticesMovements.concat(oneHoleMovements);
            }
            // Loop bevelSegments, 1 for the front, 1 for the back
            for (let b = 0; b < bevelSegments; b++) {
                //for ( b = bevelSegments; b > 0; b -- ) {
                const t = b / bevelSegments;
                const z = bevelThickness * Math.cos(t * Math.PI / 2);
                const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
                // contract shape
                for (let i = 0, il = contour.length; i < il; i++) {
                    const vert = scalePt2(contour[i], contourMovements[i], bs);
                    v(vert[0], vert[1], -z);
                }
                // expand holes
                for (let h = 0, hl = holes.length; h < hl; h++) {
                    const ahole = holes[h];
                    oneHoleMovements = holesMovements[h];
                    for (let i = 0, il = ahole.length; i < il; i++) {
                        const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
                        v(vert[0], vert[1], -z);
                    }
                }
            }
            const bs = bevelSize + bevelOffset;
            // Back facing vertices
            for (let i = 0; i < vlen; i++) {
                const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
                {
                    v(vert[0], vert[1], 0);
                }
            }
            // Add stepped vertices...
            // Including front facing vertices
            for (let s = 1; s <= steps; s++) {
                for (let i = 0; i < vlen; i++) {
                    const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
                    {
                        v(vert[0], vert[1], depth / steps * s);
                    }
                }
            }
            // Add bevel segments planes
            //for ( b = 1; b <= bevelSegments; b ++ ) {
            for (let b = bevelSegments - 1; b >= 0; b--) {
                const t = b / bevelSegments;
                const z = bevelThickness * Math.cos(t * Math.PI / 2);
                const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
                // contract shape
                for (let i = 0, il = contour.length; i < il; i++) {
                    const vert = scalePt2(contour[i], contourMovements[i], bs);
                    v(vert[0], vert[1], depth + z);
                }
                // expand holes
                for (let h = 0, hl = holes.length; h < hl; h++) {
                    const ahole = holes[h];
                    oneHoleMovements = holesMovements[h];
                    for (let i = 0, il = ahole.length; i < il; i++) {
                        const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
                        {
                            v(vert[0], vert[1], depth + z);
                        }
                    }
                }
            }
            /* Faces */
            // Top and bottom faces
            buildLidFaces();
            // Sides faces
            buildSideFaces();
            /////  Internal functions
            function buildLidFaces() {
                verticesArray.length / 3;
                if (bevelEnabled) {
                    let layer = 0; // steps + 1
                    let offset = vlen * layer;
                    // Bottom faces
                    for (let i = 0; i < flen; i++) {
                        const face = faces[i];
                        f3(face[2] + offset, face[1] + offset, face[0] + offset);
                    }
                    layer = steps + bevelSegments * 2;
                    offset = vlen * layer;
                    // Top faces
                    for (let i = 0; i < flen; i++) {
                        const face = faces[i];
                        f3(face[0] + offset, face[1] + offset, face[2] + offset);
                    }
                }
                else {
                    // Bottom faces
                    for (let i = 0; i < flen; i++) {
                        const face = faces[i];
                        f3(face[2], face[1], face[0]);
                    }
                    // Top faces
                    for (let i = 0; i < flen; i++) {
                        const face = faces[i];
                        f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
                    }
                }
                //scope.addGroup( start, verticesArray.length / 3 - start, 0 );
            }
            // Create faces for the z-sides of the shape
            function buildSideFaces() {
                verticesArray.length / 3;
                let layeroffset = 0;
                sidewalls(contour, layeroffset);
                layeroffset += contour.length;
                for (let h = 0, hl = holes.length; h < hl; h++) {
                    const ahole = holes[h];
                    sidewalls(ahole, layeroffset);
                    //, true
                    layeroffset += ahole.length;
                }
                //scope.addGroup( start, verticesArray.length / 3 - start, 1 );
            }
            function sidewalls(contour, layeroffset) {
                let i = contour.length;
                while (--i >= 0) {
                    const j = i;
                    let k = i - 1;
                    if (k < 0)
                        k = contour.length - 1;
                    //console.log('b', i,j, i-1, k,vertices.length);
                    for (let s = 0, sl = (steps + bevelSegments * 2); s < sl; s++) {
                        const slen1 = vlen * s;
                        const slen2 = vlen * (s + 1);
                        const a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
                        f4(a, b, c, d);
                    }
                }
            }
            function v(x, y, z) {
                placeholder.push(x);
                placeholder.push(y);
                placeholder.push(z);
            }
            function f3(a, b, c) {
                addIndex();
                addIndex();
                addIndex();
                addVertex(a);
                addVertex(b);
                addVertex(c);
                const nextIndex = verticesArray.length / 3;
                const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                addUV(uvs[0]);
                addUV(uvs[1]);
                addUV(uvs[2]);
            }
            function f4(a, b, c, d) {
                addIndex();
                addIndex();
                addIndex();
                addIndex();
                addIndex();
                addIndex();
                addVertex(a);
                addVertex(b);
                addVertex(d);
                addVertex(b);
                addVertex(c);
                addVertex(d);
                const nextIndex = verticesArray.length / 3;
                const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                addUV(uvs[0]);
                addUV(uvs[1]);
                addUV(uvs[3]);
                addUV(uvs[1]);
                addUV(uvs[2]);
                addUV(uvs[3]);
            }
            function addIndex(index) {
                indicesArray.push(indicesArray.length);
            }
            function addVertex(index) {
                verticesArray.push(placeholder[index * 3 + 0]);
                verticesArray.push(placeholder[index * 3 + 1]);
                verticesArray.push(placeholder[index * 3 + 2]);
            }
            function addUV(vector2) {
                uvArray.push(vector2[0]);
                uvArray.push(vector2[1]);
            }
        }
    }
}
const WorldUVGenerator = {
    generateTopUV: function (geometry, vertices, indexA, indexB, indexC) {
        const a_x = vertices[indexA * 3];
        const a_y = vertices[indexA * 3 + 1];
        const b_x = vertices[indexB * 3];
        const b_y = vertices[indexB * 3 + 1];
        const c_x = vertices[indexC * 3];
        const c_y = vertices[indexC * 3 + 1];
        return [
            vec2.fromValues(a_x, a_y),
            vec2.fromValues(b_x, b_y),
            vec2.fromValues(c_x, c_y)
        ];
    },
    generateSideWallUV: function (geometry, vertices, indexA, indexB, indexC, indexD) {
        const a_x = vertices[indexA * 3];
        const a_y = vertices[indexA * 3 + 1];
        const a_z = vertices[indexA * 3 + 2];
        const b_x = vertices[indexB * 3];
        const b_y = vertices[indexB * 3 + 1];
        const b_z = vertices[indexB * 3 + 2];
        const c_x = vertices[indexC * 3];
        const c_y = vertices[indexC * 3 + 1];
        const c_z = vertices[indexC * 3 + 2];
        const d_x = vertices[indexD * 3];
        const d_y = vertices[indexD * 3 + 1];
        const d_z = vertices[indexD * 3 + 2];
        if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
            return [
                vec2.fromValues(a_x, 1 - a_z),
                vec2.fromValues(b_x, 1 - b_z),
                vec2.fromValues(c_x, 1 - c_z),
                vec2.fromValues(d_x, 1 - d_z)
            ];
        }
        else {
            return [
                vec2.fromValues(a_y, 1 - a_z),
                vec2.fromValues(b_y, 1 - b_z),
                vec2.fromValues(c_y, 1 - c_z),
                vec2.fromValues(d_y, 1 - d_z)
            ];
        }
    }
};

class Text3D extends Mesh {
    isText3D = true;
    static defaultFont = 'arial';
    static defaultStyle = 'normal';
    #text;
    #size;
    #depth;
    #font;
    #style;
    constructor(params = {}) {
        params.geometry = new ExtrudeGeometry();
        params.material = params.material ?? new MeshBasicMaterial();
        super(params);
        this.#text = params.text ?? '';
        this.#size = params.size ?? 100;
        this.#depth = params.depth ?? 10;
        this.#font = params.font ?? Text3D.defaultFont;
        this.#style = params.style ?? Text3D.defaultStyle;
        this.#updateGeometry();
        this.rotateX(90 * DEG_TO_RAD);
        this.setParameters(params);
    }
    set text(text) {
        this.#text = text;
        this.#updateGeometry();
    }
    set size(size) {
        this.#size = size;
        this.#updateGeometry();
    }
    set depth(depth) {
        this.#depth = depth;
        this.#updateGeometry();
    }
    set font(font) {
        this.#font = font;
        this.#updateGeometry();
    }
    set style(style) {
        this.#style = style;
        this.#updateGeometry();
    }
    async #updateGeometry() {
        const font = await FontManager.getFont(this.#font);
        if (font) {
            const shapes = font.generateShapes(this.#text, this.#size);
            this.geometry.createGeometry(shapes, { depth: this.#depth, bevelThickness: 2, bevelSize: 0.5 });
        }
    }
    toJSON() {
        const json = super.toJSON();
        json.text = this.#text;
        json.size = this.#size;
        json.depth = this.#depth;
        json.font = this.#font;
        json.style = this.#style;
        return json;
    }
    static async constructFromJSON(json, entities, loadedPromise) {
        return new Text3D({}); // TODO: add params
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.#text = json.text;
        this.#size = json.size;
        this.#depth = json.depth;
        this.#font = json.font ?? Text3D.defaultFont;
        this.#style = json.style ?? Text3D.defaultStyle;
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), {
            Text3D_1: null,
            text: { i18n: '#text', f: () => { const text = prompt('Text', this.#text); this.text = text ?? ''; } },
            font: {
                i18n: '#font', f: async () => {
                    const fontList = await FontManager.getFontList();
                    const fontList2 = new Set();
                    for (const [fontName, font] of fontList) {
                        for (const style of font) {
                            fontList2.add(`${fontName}, ${style}`);
                        }
                    }
                    const font = await new Interaction().getString(0, 0, fontList2);
                    if (font) {
                        this.#font = font[0];
                        this.#style = font[1];
                        this.#updateGeometry();
                    }
                }
            },
            font_size: { i18n: '#font_size', f: () => { const size = prompt('Size', String(this.#size)); this.size = Number(size); } },
            font_depth: { i18n: '#font_depth', f: () => { const depth = prompt('Depth', String(this.#depth)); this.depth = Number(depth); } }
        });
    }
    static getEntityName() {
        return 'Text3D';
    }
}
registerEntity(Text3D);

class Wireframe extends Entity {
    #material = new LineMaterial({ polygonOffset: true, lineWidth: 3 });
    #color = vec4.fromValues(0, 0, 0, 1);
    enumerable = false;
    #meshes = new Set();
    constructor(params) {
        super(params);
        //const material = new LineMaterial({ polygonOffset: true, lineWidth: 3 });
        //this.#material = material;
        this.#material.setColorMode(MaterialColorMode.PerMesh);
        this.#material.color = vec4.fromValues(0.0, 0.0, 0.0, 1.0);
        this.#material.addUser(this);
        //this.setParameters(params);
    }
    setColor(color) {
        vec4.copy(this.#color, color);
        this.#material.setMeshColor(color);
    }
    parentChanged(parent) {
        if (parent) {
            this.#updateGeometry(parent);
        }
    }
    #updateGeometry(parent) {
        this.#disposeMeshes();
        const meshes = parent.getChildList('Mesh');
        for (const mesh of meshes) {
            if (mesh == this || !mesh.isVisible()) {
                continue;
            }
            const segments = [];
            const line = new LineSegmentsGeometry();
            line.addUser(this);
            const me = new Mesh({ geometry: line, material: this.#material });
            this.#meshes.add(me);
            this.addChild(me);
            const m = mesh.exportObj();
            const vertexIndices = m.f;
            const vertexPos = m.v;
            for (let i = 0, l = vertexIndices.length; i < l; i += 3) {
                const vertexIndex1 = vertexIndices[i + 0] * 3;
                const vertexIndex2 = vertexIndices[i + 1] * 3;
                const vertexIndex3 = vertexIndices[i + 2] * 3;
                segments.push(vertexPos[vertexIndex1] ?? 0, vertexPos[vertexIndex1 + 1] ?? 0, vertexPos[vertexIndex1 + 2] ?? 0);
                segments.push(vertexPos[vertexIndex2] ?? 0, vertexPos[vertexIndex2 + 1] ?? 0, vertexPos[vertexIndex2 + 2] ?? 0);
                segments.push(vertexPos[vertexIndex2] ?? 0, vertexPos[vertexIndex2 + 1] ?? 0, vertexPos[vertexIndex2 + 2] ?? 0);
                segments.push(vertexPos[vertexIndex3] ?? 0, vertexPos[vertexIndex3 + 1] ?? 0, vertexPos[vertexIndex3 + 2] ?? 0);
                segments.push(vertexPos[vertexIndex3] ?? 0, vertexPos[vertexIndex3 + 1] ?? 0, vertexPos[vertexIndex3 + 2] ?? 0);
                segments.push(vertexPos[vertexIndex1] ?? 0, vertexPos[vertexIndex1 + 1] ?? 0, vertexPos[vertexIndex1 + 2] ?? 0);
            }
            line.setSegments(segments);
        }
    }
    #disposeMeshes() {
        for (const mesh of this.#meshes) {
            mesh.dispose();
        }
        this.#meshes.clear();
    }
    dispose() {
        super.dispose();
        this.#material.removeUser(this);
        this.#disposeMeshes();
    }
    is(s) {
        return s == 'Wireframe';
    }
    static getEntityName() {
        return 'Wireframe';
    }
}

class World extends Entity {
    parentChanged(parent) {
        const iterator = this.getParentIterator();
        for (const p of iterator) {
            if (p.is('Scene')) {
                p.setWorld(this);
                iterator.return(null);
            }
        }
    }
    static getEntityName() {
        return 'World';
    }
    is(s) {
        if (s == 'World') {
            return true;
        }
        else {
            return super.is(s);
        }
    }
}
registerEntity(World);

const DEFAULT_SEGMENT_COLOR = vec4.fromValues(1.0, 1.0, 1.0, 1.0);
const tempVec3$k = vec3.create();
const tempQuat$7 = quat.create();
const tempQuat2 = quat.create();
const UNIT_VEC3_X$1 = vec3.fromValues(1, 0, 0);
const UNIT_VEC3_MINUS_Y = vec3.fromValues(0, -1, 0);
class BeamSegment {
    pos = vec3.create();
    normal = vec3.create();
    color = vec4.create();
    texCoordY;
    width;
    constructor(pos, color = DEFAULT_SEGMENT_COLOR, texCoordY = 0.0, width = 1.0) {
        vec3.copy(this.pos, pos);
        vec3.copy(this.normal, UNIT_VEC3_MINUS_Y);
        vec4.copy(this.color, color);
        this.texCoordY = texCoordY;
        this.width = width;
    }
    distanceTo(other) {
        return vec3.distance(this.pos, other.pos);
    }
}
class BeamBufferGeometry extends BufferGeometry {
    /*
    constructor(segments?) {
        super();

        if (segments) {
            this.segments = segments;
        }
    }
    */
    set segments(segments) {
        let previousSegment = null;
        let indiceBase = 0;
        const indices = [];
        const vertices = [];
        const uvs = [];
        const colors = [];
        for (const segment of segments) {
            if (previousSegment) {
                indices.push(indiceBase, indiceBase + 2, indiceBase + 1, indiceBase + 2, indiceBase + 3, indiceBase + 1);
                vec3.sub(tempVec3$k, segment.pos, previousSegment.pos);
                vec3.normalize(tempVec3$k, tempVec3$k);
                quat.rotationTo(tempQuat$7, UNIT_VEC3_X$1, tempVec3$k);
                quat.rotationTo(tempQuat2, UNIT_VEC3_MINUS_Y, previousSegment.normal);
                vec3.set(tempVec3$k, 0, 0, -previousSegment.width / 2.0);
                vec3.transformQuat(tempVec3$k, tempVec3$k, tempQuat$7);
                vec3.transformQuat(tempVec3$k, tempVec3$k, tempQuat2);
                vec3.add(tempVec3$k, tempVec3$k, previousSegment.pos);
                vertices.push(...tempVec3$k);
                vec3.set(tempVec3$k, 0, 0, previousSegment.width / 2.0);
                vec3.transformQuat(tempVec3$k, tempVec3$k, tempQuat$7);
                vec3.transformQuat(tempVec3$k, tempVec3$k, tempQuat2);
                vec3.add(tempVec3$k, tempVec3$k, previousSegment.pos);
                vertices.push(...tempVec3$k);
                quat.rotationTo(tempQuat2, UNIT_VEC3_MINUS_Y, segment.normal);
                vec3.set(tempVec3$k, 0, 0, -segment.width / 2.0);
                vec3.transformQuat(tempVec3$k, tempVec3$k, tempQuat$7);
                vec3.transformQuat(tempVec3$k, tempVec3$k, tempQuat2);
                vec3.add(tempVec3$k, tempVec3$k, segment.pos);
                vertices.push(...tempVec3$k);
                vec3.set(tempVec3$k, 0, 0, segment.width / 2.0);
                vec3.transformQuat(tempVec3$k, tempVec3$k, tempQuat$7);
                vec3.transformQuat(tempVec3$k, tempVec3$k, tempQuat2);
                vec3.add(tempVec3$k, tempVec3$k, segment.pos);
                vertices.push(...tempVec3$k);
                uvs.push(0, previousSegment.texCoordY, 1, previousSegment.texCoordY, 0, segment.texCoordY, 1, segment.texCoordY);
                colors.push(...previousSegment.color, ...previousSegment.color, ...segment.color, ...segment.color);
                indiceBase += 4;
            }
            previousSegment = segment;
        }
        this.setIndex(new Uint16BufferAttribute(indices, 1));
        this.setAttribute('aVertexPosition', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('aTextureCoord', new Float32BufferAttribute(uvs, 2));
        this.setAttribute('aVertexColor', new Float32BufferAttribute(colors, 4));
        //this.setAttribute('aVertexWidth', new Float32BufferAttribute(this.widths, 1));
        this.count = indices.length;
    }
}

class Metaball extends Entity {
    currentWorldPosition = vec3.create();
    radius = 0;
    radius2 = 0;
    constructor(radius = 1) {
        super();
        this.setRadius(radius);
    }
    setRadius(radius) {
        this.radius = radius;
        this.radius2 = radius * radius;
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), {
            Metaball_1: null,
            radius: { i18n: '#radius', f: () => { const radius = prompt('Radius', String(this.radius)); if (radius) {
                    this.setRadius(Number(radius));
                } } }
        });
    }
}

var _a$5;
const a$6 = vec3.create();
const b$3 = vec3.create();
const THRESHOLD = 0.99;
class MetaballsBufferGeometry extends BufferGeometry {
    constructor(balls) {
        super();
        this.updateGeometry(balls ?? []);
    }
    updateGeometry(balls, cubeWidth = 1) {
        // build geometry
        const triangles = this.#testMarchingCubes(balls, cubeWidth);
        const indices = [];
        const vertices = [];
        const normals = [];
        let vertexIndex;
        const normal = vec3.create();
        for (let triangleIndex = 0; triangleIndex < triangles.length; ++triangleIndex) {
            vertexIndex = triangleIndex * 3;
            indices.push(vertexIndex, vertexIndex + 1, vertexIndex + 2);
            vertices.push(...triangles[triangleIndex][0]);
            vertices.push(...triangles[triangleIndex][1]);
            vertices.push(...triangles[triangleIndex][2]);
            vec3.sub(a$6, triangles[triangleIndex][1], triangles[triangleIndex][0]);
            vec3.sub(b$3, triangles[triangleIndex][2], triangles[triangleIndex][0]);
            vec3.cross(normal, a$6, b$3);
            vec3.normalize(normal, normal);
            normals.push(...normal);
            normals.push(...normal);
            normals.push(...normal);
        }
        // build geometry
        this.setIndex(new Uint16BufferAttribute(indices, 1));
        this.setAttribute('aVertexPosition', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('aVertexNormal', new Float32BufferAttribute(normals, 3));
        //this.setAttribute('aTextureCoord', new Float32BufferAttribute(uvs, 2));
        this.count = indices.length;
    }
    static getBoundingBox(balls) {
        const min = vec3.fromValues(+Infinity, +Infinity, +Infinity);
        const max = vec3.fromValues(-Infinity, -Infinity, -Infinity);
        for (const ball of balls) {
            vec3.set(b$3, ball.radius, ball.radius, ball.radius);
            vec3.min(min, min, vec3.sub(a$6, ball.currentWorldPosition, b$3));
            vec3.max(max, max, vec3.add(a$6, ball.currentWorldPosition, b$3));
        }
        return [min, max];
    }
    static #computeValue(balls, position) {
        let value = 0;
        for (const ball of balls) {
            const a = 1 / vec3.squaredDistance(ball.currentWorldPosition, position);
            value += ball.radius2 * a;
        }
        if (value < THRESHOLD) {
            for (const ball of balls) {
                for (const ball2 of balls) {
                    const a = 1 / (vec3.squaredDistance(ball.currentWorldPosition, position) + vec3.squaredDistance(ball2.currentWorldPosition, position));
                    value += 20 * a;
                }
            }
        }
        return value;
    }
    #testMarchingCubes(balls, cubeWidth) {
        const [min, max] = _a$5.getBoundingBox(balls);
        for (const ball of balls) {
            ball.getWorldPosition(ball.currentWorldPosition);
        }
        vec3.floor(min, min);
        vec3.ceil(max, max);
        const grid = new GRIDCELL();
        const isolevel = THRESHOLD; //1 / (radius * radius - 0.01);
        const triangles = [];
        vec3.fromValues(3, 3, 3);
        vec3.fromValues(7, 7, 7);
        for (let i = min[0] - 1; i <= max[0]; i += cubeWidth) {
            for (let j = min[1] - 1; j <= max[1]; j += cubeWidth) {
                for (let k = min[2] - 1; k <= max[2]; k += cubeWidth) {
                    const tris = [];
                    grid.p[0][0] = i;
                    grid.p[0][1] = j;
                    grid.p[0][2] = k;
                    grid.val[0] = _a$5.#computeValue(balls, grid.p[0]); //1 / vec3.squaredDistance(center, grid.p[0]) + 1 / vec3.squaredDistance(center2, grid.p[0]) * doSphere2;
                    grid.p[1][0] = i + cubeWidth;
                    grid.p[1][1] = j;
                    grid.p[1][2] = k;
                    grid.val[1] = _a$5.#computeValue(balls, grid.p[1]); //1 / vec3.squaredDistance(center, grid.p[1]) + 1 / vec3.squaredDistance(center2, grid.p[1]) * doSphere2;
                    grid.p[2][0] = i + cubeWidth;
                    grid.p[2][1] = j + cubeWidth;
                    grid.p[2][2] = k;
                    grid.val[2] = _a$5.#computeValue(balls, grid.p[2]); //1 / vec3.squaredDistance(center, grid.p[2]) + 1 / vec3.squaredDistance(center2, grid.p[2]) * doSphere2;
                    grid.p[3][0] = i;
                    grid.p[3][1] = j + cubeWidth;
                    grid.p[3][2] = k;
                    grid.val[3] = _a$5.#computeValue(balls, grid.p[3]); //1 / vec3.squaredDistance(center, grid.p[3]) + 1 / vec3.squaredDistance(center2, grid.p[3]) * doSphere2;
                    grid.p[4][0] = i;
                    grid.p[4][1] = j;
                    grid.p[4][2] = k + cubeWidth;
                    grid.val[4] = _a$5.#computeValue(balls, grid.p[4]); //1 / vec3.squaredDistance(center, grid.p[4]) + 1 / vec3.squaredDistance(center2, grid.p[4]) * doSphere2;
                    grid.p[5][0] = i + cubeWidth;
                    grid.p[5][1] = j;
                    grid.p[5][2] = k + cubeWidth;
                    grid.val[5] = _a$5.#computeValue(balls, grid.p[5]); //1 / vec3.squaredDistance(center, grid.p[5]) + 1 / vec3.squaredDistance(center2, grid.p[5]) * doSphere2;
                    grid.p[6][0] = i + cubeWidth;
                    grid.p[6][1] = j + cubeWidth;
                    grid.p[6][2] = k + cubeWidth;
                    grid.val[6] = _a$5.#computeValue(balls, grid.p[6]); //1 / vec3.squaredDistance(center, grid.p[6]) + 1 / vec3.squaredDistance(center2, grid.p[6]) * doSphere2;
                    grid.p[7][0] = i;
                    grid.p[7][1] = j + cubeWidth;
                    grid.p[7][2] = k + cubeWidth;
                    grid.val[7] = _a$5.#computeValue(balls, grid.p[7]); //1 / vec3.squaredDistance(center, grid.p[7]) + 1 / vec3.squaredDistance(center2, grid.p[7]) * doSphere2;
                    polygonise(grid, isolevel, tris);
                    triangles.push(...tris);
                }
            }
        }
        const tris = [];
        for (let i = 0; i < triangles.length; ++i) {
            const triangle = [];
            if (triangles[i].p[0] && triangles[i].p[1] && triangles[i].p[2]) {
                triangle.push(triangles[i].p[0]);
                triangle.push(triangles[i].p[1]);
                triangle.push(triangles[i].p[2]);
                tris.push(triangle);
            }
            else {
                console.error('error');
            }
        }
        return tris;
    }
}
_a$5 = MetaballsBufferGeometry;

class Metaballs extends Mesh {
    cubeWidth;
    #balls = [];
    constructor(params = {}) {
        params.geometry = new MetaballsBufferGeometry();
        params.material = params.material ?? new MeshBasicMaterial();
        super(params);
        /*this.setGeometry(new MetaballsBufferGeometry());
        this.setMaterial(material);*/
        this.cubeWidth = params.cubeWidth ?? 1;
    }
    addBall(ball = new Metaball()) {
        this.#balls.push(ball);
        this.addChild(ball);
        this.updateGeometry();
        return ball;
    }
    setBalls(balls) {
        this.#balls = balls;
    }
    updateGeometry() {
        this.geometry.updateGeometry(this.#balls, this.cubeWidth);
    }
    buildContextMenu() {
        return Object.assign(super.buildContextMenu(), {
            Metaballs_1: null,
            add_ball: { i18n: '#add_ball', f: () => { this.addBall(); } },
            cube_width: { i18n: '#cube_width', f: () => { const cubeWidth = prompt('Cube width', String(this.cubeWidth)); if (cubeWidth) {
                    this.cubeWidth = Number(cubeWidth);
                } } }
        });
    }
}

const a$5 = vec3.create();
const b$2 = vec3.create();
class TrianglesBufferGeometry extends BufferGeometry {
    constructor(triangles) {
        super();
        this.updateGeometry(triangles);
    }
    updateGeometry(triangles = []) {
        const indices = [];
        const vertices = [];
        const normals = [];
        let vertexIndex;
        const normal = vec3.create();
        for (let triangleIndex = 0; triangleIndex < triangles.length; ++triangleIndex) {
            vertexIndex = triangleIndex * 3;
            indices.push(vertexIndex, vertexIndex + 1, vertexIndex + 2);
            vertices.push(...triangles[triangleIndex][0]);
            vertices.push(...triangles[triangleIndex][1]);
            vertices.push(...triangles[triangleIndex][2]);
            vec3.sub(a$5, triangles[triangleIndex][1], triangles[triangleIndex][0]);
            vec3.sub(b$2, triangles[triangleIndex][2], triangles[triangleIndex][0]);
            vec3.cross(normal, a$5, b$2);
            vec3.normalize(normal, normal);
            normals.push(...normal);
            normals.push(...normal);
            normals.push(...normal);
        }
        // build geometry
        this.setIndex(new Uint16BufferAttribute(indices, 1));
        this.setAttribute('aVertexPosition', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('aVertexNormal', new Float32BufferAttribute(normals, 3));
        //this.setAttribute('aTextureCoord', new Float32BufferAttribute(uvs, 2));
        this.count = indices.length;
    }
}

class Triangles extends Mesh {
    #triangles;
    //constructor(triangles, material = ) {
    constructor(params = {}) {
        super(params);
        this.#triangles = params.triangles;
        this.setMaterial(params.material ?? new MeshBasicMaterial());
        this.setGeometry(new TrianglesBufferGeometry(params.triangles));
    }
    updateGeometry() {
        this.geometry.updateGeometry(this.#triangles);
    }
}

var RepositoryError;
(function (RepositoryError) {
    RepositoryError[RepositoryError["FileNotFound"] = 1] = "FileNotFound";
    RepositoryError[RepositoryError["UnknownError"] = 2] = "UnknownError";
    RepositoryError[RepositoryError["NotSupported"] = 3] = "NotSupported";
    RepositoryError[RepositoryError["RepoNotFound"] = 4] = "RepoNotFound";
    RepositoryError[RepositoryError["RepoInactive"] = 5] = "RepoInactive";
})(RepositoryError || (RepositoryError = {}));

class OverrideRepository {
    #base;
    #overrides = new Map();
    active = true;
    constructor(base) {
        this.#base = base;
    }
    get name() {
        return this.#base.name;
    }
    async getFile(filename) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        const file = this.#overrides.get(filename);
        if (file) {
            return { file: file };
        }
        return this.#base.getFile(filename);
    }
    async getFileAsArrayBuffer(filename) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        const file = this.#overrides.get(filename);
        if (file) {
            return { buffer: await file.arrayBuffer() };
        }
        return this.#base.getFileAsArrayBuffer(filename);
    }
    async getFileAsText(filename) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        const file = this.#overrides.get(filename);
        if (file) {
            return { text: await file.text() };
        }
        return this.#base.getFileAsText(filename);
    }
    async getFileAsBlob(filename) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        const file = this.#overrides.get(filename);
        if (file) {
            return { blob: file };
        }
        return this.#base.getFileAsBlob(filename);
    }
    async getFileAsJson(filename) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        const file = this.#overrides.get(filename);
        if (file) {
            return { json: JSON.parse(await file.text()) };
        }
        return this.#base.getFileAsJson(filename);
    }
    async getFileList() {
        //TODO: added overriden files ?
        return this.#base.getFileList();
    }
    async overrideFile(filename, file) {
        this.#overrides.set(filename, file);
        return null;
    }
}

class ManifestRepository {
    #base;
    active = true;
    constructor(base) {
        this.#base = new OverrideRepository(base);
    }
    get name() {
        return this.#base.name;
    }
    async getFile(filename) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        return this.#base.getFile(filename);
    }
    async getFileAsArrayBuffer(filename) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        return this.#base.getFileAsArrayBuffer(filename);
    }
    async getFileAsText(filename) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        return this.#base.getFileAsText(filename);
    }
    async getFileAsBlob(filename) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        return this.#base.getFileAsBlob(filename);
    }
    async getFileAsJson(filename) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        return this.#base.getFileAsJson(filename);
    }
    async getFileList() {
        return this.#base.getFileList();
    }
    async generateModelManifest(name = 'models_manifest.json') {
        const response = await this.#base.getFileList();
        if (response.error) {
            return response.error;
        }
        const json = response.root.toJSON();
        this.#base.overrideFile(name, new File([JSON.stringify(json)], name));
        return null;
    }
    async generateParticlesManifest(filename = 'particles/manifest.json') {
        const response = await this.#base.getFileList();
        if (response.error) {
            return response.error;
        }
        const files = response.root.getAllChilds({ extension: 'pcf', directories: false });
        const manifestFiles = [];
        for (const file of files) {
            const pcfLoader = getLoader('Source1PcfLoader');
            const pcf = await new pcfLoader().load(this.name, file.getFullName());
            const systems = [];
            for (const name in pcf.systems) {
                systems.push(name);
            }
            manifestFiles.push({
                name: file.getName(),
                particlesystemdefinitions: systems,
            });
        }
        this.#base.overrideFile(filename, new File([JSON.stringify({ files: manifestFiles })], filename));
        return null;
    }
}

/**
 * Cache the result of the underlying repository
 */
class MemoryCacheRepository {
    #base;
    #files = new Map();
    #fileList;
    active = true;
    constructor(base) {
        this.#base = base;
    }
    get name() {
        return this.#base.name;
    }
    async getFile(filename) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        let response = this.#files.get(filename);
        if (response) {
            return response;
        }
        response = this.#base.getFile(filename);
        this.#files.set(filename, response);
        return response;
    }
    async getFileAsArrayBuffer(filename) {
        const response = await this.getFile(filename);
        if (response.error) {
            return response;
        }
        return { buffer: await response.file.arrayBuffer() };
    }
    async getFileAsText(filename) {
        const response = await this.getFile(filename);
        if (response.error) {
            return response;
        }
        return { text: await response.file.text() };
    }
    async getFileAsBlob(filename) {
        const response = await this.getFile(filename);
        if (response.error) {
            return response;
        }
        return { blob: response.file };
    }
    async getFileAsJson(filename) {
        const response = await this.getFile(filename);
        if (response.error) {
            return response;
        }
        return { json: JSON.parse(await response.file.text()) };
    }
    async getFileList() {
        if (this.#fileList) {
            return this.#fileList;
        }
        this.#fileList = await this.#base.getFileList();
        return this.#fileList;
    }
}

class MemoryRepository {
    #name;
    #files = new Map();
    active = true;
    constructor(name) {
        this.#name = name;
    }
    get name() {
        return this.#name;
    }
    async getFile(filename) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        const file = this.#files.get(filename);
        if (file) {
            return { file: file };
        }
        return { error: RepositoryError.FileNotFound };
    }
    async getFileAsArrayBuffer(filename) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        const file = this.#files.get(filename);
        if (file) {
            return { buffer: await file.arrayBuffer() };
        }
        return { error: RepositoryError.FileNotFound };
    }
    async getFileAsText(filename) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        const file = this.#files.get(filename);
        if (file) {
            return { text: await file.text() };
        }
        return { error: RepositoryError.FileNotFound };
    }
    async getFileAsBlob(filename) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        const file = this.#files.get(filename);
        if (file) {
            return { blob: file };
        }
        return { error: RepositoryError.FileNotFound };
    }
    async getFileAsJson(filename) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        const file = this.#files.get(filename);
        if (file) {
            return { json: JSON.parse(await file.text()) };
        }
        return { error: RepositoryError.FileNotFound };
    }
    async getFileList() {
        return { error: RepositoryError.NotSupported };
    }
    async setFile(path, file) {
        this.#files.set(path, file);
        return null;
    }
}

var _a$4;
class RepositoryEntry {
    #repository;
    #name;
    #childs = new Map;
    #isDirectory;
    #parent = null;
    #depth;
    constructor(repository, name, isDirectory, depth) {
        this.#repository = repository;
        this.#name = name;
        this.#isDirectory = isDirectory;
        this.#depth = depth;
    }
    addPath(path) {
        const splittedPath = path.split(/[\/\\]+/);
        let current = this;
        const len = splittedPath.length - 1;
        for (const [i, p] of splittedPath.entries()) {
            const currentChild = current.#childs.get(p);
            if (!currentChild) {
                current = current.#addFile(p, i != len, i);
            }
            else {
                current = currentChild;
            }
        }
    }
    removeEntry(name) {
        this.#childs.delete(name);
    }
    #addFile(name, isDirectory, depth) {
        const e = new _a$4(this.#repository, name, isDirectory, depth);
        e.#parent = this;
        this.#childs.set(name, e);
        return e;
    }
    setName(name) {
        this.#name = name;
    }
    getName() {
        return this.#name;
    }
    getFullName() {
        let name = '';
        if (this.#parent) {
            name = this.#parent.getFullName();
        }
        name += this.#name;
        if (this.#isDirectory && this.#parent) {
            name += '/';
        }
        return name;
    }
    setParent(parent) {
        this.#parent = parent;
    }
    getParent() {
        return this.#parent;
    }
    setRepository(repository) {
        this.#repository = repository;
    }
    getRepository() {
        return this.#repository;
    }
    getChild(name) {
        return this.#childs.get(name);
    }
    *getChilds(filter) {
        for (const [_, child] of this.#childs) {
            if (!filter || child.#matchFilter(filter)) {
                yield child;
            }
        }
        return null;
    }
    getAllChilds(filter) {
        const childs = new Set();
        let current;
        const stack = new Queue([this]);
        do {
            current = stack.dequeue();
            if (current && !childs.has(current)) {
                if ((filter === undefined) || current.#matchFilter(filter)) {
                    childs.add(current);
                }
                for (const [_, child] of current.#childs) {
                    stack.enqueue(child);
                }
            }
        } while (current);
        return childs;
    }
    getAllChildsSorted(filter) {
        const childs = new Set();
        this.#getAllChildsSorted(childs, filter);
        return childs;
    }
    #getAllChildsSorted(childs, filter) {
        if ((filter === undefined) || this.#matchFilter(filter)) {
            childs.add(this);
        }
        const sortedChilds = new Map([...this.#childs].sort());
        for (const [_, child] of sortedChilds) {
            child.#getAllChildsSorted(childs, filter);
        }
    }
    #matchFilter(filter) {
        if (filter.directories !== undefined && filter.directories != this.#isDirectory) {
            return false;
        }
        if (filter.files !== undefined && filter.files == this.#isDirectory) {
            return false;
        }
        if (filter.maxDepth !== undefined && this.#depth > filter.maxDepth) {
            return false;
        }
        const { name, extension } = splitFilename(this.#name);
        if (filter.extension && !this.#isDirectory && !match(extension, filter.extension)) {
            return false;
        }
        if (filter.name && !match(name, filter.name)) {
            return false;
        }
        return true;
    }
    getPath(path) {
        let splittedPath = path.split('/');
        for (const [_, child] of this.#childs) {
            const found = child.#getPath(splittedPath);
            if (found) {
                return found;
            }
        }
        return null;
    }
    #getPath(path) {
        if (this.#name != path.at(0)) {
            return null;
        }
        if (path.length == 1 && this.#name == path.at(0)) {
            return this;
        }
        const subPath = path.slice(1);
        for (const [_, child] of this.#childs) {
            const found = child.#getPath(subPath);
            if (found) {
                return found;
            }
        }
        return null;
    }
    isDirectory() {
        return this.#isDirectory;
    }
    toJSON() {
        const json /*TODO:improve type*/ = { name: this.#name };
        if (this.#isDirectory) {
            const files = [];
            for (const [_, child] of this.#childs) {
                files.push(child.toJSON());
            }
            json.files = files;
        }
        return json;
    }
    merge(other) {
        if (this.#isDirectory != other.#isDirectory || this.#name != other.#name) {
            return;
        }
        for (const [name, entry] of other.#childs) {
            if (this.#childs.has(name)) {
                this.#childs.get(name)?.merge(entry);
            }
            else {
                this.#childs.set(name, entry);
            }
        }
    }
}
_a$4 = RepositoryEntry;
function splitFilename(filename) {
    const pos = filename.lastIndexOf('.');
    if (pos < 1) {
        // No dot found or dot in first position
        return { name: filename, extension: '' };
    }
    return { name: filename.substring(0, pos), extension: filename.substring(pos + 1) };
}
function match(name, filter) {
    if (typeof filter == 'string') {
        return filter == name;
    }
    else {
        //regex
        return filter.exec(name) != null;
    }
}

class MergeRepository {
    #name;
    #repositories = [];
    active = true;
    constructor(name, ...repositories) {
        this.#name = name;
        for (const repo of repositories) {
            if (repo) {
                this.#repositories.push(repo);
            }
        }
    }
    get name() {
        return this.#name;
    }
    async getFile(filename) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        for (const repository of this.#repositories) {
            const response = await repository.getFile(filename);
            if (!response.error) {
                return response;
            }
        }
        return { error: RepositoryError.FileNotFound };
    }
    async getFileAsArrayBuffer(filename) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        for (const repository of this.#repositories) {
            const response = await repository.getFileAsArrayBuffer(filename);
            if (!response.error) {
                return response;
            }
        }
        return { error: RepositoryError.FileNotFound };
    }
    async getFileAsText(filename) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        for (const repository of this.#repositories) {
            const response = await repository.getFileAsText(filename);
            if (!response.error) {
                return response;
            }
        }
        return { error: RepositoryError.FileNotFound };
    }
    async getFileAsBlob(filename) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        for (const repository of this.#repositories) {
            const response = await repository.getFileAsBlob(filename);
            if (!response.error) {
                return response;
            }
        }
        return { error: RepositoryError.FileNotFound };
    }
    async getFileAsJson(filename) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        for (const repository of this.#repositories) {
            const response = await repository.getFileAsJson(filename);
            if (!response.error) {
                return response;
            }
        }
        return { error: RepositoryError.FileNotFound };
    }
    async getFileList() {
        const root = new RepositoryEntry(this, '', true, 0);
        for (const repository of this.#repositories) {
            const response = await repository.getFileList();
            if (!response.error) {
                root.merge(response.root);
            }
        }
        return { root: root };
    }
    pushRepository(repo) {
        this.#repositories.push(repo);
    }
    unshiftRepository(repo) {
        this.#repositories.unshift(repo);
    }
    getSubRepositories() {
        return new Set(this.#repositories);
    }
}

class PathPrefixRepository {
    #name;
    #base;
    prefix;
    active = true;
    constructor(name, base, prefix = '') {
        this.#name = name;
        this.#base = base;
        this.prefix = prefix;
    }
    get name() {
        return this.#name;
    }
    async getFile(path) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        return this.#base.getFile(this.prefix + '/' + path);
    }
    async getFileAsArrayBuffer(path) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        return this.#base.getFileAsArrayBuffer(this.prefix + '/' + path);
    }
    async getFileAsText(path) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        return this.#base.getFileAsText(this.prefix + '/' + path);
    }
    async getFileAsBlob(path) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        return this.#base.getFileAsBlob(this.prefix + '/' + path);
    }
    async getFileAsJson(path) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        return this.#base.getFileAsJson(this.prefix + '/' + path);
    }
    async getFileList() {
        const baseResponse = await this.#base.getFileList();
        if (baseResponse.error) {
            return baseResponse;
        }
        let root = baseResponse.root;
        root = root.getPath(this.prefix);
        if (!root) {
            return { error: RepositoryError.FileNotFound };
        }
        root.setName('');
        root.setParent(null);
        for (const entry of root.getAllChilds()) {
            entry.setRepository(this);
        }
        return { root: root };
    }
}

class Repositories {
    static #repositories = {};
    static addRepository(repo) {
        this.#repositories[repo.name] = repo;
        return repo;
    }
    static getRepository(name) {
        return this.#repositories[name];
    }
    static getRepositoryList() {
        return Object.keys(this.#repositories);
    }
    static async getFile(repositoryName, filepath) {
        const repo = this.#repositories[repositoryName];
        if (!repo) {
            return { error: RepositoryError.RepoNotFound };
        }
        return repo?.getFile(filepath);
    }
    static async getFileAsArrayBuffer(repositoryName, filepath) {
        const repo = this.#repositories[repositoryName];
        if (!repo) {
            return { error: RepositoryError.RepoNotFound };
        }
        return repo?.getFileAsArrayBuffer(filepath);
    }
    static async getFileAsText(repositoryName, filepath) {
        const repo = this.#repositories[repositoryName];
        if (!repo) {
            return { error: RepositoryError.RepoNotFound };
        }
        return repo?.getFileAsText(filepath);
    }
    static async getFileAsBlob(repositoryName, filepath) {
        const repo = this.#repositories[repositoryName];
        if (!repo) {
            return { error: RepositoryError.RepoNotFound };
        }
        return repo?.getFileAsBlob(filepath);
    }
    static async getFileAsJson(repositoryName, filepath) {
        const repo = this.#repositories[repositoryName];
        if (!repo) {
            return { error: RepositoryError.RepoNotFound };
        }
        return repo?.getFileAsJson(filepath);
    }
}

class VpkRepository {
    #name;
    #vpk = new Vpk();
    #initPromiseResolve;
    #initPromise = new Promise(resolve => this.#initPromiseResolve = resolve);
    active = true;
    constructor(name, files) {
        this.#name = name;
        (async () => {
            const error = await this.#vpk.setFiles(files);
            if (error) {
                this.#initPromiseResolve?.(false);
            }
            else {
                this.#initPromiseResolve?.(true);
            }
        })();
    }
    get name() {
        return this.#name;
    }
    async getFile(filename) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        await this.#initPromise;
        const response = await this.#vpk.getFile(cleanupFilename$1(filename));
        if (response.error) {
            return { error: RepositoryError.FileNotFound };
        }
        return { file: response.file };
    }
    async getFileAsArrayBuffer(filename) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        await this.#initPromise;
        const response = await this.#vpk.getFile(cleanupFilename$1(filename));
        if (response.error) {
            return { error: RepositoryError.FileNotFound };
        }
        return { buffer: await response.file.arrayBuffer() };
    }
    async getFileAsText(filename) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        await this.#initPromise;
        const response = await this.#vpk.getFile(cleanupFilename$1(filename));
        if (response.error) {
            return { error: RepositoryError.FileNotFound };
        }
        return { text: await response.file.text() };
    }
    async getFileAsBlob(filename) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        await this.#initPromise;
        const response = await this.#vpk.getFile(cleanupFilename$1(filename));
        if (response.error) {
            return { error: RepositoryError.FileNotFound };
        }
        return { blob: response.file };
    }
    async getFileAsJson(filename) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        await this.#initPromise;
        const response = await this.#vpk.getFile(cleanupFilename$1(filename));
        if (response.error) {
            return { error: RepositoryError.FileNotFound };
        }
        return { json: JSON.parse(await response.file.text()) };
    }
    async getFileList() {
        await this.#initPromise;
        const root = new RepositoryEntry(this, '', true, 0);
        for (const filename of await this.#vpk.getFileList()) {
            root.addPath(filename);
        }
        return { root: root };
    }
}
function cleanupFilename$1(filename) {
    filename = filename.toLowerCase().replaceAll('\\', '/');
    const arr = filename.split('/');
    return arr.filter((path) => path != '').join('/');
}

class WebRepository {
    #name;
    #base;
    active = true;
    constructor(name, base) {
        this.#name = name;
        this.#base = base;
    }
    get name() {
        return this.#name;
    }
    get base() {
        return this.#base;
    }
    async getFile(fileName) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        const url = new URL(fileName, this.#base);
        const response = await customFetch(url);
        if (response.ok) {
            return { file: new File([new Uint8Array(await response.arrayBuffer())], fileName) };
        }
        else {
            let error = RepositoryError.UnknownError;
            if (response.status == 404) {
                error = RepositoryError.FileNotFound;
            }
            return { error: error };
        }
    }
    async getFileAsArrayBuffer(fileName) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        const url = new URL(fileName, this.#base);
        const response = await customFetch(url);
        if (response.ok) {
            return { buffer: await response.arrayBuffer() };
        }
        else {
            let error = RepositoryError.UnknownError;
            if (response.status == 404) {
                error = RepositoryError.FileNotFound;
            }
            return { error: error };
        }
    }
    async getFileAsText(fileName) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        const url = new URL(fileName, this.#base);
        const response = await customFetch(url);
        if (response.ok) {
            return { text: await response.text() };
        }
        else {
            let error = RepositoryError.UnknownError;
            if (response.status == 404) {
                error = RepositoryError.FileNotFound;
            }
            return { error: error };
        }
    }
    async getFileAsBlob(fileName) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        const url = new URL(fileName, this.#base);
        const response = await customFetch(url);
        if (response.ok) {
            return { blob: new Blob([new Uint8Array(await response.arrayBuffer())]) };
        }
        else {
            let error = RepositoryError.UnknownError;
            if (response.status == 404) {
                error = RepositoryError.FileNotFound;
            }
            return { error: error };
        }
    }
    async getFileAsJson(fileName) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        const url = new URL(fileName, this.#base);
        const response = await customFetch(url);
        if (response.ok) {
            return { json: await response.json() };
        }
        else {
            let error = RepositoryError.UnknownError;
            if (response.status == 404) {
                error = RepositoryError.FileNotFound;
            }
            return { error: error };
        }
    }
    async getFileList() {
        return { error: RepositoryError.NotSupported };
    }
}

class ZipRepository {
    #name;
    #zip;
    #reader;
    #zipEntries = new Map();
    #initPromiseResolve;
    #initPromise = new Promise(resolve => this.#initPromiseResolve = resolve);
    active = true;
    constructor(name, zip) {
        this.#name = name;
        this.#zip = zip;
        this.#reader = new ZipReader(new BlobReader(zip));
        this.#initEntries();
    }
    async #initEntries() {
        const entries = await this.#reader.getEntries();
        for (const entry of entries) {
            if (!entry.getData || entry.directory) {
                continue;
            }
            const blob = await entry.getData(new BlobWriter());
            const filename = cleanupFilename(entry.filename);
            this.#zipEntries.set(filename, new File([blob], filename));
        }
        this.#initPromiseResolve?.(true);
    }
    get name() {
        return this.#name;
    }
    async getFile(filename) {
        if (!this.active) {
            return { error: RepositoryError.RepoInactive };
        }
        await this.#initPromise;
        const file = this.#zipEntries.get(cleanupFilename(filename));
        if (!file) {
            return { error: RepositoryError.FileNotFound };
        }
        return { file: file };
    }
    async getFileAsArrayBuffer(filename) {
        const response = await this.getFile(filename);
        if (response.error) {
            return { error: response.error };
        }
        return { buffer: await response.file.arrayBuffer() };
    }
    async getFileAsText(filename) {
        const response = await this.getFile(filename);
        if (response.error) {
            return { error: response.error };
        }
        return { text: await response.file.text() };
    }
    async getFileAsBlob(filename) {
        const response = await this.getFile(filename);
        if (response.error) {
            return { error: response.error };
        }
        return { blob: await response.file };
    }
    async getFileAsJson(filename) {
        const response = await this.getFile(filename);
        if (response.error) {
            return { error: response.error };
        }
        return { json: JSON.parse(await response.file.text()) };
    }
    async getFileList() {
        await this.#initPromise;
        const root = new RepositoryEntry(this, '', true, 0);
        for (const [filename, _] of this.#zipEntries) {
            root.addPath(filename);
        }
        return { root: root };
    }
}
function cleanupFilename(filename) {
    filename = filename.toLowerCase().replaceAll('\\', '/');
    const arr = filename.split('/');
    return arr.filter((path) => path != '').join('/');
}

class Environment {
    constructor() {
    }
}

class CubeEnvironment extends Environment {
    texture;
    constructor() {
        super();
    }
}

var sceneExplorerCSS = ":host {\n\tbackground-color: var(--theme-scene-explorer-bg-color);\n\twidth: 100%;\n\theight: 100%;\n\toverflow: auto;\n\t/*padding: 5px;*/\n\t/*box-sizing: border-box;*/\n\tdisplay: flex;\n\tflex-direction: column;\n\tfont-size: 1.5em;\n\tuser-select: none;\n}\n\n.scene-explorer-contextmenu {\n\tposition: absolute;\n\theight: 50px;\n\twidth: 50px;\n\tbackground-color: turquoise;\n}\n\n.scene-explorer-scene {\n\tflex: 1;\n\toverflow: auto;\n}\n\n.scene-explorer-file-selector {\n\tflex: 1;\n\toverflow: auto;\n\tdisplay: flex;\n}\n\n.scene-explorer-properties {\n\tbackground-color: orange;\n\tdisplay: flex;\n\tflex-wrap: wrap;\n\n}\n\n.scene-explorer-properties>div,\n.scene-explorer-properties>label {\n\twidth: 50%;\n}\n\n.scene-explorer-properties>.scene-explorer-entity-title {\n\twidth: 100%;\n}\n\n.scene-explorer-selector {\n\tposition: absolute;\n\twidth: 100%;\n\theight: 100%;\n\tbackground-color: bisque;\n\tmargin: 10px;\n}\n\n\nscene-explorer-entity {\n\tflex-direction: column;\n}\n\n.scene-explorer-entity-header {\n\tcursor: pointer;\n\tdisplay: flex;\n}\n\nscene-explorer-entity>.scene-explorer-entity-header {\n\tbackground-color: teal;\n}\n\nscene-explorer-entity.selected>.scene-explorer-entity-header {\n\tbackground-color: var(--theme-scene-explorer-entity-selected-bg-color);\n}\n\nscene-explorer-entity .animation input {\n\twidth: 100%;\n}\n\n.scene-explorer-entity-buttons {\n\tdisplay: flex;\n}\n\n.scene-explorer-entity-buttons>div {\n\twidth: 20px;\n\theight: 20px;\n\tcursor: pointer;\n}\n\n.scene-explorer-entity-button-properties {\n\tbackground-color: blue;\n}\n\n.scene-explorer-entity-button-childs {\n\tbackground-color: green;\n}\n\n.scene-explorer-entity-visible {\n\tcursor: pointer;\n}\n\n.scene-explorer-entity-childs {\n\tbackground-color: teal;\n\t/*padding: 5px;*/\n\tpadding-left: 20px;\n}\n\n.file-explorer-file {\n\tcursor: pointer;\n}\n\n.file-explorer-file-header:hover {\n\tfont-weight: bold;\n}\n\n.file-explorer-childs {\n\tpadding-left: 20px;\n}\n\nfile-selector {\n\tdisplay: flex;\n\tflex-direction: column;\n\toverflow: auto;\n\twidth: 100%;\n}\n\n.file-selector-header {\n\tflex: 0;\n}\n\n.file-selector-content {\n\tflex: 1;\n\toverflow: auto;\n}\n\nfile-selector-directory {\n\tdisplay: block;\n\tcursor: pointer;\n}\n\nfile-selector-file {\n\tdisplay: block;\n\tcursor: pointer;\n}\n\nfile-selector-tile {\n\tdisplay: block;\n\toverflow: hidden;\n\twidth: 100%;\n\tcursor: pointer;\n}\n\n.file-selector-directory-header:hover,\nfile-selector-file:hover,\nfile-selector-tile:hover {\n\tbackground-color: var(--theme-file-selector-item-hover-bg-color);\n}\n\n.file-selector-directory-content {\n\tpadding-left: 20px;\n}\n\n.manipulator {\n\tdisplay: inline-flex;\n}\n\n.manipulator-button {\n\tbackground-color: var(--theme-scene-explorer-bg-color);\n\tcursor: pointer;\n}\n";

function getUniformsHtml(uniforms /*TODO: create a proper type for uniforms*/) {
    const htmlUniforms = createElement('div');
    for (const uniformName in uniforms) {
        const uniform = uniforms[uniformName];
        htmlUniforms.append(addHtmlParameter(uniformName, uniform));
    }
    return htmlUniforms;
}
function addHtmlParameter(name, value) {
    const htmlParameter = createElement('div');
    const htmlParameterName = createElement('span');
    htmlParameterName.innerText = name;
    const htmlParameterValue = createElement('span');
    htmlParameterValue.innerText = value;
    htmlParameter.append(htmlParameterName, htmlParameterValue);
    return htmlParameter;
}
let materialEditor = null;
function getMaterialEditor() {
    if (!materialEditor) {
        materialEditor = new MaterialEditor();
    }
    return materialEditor;
}
class MaterialEditor {
    static #instance;
    #shadowRoot;
    #htmlHeader;
    #htmlShader;
    #htmlBlending;
    #htmlHasBlending;
    #htmlBlendFactors = new Array(4);
    #htmlBlendSelects = new Array(6);
    #htmlParams;
    #material;
    constructor() {
        if (MaterialEditor.#instance) {
            return MaterialEditor.#instance;
        }
        MaterialEditor.#instance = this;
        this.#shadowRoot = createShadowRoot('div', {
            childs: [
                this.#htmlHeader = createElement('div', {
                    childs: [
                        this.#htmlShader = createElement('div', {}),
                        this.#htmlBlending = createElement('div', {
                            childs: [
                                createElement('label', {
                                    childs: [
                                        createElement('span', {
                                            i18n: '#enable_blending',
                                        }),
                                        this.#htmlHasBlending = createElement('input', {
                                            type: 'checkbox',
                                            events: {
                                                change: (event) => this.#setBlending(event.target.checked),
                                            }
                                        }),
                                    ]
                                }),
                            ]
                        }),
                        this.#htmlParams = createElement('div', {}),
                    ]
                }),
            ],
        });
        const i18n = ['#source_color', '#source_alpha', '#destination_color', '#destination_alpha', '#mode_color', '#mode_alpha'];
        for (let i = 0; i < 6; i++) {
            this.#htmlBlendFactors[i] = createElement('div', {
                hidden: true,
                parent: this.#htmlBlending,
                childs: [
                    createElement('span', {
                        i18n: i18n[i],
                    }),
                    this.#htmlBlendSelects[i] = createElement('select', {
                        list: 'factors',
                        events: {
                            change: (event) => this.#changeBlendingFactor(i, event.target.value),
                        },
                    }),
                ],
            });
            if (i < 4) {
                for (const suite in BlendingFactor) {
                    const value = BlendingFactor[suite];
                    if (typeof value === 'string') {
                        createElement('option', {
                            parent: this.#htmlBlendSelects[i],
                            innerText: value,
                            value: value,
                        });
                    }
                }
            }
            else {
                for (const suite in BlendingEquation) {
                    const value = BlendingEquation[suite];
                    if (typeof value === 'string') {
                        createElement('option', {
                            parent: this.#htmlBlendSelects[i],
                            innerText: value,
                            value: value,
                        });
                    }
                }
            }
        }
    }
    editEntity(entity) {
        //this.#entity = entity;
        this.#material = entity.material;
        this.#refreshHtml();
    }
    editMaterial(material) {
        //this.#entity = null;
        this.#material = material;
        this.#refreshHtml();
    }
    #refreshHtml() {
        this.#htmlParams.innerText = '';
        this.#htmlShader.innerText = '';
        const material = this.#material;
        if (!material) {
            return;
        }
        const fileName = material.name;
        if (fileName) {
            this.#htmlParams.append(addHtmlParameter('filename', fileName));
        }
        this.#htmlShader.append(addHtmlParameter('shader', material.getShaderSource()));
        this.#htmlBlendSelects[0].value = BlendingFactor[material.srcRGB];
        this.#htmlBlendSelects[1].value = BlendingFactor[material.srcAlpha];
        this.#htmlBlendSelects[2].value = BlendingFactor[material.dstRGB];
        this.#htmlBlendSelects[3].value = BlendingFactor[material.dstAlpha];
        this.#htmlHasBlending.checked = material.blend;
        if (material.blend) {
            show(this.#htmlBlendFactors);
        }
        else {
            hide(this.#htmlBlendFactors);
        }
        //this.#htmlElement.innerHTML += this.material.name;
        this.#htmlParams.append(getUniformsHtml(material.uniforms));
    }
    getHTML() {
        return this.#shadowRoot.host;
    }
    #setBlending(blending) {
        if (!this.#material) {
            return;
        }
        this.#material.blend = blending;
        this.#refreshHtml();
    }
    #changeBlendingFactor(i, blending) {
        if (!this.#material) {
            return;
        }
        let value;
        if (i < 4) {
            value = BlendingFactor[blending];
        }
        else {
            value = BlendingEquation[blending];
        }
        switch (i) {
            case 0: // src color
                this.#material.srcRGB = value;
                break;
            case 1: // src alpha
                this.#material.srcAlpha = value;
                break;
            case 2: // dst color
                this.#material.dstRGB = value;
                break;
            case 3: // dst alpha
                this.#material.dstAlpha = value;
                break;
            case 4: // color mode
                this.#material.modeRGB = value;
                break;
            case 5: // alpha mode
                this.#material.modeAlpha = value;
                break;
        }
    }
}

class WireframeHelper extends Entity {
    #meshToWireframe = new Map();
    #wireframeToMesh = new Map();
    parentChanged(parent) {
        const meshes = parent.getChildList('Mesh');
        for (const mesh of meshes) {
            if (mesh.renderMode !== GL_LINES) { //TODO: improve wireframe detection
                const wireframeGeometry = mesh.getGeometry().clone();
                const wireframeMesh = new Mesh({ geometry: wireframeGeometry, material: mesh.getMaterial() });
                wireframeMesh.renderMode = GL_LINES;
                this.#meshToWireframe.set(mesh, wireframeMesh);
                this.#wireframeToMesh.set(wireframeMesh, mesh);
                WireframeHelper.#updateWireframeIndex(wireframeGeometry);
                mesh.addChild(wireframeMesh);
            }
        }
    }
    setVisible(visible) {
        super.setVisible(visible);
        for (const [w, m] of this.#wireframeToMesh) {
            w.setVisible(visible);
        }
    }
    static #updateWireframeIndex(geometry) {
        const attribute = geometry.attributes.get('index');
        if (attribute) {
            const indexArray = attribute._array;
            let wireframeArray;
            const arraySize = indexArray.length * 2;
            const wireframeAttribute = (geometry.elementArrayType == GL_UNSIGNED_INT) ? new Uint32BufferAttribute(new Array(arraySize), 1) : new Uint16BufferAttribute(new Array(arraySize), 1);
            wireframeAttribute.target = GL_ELEMENT_ARRAY_BUFFER;
            geometry.setAttribute('index', wireframeAttribute);
            geometry.count = arraySize;
            wireframeArray = wireframeAttribute._array;
            for (let i = 0, j = 0, l = indexArray.length; i < l; i += 3, j += 6) {
                const i1 = indexArray[i];
                const i2 = indexArray[i + 1];
                const i3 = indexArray[i + 2];
                wireframeArray[j + 0] = i1;
                wireframeArray[j + 1] = i2;
                wireframeArray[j + 2] = i2;
                wireframeArray[j + 3] = i3;
                wireframeArray[j + 4] = i3;
                wireframeArray[j + 5] = i1;
            }
            wireframeAttribute.dirty = true;
        }
    }
    static getEntityName() {
        return 'Wireframe helper';
    }
}

class Source1ModelManager {
    static #modelListPerRepository = new Map();
    static #modelsPerRepository = new Map2();
    static async #createModel(repositoryName, fileName) {
        let promise = this.#modelsPerRepository.get(repositoryName, fileName);
        if (promise) {
            return promise;
        }
        let loadedResolve;
        promise = new Promise(resolve => loadedResolve = resolve);
        this.#modelsPerRepository.set(repositoryName, fileName, promise);
        const modelLoader = getLoader('ModelLoader');
        let model = await new modelLoader().load(repositoryName, fileName);
        loadedResolve /*assigned during promise creation*/(model);
        return model;
    }
    static async createInstance(repository, fileName, dynamic, preventInit = false) {
        if (!repository) {
            //try to get repository from filename
            for (const [repo] of this.#modelListPerRepository) {
                if (fileName.startsWith(repo)) {
                    repository = repo;
                    fileName = fileName.replace(repo, '');
                    break;
                }
            }
        }
        const model = await this.#createModel(repository, fileName);
        if (model) {
            const instance = model.createInstance(dynamic, preventInit);
            return instance;
        }
        return null;
    }
    static loadManifest(repositoryName) {
        if (!this.#modelListPerRepository.has(repositoryName)) {
            this.#modelListPerRepository.set(repositoryName, null);
        }
    }
    static async getModelList() {
        const repoList = [];
        for (const [repositoryName, repo] of this.#modelListPerRepository) {
            if (repo === null) {
                const response = await Repositories.getFileAsJson(repositoryName, 'models_manifest.json');
                if (!response.error) {
                    this.#modelListPerRepository.set(repositoryName, response.json);
                    repoList.push({ name: repositoryName, files: [response.json] });
                }
            }
            else {
                repoList.push({ name: repositoryName, files: [repo] });
            }
        }
        return { name: '', path: '', files: repoList };
    }
}

class Source1ParticleControler {
    static #loadManifestPromises = {};
    static speed = 1.0;
    static visible = true;
    static #systemList = {}; //TODOv3: make map
    static #activeSystemList = new Map();
    static #pcfList = {};
    static #systemNameToPcf = {};
    static #sourceEngineParticleSystem;
    static fixedTime;
    static {
        GraphicsEvents.addEventListener(GraphicsEvent.Tick, (event) => {
            this.stepSystems(this.fixedTime ? (this.fixedTime * event.detail.speed) : event.detail.delta); //TODOv3: imporve this
        });
    }
    static setParticleConstructor(ps) {
        this.#sourceEngineParticleSystem = ps;
    }
    /**
     * Reset all active systems
     */
    static resetAll() {
        for (const system of this.#activeSystemList.values()) {
            system.reset();
        }
    }
    /**
     * Step systems
     * @param {Number} elapsedTime Step time
     */
    static stepSystems(elapsedTime) {
        if (elapsedTime) {
            elapsedTime *= this.speed;
            elapsedTime = Math.min(elapsedTime, 0.1);
            for (const system of this.#activeSystemList.values()) {
                if (system.parentSystem === undefined) {
                    system.step(elapsedTime);
                }
            }
        }
    }
    /**
     * Add system TODO
     * @param {Number} elapsedTime Step time
     */
    static addSystem2(system) {
        this.#systemList[system.id] = system;
    }
    /**
     * Create system
     * @param {Number} elapsedTime Step time
     */
    static async createSystem(repository, systemName) {
        if (!repository) {
            //try to get repository from filename
            for (const repo in this.#systemNameToPcf) {
                if (systemName.startsWith(repo)) {
                    repository = repo;
                    systemName = systemName.replace(repo, '');
                    break;
                }
            }
            const index = systemName.lastIndexOf('.pcf/');
            if (index != -1) {
                systemName = systemName.substring(index + 5);
            }
        }
        const ps = new this.#sourceEngineParticleSystem({ repository: repository, name: systemName }); //TODOV2
        this.#systemList[ps.id] = ps;
        await this.#createSystem(repository, ps);
        return ps;
    }
    /**
     * Create system
     * @param {Number} elapsedTime Step time
     */
    static async #createSystem(repositoryName, system) {
        const pcfName = await this.#getPcfBySystemName(repositoryName, system.name);
        if (pcfName) {
            const pcf = await this.#getPcf(repositoryName, 'particles/' + pcfName);
            if (pcf) {
                pcf.initSystem(system);
            }
        }
    }
    static async #getPcfBySystemName(repository, systemName) {
        await this.#loadManifest(repository);
        const systemNameToPcfRepo = this.#systemNameToPcf[repository];
        if (systemNameToPcfRepo) {
            return systemNameToPcfRepo[systemName];
        }
        return null;
    }
    static async loadManifest(repository) {
        if (this.#systemNameToPcf[repository] === undefined) {
            this.#systemNameToPcf[repository] = null;
        }
    }
    /**
     * TODO
     */
    static async #loadManifest(repositoryName) {
        this.#loadManifestPromises[repositoryName] = this.#loadManifestPromises[repositoryName] ?? new Promise(async (resolve) => {
            const systemNameToPcfRepo = {};
            this.#systemNameToPcf[repositoryName] = systemNameToPcfRepo;
            const response = await Repositories.getFileAsJson(repositoryName, 'particles/manifest.json'); //TODO const
            if (response.error) {
                resolve(false);
            }
            const json /*TODO: change type*/ = response.json;
            if (json && json.files) {
                for (const file of json.files) {
                    const pcfName = file.name;
                    for (const definition of file.particlesystemdefinitions) {
                        systemNameToPcfRepo[definition] = pcfName;
                    }
                }
                resolve(true);
            }
            else {
                resolve(false);
            }
        });
        return this.#loadManifestPromises[repositoryName];
    }
    /**
     * Start all systems
     */
    static startAll() {
        for (const system of this.#activeSystemList.values()) {
            system.start();
        }
    }
    /**
     * Stop all systems
     */
    static stopAll() {
        for (const system of this.#activeSystemList.values()) {
            system.stop();
        }
    }
    /**
     * Set a system active
     */
    static setActive(system) {
        if (!system) {
            return;
        }
        this.#activeSystemList.set(system.id, system);
    }
    /**
     * Set a system inactive
     */
    static setInactive(system) {
        if (!system) {
            return;
        }
        this.#activeSystemList.delete(system.id);
    }
    /**
     * Get a pcf from cache or load it
     * @param {String} name Name of the pcf
     * @return {Object SourcePCF} Pcf
     */
    static async #getPcf(repository, pcfName) {
        const promise = new Promise(resolve => {
            const pcf = this.#pcfList[pcfName];
            if (!pcf) {
                const callback1 = (pcf) => {
                    if (pcf) {
                        this.#pcfList[pcfName] = pcf;
                        pcf.repository = repository;
                    }
                    resolve(pcf);
                };
                this.#loadPcf(repository, pcfName).then(callback1);
            }
            else {
                resolve(pcf);
            }
        });
        return promise;
    }
    /**
     * Load a pcf
     * @param {String} name Name of the pcf
     * @return {Object SourcePCF} Pcf or null
     */
    static async #loadPcf(repositoryName, pcfName) {
        //TODO: return an empty system if not found?
        const promise = new Promise(resolve => {
            const pcfLoader = getLoader('Source1PcfLoader');
            new pcfLoader().load(repositoryName, pcfName).then((pcf) => resolve(pcf));
        });
        return promise;
    }
    static setSpeed(s) {
        this.speed = s;
    }
    static async getSystemList() {
        const repoList = [];
        for (const repoName in this.#systemNameToPcf) {
            const pcfs = {};
            await this.#loadManifest(repoName);
            const repo = this.#systemNameToPcf[repoName];
            for (const systemName in repo) {
                const pcfName = repo[systemName];
                if (!pcfs[pcfName]) {
                    pcfs[pcfName] = [];
                }
                pcfs[pcfName].push({ name: systemName });
            }
            const pcfList = [];
            for (const pcfName in pcfs) {
                pcfList.push({ name: pcfName, files: pcfs[pcfName] });
            }
            repoList.push({ name: repoName, files: pcfList });
        }
        return { name: '', path: '', files: repoList };
    }
    static set renderSystems(renderSystems) {
        this.visible = renderSystems ? undefined : false;
    }
}

class SourceBinaryLoader {
    repository = '';
    async load(repositoryName, fileName) {
        this.repository = repositoryName;
        const promise = new Promise(resolve => {
            const p = Repositories.getFileAsArrayBuffer(repositoryName, fileName);
            p.then((response) => {
                if (!response.error) {
                    resolve(this.parse(repositoryName, fileName, response.buffer));
                }
                else {
                    resolve(null);
                }
            });
        });
        return promise;
    }
    parse(repository, fileName, arrayBuffer) {
        throw 'override me';
    }
}

var TextureCompressionMethod;
(function (TextureCompressionMethod) {
    TextureCompressionMethod[TextureCompressionMethod["Uncompressed"] = 0] = "Uncompressed";
    TextureCompressionMethod[TextureCompressionMethod["St3c"] = 1] = "St3c";
    TextureCompressionMethod[TextureCompressionMethod["Bptc"] = 2] = "Bptc";
    TextureCompressionMethod[TextureCompressionMethod["Rgtc"] = 3] = "Rgtc";
})(TextureCompressionMethod || (TextureCompressionMethod = {}));
// TODO (long term): revert to numbers
var ImageFormat;
(function (ImageFormat) {
    ImageFormat["Unknown"] = "Unknown";
    /*
    Dxt1 = 'Dxt1',
    Dxt2 = 'Dxt2',
    Dxt3 = 'Dxt3',
    Dxt4 = 'Dxt4',
    Dxt5 = 'Dxt5',
    */
    // S3TC formats
    ImageFormat["Bc1"] = "Bc1";
    ImageFormat["Bc2"] = "Bc2";
    ImageFormat["Bc3"] = "Bc3";
    // RGTC formats
    ImageFormat["Bc4"] = "Bc4";
    ImageFormat["Bc4Signed"] = "Bc4Signed";
    ImageFormat["Bc5"] = "Bc5";
    ImageFormat["Bc5Signed"] = "Bc5Signed";
    // BPTC formats
    ImageFormat["Bc6"] = "Bc6";
    ImageFormat["Bc7"] = "Bc7";
    /*
    Rgtc1 = 'Rgtc1',
    Rgtc1Signed = 'Rgtc1Signed',
    Rgtc2 = 'Rgtc2',
    Rgtc2Signed = 'Rgtc2Signed',
    */
    ImageFormat["R8"] = "R8";
    ImageFormat["R8G8B8A8Uint"] = "R8G8B8A8Uint";
    ImageFormat["BGRA8888"] = "BGRA8888";
    ImageFormat["RGBA"] = "RGBA";
    ImageFormat["PngR8G8B8A8Uint"] = "PngR8G8B8A8Uint";
    ImageFormat["PngDXT5"] = "PngDXT5";
})(ImageFormat || (ImageFormat = {}));
/*
export enum ImageFormat {
    Unknown = 0,
    Dxt1 = 1,
    Dxt2 = 2,
    Dxt3 = 3,
    Dxt4 = 4,
    Dxt5 = 5,
    Bc1 = 10,
    Bc2 = 11,
    Bc3 = 12,
    Bc4 = 13,
    Bc5 = 14,
    Bc6 = 15,
    Bc7 = 16,
    Rgtc1 = 20,
    Rgtc1Signed = 21,
    Rgtc2 = 22,
    Rgtc2Signed = 23,
    R8 = 1000,
    R8G8B8A8Uint = 1001,
    BGRA8888 = 1002,
}
*/
function formatCompression(format) {
    switch (format) {
        /*
        case ImageFormat.Dxt1:
        case ImageFormat.Dxt2:
        case ImageFormat.Dxt3:
        case ImageFormat.Dxt4:
        case ImageFormat.Dxt5:
            */
        case ImageFormat.Bc1:
        case ImageFormat.Bc2:
        case ImageFormat.Bc3:
            return TextureCompressionMethod.St3c;
        case ImageFormat.Bc4:
        case ImageFormat.Bc4Signed:
        case ImageFormat.Bc5:
        case ImageFormat.Bc5Signed:
            return TextureCompressionMethod.Rgtc;
        case ImageFormat.Bc6:
        case ImageFormat.Bc7:
            return TextureCompressionMethod.Bptc;
        /*
    case ImageFormat.Rgtc1:
    case ImageFormat.Rgtc1Signed:
    case ImageFormat.Rgtc2:
    case ImageFormat.Rgtc2Signed:
        */
    }
    return TextureCompressionMethod.Uncompressed;
}

function detex(imports){return _loadWasmModule(0, null, 'AGFzbQEAAAABiAEWYAN/f38AYAR/f39/AX9gA39/fwF/YAF/AX9gAn9/AX9gAn9/AGABfwBgAAF/YAAAYAR/f39/AGAEf35+fwBgAn5/AX9gBX9/f39/AGABfQBgBX9/f39/AX9gBn98f39/fwF/YAN+f38Bf2ABfQF/YAJ9fwF9YAJ9fQF9YAJ+fgF8YAJ8fwF8AicBA2Vudh9lbXNjcmlwdGVuX25vdGlmeV9tZW1vcnlfZ3Jvd3RoAAYDoAGeAQAMBAMCEwEDCwEDEQQABAABBgUFAAUACAQEAA4FCAEBBAEAAAAAAAAAAAABBQ8AAxUEAAUBAQEBAQkHCQUDAQEDBwEBAQEBAAYEAgAAAAAAAAAAAAIAAAAAAAAAAAAAAgAAAAAAAAACAAAAAAAAAAACAAAAAAAAAAAAAAYGAwcDAAcAAwASFAoKBAACEAsAAgQCAAINCAEBAQEBBQcDBAUBcAFWVgUEAQCAAgYJAX8BQYDZwAILB+gBDwZtZW1vcnkCAA1jcmVhdGVfYnVmZmVyAJ4BDmRlc3Ryb3lfYnVmZmVyAHwKZGVjb2RlX0JDMQBxCmRlY29kZV9CQzIAaApkZWNvZGVfQkMzAGAKZGVjb2RlX0JDNABVCmRlY29kZV9CQzcASxJnZXRfcmVzdWx0X3BvaW50ZXIAQg9nZXRfcmVzdWx0X3NpemUAOx9nZXRfZGV0ZXhfZXJyb3JfbWVzc2FnZV9wb2ludGVyAJ0BBl9zdGFydAAeCXN0YWNrU2F2ZQB/CnN0YWNrQWxsb2MAfgxzdGFja1Jlc3RvcmUAfQllAQBBAQtVkwGPAYsBhQErKisqKSgpKHt6eXh3dnV0c3Jwb25tbGtqaWdmZWRjIyNiYV8nJiUkXl1cW1pZWFdWVFNSUVBPTk1MR0ZFRJoBmAGZAZcBQ0A/ER+bATk4Njc1Hi4tjAEKq6EDngEXACAALQAAQSBxRQRAIAEgAiAAEIMBCwtoAQF/IwBBgAJrIgUkACAEQYDABHEgAiADTHJFBEAgBSABIAIgA2siAkGAAiACQYACSSIBGxAbIAFFBEADQCAAIAVBgAIQASACQYB+aiICQf8BSw0ACwsgACAFIAIQAQsgBUGAAmokAAsZAEEAIAAgAUF/anZBAXFrQX8gAXRxIAByC8QuAQt/IwBBEGsiCyQAAkACQAJAAkACQAJAAkACQAJAAkACQCAAQfQBTQRAQYTVACgCACIGQRAgAEELakF4cSAAQQtJGyIFQQN2IgB2IgFBA3EEQCABQX9zQQFxIABqIgJBA3QiBEG01QBqKAIAIgFBCGohAAJAIAEoAggiAyAEQazVAGoiBEYEQEGE1QAgBkF+IAJ3cTYCAAwBC0GU1QAoAgAaIAMgBDYCDCAEIAM2AggLIAEgAkEDdCICQQNyNgIEIAEgAmoiASABKAIEQQFyNgIEDAwLIAVBjNUAKAIAIghNDQEgAQRAAkBBAiAAdCICQQAgAmtyIAEgAHRxIgBBACAAa3FBf2oiACAAQQx2QRBxIgB2IgFBBXZBCHEiAiAAciABIAJ2IgBBAnZBBHEiAXIgACABdiIAQQF2QQJxIgFyIAAgAXYiAEEBdkEBcSIBciAAIAF2aiICQQN0IgNBtNUAaigCACIBKAIIIgAgA0Gs1QBqIgNGBEBBhNUAIAZBfiACd3EiBjYCAAwBC0GU1QAoAgAaIAAgAzYCDCADIAA2AggLIAFBCGohACABIAVBA3I2AgQgASAFaiIHIAJBA3QiAiAFayIDQQFyNgIEIAEgAmogAzYCACAIBEAgCEEDdiIEQQN0QazVAGohAUGY1QAoAgAhAgJ/IAZBASAEdCIEcUUEQEGE1QAgBCAGcjYCACABDAELIAEoAggLIQQgASACNgIIIAQgAjYCDCACIAE2AgwgAiAENgIIC0GY1QAgBzYCAEGM1QAgAzYCAAwMC0GI1QAoAgAiCkUNASAKQQAgCmtxQX9qIgAgAEEMdkEQcSIAdiIBQQV2QQhxIgIgAHIgASACdiIAQQJ2QQRxIgFyIAAgAXYiAEEBdkECcSIBciAAIAF2IgBBAXZBAXEiAXIgACABdmpBAnRBtNcAaigCACIBKAIEQXhxIAVrIQMgASECA0ACQCACKAIQIgBFBEAgAigCFCIARQ0BCyAAKAIEQXhxIAVrIgIgAyACIANJIgIbIQMgACABIAIbIQEgACECDAELCyABKAIYIQkgASABKAIMIgRHBEBBlNUAKAIAIAEoAggiAE0EQCAAKAIMGgsgACAENgIMIAQgADYCCAwLCyABQRRqIgIoAgAiAEUEQCABKAIQIgBFDQMgAUEQaiECCwNAIAIhByAAIgRBFGoiAigCACIADQAgBEEQaiECIAQoAhAiAA0ACyAHQQA2AgAMCgtBfyEFIABBv39LDQAgAEELaiIAQXhxIQVBiNUAKAIAIgdFDQBBACAFayECAkACQAJAAn9BACAAQQh2IgBFDQAaQR8gBUH///8HSw0AGiAAIABBgP4/akEQdkEIcSIAdCIBIAFBgOAfakEQdkEEcSIBdCIDIANBgIAPakEQdkECcSIDdEEPdiAAIAFyIANyayIAQQF0IAUgAEEVanZBAXFyQRxqCyIIQQJ0QbTXAGooAgAiA0UEQEEAIQAMAQsgBUEAQRkgCEEBdmsgCEEfRht0IQFBACEAA0ACQCADKAIEQXhxIAVrIgYgAk8NACADIQQgBiICDQBBACECIAMhAAwDCyAAIAMoAhQiBiAGIAMgAUEddkEEcWooAhAiA0YbIAAgBhshACABIANBAEd0IQEgAw0ACwsgACAEckUEQEECIAh0IgBBACAAa3IgB3EiAEUNAyAAQQAgAGtxQX9qIgAgAEEMdkEQcSIAdiIBQQV2QQhxIgMgAHIgASADdiIAQQJ2QQRxIgFyIAAgAXYiAEEBdkECcSIBciAAIAF2IgBBAXZBAXEiAXIgACABdmpBAnRBtNcAaigCACEACyAARQ0BCwNAIAAoAgRBeHEgBWsiAyACSSEBIAMgAiABGyECIAAgBCABGyEEIAAoAhAiAQR/IAEFIAAoAhQLIgANAAsLIARFDQAgAkGM1QAoAgAgBWtPDQAgBCgCGCEIIAQgBCgCDCIBRwRAQZTVACgCACAEKAIIIgBNBEAgACgCDBoLIAAgATYCDCABIAA2AggMCQsgBEEUaiIDKAIAIgBFBEAgBCgCECIARQ0DIARBEGohAwsDQCADIQYgACIBQRRqIgMoAgAiAA0AIAFBEGohAyABKAIQIgANAAsgBkEANgIADAgLQYzVACgCACIBIAVPBEBBmNUAKAIAIQACQCABIAVrIgJBEE8EQEGM1QAgAjYCAEGY1QAgACAFaiIDNgIAIAMgAkEBcjYCBCAAIAFqIAI2AgAgACAFQQNyNgIEDAELQZjVAEEANgIAQYzVAEEANgIAIAAgAUEDcjYCBCAAIAFqIgEgASgCBEEBcjYCBAsgAEEIaiEADAoLQZDVACgCACIBIAVLBEBBkNUAIAEgBWsiATYCAEGc1QBBnNUAKAIAIgAgBWoiAjYCACACIAFBAXI2AgQgACAFQQNyNgIEIABBCGohAAwKC0EAIQAgBUEvaiIEAn9B3NgAKAIABEBB5NgAKAIADAELQejYAEJ/NwIAQeDYAEKAoICAgIAENwIAQdzYACALQQxqQXBxQdiq1aoFczYCAEHw2ABBADYCAEHA2ABBADYCAEGAIAsiAmoiBkEAIAJrIgdxIgIgBU0NCUG82AAoAgAiAwRAQbTYACgCACIIIAJqIgkgCE0gCSADS3INCgtBwNgALQAAQQRxDQQCQAJAQZzVACgCACIDBEBBxNgAIQADQCAAKAIAIgggA00EQCAIIAAoAgRqIANLDQMLIAAoAggiAA0ACwtBABAIIgFBf0YNBSACIQZB4NgAKAIAIgBBf2oiAyABcQRAIAIgAWsgASADakEAIABrcWohBgsgBiAFTSAGQf7///8HS3INBUG82AAoAgAiAARAQbTYACgCACIDIAZqIgcgA00gByAAS3INBgsgBhAIIgAgAUcNAQwHCyAGIAFrIAdxIgZB/v///wdLDQQgBhAIIgEgACgCACAAKAIEakYNAyABIQALIABBf0YgBUEwaiAGTXJFBEBB5NgAKAIAIgEgBCAGa2pBACABa3EiAUH+////B0sEQCAAIQEMBwsgARAIQX9HBEAgASAGaiEGIAAhAQwHC0EAIAZrEAgaDAQLIAAiAUF/Rw0FDAMLQQAhBAwHC0EAIQEMBQsgAUF/Rw0CC0HA2ABBwNgAKAIAQQRyNgIACyACQf7///8HSw0BIAIQCCIBQQAQCCIATyABQX9GciAAQX9Gcg0BIAAgAWsiBiAFQShqTQ0BC0G02ABBtNgAKAIAIAZqIgA2AgAgAEG42AAoAgBLBEBBuNgAIAA2AgALAkACQAJAQZzVACgCACIDBEBBxNgAIQADQCABIAAoAgAiAiAAKAIEIgRqRg0CIAAoAggiAA0ACwwCC0GU1QAoAgAiAEEAIAEgAE8bRQRAQZTVACABNgIAC0EAIQBByNgAIAY2AgBBxNgAIAE2AgBBpNUAQX82AgBBqNUAQdzYACgCADYCAEHQ2ABBADYCAANAIABBA3QiAkG01QBqIAJBrNUAaiIDNgIAIAJBuNUAaiADNgIAIABBAWoiAEEgRw0AC0GQ1QAgBkFYaiIAQXggAWtBB3FBACABQQhqQQdxGyICayIDNgIAQZzVACABIAJqIgI2AgAgAiADQQFyNgIEIAAgAWpBKDYCBEGg1QBB7NgAKAIANgIADAILIAAtAAxBCHEgASADTXIgAiADS3INACAAIAQgBmo2AgRBnNUAIANBeCADa0EHcUEAIANBCGpBB3EbIgBqIgE2AgBBkNUAQZDVACgCACAGaiICIABrIgA2AgAgASAAQQFyNgIEIAIgA2pBKDYCBEGg1QBB7NgAKAIANgIADAELIAFBlNUAKAIAIgRJBEBBlNUAIAE2AgAgASEECyABIAZqIQJBxNgAIQACQAJAAkACQAJAAkADQCACIAAoAgBHBEAgACgCCCIADQEMAgsLIAAtAAxBCHFFDQELQcTYACEAA0AgACgCACICIANNBEAgAiAAKAIEaiIEIANLDQMLIAAoAgghAAwAAAsACyAAIAE2AgAgACAAKAIEIAZqNgIEIAFBeCABa0EHcUEAIAFBCGpBB3EbaiIJIAVBA3I2AgQgAkF4IAJrQQdxQQAgAkEIakEHcRtqIgEgCWsgBWshACAFIAlqIQcgASADRgRAQZzVACAHNgIAQZDVAEGQ1QAoAgAgAGoiADYCACAHIABBAXI2AgQMAwsgAUGY1QAoAgBGBEBBmNUAIAc2AgBBjNUAQYzVACgCACAAaiIANgIAIAcgAEEBcjYCBCAAIAdqIAA2AgAMAwsgASgCBCICQQNxQQFGBEAgAkF4cSEKAkAgAkH/AU0EQCABKAIIIgMgAkEDdiIEQQN0QazVAGpHGiADIAEoAgwiAkYEQEGE1QBBhNUAKAIAQX4gBHdxNgIADAILIAMgAjYCDCACIAM2AggMAQsgASgCGCEIAkAgASABKAIMIgZHBEAgBCABKAIIIgJNBEAgAigCDBoLIAIgBjYCDCAGIAI2AggMAQsCQCABQRRqIgMoAgAiBQ0AIAFBEGoiAygCACIFDQBBACEGDAELA0AgAyECIAUiBkEUaiIDKAIAIgUNACAGQRBqIQMgBigCECIFDQALIAJBADYCAAsgCEUNAAJAIAEgASgCHCICQQJ0QbTXAGoiAygCAEYEQCADIAY2AgAgBg0BQYjVAEGI1QAoAgBBfiACd3E2AgAMAgsgCEEQQRQgCCgCECABRhtqIAY2AgAgBkUNAQsgBiAINgIYIAEoAhAiAgRAIAYgAjYCECACIAY2AhgLIAEoAhQiAkUNACAGIAI2AhQgAiAGNgIYCyABIApqIQEgACAKaiEACyABIAEoAgRBfnE2AgQgByAAQQFyNgIEIAAgB2ogADYCACAAQf8BTQRAIABBA3YiAUEDdEGs1QBqIQACf0GE1QAoAgAiAkEBIAF0IgFxRQRAQYTVACABIAJyNgIAIAAMAQsgACgCCAshASAAIAc2AgggASAHNgIMIAcgADYCDCAHIAE2AggMAwsgBwJ/QQAgAEEIdiIBRQ0AGkEfIABB////B0sNABogASABQYD+P2pBEHZBCHEiAXQiAiACQYDgH2pBEHZBBHEiAnQiAyADQYCAD2pBEHZBAnEiA3RBD3YgASACciADcmsiAUEBdCAAIAFBFWp2QQFxckEcagsiATYCHCAHQgA3AhAgAUECdEG01wBqIQICQEGI1QAoAgAiA0EBIAF0IgRxRQRAQYjVACADIARyNgIAIAIgBzYCAAwBCyAAQQBBGSABQQF2ayABQR9GG3QhAyACKAIAIQEDQCABIgIoAgRBeHEgAEYNAyADQR12IQEgA0EBdCEDIAIgAUEEcWoiBCgCECIBDQALIAQgBzYCEAsgByACNgIYIAcgBzYCDCAHIAc2AggMAgtBkNUAIAZBWGoiAEF4IAFrQQdxQQAgAUEIakEHcRsiAmsiBzYCAEGc1QAgASACaiICNgIAIAIgB0EBcjYCBCAAIAFqQSg2AgRBoNUAQezYACgCADYCACADIARBJyAEa0EHcUEAIARBWWpBB3EbakFRaiIAIAAgA0EQakkbIgJBGzYCBCACQczYACkCADcCECACQcTYACkCADcCCEHM2AAgAkEIajYCAEHI2AAgBjYCAEHE2AAgATYCAEHQ2ABBADYCACACQRhqIQADQCAAQQc2AgQgAEEIaiEBIABBBGohACAEIAFLDQALIAIgA0YNAyACIAIoAgRBfnE2AgQgAyACIANrIgRBAXI2AgQgAiAENgIAIARB/wFNBEAgBEEDdiIBQQN0QazVAGohAAJ/QYTVACgCACICQQEgAXQiAXFFBEBBhNUAIAEgAnI2AgAgAAwBCyAAKAIICyEBIAAgAzYCCCABIAM2AgwgAyAANgIMIAMgATYCCAwECyADQgA3AhAgAwJ/QQAgBEEIdiIARQ0AGkEfIARB////B0sNABogACAAQYD+P2pBEHZBCHEiAHQiASABQYDgH2pBEHZBBHEiAXQiAiACQYCAD2pBEHZBAnEiAnRBD3YgACABciACcmsiAEEBdCAEIABBFWp2QQFxckEcagsiADYCHCAAQQJ0QbTXAGohAQJAQYjVACgCACICQQEgAHQiBnFFBEBBiNUAIAIgBnI2AgAgASADNgIAIAMgATYCGAwBCyAEQQBBGSAAQQF2ayAAQR9GG3QhACABKAIAIQEDQCABIgIoAgRBeHEgBEYNBCAAQR12IQEgAEEBdCEAIAIgAUEEcWoiBigCECIBDQALIAYgAzYCECADIAI2AhgLIAMgAzYCDCADIAM2AggMAwsgAigCCCIAIAc2AgwgAiAHNgIIIAdBADYCGCAHIAI2AgwgByAANgIICyAJQQhqIQAMBQsgAigCCCIAIAM2AgwgAiADNgIIIANBADYCGCADIAI2AgwgAyAANgIIC0GQ1QAoAgAiACAFTQ0AQZDVACAAIAVrIgE2AgBBnNUAQZzVACgCACIAIAVqIgI2AgAgAiABQQFyNgIEIAAgBUEDcjYCBCAAQQhqIQAMAwtBwNQAQTA2AgBBACEADAILAkAgCEUNAAJAIAQoAhwiAEECdEG01wBqIgMoAgAgBEYEQCADIAE2AgAgAQ0BQYjVACAHQX4gAHdxIgc2AgAMAgsgCEEQQRQgCCgCECAERhtqIAE2AgAgAUUNAQsgASAINgIYIAQoAhAiAARAIAEgADYCECAAIAE2AhgLIAQoAhQiAEUNACABIAA2AhQgACABNgIYCwJAIAJBD00EQCAEIAIgBWoiAEEDcjYCBCAAIARqIgAgACgCBEEBcjYCBAwBCyAEIAVBA3I2AgQgBCAFaiIDIAJBAXI2AgQgAiADaiACNgIAIAJB/wFNBEAgAkEDdiIBQQN0QazVAGohAAJ/QYTVACgCACICQQEgAXQiAXFFBEBBhNUAIAEgAnI2AgAgAAwBCyAAKAIICyEBIAAgAzYCCCABIAM2AgwgAyAANgIMIAMgATYCCAwBCyADAn9BACACQQh2IgBFDQAaQR8gAkH///8HSw0AGiAAIABBgP4/akEQdkEIcSIAdCIBIAFBgOAfakEQdkEEcSIBdCIFIAVBgIAPakEQdkECcSIFdEEPdiAAIAFyIAVyayIAQQF0IAIgAEEVanZBAXFyQRxqCyIANgIcIANCADcCECAAQQJ0QbTXAGohAQJAAkAgB0EBIAB0IgVxRQRAQYjVACAFIAdyNgIAIAEgAzYCAAwBCyACQQBBGSAAQQF2ayAAQR9GG3QhACABKAIAIQUDQCAFIgEoAgRBeHEgAkYNAiAAQR12IQUgAEEBdCEAIAEgBUEEcWoiBigCECIFDQALIAYgAzYCEAsgAyABNgIYIAMgAzYCDCADIAM2AggMAQsgASgCCCIAIAM2AgwgASADNgIIIANBADYCGCADIAE2AgwgAyAANgIICyAEQQhqIQAMAQsCQCAJRQ0AAkAgASgCHCIAQQJ0QbTXAGoiAigCACABRgRAIAIgBDYCACAEDQFBiNUAIApBfiAAd3E2AgAMAgsgCUEQQRQgCSgCECABRhtqIAQ2AgAgBEUNAQsgBCAJNgIYIAEoAhAiAARAIAQgADYCECAAIAQ2AhgLIAEoAhQiAEUNACAEIAA2AhQgACAENgIYCwJAIANBD00EQCABIAMgBWoiAEEDcjYCBCAAIAFqIgAgACgCBEEBcjYCBAwBCyABIAVBA3I2AgQgASAFaiIEIANBAXI2AgQgAyAEaiADNgIAIAgEQCAIQQN2IgVBA3RBrNUAaiEAQZjVACgCACECAn9BASAFdCIFIAZxRQRAQYTVACAFIAZyNgIAIAAMAQsgACgCCAshBSAAIAI2AgggBSACNgIMIAIgADYCDCACIAU2AggLQZjVACAENgIAQYzVACADNgIACyABQQhqIQALIAtBEGokACAAC4IEAQN/IAJBgARPBEAgACABIAIQgQEgAA8LIAAgAmohAwJAIAAgAXNBA3FFBEACQCACQQFIBEAgACECDAELIABBA3FFBEAgACECDAELIAAhAgNAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIANPDQEgAkEDcQ0ACwsCQCADQXxxIgRBwABJDQAgAiAEQUBqIgVLDQADQCACIAEoAgA2AgAgAiABKAIENgIEIAIgASgCCDYCCCACIAEoAgw2AgwgAiABKAIQNgIQIAIgASgCFDYCFCACIAEoAhg2AhggAiABKAIcNgIcIAIgASgCIDYCICACIAEoAiQ2AiQgAiABKAIoNgIoIAIgASgCLDYCLCACIAEoAjA2AjAgAiABKAI0NgI0IAIgASgCODYCOCACIAEoAjw2AjwgAUFAayEBIAJBQGsiAiAFTQ0ACwsgAiAETw0BA0AgAiABKAIANgIAIAFBBGohASACQQRqIgIgBEkNAAsMAQsgA0EESQRAIAAhAgwBCyADQXxqIgQgAEkEQCAAIQIMAQsgACECA0AgAiABLQAAOgAAIAIgAS0AAToAASACIAEtAAI6AAIgAiABLQADOgADIAFBBGohASACQQRqIgIgBE0NAAsLIAIgA0kEQANAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIANHDQALCyAAC+MLAgZ/CH1DAACAPyEJAkACQAJAIAC8IgRBgICA/ANGDQAgAbwiBUH/////B3EiAkUNACAEQf////8HcSIDQYCAgPwHTUEAIAJBgYCA/AdJG0UEQCAAIAGSDwsCf0EAIARBf0oNABpBAiACQf///9sESw0AGkEAIAJBgICA/ANJDQAaQQAgAkGWASACQRd2ayIGdiIHIAZ0IAJHDQAaQQIgB0EBcWsLIQYCQCACQYCAgPwDRwRAIAJBgICA/AdHDQEgA0GAgID8A0YNAiADQYGAgPwDTwRAIAFDAAAAACAFQX9KGw8LQwAAAAAgAYwgBUF/ShsPCyAAQwAAgD8gAJUgBUF/ShsPCyAFQYCAgIAERgRAIAAgAJQPCyAFQYCAgPgDRyAEQQBIckUEQCAAkQ8LIACLIQggA0EAIANBgICAgARyQYCAgPwHRxtFBEBDAACAPyAIlSAIIAVBAEgbIQkgBEF/Sg0BIAYgA0GAgICEfGpyRQRAIAkgCZMiACAAlQ8LIAmMIAkgBkEBRhsPCyAEQX9KIAZBAUtyRQRAIAZBAWsEQCAAIACTIgAgAJUPC0MAAIC/IQkLAn0gAkGBgIDoBE8EQCADQff///sDTQRAIAlDyvJJcZRDyvJJcZQgCUNgQqINlENgQqINlCAFQQBIGw8LIANBiICA/ANPBEAgCUPK8klxlEPK8klxlCAJQ2BCog2UQ2BCog2UIAVBAEobDwsgCEMAAIC/kiIAQwCquD+UIgggAENwpew2lCAAIACUQwAAAD8gACAAQwAAgL6UQ6uqqj6SlJOUQzuquL+UkiILkrxBgGBxviIAIAiTDAELIAhDAACAS5S8IAMgA0GAgIAESSIDGyIEQf///wNxIgZBgICA/ANyIQIgBEEXdUHpfkGBfyADG2ohA0EAIQQCQCAGQfKI8wBJDQAgBkHX5/YCSQRAQQEhBAwBCyACQYCAgHxqIQIgA0EBaiEDCyAEQQJ0IgZB+MoAaioCACINIAK+IgsgBkHoygBqKgIAIgqTIgxDAACAPyAKIAuSlSIOlCIIvEGAYHG+IgAgACAAlCIPQwAAQECSIAggAJIgDiAMIAAgAkEBdUGA4P//fXFBgICAgAJyIARBFXRqQYCAgAJqviIMlJMgACALIAwgCpOTlJOUIguUIAggCJQiACAAlCAAIAAgACAAIABDQvFTPpRDVTJsPpKUQwWjiz6SlEOrqqo+kpRDt23bPpKUQ5qZGT+SlJIiCpK8QYBgcb4iAJQiDCALIACUIAggCiAAQwAAQMCSIA+Tk5SSIgiSvEGAYHG+IgBDAEB2P5QiCiAGQfDKAGoqAgAgCCAAIAyTk0NPOHY/lCAAQ8Yj9riUkpIiC5KSIAOyIgiSvEGAYHG+IgAgCJMgDZMgCpMLIQogACAFQYBgcb4iDZQiCCALIAqTIAGUIAEgDZMgAJSSIgCSIgG8IgJBgYCAmARODQFBgICAmAQhBAJAAkAgAkGAgICYBEYEQCAAQzyqODOSIAEgCJNeQQFzDQEMBAsgACABIAiTX0EBcyACQYCA2Jh8R3JFIAJB/////wdxIgRBgYDYmARPcg0EQQAhAyAEQYGAgPgDSQ0BC0EAQYCAgAQgBEEXdkGCf2p2IAJqIgVB////A3FBgICABHJBlgEgBUEXdkH/AXEiBGt2IgNrIAMgAkEASBshAyAAIAhBgICAfCAEQYF/anUgBXG+kyIIkrwhAgsgCQJ9IAJBgIB+cb4iAUMAcjE/lCIJIAFDjL6/NZQgACABIAiTk0MYcjE/lJIiCJIiACAAIAAgACAAlCIBIAEgASABIAFDTLsxM5RDDurdtZKUQ1WzijiSlENhCza7kpRDq6oqPpKUkyIBlCABQwAAAMCSlSAIIAAgCZOTIgEgACABlJKTk0MAAIA/kiIAvCADQRd0aiICQf///wNMBEAgACADEIYBDAELIAK+C5QhCQsgCQ8LIAlDyvJJcZRDyvJJcZQPCyAJQ2BCog2UQ2BCog2UC4ABAAJ/IANBAkYEQCABIAJBAXRBwBlqLwEAIgFsQcAAIAFrIABsakEgakEGdQwBCyADQQNGBEAgASACQQF0QdAZai8BACIBbEHAACABayAAbGpBIGpBBnUMAQsgASACQQF0QeAZai8BACIBbEHAACABayAAbGpBIGpBBnYLQf8BcQtFAQJ/PwAhAQJAQYDZACgCACICIABBA2pBfHFqIgAgAUEQdE0NACAAEIABDQBBwNQAQTA2AgBBfw8LQYDZACAANgIAIAILgwECA38BfgJAIABCgICAgBBUBEAgACEFDAELA0AgAUF/aiIBIAAgAEIKgCIFQgp+fadBMHI6AAAgAEL/////nwFWIQIgBSEAIAINAAsLIAWnIgIEQANAIAFBf2oiASACIAJBCm4iA0EKbGtBMHI6AAAgAkEJSyEEIAMhAiAEDQALCyABC0gAIABBwAACfyACQQF0QcAZaiADQQJGDQAaIAJBAXRB0BlqIANBA0YNABogAkEBdEHgGWoLLwEAIgBrbCAAIAFsakEgakEGdQsKACAAQVBqQQpJCxsAIACQIgCLQwAAAE9dBEAgAKgPC0GAgICAeAvEAgELfyMAQYACayIEJAAgACgCBCEFAkAgACgCACICQf///wdNBEAgBSAAKAIMIAAoAghsIAJB//8DcSABECIhBgwBC0EBIQYDQCAIIAAoAhRODQFBACEHQQQgACgCDCIDIAhBAnQiCWsgCUEDciADSBsiA0EAIANBAEobIQoDQCAHIAAoAhBOBEAgCEEBaiEIDAILIAUgAiAEEJQBRQRAIARBAEHAABAbQQAhBgtBBCAAKAIIIgIgB0ECdCIDayADQQNyIAJIG0ECdCELIAEgAkECdCIMIAlsaiADQQJ0aiEDQQAhAgNAIAIgCkYEQCAHQQFqIQcgACgCACICQRR2QQhxIAVqQQhqIQUMAgUgAyACIAxsaiAEIAJBBHRqIAsQBRogAkEBaiECDAELAAALAAALAAALAAsgBEGAAmokACAGQQFxC6MCAQR/A0AgAQRAAn8gACgCACIDQf////8HcUUEQCADQRB2DAELIANB////A3EhBiADQYCAgIB4cSEFAkAgA0GAgID8B3EiBEGAgID8B0cEQCAEDQEgBUEQdgwCC0GA/AMgBg0BGiAFQRB2QYD4AXIMAQsgBUEQdiEFIAVBgPgBciAEQYGAgLgETw0AGiAEQf///8MDTQRAQQAhAwJAIARBgICAmANJDQAgBkGAgIAEciIGQf4AIARBF3YiBGt2IQMgBkH9ACAEa3ZBAXFFDQAgA0H//wNxQQFqIQMLIAMgBXIMAQsgA0EMdkEBcSAEQQ12QYCAAWogBkENdiAFcnJqCyEDIAFBf2ohASAAQQRqIQAgAiADOwEAIAJBAmohAgwBCwsLsAECBH8BfiABQQAgAUEAShshBUEAIQEDQCABIAVGRQRAAn4gACgCECIDQT9MBEAgACkDAEIBIAOthoMhBiADIAFrIgJBf0wEQCAGQQAgAmuthgwCCyAGIAKtiAwBCyAAKQMIQgEgA0FAaiICrYaDIQYgAiABayICQX9MBEAgBkEAIAJrrYYMAQsgBiACrYgLIQYgACADQQFqNgIQIAFBAWohASAEIAanciEEDAELCyAEC+EGAQh/IAAtAAAhAyMAQTBrIgQCfyABQQRGBEAgAC0AAiEGIAAtAAMhASAEIAAtAAEiBUHwAXEgBUEEdnI2AhAgBCAFQQ9xIgVBBHQgBXI2AgAgBCADQQF2QQxxIANBA3FyIgNBBHQgA3I2AiAgBCAGQfABcSAGQQR2ciIDNgIoIAQgAUEBdkEGcSABQQFxckECdEHAJGooAgAiB0H/AWoiBSADakGAGmotAAA2AiQgBCAGQQ9xIgZBBHQgBnIiBjYCGCAEIAUgBmpBgBpqLQAANgIUIAQgAUHwAXEgAUEEdnIiATYCCCAEIAEgBWpBgBpqLQAANgIEIAQgA0H/ASAHayIDakGAGmotAAA2AiwgBCADIAZqQYAaai0AADYCHCABIANqDAELIAQgA0EDdkEPcSIBQQR0IAFyIgYgAC0AAyIBQQF0QQJxIAFBBHFyIAAtAAEiBUEEdkEBcSADQQF0QQ5xciIDQQR0IANyIgNBCHQgBkEQdHIgBUEBdEEGcSAFQQhxciAALQACIgVBB3ZyIgdBBHQgB3IiB3IgAUEDdkEPcSIIQQR0IAhyIgggBUEDdkEPcSIJQQR0IAlyIglBEHRyIAVBAXRBDnEgAUEHdnIiAUEEdCABciIFQQh0ck5yQQJ0QcAkaigCACIKa0H/G2otAAA2AiQgBCAKQf8BaiIBIANqQYAaai0AADYCECAEIAEgBmpBgBpqLQAANgIgIAQgASAHakGAGmotAAA2AgAgBCADQf8BIAprIgNqQYAaai0AADYCFCAEIAMgB2pBgBpqLQAANgIEIAQgASAJakGAGmotAAA2AiggBCABIAVqQYAaai0AADYCGCAEIAEgCGpBgBpqLQAANgIIIAQgAyAJakGAGmotAAA2AiwgBCADIAVqQYAaai0AADYCHCADIAhqC0GAGmotAAA2AgwgACgABCIAQRh0IABBCHRBgID8B3FyIABBCHZBgP4DcSAAQRh2cnIhAUEAIQADQCAAQRBHBEAgAiAAQQJ0QQxxIABBAnZyQQJ0akEBIAB0IAFxIAB2QYCABCAAdCABcSAAQQ9qdnJBAnQiAyAEQSBqaigCACAEQRBqIANqKAIAQQh0ciADIARqKAIAQRB0ckGAgIB4cjYCACAAQQFqIQAMAQsLC+cWAQx/AkACfyAALQADIgVBAnEEQCABQQJxRQ0CIAAtAAAiAUEHcUECdEGgI2ooAgAgAUH4AXEiCmoiAkGH/gNxDQIgAC0AASIGQQdxQQJ0QaAjaigCACAGQfgBcSIGaiIIQYf+A3ENAiAALQACIgRBB3FBAnRBoCNqKAIAIARB+AFxIgRqIglBh/4DcQ0CIAogAUEFdnIhASAEQQV2IARyIQogBkEFdiAGciELIAlBBXZBB3EgCXIhBiAIQQV2QQdxIAhyIQggAkEFdkEHcSACcgwBCyABQQFxRQ0BIAAtAAAiAkHwAXEgAkEEdnIhASAALQACIgRBD3EiBkEEdCAGciEGIAAtAAEiCUEPcSIIQQR0IAhyIQggBEHwAXEiBEEEdiAEciEKIAlB8AFxIgRBBHYgBHIhCyACQQ9xIgJBBHQgAnILIQJBASEOIAAtAAYhBCAALQAEIQkgAyAFQQV2QQR0QcAjaiIMIAAtAAciDUEBdkEBcSAALQAFIgBBAnFyQQJ0aigCAEH/AWoiByALakGAGmotAABBCHQgASAHakGAGmotAAByIAcgCmpBgBpqLQAAQRB0ckGAgIB4cjYCECADIAwgDUEBcSAAQQF0QQJxckECdGooAgBB/wFqIgcgC2pBgBpqLQAAQQh0IAEgB2pBgBpqLQAAciAHIApqQYAaai0AAEEQdHJBgICAeHI2AgAgDUECdkEBcSAAQQF2QQJxciEHIAVBAnZBB3EhDyAFQQFxRQRAIAMgDCAHQQJ0aigCAEH/AWoiBSALakGAGmotAABBCHQgASAFakGAGmotAAByIAUgCmpBgBpqLQAAQRB0ckGAgIB4cjYCICADIAwgDUEDdkEBcSAAQQJ2QQJxckECdGooAgBB/wFqIgUgC2pBgBpqLQAAQQh0IAEgBWpBgBpqLQAAciAFIApqQYAaai0AAEEQdHJBgICAeHI2AjAgAyAMIABBBnZBAnEgDUEHdnJBAnRqKAIAQf8BaiIFIAtqQYAaai0AAEEIdCABIAVqQYAaai0AAHIgBSAKakGAGmotAABBEHRyQYCAgHhyNgI0IAMgDCANQQZ2QQFxIABBBXZBAnFyQQJ0aigCAEH/AWoiBSALakGAGmotAABBCHQgASAFakGAGmotAAByIAUgCmpBgBpqLQAAQRB0ckGAgIB4cjYCJCADIAwgDUEFdkEBcSAAQQR2QQJxckECdGooAgBB/wFqIgUgC2pBgBpqLQAAQQh0IAEgBWpBgBpqLQAAciAFIApqQYAaai0AAEEQdHJBgICAeHI2AhQgAyAMIA1BBHZBAXEgAEEDdkECcXJBAnRqKAIAQf8BaiIAIAtqQYAaai0AAEEIdCAAIAFqQYAaai0AAHIgACAKakGAGmotAABBEHRyQYCAgHhyNgIEIAMgD0EEdEHAI2oiACAEQQN2QQFxIAlBAnZBAnFyQQJ0aigCAEH/AWoiASAIakGAGmotAABBCHQgASACakGAGmotAAByIAEgBmpBgBpqLQAAQRB0ckGAgIB4cjYCOCADIAAgBEECdkEBcSAJQQF2QQJxckECdGooAgBB/wFqIgEgCGpBgBpqLQAAQQh0IAEgAmpBgBpqLQAAciABIAZqQYAaai0AAEEQdHJBgICAeHI2AiggAyAAIARBAXZBAXEgCUECcXJBAnRqKAIAQf8BaiIBIAhqQYAaai0AAEEIdCABIAJqQYAaai0AAHIgASAGakGAGmotAABBEHRyQYCAgHhyNgIYIAMgACAEQQFxIAlBAXRBAnFyQQJ0aigCAEH/AWoiASAIakGAGmotAABBCHQgASACakGAGmotAAByIAEgBmpBgBpqLQAAQRB0ckGAgIB4cjYCCCADIAAgCUEGdkECcSAEQQd2ckECdGooAgBB/wFqIgEgCGpBgBpqLQAAQQh0IAEgAmpBgBpqLQAAciABIAZqQYAaai0AAEEQdHJBgICAeHI2AjwgAyAAIARBBnZBAXEgCUEFdkECcXJBAnRqKAIAQf8BaiIBIAhqQYAaai0AAEEIdCABIAJqQYAaai0AAHIgASAGakGAGmotAABBEHRyQYCAgHhyNgIsIAMgACAEQQV2QQFxIAlBBHZBAnFyQQJ0aigCAEH/AWoiASAIakGAGmotAABBCHQgASACakGAGmotAAByIAEgBmpBgBpqLQAAQRB0ckGAgIB4cjYCHCADIAAgBEEEdkEBcSAJQQN2QQJxckECdGooAgBB/wFqIgAgCGpBgBpqLQAAQQh0IAAgAmpBgBpqLQAAciAAIAZqQYAaai0AAEEQdHJBgICAeHI2AgxBAQ8LIAMgD0EEdEHAI2oiBSAHQQJ0aigCAEH/AWoiByAIakGAGmotAABBCHQgAiAHakGAGmotAAByIAYgB2pBgBpqLQAAQRB0ckGAgIB4cjYCICADIAUgDUEDdkEBcSAAQQJ2QQJxckECdGooAgBB/wFqIgcgCGpBgBpqLQAAQQh0IAIgB2pBgBpqLQAAciAGIAdqQYAaai0AAEEQdHJBgICAeHI2AjAgAyAFIABBBnZBAnEgDUEHdnJBAnRqKAIAQf8BaiIHIAhqQYAaai0AAEEIdCACIAdqQYAaai0AAHIgBiAHakGAGmotAABBEHRyQYCAgHhyNgI0IAMgBSANQQZ2QQFxIABBBXZBAnFyQQJ0aigCAEH/AWoiByAIakGAGmotAABBCHQgAiAHakGAGmotAAByIAYgB2pBgBpqLQAAQRB0ckGAgIB4cjYCJCADIAwgDUEFdkEBcSAAQQR2QQJxckECdGooAgBB/wFqIgcgC2pBgBpqLQAAQQh0IAEgB2pBgBpqLQAAciAHIApqQYAaai0AAEEQdHJBgICAeHI2AhQgAyAMIA1BBHZBAXEgAEEDdkECcXJBAnRqKAIAQf8BaiIAIAtqQYAaai0AAEEIdCAAIAFqQYAaai0AAHIgACAKakGAGmotAABBEHRyQYCAgHhyNgIEIAMgBSAEQQN2QQFxIAlBAnZBAnFyQQJ0aigCAEH/AWoiACAIakGAGmotAABBCHQgACACakGAGmotAAByIAAgBmpBgBpqLQAAQRB0ckGAgIB4cjYCOCADIAUgBEECdkEBcSAJQQF2QQJxckECdGooAgBB/wFqIgAgCGpBgBpqLQAAQQh0IAAgAmpBgBpqLQAAciAAIAZqQYAaai0AAEEQdHJBgICAeHI2AiggAyAMIARBAXZBAXEgCUECcXJBAnRqKAIAQf8BaiIAIAtqQYAaai0AAEEIdCAAIAFqQYAaai0AAHIgACAKakGAGmotAABBEHRyQYCAgHhyNgIYIAMgDCAEQQFxIAlBAXRBAnFyQQJ0aigCAEH/AWoiACALakGAGmotAABBCHQgACABakGAGmotAAByIAAgCmpBgBpqLQAAQRB0ckGAgIB4cjYCCCADIAUgCUEGdkECcSAEQQd2ckECdGooAgBB/wFqIgAgCGpBgBpqLQAAQQh0IAAgAmpBgBpqLQAAciAAIAZqQYAaai0AAEEQdHJBgICAeHI2AjwgAyAFIARBBnZBAXEgCUEFdkECcXJBAnRqKAIAQf8BaiIAIAhqQYAaai0AAEEIdCAAIAJqQYAaai0AAHIgACAGakGAGmotAABBEHRyQYCAgHhyNgIsIAMgDCAEQQV2QQFxIAlBBHZBAnFyQQJ0aigCAEH/AWoiACALakGAGmotAABBCHQgACABakGAGmotAAByIAAgCmpBgBpqLQAAQRB0ckGAgIB4cjYCHCADIAwgBEEEdkEBcSAJQQN2QQJxckECdGooAgBB/wFqIgAgC2pBgBpqLQAAQQh0IAAgAWpBgBpqLQAAciAAIApqQYAaai0AAEEQdHJBgICAeHI2AgwLIA4Lqg0BB38CQCAARQ0AIABBeGoiAyAAQXxqKAIAIgFBeHEiAGohBQJAIAFBAXENACABQQNxRQ0BIAMgAygCACICayIDQZTVACgCACIESQ0BIAAgAmohACADQZjVACgCAEcEQCACQf8BTQRAIAMoAggiBCACQQN2IgJBA3RBrNUAakcaIAQgAygCDCIBRgRAQYTVAEGE1QAoAgBBfiACd3E2AgAMAwsgBCABNgIMIAEgBDYCCAwCCyADKAIYIQYCQCADIAMoAgwiAUcEQCAEIAMoAggiAk0EQCACKAIMGgsgAiABNgIMIAEgAjYCCAwBCwJAIANBFGoiAigCACIEDQAgA0EQaiICKAIAIgQNAEEAIQEMAQsDQCACIQcgBCIBQRRqIgIoAgAiBA0AIAFBEGohAiABKAIQIgQNAAsgB0EANgIACyAGRQ0BAkAgAyADKAIcIgJBAnRBtNcAaiIEKAIARgRAIAQgATYCACABDQFBiNUAQYjVACgCAEF+IAJ3cTYCAAwDCyAGQRBBFCAGKAIQIANGG2ogATYCACABRQ0CCyABIAY2AhggAygCECICBEAgASACNgIQIAIgATYCGAsgAygCFCICRQ0BIAEgAjYCFCACIAE2AhgMAQsgBSgCBCIBQQNxQQNHDQBBjNUAIAA2AgAgBSABQX5xNgIEIAMgAEEBcjYCBCAAIANqIAA2AgAPCyAFIANNDQAgBSgCBCIBQQFxRQ0AAkAgAUECcUUEQCAFQZzVACgCAEYEQEGc1QAgAzYCAEGQ1QBBkNUAKAIAIABqIgA2AgAgAyAAQQFyNgIEIANBmNUAKAIARw0DQYzVAEEANgIAQZjVAEEANgIADwsgBUGY1QAoAgBGBEBBmNUAIAM2AgBBjNUAQYzVACgCACAAaiIANgIAIAMgAEEBcjYCBCAAIANqIAA2AgAPCyABQXhxIABqIQACQCABQf8BTQRAIAUoAgwhAiAFKAIIIgQgAUEDdiIBQQN0QazVAGoiB0cEQEGU1QAoAgAaCyACIARGBEBBhNUAQYTVACgCAEF+IAF3cTYCAAwCCyACIAdHBEBBlNUAKAIAGgsgBCACNgIMIAIgBDYCCAwBCyAFKAIYIQYCQCAFIAUoAgwiAUcEQEGU1QAoAgAgBSgCCCICTQRAIAIoAgwaCyACIAE2AgwgASACNgIIDAELAkAgBUEUaiICKAIAIgQNACAFQRBqIgIoAgAiBA0AQQAhAQwBCwNAIAIhByAEIgFBFGoiAigCACIEDQAgAUEQaiECIAEoAhAiBA0ACyAHQQA2AgALIAZFDQACQCAFIAUoAhwiAkECdEG01wBqIgQoAgBGBEAgBCABNgIAIAENAUGI1QBBiNUAKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgBUYbaiABNgIAIAFFDQELIAEgBjYCGCAFKAIQIgIEQCABIAI2AhAgAiABNgIYCyAFKAIUIgJFDQAgASACNgIUIAIgATYCGAsgAyAAQQFyNgIEIAAgA2ogADYCACADQZjVACgCAEcNAUGM1QAgADYCAA8LIAUgAUF+cTYCBCADIABBAXI2AgQgACADaiAANgIACyAAQf8BTQRAIABBA3YiAUEDdEGs1QBqIQACf0GE1QAoAgAiAkEBIAF0IgFxRQRAQYTVACABIAJyNgIAIAAMAQsgACgCCAshAiAAIAM2AgggAiADNgIMIAMgADYCDCADIAI2AggPCyADQgA3AhAgAwJ/QQAgAEEIdiIBRQ0AGkEfIABB////B0sNABogASABQYD+P2pBEHZBCHEiAXQiAiACQYDgH2pBEHZBBHEiAnQiBCAEQYCAD2pBEHZBAnEiBHRBD3YgASACciAEcmsiAUEBdCAAIAFBFWp2QQFxckEcagsiAjYCHCACQQJ0QbTXAGohAQJAAkACQEGI1QAoAgAiBEEBIAJ0IgdxRQRAQYjVACAEIAdyNgIAIAEgAzYCACADIAE2AhgMAQsgAEEAQRkgAkEBdmsgAkEfRht0IQIgASgCACEBA0AgASIEKAIEQXhxIABGDQIgAkEddiEBIAJBAXQhAiAEIAFBBHFqIgdBEGooAgAiAQ0ACyAHIAM2AhAgAyAENgIYCyADIAM2AgwgAyADNgIIDAELIAQoAggiACADNgIMIAQgAzYCCCADQQA2AhggAyAENgIMIAMgADYCCAtBpNUAQaTVACgCAEF/aiIANgIAIAANAEHM2AAhAwNAIAMoAgAiAEEIaiEDIAANAAtBpNUAQX82AgALC2YBAX8jAEEQayICJABBvNQAKAIAEBIgAiABNgIMIAJBCGogACABEJIBQX9MBEAgAgJ/QQAQggFBAWoiABAEIgFFDQAaIAFB8MMAIAAQBQs2AggLQbzUACACKAIINgIAIAJBEGokAAufAwICfwN9QfzRACoCACEFQbDUACoCACEEAkBB+NEAKgIAIgZDAACAP1sEQCAEQwAAAABcIAVDAACAP1xyRQRAIAFBACABQQBKGyEBA0AgASACRg0DIAAgAkECdGoiA0MAAAAAIAMqAgAiBEMAAIA/liAEQwAAAABdGzgCACACQQFqIQIMAAALAAsgAUEAIAFBAEobIQFDAACAPyAFIASTlSEFA0AgASACRg0CIAAgAkECdGoiA0MAAAAAIAUgAyoCACAEk5QiBkMAAIA/liAGQwAAAABdGzgCACACQQFqIQIMAAALAAsCfSAEQwAAAABgQQFzRQRAIARDAACAPyAGlRAGDAELIASMQwAAgD8gBpUQBowLIQQgAUEAIAFBAEobIQFDAACAPwJ9IAVDAAAAAGBBAXNFBEAgBUMAAIA/IAaVEAYMAQsgBYxDAACAPyAGlRAGjAsgBJOVIQUDQCABIAJGDQEgACACQQJ0aiIDQwAAAAAgBSADKgIAIASTlCIGQwAAgD+WIAZDAAAAAF0bOAIAIAJBAWohAgwAAAsACwtgAgF/AX0gAUEAIAFBAEobIQEDQCABIANHBEAgAiADQQF0akMAAAA/IAAgA0ECdGoqAgAiBEMAAIA/lkMA/39HlEMAAAA/kiAEQwAAAABdGxAMOwEAIANBAWohAwwBCwsLcAIDfwF9EBggAUEAIAFBAEobIQFBkNQAKAIAIQMDQCABIAJHBEAgACACQQF0aiIEQwAAAD8gAyAELwEAQQJ0aioCACIFQwAAgD+WQwD/f0eUQwAAAD+SIAVDAAAAAF0bEAw7AQAgAkEBaiECDAELCwtOAQJ/IAFBACABQQBKGyEBEBhBkNQAKAIAIQQDQCABIANHBEAgAiADQQJ0aiAEIAAgA0EBdGovAQBBAnRqKAIANgIAIANBAWohAwwBCwsLEABBkNQAKAIARQRAEJYBCwtDAAJ/IAAgAUENRg0AGiAARQRAQQAPC0H//wMgAEF/IAFBkCFqLQAAIgF0QX9zRg0AGiAAQQ90QYCAAXIgAUF/anYLC2wBAX8gAUENRwRAAn9BACAAIABBH3UiAmogAnMiAkH//wNxRQ0AGkH//wEgAkEQdEEQdSICQX8gAUGQIWotAABBf2oiAXRBf3NODQAaIAJBD3RBgIABciABdQsiAUEAIAFrIABBf0obDwsgAAvxAgICfwF+AkAgAkUNACAAIAJqIgNBf2ogAToAACAAIAE6AAAgAkEDSQ0AIANBfmogAToAACAAIAE6AAEgA0F9aiABOgAAIAAgAToAAiACQQdJDQAgA0F8aiABOgAAIAAgAToAAyACQQlJDQAgAEEAIABrQQNxIgRqIgMgAUH/AXFBgYKECGwiADYCACADIAIgBGtBfHEiAmoiAUF8aiAANgIAIAJBCUkNACADIAA2AgggAyAANgIEIAFBeGogADYCACABQXRqIAA2AgAgAkEZSQ0AIAMgADYCGCADIAA2AhQgAyAANgIQIAMgADYCDCABQXBqIAA2AgAgAUFsaiAANgIAIAFBaGogADYCACABQWRqIAA2AgAgAiADQQRxQRhyIgFrIgJBIEkNACAArSIFQiCGIAWEIQUgASADaiEBA0AgASAFNwMYIAEgBTcDECABIAU3AwggASAFNwMAIAFBIGohASACQWBqIgJBH0sNAAsLC7cRAg9/AX4jAEHQAGsiBSQAIAUgATYCTCAFQTdqIRMgBUE4aiEQQQAhAQJAAkADQAJAIA1BAEgNACABQf////8HIA1rSgRAQcDUAEE9NgIAQX8hDQwBCyABIA1qIQ0LIAUoAkwiCSEBAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkAgCS0AACIHBEADQAJAAkACQCAHQf8BcSIGRQRAIAEhBwwBCyAGQSVHDQEgASEHA0AgAS0AAUElRw0BIAUgAUECaiIGNgJMIAdBAWohByABLQACIQogBiEBIApBJUYNAAsLIAcgCWshASAABEAgACAJIAEQAQsgAQ0RQX8hD0EBIQcgBSgCTCwAARALIQYgBSgCTCEBAkAgBkUNACABLQACQSRHDQAgASwAAUFQaiEPQQEhEUEDIQcLIAUgASAHaiIBNgJMQQAhBwJAIAEsAAAiDkFgaiIKQR9LBEAgASEGDAELIAEhBkEBIAp0IgpBidEEcUUNAANAIAUgAUEBaiIGNgJMIAcgCnIhByABLAABIg5BYGoiCkEfSw0BIAYhAUEBIAp0IgpBidEEcQ0ACwsCQCAOQSpGBEAgBQJ/AkAgBiwAARALRQ0AIAUoAkwiAS0AAkEkRw0AIAEsAAFBAnQgBGpBwH5qQQo2AgAgASwAAUEDdCADakGAfWooAgAhC0EBIREgAUEDagwBCyARDRVBACERQQAhCyAABEAgAiACKAIAIgFBBGo2AgAgASgCACELCyAFKAJMQQFqCyIBNgJMIAtBf0oNAUEAIAtrIQsgB0GAwAByIQcMAQsgBUHMAGoQMCILQQBIDRMgBSgCTCEBC0F/IQgCQCABLQAAQS5HDQAgAS0AAUEqRgRAAkAgASwAAhALRQ0AIAUoAkwiAS0AA0EkRw0AIAEsAAJBAnQgBGpBwH5qQQo2AgAgASwAAkEDdCADakGAfWooAgAhCCAFIAFBBGoiATYCTAwCCyARDRQgAAR/IAIgAigCACIBQQRqNgIAIAEoAgAFQQALIQggBSAFKAJMQQJqIgE2AkwMAQsgBSABQQFqNgJMIAVBzABqEDAhCCAFKAJMIQELQQAhBgNAIAYhEkF/IQwgASwAAEG/f2pBOUsNFCAFIAFBAWoiDjYCTCABLAAAIQYgDiEBIAYgEkE6bGpBj8UAai0AACIGQX9qQQhJDQALIAZFDRMCQAJAAkAgBkETRgRAIA9Bf0wNAQwXCyAPQQBIDQEgBCAPQQJ0aiAGNgIAIAUgAyAPQQN0aikDADcDQAtBACEBIABFDRMMAQsgAEUNESAFQUBrIAYgAhAvIAUoAkwhDgsgB0H//3txIgogByAHQYDAAHEbIQdBACEMQbvFACEPIBAhBiAOQX9qLAAAIgFBX3EgASABQQ9xQQNGGyABIBIbIgFBqH9qIg5BIE0NAQJAAn8CQAJAIAFBv39qIgpBBksEQCABQdMARw0UIAhFDQEgBSgCQAwDCyAKQQFrDgMTARMIC0EAIQEgAEEgIAtBACAHEAIMAgsgBUEANgIMIAUgBSkDQD4CCCAFIAVBCGo2AkBBfyEIIAVBCGoLIQZBACEBAkADQCAGKAIAIglFDQEgBUEEaiAJEDIiCUEASCIKIAkgCCABa0tyRQRAIAZBBGohBiAIIAEgCWoiAUsNAQwCCwtBfyEMIAoNFQsgAEEgIAsgASAHEAIgAUUEQEEAIQEMAQtBACEKIAUoAkAhBgNAIAYoAgAiCUUNASAFQQRqIAkQMiIJIApqIgogAUoNASAAIAVBBGogCRABIAZBBGohBiAKIAFJDQALCyAAQSAgCyABIAdBgMAAcxACIAsgASALIAFKGyEBDBELIAUgAUEBaiIGNgJMIAEtAAEhByAGIQEMAQsLIA5BAWsOHwwMDAwMDAwMAQwDBAEBAQwEDAwMDAgFBgwMAgwJDAwHCyANIQwgAA0PIBFFDQxBASEBA0AgBCABQQJ0aigCACIABEAgAyABQQN0aiAAIAIQL0EBIQwgAUEBaiIBQQpHDQEMEQsLQQEhDCABQQlLDQ8DQCABIgBBAWoiAUEKRwRAIAQgAUECdGooAgBFDQELC0F/QQEgAEEJSRshDAwPCyAAIAUrA0AgCyAIIAcgARAuIQEMDAsgBSgCQCIBQcXFACABGyIJIAgQigEiASAIIAlqIAEbIQYgCiEHIAEgCWsgCCABGyEIDAkLIAUgBSkDQDwAN0EBIQggEyEJIAohBwwICyAFKQNAIhRCf1cEQCAFQgAgFH0iFDcDQEEBIQxBu8UADAYLIAdBgBBxBEBBASEMQbzFAAwGC0G9xQBBu8UAIAdBAXEiDBsMBQsgBSkDQCAQEI4BIQkgB0EIcUUNBSAIIBAgCWsiAUEBaiAIIAFKGyEIDAULIAhBCCAIQQhLGyEIIAdBCHIhB0H4ACEBCyAFKQNAIBAgAUEgcRCNASEJIAdBCHFFDQMgBSkDQFANAyABQQR2QbvFAGohD0ECIQwMAwtBACEBIBJB/wFxIgZBB0sNBQJAAkACQAJAAkACQAJAIAZBAWsOBwECAwQMBQYACyAFKAJAIA02AgAMCwsgBSgCQCANNgIADAoLIAUoAkAgDaw3AwAMCQsgBSgCQCANOwEADAgLIAUoAkAgDToAAAwHCyAFKAJAIA02AgAMBgsgBSgCQCANrDcDAAwFCyAFKQNAIRRBu8UACyEPIBQgEBAJIQkLIAdB//97cSAHIAhBf0obIQcCfyAIIAUpA0AiFFBFckUEQCAQIQlBAAwBCyAIIBRQIBAgCWtqIgEgCCABShsLIQgLIABBICAMIAYgCWsiCiAIIAggCkgbIg5qIgYgCyALIAZIGyIBIAYgBxACIAAgDyAMEAEgAEEwIAEgBiAHQYCABHMQAiAAQTAgDiAKQQAQAiAAIAkgChABIABBICABIAYgB0GAwABzEAIMAQsLQQAhDAwBC0F/IQwLIAVB0ABqJAAgDAuUBAIDfwN9AkBB+NEAKgIAIgVDAACAP1sEQBAYQbDUACoCACIFQwAAAABcQfzRACoCACIGQwAAgD9cckUEQCABQQAgAUEAShshAUGQ1AAoAgAhAwNAIAEgAkYNAyAAIAJBAXRqIgRDAAAAPyADIAQvAQBBAnRqKgIAIgVDAACAP5ZDAP9/R5RDAAAAP5IgBUMAAAAAXRsQDDsBACACQQFqIQIMAAALAAsgAUEAIAFBAEobIQFDAACAPyAGIAWTlSEGQZDUACgCACEDA0AgASACRg0CIAAgAkEBdGoiBEMAAAA/IAYgAyAELwEAQQJ0aioCACAFk5QiB0MAAIA/lkMA/39HlEMAAAA/kiAHQwAAAABdGxAMOwEAIAJBAWohAgwAAAsAC0H80QAqAgAhBkGw1AAqAgAhByAFEJUBQbTUACgCACEDAn0gB0MAAAAAYEEBc0UEQCAHQwAAgD8gBZUQBgwBCyAHjEMAAIA/IAWVEAaMCyEHIAFBACABQQBKGyEBQwAAgD8CfSAGQwAAAABgQQFzRQRAIAZDAACAPyAFlRAGDAELIAaMQwAAgD8gBZUQBowLIAeTlSEFA0AgASACRg0BIAAgAkEBdGoiBEMAAAA/IAUgAyAELwEAQQJ0aioCACAHk5QiBkMAAIA/lkMA/39HlEMAAAA/kiAGQwAAAABdGxAMOwEAIAJBAWohAgwAAAsACwsDAAEL1wEBAX8gAC0AA0ECcUUEQCAAIAEgACADEBEPC0EAIQICQCABQQJJDQAgAC0AACIEQfgBcSAEQQdxQQJ0QaAjaigCAGpBh/4DcQRAIAFBBHFFDQEgAEEEIAMQEEEBDwsgAC0AASIEQQdxQQJ0QaAjaigCACAEQfgBcWpBh/4DcQRAIAFBCHFFDQEgAEEIIAMQEEEBDwsgAC0AAiIEQfgBcSAEQQdxQQJ0QaAjaigCAGpBh/4DcQRAIAFBEHFFDQEgACADEDRBAQ8LIAAgASAAIAMQESECCyACC4AoAhB/BH4jAEGAAWsiBCQAIAQgACkDADcDaCAAKQMIIRQgBEEANgJ4IAQgFDcDcCAEQegAahBBIglBf0YgASAJdkEBcUVyRQRAIAQpA3AhFQJAIAlBDUsEQEEAIQEMAQsgBCkDaCEUAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkAgCUEBaw4NAQIDBAYHCAkKCwwNDgALIAQgFKciBUEPdkH/B3EiBjYCQEEFIQggBCAFQQV2Qf8HcTYCUCAEIBRCGYinQf8HcSIHNgIwIAQgFEIjiKdBH3E2AlQgBCAUQi2Ip0EfcTYCRCAEIBRCN4inQR9xNgI0IAQgFaciAUEHdkEfcTYCXCAEIAFBAXZBH3E2AlggBCAFQQJ0QRBxIBRCKYinQQ9xcjYCSCAEIBRCJIinQRBxIBRCM4inQQ9xcjYCTCAEIAFBA3RBCHEgBUEBdEEQcXI2AjggBCABQQl2QQhxIAFBBHZBBHEgFEI7iKdBAnEgFEIyiKdBAXEgBUEQcXJycnI2AjwMEAsgBCAUpyIBQRl2Igc2AjAgBCABQQ92Qf8AcSIGNgJAIAQgAUEFdkH/AHE2AlAgBCAUQiOIp0E/cTYCVCAEIBRCLYinQT9xNgJEIAQgFEI3iKdBP3E2AjQgBCAVpyIFQQd2QT9xNgJcIAQgBUEBdkE/cTYCWCAEIAFBAXRBMHEgFEIziKdBD3FyNgJMIAQgFEIpiKdBD3EgAUEDdEEgcSABQRR2QRBxcnI2AkggBCAFQQN0QQhxIAFBCnZBEHEgAUERdkEgcXJyNgI4IAQgFEIeiKdBEHEgFEIciKdBIHEgFEIdiKdBCHFyciABQQx2QQNxIAFBFXZBBHFycjYCPCAFQQ12QR9xIQFBBiEIQdIAIQVBBiEKQQYhCwwQCyAEIBRCI4inQR9xNgJUIAQgFEIpiKdBD3E2AkggBCAUQi2Ip0EPcTYCRCAEIBRCM4inQQ9xNgJMIAQgFEI3iKdBD3E2AjQgBCAVpyIBQQN0QQhxNgI4IAQgAUEHdkEfcTYCXCAEIAFBAXZBH3E2AlhBBSELIAQgFKciBkEFdkH/B3EgFEIeiKdBgAhxcjYCUCAEIAZBD3ZB/wdxIBRCJ4inQYAIcXIiBjYCQCAEIBRCGYinQf8HcSAUQjGIp0GACHFyIgc2AjBBBCEIIAQgAUEJdkEIcSABQQR2QQRxIBRCMoinQQFxIBRCO4inQQJxcnJyNgI8IAFBDXZBH3EhAUHSACEFQQQhCgwPCyAEIBRCI4inQQ9xNgJUIAQgFEItiKdBH3E2AkQgBCAUQjeIp0EPcTYCNCAEIBWnIgFBA3RBCHE2AjggBCAVQgeIpyIFQQ9xNgJcIAQgAUEBdkEPcTYCWEEFIQogBCAUpyIGQQV2Qf8HcSAUQh2Ip0GACHFyNgJQIAQgFEIkiKdBEHEgFEIziKdBD3FyNgJMIAQgBkEPdkH/B3EgFEIoiKdBgAhxciIGNgJAIAQgFEIZiKdB/wdxIBRCMYinQYAIcXIiBzYCMCAEIAVBEHEgFEIpiKdBD3FyNgJIQQQhCCAEIAFBCXZBCHEgAUEEdkEEcSABQQV2QQFxIBRCO4inQQJxcnJyNgI8IAFBDXZBH3EMAQsgBCAUQiOIp0EPcTYCVCAEIBRCKYinQQ9xNgJIIAQgFEItiKdBD3E2AkQgBCAUQjOIp0EPcTYCTCAEIBRCN4inQR9xNgI0IAQgFUIHiKciBUEPcTYCXCAEIBWnIgFBAXZBD3E2AlhBBSEIIAQgFKciBkEFdkH/B3EgFEIdiKdBgAhxcjYCUCAEIAZBD3ZB/wdxIBRCJ4inQYAIcXIiBjYCQCAEIAFBA3RBCHEgFEIkiKdBEHFyNgI4IAQgFEIZiKdB/wdxIBRCMoinIgtBgAhxciIHNgIwQQQhCiAEIAFBCXZBCHEgBUEQcXIgFUIEiKciBUECcSALQQFxciAFQQRxcnI2AjwgAUENdkEfcQshAUHSAAwJCyAEIBSnIgVBD3ZB/wNxIgY2AkBBBSEIIAQgBUEFdkH/A3E2AlAgBCAUQhmIp0H/A3EiBzYCMCAEIBRCI4inQR9xNgJUIAQgFEItiKdBH3E2AkQgBCAUQjeIp0EfcTYCNCAEIBWnIgFBB3ZBH3E2AlwgBCABQQF2QR9xNgJYIAQgBUEUdkEQcSAUQimIp0EPcXI2AkggBCAUQiSIp0EQcSAUQjOIp0EPcXI2AkwgBCABQQN0QQhxIAVBCnZBEHFyNgI4IAQgAUEJdkEIcSABQQR2QQRxIBRCO4inQQJxIBRCHoinQRBxIBRCMoinQQFxcnJycjYCPAwKCyAEIBSnIgFBD3ZB/wFxIgY2AkBBBSEIIAQgAUEFdkH/AXE2AlAgBCAUQhmIp0H/AXEiBzYCMCAEIBRCI4inQT9xNgJUIAQgFEItiKdBH3E2AkQgBCAUQjeIp0EfcTYCNCAEIBWnIgVBB3ZBP3E2AlwgBCAFQQF2QT9xNgJYIAQgAUEUdkEQcSAUQimIp0EPcXI2AkggBCABQQl2QRBxIBRCM4inQQ9xcjYCTCAEIAVBA3RBCHEgAUEKdkEQcXI2AjggBCAUQjuIp0ECcSAUQjKIp0EBcSABQRV2QQRxIBRCHoinIgFBCHFyIAFBEHFycnI2AjwgBUENdkEfcSEBQQYhC0HSACEFQQUhCgwKCyAEIBSnIgFBD3ZB/wFxIgY2AkBBBSEIIAQgAUEFdkH/AXE2AlAgBCAUQhmIp0H/AXEiBzYCMCAEIBRCI4inQR9xNgJUIAQgFEItiKdBP3E2AkQgBCAUQjeIp0EfcTYCNCAEIBWnIgVBB3ZBH3E2AlwgBCAFQQF2QR9xNgJYIAQgBUEDdEEIcSABQQp2QRBxcjYCOCAEIBRCKYinQQ9xIAFBEnZBIHEgAUEUdkEQcXJyNgJIIAQgFEIziKdBD3EgFEIciKdBIHEgFEIkiKdBEHFycjYCTCAEIAVBCXZBCHEgBUEEdkEEcSAUQjuIp0ECcSABQQ12QQFxIBRCHoinQRBxcnJycjYCPCAFQQ12QR9xIQFBBiEKDAcLIAQgFKciAUEPdkH/AXEiBjYCQEEFIQogBCABQQV2Qf8BcTYCUCAEIBRCGYinQf8BcSIHNgIwIAQgFEIjiKdBH3E2AlQgBCAUQi2Ip0EfcTYCRCAEIBRCN4inQT9xNgI0IAQgFaciBUEHdkEfcTYCXCAEIAVBAXZBH3E2AlggBCABQRR2QRBxIBRCKYinQQ9xcjYCSCAEIBRCJIinQRBxIBRCM4inQQ9xcjYCTCAEIAVBA3RBCHEgAUEKdkEQcSABQRJ2QSBxcnI2AjggBCAFQQl2QQhxIAVBBHZBBHEgFEIyiKdBAXEgFEIeiKdBEHEgAUEMdkECcSAUQhyIp0EgcXJycnJyNgI8IAVBDXZBH3EhAUEGIQgMBgsgBCAUpyIBQQ92QT9xIgY2AkAgBCABQQV2QT9xNgJQIAQgAUEZdkE/cSIHNgIwIAQgFEIjiKdBP3E2AlQgBCAUQi2Ip0E/cTYCRCAEIBRCN4inQT9xNgI0IAQgFaciBUEHdkE/cTYCXCAEIAVBAXZBP3E2AlggBCAUQimIp0EPcSABQRB2QSBxIAFBFHZBEHFycjYCSCAEIBRCM4inQQ9xIAFBB3ZBEHEgAUEadkEgcXJyNgJMIAQgBUEDdEEIcSABQQp2QRBxIAFBEXZBIHFycjYCOCAEIBRCHoinQRBxIBRCHIinQSBxIBRCHYinQQhxcnIgAUEMdkEDcSABQRV2QQRxcnI2AjwgBUENdkEfcSEBQdIAIQUMBwsgBCAUpyIBQQ92Qf8HcSIGNgJAIAQgAUEFdkH/B3E2AlAgBCAUQhmIp0H/B3EiBzYCMCAEIBRCI4inQf8HcTYCVCAEIBRCLYinQf8HcTYCRCAEIBWnQQl0QYAEcTYCNEEAIQFBwQAhBQwGC0EAIQEgBEEANgI0IAQgFEIjiKdB/wNxNgJUIAQgFEItiKdB/wNxNgJEIAQgFKciBkEFdkH/B3EgFEIiiKdBgAhxcjYCUCAEIAZBD3ZB/wdxIBRCLIinQYAIcXIiBjYCQCAEIBWnQQp0QYAIcSAUQhmIp0H/B3FyIgc2AjBBCSEIQcEAIQVBCSEKQQkhCwwFCyAEIBRCI4inQf8BcTYCVCAEIBRCLYinQf8BcTYCRCAEIBRCN4inQf8BcTYCNCAEIBWnQQp0QYAIcSAUQhmIp0H/B3FyIgc2AjAgBCAUpyIBQQV2Qf8HcSAUQiyIQgGDIBRCKohCAoOEp0EKdHI2AlAgBCABQQ92Qf8HcSAUQjaIQgGDIBRCNIhCAoOEp0EKdHIiBjYCQEEAIQFBCCEIQcEAIQVBCCEKQQghCwwECyAEIBSnIgFBD3ZB/wdxIgY2AkAgBCABQQV2Qf8HcSIHNgJQIAQgFEIZiKdB/wdxIgg2AjAgBCAUQiOIp0EPcTYCVANAIBZCBlIEQEIBQiwgFn2GIBSDIRcCfiAWp0EBdCIBQSxMBEAgF0EsIAFrrYgMAQsgFyABQVRqrYYLIRcgFkIBfCEWIAUgF6dyIQUMAQsLIAQgBUEKdCAHcjYCUCAEIBRCLYinQQ9xNgJEQQAhBUIAIRYDQCAWQgZSBEBCAUI2IBZ9hiAUgyEXAn4gFqdBAXQiAUE2TARAIBdBNiABa62IDAELIBcgAUFKaq2GCyEXIBZCAXwhFiAFIBenciEFDAELCyAEIAVBCnQgBnIiBjYCQCAEIBRCN4inQQ9xNgI0QQAhBUIAIRYDQCAWQgVSBEBCgICAgICAgICAfyAWiCAUgyEXAn4gFqdBAXQiAUE/TARAIBdBPyABa62IDAELIBcgAUFBaq2GCyEXIBZCAXwhFiAFIBenciEFDAELCyAEIBWnQQp0QYAIcSAIciAFQQt0ciIHNgIwQQAhAUEEIQhBBCEKQcEACyEFQQQhCwwCC0HSACEFQQUhCwwBCyABQQ12QR9xIQFB0gAhBUEFIQpBBSELCyAEIAU2AngLQQFBAiAJQQlLGyEMAkACQAJAAkAgAgRAIAQgBCgCUCAJQZAhai0AACINEAM2AlAgBCAGIA0QAzYCQCAEIAcgDRADNgIwIAlBd2pBAUsNASAMQQF0IQdBASEFA0AgBSAHRg0DIAVBAnQiBiAEQdAAamoiCCAIKAIAIA0QAzYCACAEQUBrIAZqIgggCCgCACANEAM2AgAgBEEwaiAGaiIGIAYoAgAgDRADNgIAIAVBAWohBQwAAAsACyAJQXdqQQJJDQILIAxBAXQhEkF/IAlBkCFqLQAAIgV0QX9zIQdBASEGA0AgBiASRg0BIAZBAnQiDiAEQdAAamoiDSANKAIAIAsQAyIPNgIAIA0gBCgCUCAPaiAHcSITNgIAIARBQGsgDmoiDyAPKAIAIAoQAyIQNgIAIA8gBCgCQCAQaiAHcSIQNgIAIARBMGogDmoiDiAOKAIAIAgQAyIRNgIAIA4gBCgCMCARaiAHcSIRNgIAIAIEQCANIBMgBRADNgIAIA8gECAFEAM2AgAgDiARIAUQAzYCAAsgBkEBaiEGDAAACwALIAJFDQAgDEEBdCEHQQAhBQNAIAUgB0YNAiAFQQJ0IgYgBEHQAGpqIgggCC4BACAJEBo2AgAgBEFAayAGaiIIIAguAQAgCRAaNgIAIARBMGogBmoiBiAGLgEAIAkQGjYCACAFQQFqIQUMAAALAAsgDEEBdCEHQQAhBQNAIAUgB0YNASAFQQJ0IgYgBEHQAGpqIgggCC8BACAJEBk2AgAgBEFAayAGaiIIIAgvAQAgCRAZNgIAIARBMGogBmoiBiAGLwEAIAkQGTYCACAFQQFqIQUMAAALAAtBACEGA38gBkEQRgR/QQAhBiABQYAYaiEBA38gBiAMRgR/IBUgBCgCeEFAaq2IIRRBf0EEQQMgAC0AAEEDcUEDRhsiAEF/aiIBdEH/AXMhBUF/IAB0Qf4AcUH/AHMhCUEABSAEQRxqIAZqIAYEfyABLQAABUEACzoAACAGQQFqIQYMAQsLIQYDQCAGQRBHBEAgBCAGaiAUIAUgCSAGIARBIGogBmotAAAgBEEcamotAABGIgcbrYM8AAAgBkEBaiEGIBQgASAAIAcbrYghFAwBCwtBACEGA38gBkEQRgR/QQEFIARBIGogBmotAABBA3QiASAEQTBqaigCACEJIARBQGsgAWooAgAhByABQQRyIgUgBEEwamooAgAhCCAEQUBrIAVqKAIAIQogBEHQAGogAWooAgAgBEHQAGogBWooAgAgBCAGai0AACIFIAAQCiEBAkAgAgRAQQAgAUFhbEEFdWsgAUEfbEEFdSABQX9MGyIBQR91IgsgAWohDCALIAxzIQsgAUEQdkGAgAJxIQwCfyAHIAogBSAAEAoiAUF/TARAQQAgAUFhbEEFdWsMAQsgAUEfbEEFdQsiAUEfdSIHIAFqIAdzIQcgAUGAgICAeHEgC0H//wNxIAxyciAHQRB0ciEBAn8gCSAIIAUgABAKIgVBf0wEQEEAIAVBYWxBBXVrDAELIAVBH2xBBXULIgVBH3UiCSAFaiAJc0H//wNxIAVBEHZBgIACcXIhBQwBCyAHIAogBSAAEAohByAJIAggBSAAEApBH2xBwABtIQUgAUEfbEHAAG0gB0EfbEHAAG1BEHRyIQELIAMgBkEDdGogAa0gBa1CIIaENwMAIAZBAWohBgwBCwsFIARBIGogBmogDEEBRwR/IAFBBHQgBmpBgAhqLQAABUEACzoAACAGQQFqIQYMAQsLIQULIARBgAFqJAAgBQsuAQJ/IAAoAhgiA0EDRwRAIAAgA0ECdGogARAEIgI2AgAgACADQQFqNgIYCyACC5EEAQd/IwBBMGsiByQAAkAgAkG0BkYEQCADRQRAQQEhBgwCC0EBIQYgAyAAIAJBCHZBD3FBAWogAWwQBRoMAQtBfyEJIAIgB0EgahBKIghBf0oEQEF/IQQDQCAFIAhGBEAgAyAGRXJFBEBBACEGQbIgQQAQEwwECyAHQQA2AhgCQCAEQQFIBEAgACEEDAELIAcgAkEIdkEPcUEBaiABbCIFECEiBCAAIAUQBRoLIANFIAZyRQRAIAMgBCACQQh2QQ9xQQFqIAFsEAUhBAsgCEEAIAhBAEobIQhBASEGQQAhBQJAA0AgBSAIRg0BAkACQCAHQSBqIAVBAnRqKAIAQQxsIgJBgMsAaigCAEEIdkEPcSACQYTLAGooAgBBCHZBD3EiAEYEQCAEIAFBACACQYjLAGooAgARAAAMAQsgBSAJRgRAIAQgASADIAJBiMsAaigCABEAACADIQQMAQsgByAAQQFqIAFsECEiAEUNASAEIAEgACACQYjLAGooAgARAAAgACEECyAFQQFqIQUMAQsLQQAhBkHaIEEAEBMLIAcQSQwDBSAFIAQgBEEASBsgBCAHQSBqIAVBAnRqKAIAQQxsIgRBhMsAaigCACAEQYDLAGooAgBzQYAecSIKGyEEIAUgCSAKGyEJIAYgCkEAR2ohBiAFQQFqIQUMAQsAAAsAC0H/H0EAEBMLIAdBMGokACAGCwsAIAAgAUECdBAWCw0AIAAgAUECdCACEA4LDQAgACABQQNsIAIQDgsNACAAIAFBAXQgAhAOCwoAIAAgASACEA4LPgBBACECIAFBACABQQBKGyEBA0AgASACRwRAIAAgACgCAEGAgIKAeHM2AgAgAkEBaiECIABBBGohAAwBCwsLPABBACECIAFBACABQQBKGyEBA0AgASACRwRAIAAgAC8BAEGAgAJzOwEAIAJBAWohAiAAQQJqIQAMAQsLCzwAQQAhAiABQQAgAUEAShshAQNAIAEgAkcEQCAAIAAvAQBBgIECczsBACACQQFqIQIgAEECaiEADAELCws7AEEAIQIgAUEAIAFBAEobIQEDQCABIAJHBEAgACAALQAAQYABczoAACACQQFqIQIgAEEBaiEADAELCwu6AQECfyMAQaABayIEJAAgBEEIakHYyQBBkAEQBRoCQAJAIAFBf2pB/////wdPBEAgAQ0BQQEhASAEQZ8BaiEACyAEIAA2AjQgBCAANgIcIARBfiAAayIFIAEgASAFSxsiATYCOCAEIAAgAWoiADYCJCAEIAA2AhggBEEIaiACIAMQkAEhACABRQ0BIAQoAhwiASABIAQoAhhGa0EAOgAADAELQcDUAEE9NgIAQX8hAAsgBEGgAWokACAACykAIAEgASgCAEEPakFwcSIBQRBqNgIAIAAgASkDACABKQMIEIcBOQMAC9QWAxF/An4BfCMAQbAEayIJJAAgCUEANgIsAn8gAb0iF0J/VwRAQQEhEiABmiIBvSEXQbDJAAwBCyAEQYAQcQRAQQEhEkGzyQAMAQtBtskAQbHJACAEQQFxIhIbCyEWAkAgF0KAgICAgICA+P8Ag0KAgICAgICA+P8AUQRAIABBICACIBJBA2oiDCAEQf//e3EQAiAAIBYgEhABIABBy8kAQc/JACAFQQV2QQFxIgMbQcPJAEHHyQAgAxsgASABYhtBAxABDAELIAlBEGohEQJAAn8CQCABIAlBLGoQMSIBIAGgIgFEAAAAAAAAAABiBEAgCSAJKAIsIgZBf2o2AiwgBUEgciIQQeEARw0BDAMLIAVBIHIiEEHhAEYNAiAJKAIsIQpBBiADIANBAEgbDAELIAkgBkFjaiIKNgIsIAFEAAAAAAAAsEGiIQFBBiADIANBAEgbCyELIAlBMGogCUHQAmogCkEASBsiDiEIA0AgCAJ/IAFEAAAAAAAA8EFjIAFEAAAAAAAAAABmcQRAIAGrDAELQQALIgM2AgAgCEEEaiEIIAEgA7ihRAAAAABlzc1BoiIBRAAAAAAAAAAAYg0ACwJAIApBAUgEQCAIIQYgDiEHDAELIA4hBwNAIApBHSAKQR1IGyENAkAgCEF8aiIGIAdJDQAgDa0hGEIAIRcDQCAGIBdC/////w+DIAY1AgAgGIZ8IhcgF0KAlOvcA4AiF0KAlOvcA359PgIAIAZBfGoiBiAHTw0ACyAXpyIDRQ0AIAdBfGoiByADNgIACwNAIAgiBiAHSwRAIAZBfGoiCCgCAEUNAQsLIAkgCSgCLCANayIKNgIsIAYhCCAKQQBKDQALCyAKQX9MBEAgC0EZakEJbUEBaiETIBBB5gBGIRQDQEEJQQAgCmsgCkF3SBshFQJAIAcgBk8EQCAHIAdBBGogBygCABshBwwBC0GAlOvcAyAVdiEPQX8gFXRBf3MhDUEAIQogByEIA0AgCCAIKAIAIgMgFXYgCmo2AgAgAyANcSAPbCEKIAhBBGoiCCAGSQ0ACyAHIAdBBGogBygCABshByAKRQ0AIAYgCjYCACAGQQRqIQYLIAkgCSgCLCAVaiIKNgIsIA4gByAUGyIDIBNBAnRqIAYgBiADa0ECdSATShshBiAKQQBIDQALC0EAIQgCQCAHIAZPDQAgDiAHa0ECdUEJbCEIQQohCiAHKAIAIgNBCkkNAANAIAhBAWohCCADIApBCmwiCk8NAAsLIAtBACAIIBBB5gBGG2sgEEHnAEYgC0EAR3FrIgMgBiAOa0ECdUEJbEF3akgEQCADQYDIAGoiDUEJbSIDQQJ0IA5qQYRgaiEMQQohCiANIANBCWxrIgNBB0wEQANAIApBCmwhCiADQQFqIgNBCEcNAAsLAkBBACAGIAxBBGoiE0YgDCgCACIPIA8gCm4iDSAKbGsiFBsNAEQAAAAAAADgP0QAAAAAAADwP0QAAAAAAAD4PyAUIApBAXYiA0YbRAAAAAAAAPg/IAYgE0YbIBQgA0kbIRlEAQAAAAAAQENEAAAAAAAAQEMgDUEBcRshAQJAIBJFDQAgFi0AAEEtRw0AIBmaIRkgAZohAQsgDCAPIBRrIgM2AgAgASAZoCABYQ0AIAwgAyAKaiIDNgIAIANBgJTr3ANPBEADQCAMQQA2AgAgDEF8aiIMIAdJBEAgB0F8aiIHQQA2AgALIAwgDCgCAEEBaiIDNgIAIANB/5Pr3ANLDQALCyAOIAdrQQJ1QQlsIQhBCiEKIAcoAgAiA0EKSQ0AA0AgCEEBaiEIIAMgCkEKbCIKTw0ACwsgDEEEaiIDIAYgBiADSxshBgsCfwNAQQAgBiINIAdNDQEaIA1BfGoiBigCAEUNAAtBAQshCgJAIBBB5wBHBEAgBEEIcSEQDAELIAhBf3NBfyALQQEgCxsiBiAISiAIQXtKcSIDGyAGaiELQX9BfiADGyAFaiEFIARBCHEiEA0AQQkhBgJAIApFDQAgDUF8aigCACIPRQ0AQQohA0EAIQYgD0EKcA0AA0AgBkEBaiEGIA8gA0EKbCIDcEUNAAsLIA0gDmtBAnVBCWxBd2ohAyAFQSByQeYARgRAQQAhECALIAMgBmsiA0EAIANBAEobIgMgCyADSBshCwwBC0EAIRAgCyADIAhqIAZrIgNBACADQQBKGyIDIAsgA0gbIQsLIAsgEHIiFUEARyEUIABBICACAn8gCEEAIAhBAEobIAVBIHIiD0HmAEYNABogESAIIAhBH3UiA2ogA3OtIBEQCSIGa0EBTARAA0AgBkF/aiIGQTA6AAAgESAGa0ECSA0ACwsgBkF+aiITIAU6AAAgBkF/akEtQSsgCEEASBs6AAAgESATawsgCyASaiAUampBAWoiDCAEEAIgACAWIBIQASAAQTAgAiAMIARBgIAEcxACAkACQAJAIA9B5gBGBEAgCUEQakEIciEDIAlBEGpBCXIhCCAOIAcgByAOSxsiBSEHA0AgBzUCACAIEAkhBgJAIAUgB0cEQCAGIAlBEGpNDQEDQCAGQX9qIgZBMDoAACAGIAlBEGpLDQALDAELIAYgCEcNACAJQTA6ABggAyEGCyAAIAYgCCAGaxABIAdBBGoiByAOTQ0ACyAVBEAgAEHTyQBBARABCyALQQFIIAcgDU9yDQEDQCAHNQIAIAgQCSIGIAlBEGpLBEADQCAGQX9qIgZBMDoAACAGIAlBEGpLDQALCyAAIAYgC0EJIAtBCUgbEAEgC0F3aiEGIAdBBGoiByANTw0DIAtBCUohAyAGIQsgAw0ACwwCCwJAIAtBAEgNACANIAdBBGogChshBSAJQRBqQQhyIQMgCUEQakEJciEOIAchCANAIA4gCDUCACAOEAkiBkYEQCAJQTA6ABggAyEGCwJAIAcgCEcEQCAGIAlBEGpNDQEDQCAGQX9qIgZBMDoAACAGIAlBEGpLDQALDAELIAAgBkEBEAEgBkEBaiEGIBBFQQAgC0EBSBsNACAAQdPJAEEBEAELIAAgBiAOIAZrIgYgCyALIAZKGxABIAsgBmshCyAIQQRqIgggBU8NASALQX9KDQALCyAAQTAgC0ESakESQQAQAiAAIBMgESATaxABDAILIAshBgsgAEEwIAZBCWpBCUEAEAILDAELIBZBCWogFiAFQSBxIg4bIQ0CQCADQQtLDQBBDCADayIGRQ0ARAAAAAAAACBAIRkDQCAZRAAAAAAAADBAoiEZIAZBf2oiBg0ACyANLQAAQS1GBEAgGSABmiAZoaCaIQEMAQsgASAZoCAZoSEBCyARIAkoAiwiBiAGQR91IgZqIAZzrSAREAkiBkYEQCAJQTA6AA8gCUEPaiEGCyASQQJyIQsgCSgCLCEIIAZBfmoiDyAFQQ9qOgAAIAZBf2pBLUErIAhBAEgbOgAAIARBCHEhCCAJQRBqIQcDQCAHIgUCfyABmUQAAAAAAADgQWMEQCABqgwBC0GAgICAeAsiBkGgyQBqLQAAIA5yOgAAIAVBAWoiByAJQRBqa0EBRyAIIANBAEpyRUEAIAEgBrehRAAAAAAAADBAoiIBRAAAAAAAAAAAYRtyRQRAIAVBLjoAASAFQQJqIQcLIAFEAAAAAAAAAABiDQALIABBICACIAsgESAJQRBqayAPayAHaiADIBFqIA9rQQJqIANFIAcgCWtBbmogA05yGyIDaiIMIAQQAiAAIA0gCxABIABBMCACIAwgBEGAgARzEAIgACAJQRBqIAcgCUEQamsiBRABIABBMCADIAUgESAPayIDamtBAEEAEAIgACAPIAMQAQsgAEEgIAIgDCAEQYDAAHMQAiAJQbAEaiQAIAIgDCAMIAJIGwugAgACQAJAIAFBFEsNACABQXdqIgFBCUsNAAJAAkACQAJAAkACQAJAAkAgAUEBaw4JAQIJAwQFBgkHAAsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgACACEC0LDwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC0IBA38gACgCACwAABALBEADQCAAKAIAIgIsAAAhAyAAIAJBAWo2AgAgAyABQQpsakFQaiEBIAIsAAEQCw0ACwsgAQt+AgF/AX4gAL0iA0I0iKdB/w9xIgJB/w9HBHwgAkUEQCABIABEAAAAAAAAAABhBH9BAAUgAEQAAAAAAADwQ6IgARAxIQAgASgCAEFAags2AgAgAA8LIAEgAkGCeGo2AgAgA0L/////////h4B/g0KAgICAgICA8D+EvwUgAAsLEgAgAEUEQEEADwsgACABEJEBC+sGAQh/IAAtAAAhAyMAQTBrIgQCfyABQQRGBEAgAC0AAiEGIAAtAAMhASAEIAAtAAEiBUHwAXEgBUEEdnI2AhAgBCAFQQ9xIgVBBHQgBXI2AgAgBCADQQF2QQxxIANBA3FyIgNBBHQgA3I2AiAgBCAGQfABcSAGQQR2ciIDNgIoIAQgAUEBdkEGcSABQQFxckECdEHAJGooAgAiB0H/AWoiBSADakGAGmotAAA2AiQgBCAGQQ9xIgZBBHQgBnIiBjYCGCAEIAUgBmpBgBpqLQAANgIUIAQgAUHwAXEgAUEEdnIiATYCCCAEIAEgBWpBgBpqLQAANgIEIAQgA0H/ASAHayIDakGAGmotAAA2AiwgBCADIAZqQYAaai0AADYCHCABIANqDAELIAQgA0EDdkEPcSIBQQR0IAFyIgYgAC0AAyIBQQF0QQJxIAFBBHFyIAAtAAEiBUEEdkEBcSADQQF0QQ5xciIDQQR0IANyIgNBCHQgBkEQdHIgBUEBdEEGcSAFQQhxciAALQACIgVBB3ZyIgdBBHQgB3IiB3IgAUEDdkEPcSIIQQR0IAhyIgggBUEDdkEPcSIJQQR0IAlyIglBEHRyIAVBAXRBDnEgAUEHdnIiAUEEdCABciIFQQh0ck5yQQJ0QcAkaigCACIKa0H/G2otAAA2AiQgBCAKQf8BaiIBIANqQYAaai0AADYCECAEIAEgBmpBgBpqLQAANgIgIAQgASAHakGAGmotAAA2AgAgBCADQf8BIAprIgNqQYAaai0AADYCFCAEIAMgB2pBgBpqLQAANgIEIAQgASAJakGAGmotAAA2AiggBCABIAVqQYAaai0AADYCGCAEIAEgCGpBgBpqLQAANgIIIAQgAyAJakGAGmotAAA2AiwgBCADIAVqQYAaai0AADYCHCADIAhqC0GAGmotAAA2AgwgACgABCIAQRh0IABBCHRBgID8B3FyIABBCHZBgP4DcSAAQRh2cnIhA0EAIQADQCAAQRBHBEAgAiAAQQJ0QQxxIABBAnZyQQJ0akEBIAB0IANxIAB2QYCABCAAdCADcSAAQQ9qdnJBAnQiASAEQSBqaigCACAEQRBqIAFqKAIAQQh0ciABIARqKAIAQRB0ckGAgIB4ciABQeAlaigCAHE2AgAgAEEBaiEADAELCwvuAwEOfyAALQAEIgVBBXRBIHEgAC0ABSIGQQN2ciICQQJ0IAJBBHZyIAAtAAEiA0EFdEEgcSAALQACIgJBGHFyIgQgAkEBdEEGcXIgAC0AAyICQQd2ckECdCAEQQR2ciIEayEJIAAtAAYiB0ECdEH8AHEgAC0AByIIQQZ2ckEBdCAHQQR2QQFxciADQf4AcSAALQAAIgBBBnRBwABxIgNBAXRyIANBBnZyIgNrIQogBUH+AXEgBUEHdnIgA2shBSAGQQF2QQNxIAZBA3RBOHEgB0EFdnJBAnRyIABBAXRB/AFxIABBBXZBA3FyIgBrIQYgAkEFdkEDcSACQQF2QT5xIAJBAXFyQQJ0ciAAayEHIAhBAnRB/AFxIAhBBHZBA3FyIARrIQggBEECdEECciEEIABBAnRBAnIhCyADQQJ0QQJyIQNBACECA0AgAkEERwRAIAJBAnQhDCAEIAIgCGxqIQ0gAyACIApsaiEOIAsgAiAGbGohD0EAIQADQCAAQQRGBEAgAkEBaiECDAMFIAEgACAMakECdGogDyAAIAdsakECdUH/G2otAAAgDiAAIAVsakECdUH/G2otAABBCHRyIA0gACAJbGpBAnVB/xtqLQAAQRB0ckGAgIB4cjYCACAAQQFqIQAMAQsAAAsACwsL3AQCA38DfkEAIQICQCAALQAAIgFBgAFGDQAgADEAByAALQABIgKtQv8Bg0IwhiABrUI4hoQgADEAAkIohoQgADEAA0IghoQgADEABEIYhoQgADEABUIQhoQgADEABkIIhoSEIQggAUEYdEEYdUEDdCEEIAJBAXZB+ABxIgFBASABGyEFIAJBD3FBA3QhAgNAIAdCEFFFBEAgAyAHpyIGQQJ0QQxxIAZBAnZyQQJ0agJ/IAJCgICAgICAOCAHQgN+IgmIIAiDQi0gCX2Ip2pBoCJqLAAAIAVsIARqIgFB/wcgAUH/B0gbIgFBgXggAUGBeEobIgFBAE4EQCABQQV0IAFBBXZyDAELQQBBACABayIBQQV0IAFBBXVyaws7AQAgB0IBfCEHDAELC0EAIQIgAC0ACCIBQYABRg0AIAAxAA8gAC0ACSIErUL/AYNCMIYgAa1COIaEIAAxAApCKIaEIAAxAAtCIIaEIAAxAAxCGIaEIAAxAA1CEIaEIAAxAA5CCIaEhCEIIAFBGHRBGHVBA3QhBUEBIQIgBEEBdkH4AHEiAEEBIAAbIQZCACEHIARBD3FBA3QhBANAIAdCEFENAQJ/IARCgICAgICAOCAHQgN+IgmIIAiDQi0gCX2Ip2pBoCJqLAAAIAZsIAVqIgBB/wcgAEH/B0gbIgBBgXggAEGBeEobIgBBAE4EQCAAQQV0IABBBXZyDAELQQBBACAAayIAQQV0IABBBXVyawshASADIAenIgBBAnRBDHEgAEECdnJBAnRBAnJqIAE7AQAgB0IBfCEHDAAACwALIAILsAICAn8DfkEAIQECQCAALQAAIgJBgAFGDQAgADEAByAALQABIgStQv8Bg0IwhiACrUI4hoQgADEAAkIohoQgADEAA0IghoQgADEABEIYhoQgADEABUIQhoQgADEABkIIhoSEIQcgAkEYdEEYdUEDdCECQQEhASAEQQF2QfgAcSIAQQEgABshBSAEQQ9xQQN0IQQDQCAGQhBRDQEgAyAGpyIAQQJ0QQxxIABBAnZyQQF0agJ/IARCgICAgICAOCAGQgN+IgiIIAeDQi0gCH2Ip2pBoCJqLAAAIAVsIAJqIgBB/wcgAEH/B0gbIgBBgXggAEGBeEobIgBBAE4EQCAAQQV0IABBBXZyDAELQQBBACAAayIAQQV0IABBBXVyaws7AQAgBkIBfCEGDAAACwALIAEL5wMCAn8DfiAAMQAHIAAtAAEiAa1CMIYgAC0AACICrUI4hoQgADEAAkIohoQgADEAA0IghoQgADEABEIYhoQgADEABUIQhoQgADEABkIIhoSEIQcgAkEDdEEEciECIAFBAXZB+ABxIgRBASAEGyEEIAFBD3FBA3QhAQNAIAZCEFFFBEAgAyAGpyIFQQJ0QQxxIAVBAnZyQQJ0aiABQoCAgICAgDggBkIDfiIIiCAHg0ItIAh9iKdqQaAiaiwAACAEbCACaiIFQf8PIAVB/w9IGyIFQQAgBUEAShsiBUEFdCAFQQZ2cjsBACAGQgF8IQYMAQsLIAAxAA8gAC0ACSIBrUIwhiAALQAIIgKtQjiGhCAAMQAKQiiGhCAAMQALQiCGhCAAMQAMQhiGhCAAMQANQhCGhCAAMQAOQgiGhIQhByACQQN0QQRyIQAgAUEBdkH4AHEiAkEBIAIbIQJCACEGIAFBD3FBA3QhAQNAIAZCEFFFBEAgAyAGpyIEQQJ0QQxxIARBAnZyQQJ0QQJyaiABQoCAgICAgDggBkIDfiIIiCAHg0ItIAh9iKdqQaAiaiwAACACbCAAaiIEQf8PIARB/w9IGyIEQQAgBEEAShsiBEEFdCAEQQZ2cjsBACAGQgF8IQYMAQsLQQEL9AECAX8DfiAAMQAHIAAtAAEiAa1CMIYgAC0AACICrUI4hoQgADEAAkIohoQgADEAA0IghoQgADEABEIYhoQgADEABUIQhoQgADEABkIIhoSEIQYgAkEDdEEEciEAIAFBAXZB+ABxIgJBASACGyECIAFBD3FBA3QhAQNAIAVCEFFFBEAgAyAFpyIEQQJ0QQxxIARBAnZyQQF0aiABQoCAgICAgDggBUIDfiIHiCAGg0ItIAd9iKdqQaAiaiwAACACbCAAaiIEQf8PIARB/w9IGyIEQQAgBEEAShsiBEEFdCAEQQZ2cjsBACAFQgF8IQUMAQsLQQELnQUCBH8EfgJAIABBCGogASACIAMQH0UNAEEAIAJBAXEgAC0AASIHQQR2IgEbDQAgADEAByELIAAxAAYhCCAAMQAFIQkgAC0AAyEFIAAtAAQhBiADIAAtAABB/wFqIgIgASAHQQ9xQQN0QaAiaiIEIAAtAAIiAEEFdmosAABsakGAGmotAAA6AAMgAyABIAQgBkEHcWosAABsIAJqQYAaai0AADoANyADIAEgBCAFQQR2QQdxaiwAAGwgAmpBgBpqLQAAOgAzIAMgASAEIABBAnZBB3FqLAAAbCACakGAGmotAAA6ABMgAyABIAQgBkEDdkEHcWosAABsIAJqQYAaai0AADoAJyADIAEgBCAFQQF2QQdxaiwAAGwgAmpBgBpqLQAAOgAHIAMgASAEIAWtQiCGIACtQiiGhCIKQieIp0EHcWosAABsIAJqQYAaai0AADoAIyADIAEgBCAKIAatQhiGhCIKQh6Ip0EHcWosAABsIAJqQYAaai0AADoAFyADIAEgBCAKIAlCEIaEIgmnIgBBEnZBB3FqLAAAbCACakGAGmotAAA6ABsgAyABIAQgAEEVdkEHcWosAABsIAJqQYAaai0AADoACyADIAEgBCAJIAhCCIaEIginIgBBDHZBB3FqLAAAbCACakGAGmotAAA6ADsgAyABIAQgAEEPdkEHcWosAABsIAJqQYAaai0AADoAKyADIAEgBCAIIAuEpyIFQQdxaiwAAGwgAmpBgBpqLQAAOgA/IAMgASAEIABBCXZBB3FqLAAAbCACakGAGmotAAA6AA8gAyABIAQgBUEDdkEHcWosAABsIAJqQYAaai0AADoALyADIAEgBCAFQQZ2QQdxaiwAAGwgAmpBgBpqLQAAOgAfQQEhBAsgBAv4AwEMfwJAQcsBIAJ2QQFxRQRAIAFBAXQhAQwBCyABQQF0IgFBACABQQBKGyEIIAMgAygCECIEQT9KQQN0aikDACAEIARBQGogBEHAAEgbrYinIQcDQCAFIAhGBEAgAyABIARqNgIQBSAAIAVBAnQiBkEDcmoiCS0AACEKIAAgBkECcmoiCy0AACEMIAAgBkEBcmoiDS0AACEOIAAgBmoiDyAHQQFxIgYgDy0AAEEBdHI6AAAgDSAOQQF0IAZyOgAAIAsgDEEBdCAGcjoAACAJIApBAXQgBnI6AAAgBUEBaiEFIAdBAXYhBwwBCwsLQQAhBSABQQAgAUEAShshB0EIIAJBkCJqLQAAIgZrIQhBCCACQYgiai0AACIBayEDA0AgBSAHRgRAAkAgAkEETg0AQQAhBQNAIAUgB0YNASAAIAVBAnRBA3JqQf8BOgAAIAVBAWohBQwAAAsACwUgACAFQQJ0IgRBA3JqIgktAAAhCiAAIARBAnJqIgstAAAhDCAAIARBAXJqIg0tAAAhDiAAIARqIgQgBC0AACADdCIEQf8BcSABdiAEcjoAACANIA4gA3QiBEH/AXEgAXYgBHI6AAAgCyAMIAN0IgRB/wFxIAF2IARyOgAAIAkgCiAIdCIEQf8BcSAGdiAEcjoAACAFQQFqIQUMAQsLCwkAQfTTACgCAAu9BQIKfwR+IABB8CFqLAAAIgZBACAGQQBKGyEJIAFBACABQQBKGyEIIAFBAXQhCyACKQMAIhAgAigCECIMrYghDkF/IABB+CFqLQAAIgd0QX9zIQogB60hDwJAAn4DQAJAQQAhBAJAAkAgBSAJRgRAIAIgByALbCIHIAZsIAxqIgU2AhAgAEF8akECSw0BIABBgCJqLQAAIQEMAwsDQCAEIAhGDQIgBEEDdCAFaiENQQAhAQNAIAFBAkYEQCAEQQFqIQQMAgUgAyANIAFBAnRqaiAOpyAKcToAACABQQFqIQEgDiAPiCEODAELAAALAAALAAsgAikDCCIRQcAAIAVrrYYgECAFrYiEIQ4DQCAEIAhHBEAgBEEDdCAGaiEJQQAhAQNAIAFBAkYEQCAEQQFqIQQMAwUgAyAJIAFBAnRqaiAOpyAKcToAACABQQFqIQEgDiAPiCEODAELAAALAAsLIAIgBSAHaiIFNgIQIABBf2pBAk0EQCARIAVBQGqtiCEOQQAhBANAIAQgCEcEQCAEQQN0IQZBACEBA0AgAUECRgRAIARBAWohBAwDBSADIAFBAnQgBmpBAnJqIA6nIApxOgAAIAFBAWohASAOIA+IIQ4MAQsAAAsACwsgAiAFIAdqIgU2AhALIABBBEkNBCAAQYAiai0AACEBIABBB0cNASACKQMIIAVBQGqtiAwDCyAFQQFqIQUMAQsLIBAgBa2IIg4gAEEFRw0AGiACKQMIQg6GQoCAA4MgDoQLIQ4gAa1C/wGDIQ9BfyABQf8BcSIEdEH/AXOtIRBBACEAA0AgACAIRwRAIABBA3QhBkEAIQEDQCABQQJGBEAgAEEBaiEADAMFIAMgAUECdCAGakEDcmogDiAQgzwAACABQQFqIQEgDiAPiCEODAELAAALAAsLIAIgBSAEIAtsajYCEAsL7AYCBn8CfiMAQdAAayICJAAgACkDCCEJIAIgACkDACIIpyIAQRp2OgBNIAIgAEEUdkE/cToASiACIABBDnZBP3E6AEcgAiAAQQh2QT9xOgBEIAIgCEIyiKdBP3E6AE4gAiAIQiyIp0E/cToASyACIAhCJoinQT9xOgBIIAIgCEIgiKdBP3E6AEUgAiAJpyIEQQp2QT9xOgBPIAIgBEEEdkE/cToATCACIARBAnRBPHE6AEkgAiAIQjiIp0E/cToARiAIQgKIpyEFQQAhAANAIABBBEYEQCAFQT9xIQUgBEEQdkECcSEGIARBD3ZBAnEhB0EAIQNBACEEA0AgBEEDRgRAA0AgA0EERgRAIAVBBHQhA0EAIQADQCAAQRBGBEBBACEAIAJBADoALiACIAVBgBhqLQAAOgAvIAlCEoghCANAIABBEEYEQAJAQQAhAwNAIANBEEYNASACQTBqIANqLQAAIgBBBmwhBCAAQQF0QQFyQQNsIQVBACEAA0AgAEEDRgRAIAEgA0ECdGogAi0ADSACLQAKIAJBEGogA2otAAAiAEEDEAcgAi0ADiACLQALIABBAxAHQQh0ciACLQAPIAItAAwgAEEDEAdBEHRyQYCAgHhyNgIAIANBAWohAwwCBSACQQ1qIABqIAJBxABqIAAgBGpqLQAAOgAAIAJBCmogAGogAkHEAGogACAFamotAAA6AAAgAEEBaiEADAELAAALAAALAAsFIAJBEGogAGogCKdBA0EHIAAgAkEwaiAAai0AACACQS5qai0AAEYiAxtxOgAAIABBAWohACAIQgJCAyADG4ghCAwBCwsgAkHQAGokAAUgAkEwaiAAaiAAIANqQYAIai0AADoAACAAQQFqIQAMAQsLBSACQcQAaiADQQNsaiIAIAAtAAAiBEEHdiAEcjoAACAAIAAtAAEiBEEHdiAEcjoAASAAIAAtAAIiAEEHdiAAcjoAAiADQQFqIQMMAQsLBSACQcQAaiAEaiIAIAAtAAAgB3I6AAAgACAALQADIAdyOgADIAAgAC0ABiAGcjoABiAAIAAtAAkgBnI6AAkgBEEBaiEEDAELCwUgAkHEAGogAEEDbGoiAyADLQAAQQJ0OgAAIAMgAy0AAUECdDoAASADIAMtAAJBAnQ6AAIgAEEBaiEADAELCws3AQN+IAApAwAhAwNAIAEiAkIIUQRAQX8PCyACQgF8IQEgAyACiEIBg1ANAAsgACABPgIQIAKnC7EKAgt/Bn4jAEGAAWsiBCQAIAQgACkDADcDaCAAKQMIIRBBACEAIARBADYCeCAEIBA3A3AgBEHoAGoQPiIFQX9GIAEgBXZBAXFFciACQQJxQQAgBUEDShtyIAJBBHFBACAFQQRIG3JFBEBBASECAkAgBUEBRgRAIARB6ABqIAMQPQwBCyAFQXxqQQNPBEAgBUHIIWotAAAhAiAEQegAaiAFQdAhai0AABAPIQYLIARB6ABqIAVB2CFqLQAAEA8hDSAFQQRGBEAgBEHoAGpBARAPIQcLIAUgAiAEQegAaiAEQdAAahA8IARB0ABqIAIgBSAEQegAahA6QYAIQYAQIAJBAkYbIQggBkEEdCEJIAVB6CFqLQAAIQsgBUHgIWotAAAhDCACQQFGIQoDQCAAQRBGBEAgBkGAGGohCCAGQcAYaiEJIAZBgBlqIQZBACEAIAJBAkYhCgJAA0AgACACRgRAAkAgBCgCeCIAQT9MDQAgBCkDcCAAQUBqrYghDyAFQeghai0AACIBrSIQQn98Qv////8PgyERQQAhAANAIABBEEYNBCAEQSBqIABqIA9BfyABIAAgBEFAayAAai0AACAEQTxqai0AAEYiAmt0QX9zrYOnIgY6AAAgBEEQaiAAaiAGOgAAIABBAWohACAPIBEgECACG4ghDwwAAAsACwUgBEE8aiAAaiAABH8gCCAJIAYgAEEBRhsgChstAAAFQQALOgAAIABBAWohAAwBCwsgBCkDcCIQQg6GIAQpA2hCMoiEIQ8gBEEQaiAEQSBqIAcbIQFBACEAA34gAEEQRgR+IBBCEYgFIAAgAWogD6dBAUEDIAAgBEFAayAAai0AACAEQTxqai0AAEYiAhtxOgAAIABBAWohACAPQgFCAiACG4ghDwwBCwshDwsCQCAFQQFyQQVHDQAgBUHAIWotAAAiAK0iEUJ/fEL/////D4MhEkF/IAB0Qf8Bc60hE0F/IABBf2p0Qf8Bc60hFEEAIQADQCAAQRBGDQECfyAEQUBrIABqLQAAIARBPGpqLQAAIABGBEAgBwRAQgIhECAEQSBqIQIgD6dBA3EMAgsgBEEQaiECIBIhECAPIBSDpwwBCyAHBEBCAyEQIARBIGohAiAPp0EHcQwBCyAEQRBqIQIgESEQIA8gE4OnCyEBIAAgAmogAToAACAAQQFqIQAgDyAQiCEPDAAACwALIAcgC2pB/wFxIQEgDCAHa0H/AXEhCCANQX9qIglBAUshC0EAIQIDQCACQRBGDQMgBEFAayACai0AAEEDdCIFQQRyIQdBACEAIAMgAkECdGoCfwNAIABBBEYEQAJAIAQtAAwgBC0ACCAEQSBqIAJqLQAAIgAgARAHIgcgBC0ADSAELQAJIAAgARAHIgxBCHQiCnIhBiAELQAOIAQtAAogACABEAciDkEQdCEFIAQtAA8gBC0ACyAEQRBqIAJqLQAAIAgQByEAIA1BAEoNACAFIAZyIABBGHRyDAMLBSAEQQxqIABqIARB0ABqIAAgBWpqLQAAOgAAIARBCGogAGogBEHQAGogACAHamotAAA6AAAgAEEBaiEADAELCyALRQRAIAogB0EYdHIgBXIgAHIgCUEBaw0BGiAMQRh0IAdyIAVyIABBCHRyDAELIAYgDkEYdHIgAEEQdHILNgIAIAJBAWohAgwAAAsABUEAIQEgBEFAayAAaiAKBH9BAAUgCCAAIAlqai0AAAs6AAAgAEEBaiEADAELAAALAAtBASEACyAEQYABaiQAIAALDAAgACABQQEgAxAgCygBAX8gAEECEA8iAUECTwR/IABBAxAPQQJ0IAFyQaAhaiwAAAUgAQsLCQBB8NMAKAIACwwAIAAgAUEAIAMQIAuNBgIPfwJ+IwBBMGshBAJAIAJBAnFBACAALQAAIgUgAC0AASIGSxsNACACQQFxQQAgACgCCCIBQf//A3EgAUEQdk0bDQAgBCABQQh2QfgBcSICNgIgIAQgAUEYdkH4AXEiBzYCJCAEIAJBAXQgB2pB8CVqLQAANgIoIAQgAUEDdkH8AXEiCTYCECAEIAFBE3ZB/AFxIgo2AhQgBCAJQQF0IApqQfAlai0AADYCGCAEIAFBA3RB+AFxIgg2AgAgBCABQQ12QfgBcSIBNgIEIAQgCEEBdCABakHwJWotAAA2AgggBCAHQQF0IAJqQfAlai0AADYCLCAEIApBAXQgCWpB8CVqLQAANgIcIAQgAUEBdCAIakHwJWotAAA2AgwgADMAAiAANQIEQhCGhCEUIAAoAgwhB0EAIQAgBUEGbCAGakHwK2ohCSAGQQF0IgEgBUEFbGpB8CtqIQogBkEDbCICIAVBAnQiCGpB8CtqIQ4gBkECdCILIAVBA2wiDGpB8CtqIQ8gBUEBdCINIAZBBWxqQfAraiEQIAZBBmwgBWpB8CtqIREgBiAIakHwOWohCCABIAxqQfA5aiEMIAIgDWpB8DlqIQ0gBSALakHwOWohCwN/IBNCEFEEf0EBBSAUIBNCA36Ip0EHcSECIAcgE6dBAXR2QQNxIRICQAJAAkACQAJAAkACQAJAIAUgBksEQCAFIQECQAJAAkACQAJAAkAgAkEBaw4HBwABAgMEBQ4LIAktAAAhAQwNCyAKLQAAIQEMDAsgDi0AACEBDAsLIA8tAAAhAQwKCyAQLQAAIQEMCQsgES0AACEBDAgLIAUhASACQQFrDgcAAQIDBAUGBwsgBiEBDAYLIAgtAAAhAQwFCyAMLQAAIQEMBAsgDS0AACEBDAMLIAstAAAhAQwCC0EAIQEMAQtB/wEhAQsgAyAAQQJ0aiASQQJ0IgIgBEEganIoAgAgAUEYdHIgBEEQaiACcigCAEEIdHIgAiAEcigCAEEQdHI2AgAgAEEBaiEAIBNCAXwhEwwBCwshBwsgBwuNAwIFfwJ+IwBBMGshASAAKAIIIQQCfyACQQFxBEBBACAEQf//A3EgBEEQdk0NARoLIAEgBEEIdkH4AXEiAjYCICABIARBGHZB+AFxIgU2AiQgASACQQF0IAVqQfAlai0AADYCKCABIARBA3ZB/AFxIgY2AhAgASAEQRN2QfwBcSIHNgIUIAEgBkEBdCAHakHwJWotAAA2AhggASAEQQN0QfgBcSIINgIAIAEgBEENdkH4AXEiBDYCBCABIAhBAXQgBGpB8CVqLQAANgIIIAEgBUEBdCACakHwJWotAAA2AiwgASAHQQF0IAZqQfAlai0AADYCHCABIARBAXQgCGpB8CVqLQAANgIMIAApAwAhCiAAKAIMIQRBACEAA38gCUIQUQR/QQEFIAMgAEECdGogBCAJp0EBdHZBA3FBAnQiAiABQSBqcigCACAKIAlCAoaIp0EPcUGAgICIAWxyIAFBEGogAnIoAgBBCHRyIAEgAnIoAgBBEHRyNgIAIABBAWohACAJQgF8IQkMAQsLCwvvAwEIfyMAQUBqIQEgACgCACIEQRB2IQYgAkEEcUEAIARB//8DcSIHIAZLGyACQQJxQQAgByAGTRtyBH9BAAUgASAEQQN0QfgBcSICNgIQIAEgBEEDdkH8AXEiBTYCICABIARBCHZB+AFxIgg2AjAgASAEQQ12QfgBcSIJNgIUIAEgBEETdkH8AXEiCjYCJCABIARBGHZB+AFxIgQ2AjQgAUL/gYCA8B83AwggAUL/gYCA8B83AwACfyAHIAZLBEAgCUEBdCACakHwJWotAAAhBiAKQQF0IAVqQfAlai0AACEHIARBAXQgCGpB8CVqLQAAIQsgBUEBdCAKakHwJWotAAAhBSAIQQF0IARqQfAlai0AACEEIAJBAXQgCWpB8CVqLQAADAELIAFBADYCDCAFIApqQQF2IQUgBCAIakEBdiEEQQAhB0EAIQYgAiAJakEBdgshAiABIAU2AiggASAENgI4IAEgAjYCGCABIAs2AjwgASAHNgIsIAEgBjYCHCAAKAIEIQJBACEEA38gBEEQRgR/QQEFIAMgBEECdGogAiAEQQF0dkEDcUECdCIAIAFBIGpyKAIAQQh0IAFBMGogAHIoAgByIAFBEGogAHIoAgBBEHRyIAAgAXIoAgBBGHRyNgIAIARBAWohBAwBCwsLC5YDAQh/IwBBMGsiASAAKAIAIgJBA3ZB/AFxIgY2AhAgASACQQh2QfgBcSIENgIgIAEgAkETdkH8AXEiBzYCFCABIAJBGHZB+AFxIgg2AiQgASACQQN0QfgBcSIFNgIAIAEgAkENdkH4AXEiCTYCBCABAn8gAkH//wNxIAJBEHZLBEAgCUEBdCAFakHwJWotAAAhAiAHQQF0IAZqQfAlai0AACEKIAhBAXQgBGpB8CVqLQAAIQsgBUEBdCAJakHwJWotAAAhBSAEQQF0IAhqQfAlai0AACEEIAZBAXQgB2pB8CVqLQAADAELIAUgCWpBAXYhBSAEIAhqQQF2IQRBACECIAYgB2pBAXYLNgIYIAEgBDYCKCABIAU2AgggASALNgIsIAEgCjYCHCABIAI2AgwgACgCBCEGQQAhAgN/IAJBEEYEf0EBBSADIAJBAnRqIAYgAkEBdHZBA3FBAnQiACABQSBqcigCACABQRBqIAByKAIAQQh0ciAAIAFyKAIAQRB0ckGAgIB4cjYCACACQQFqIQIMAQsLC1cBAX9B8NEAQbQGNgIAQezRACAANgIAQfTRACABNgIAIAFBACABQQBKGyEAA0AgACADRwRAIANBAnQiAUGA1ABqIAEgAmooAgA2AgAgA0EBaiEDDAELCwsoAQF/A0AgASAAKAIYSARAIAAgAUECdGooAgAQEiABQQFqIQEMAQsLC9wJAQt/AkAgAEG0BkYNAAJAQezRACgCACAARw0AQfDRACgCAEG0BkcNAEH00QAoAgAiA0EAIANBAEobIQADQCAAIAJGDQIgASACQQJ0IgRqIARBgNQAaigCADYCACACQQFqIQIMAAALAAsCQAJAA0AgAkHJAEYNAQJAIAJBDGwiA0GEywBqKAIAQbQGRgRAIANBgMsAaigCACAARg0BCyACQQFqIQIMAQsLIAEgAjYCAEEBIQMMAQtBCEEIIABBA3EiAnQgAEENdkEBcUECQQEgAkECRhtsQQVsayICQQggAkgbIQZBAyAAQQR2QQNxIgJBAyACSRshB0EAIQMDQAJAIANByQBGBEBBACEEDAELAkAgA0EMbCICQYTLAGooAgBBtAZHDQAgAkGAywBqIgQoAgAiAkEEdkEDcSAHSA0AQQggAkEDcSIFdCACQQ12QQFxQQJBASAFQQJGG2xBBWxrIAZJDQAgASADNgIEIAQoAgAhBEEAIQIDQCACQckARg0BAkAgBCACQQxsIgVBhMsAaigCAEYEQCAFQYDLAGooAgAgAEYNAQsgAkEBaiECDAELCyABIAI2AgBBAiEDDAMLIANBAWohAwwBCwsDQCAEQckARgRAQQAhBQNAIAVByQBGBEBBfw8LAkACQCAFQQxsIgJBgMsAaigCACAARw0AIAJBhMsAaiIIKAIAIgJBBHZBA3EgB0gNAEEIIAJBA3EiA3QgAkENdkEBcUECQQEgA0ECRhtsQQVsayAGSQ0AIAEgBTYCAEEAIQQDQCAEQckARg0BAkAgBEEMbCICQYTLAGooAgBBtAZHDQAgAkGAywBqIgkoAgAiAkEEdkEDcSAHSA0AQQggAkEDcSIDdCACQQ12QQFxQQJBASADQQJGG2xBBWxrIAZJDQAgASAENgIMQQAhAwNAIANByQBGDQECQCADQQxsIgJBgMsAaigCACAIKAIARw0AIAJBhMsAaiILKAIAIgJBBHZBA3EgB0gNAEEIIAJBA3EiCnQgAkENdkEBcUECQQEgCkECRhtsQQVsayAGSQ0AIAEgAzYCBCAJKAIAIQpBACECA0AgAkHJAEYNASAKIAJBDGwiDEGEywBqKAIARgRAIAxBgMsAaigCACALKAIARg0HCyACQQFqIQIMAAALAAsgA0EBaiEDDAAACwALIARBAWohBAwAAAsACyAFQQFqIQUMAQsLIAEgAjYCCEEEIQMMAgsCQCAEQQxsIgJBgMsAaigCACAARw0AIAJBhMsAaiIFKAIAIgJBBHZBA3EgB0gNAEEIIAJBA3EiA3QgAkENdkEBcUECQQEgA0ECRhtsQQVsayAGSQ0AIAEgBDYCAEEAIQMDQCADQckARg0BAkACQCADQQxsIgJBhMsAaigCAEG0BkcNACACQYDLAGoiCCgCACICQQR2QQNxIAdIDQBBCCACQQNxIgl0IAJBDXZBAXFBAkEBIAlBAkYbbEEFbGsgBkkNACABIAM2AgggCCgCACEIQQAhAgNAIAJByQBGDQEgCCACQQxsIglBhMsAaigCAEYEQCAJQYDLAGooAgAgBSgCAEYNAwsgAkEBaiECDAAACwALIANBAWohAwwBCwsgASACNgIEQQMhAwwCCyAEQQFqIQQMAAALAAsgACADIAEQSAsgAwtzAQF/IwBBIGsiAyQAIAMgADYCDCADQbSGgNwANgIIIAMgAjYCFCADIAJBBG02AhwgAyABNgIQIAMgAUEEbTYCGCADQQhqIAEgAmxBAnQiABAEIgEQDSECQfTTACAANgIAQfDTACABNgIAIANBIGokACACC0wCAX8BfiABQQAgAUEAShshAQNAIAEgA0cEQCAAKQIAIQQgAiAAKAIINgIIIAIgBDcCACADQQFqIQMgAkEMaiECIABBEGohAAwBCwsLWwICfwF+IAFBACABQQBKGyEBA0AgASADRwRAIAApAgAhBSAAKAIIIQQgAkGAgID8AzYCDCACIAQ2AgggAiAFNwIAIANBAWohAyACQRBqIQIgAEEMaiEADAELCwtYAgF/AX5BACECIAFBACABQQBKGyEDA0AgAiADRwRAIAEgACkDACIEPQEAIAEgBEIgiD0BBCABIARCEIg9AQIgAkEBaiECIAFBBmohASAAQQhqIQAMAQsLC34CAn8BfiMAQRBrIgMkACADQYCAgPwDNgIIIANBCGpBASADQQ5qEA4gAUEAIAFBAEobIQEgAzMBDkIwhiEFA0AgASAERgRAIANBEGokAAUgAiAANQEAIAAzAQRCIIaEIAWENwMAIARBAWohBCACQQhqIQIgAEEGaiEADAELCwtSAQJ/IAFBACABQQBKGyEEA0AgAyAERwRAIAIgACgCACIBOgAAIAIgAUEQdjoAAiACIAFBCHY6AAEgA0EBaiEDIAJBA2ohAiAAQQRqIQAMAQsLC0sBAX8gAUEAIAFBAEobIQEDQCABIANHBEAgAiAALwAAIAAtAAJBEHRyQYCAgHhyNgIAIANBAWohAyACQQRqIQIgAEEDaiEADAELCwsLACAAIAFBAnQQFAsLACAAIAFBA2wQFAsLACAAIAFBAXQQFAtyAQF/IwBBIGsiAyQAIAMgADYCDCADQYCAgCg2AgggAyACNgIUIAMgAkEEbTYCHCADIAE2AhAgAyABQQRtNgIYIANBCGogASACbEECdCIAEAQiARANIQJB9NMAIAA2AgBB8NMAIAE2AgAgA0EgaiQAIAILCAAgACABEBQLDQAgACABQQJ0IAIQFwsNACAAIAFBA2wgAhAXCw0AIAAgAUEBdCACEBcLCgAgACABIAIQFwsNACAAIAFBAnQgAhAVCw0AIAAgAUEDbCACEBULDQAgACABQQF0IAIQFQsKACAAIAEgAhAVCwsAIAAgAUECdBAdC3IBAX8jAEEgayIDJAAgAyAANgIMIANBtIaAJDYCCCADIAI2AhQgAyACQQRtNgIcIAMgATYCECADIAFBBG02AhggA0EIaiABIAJsQQJ0IgAQBCIBEA0hAkH00wAgADYCAEHw0wAgATYCACADQSBqJAAgAgsLACAAIAFBAXQQHQsIACAAIAEQHQsLACAAIAFBA2wQFgsLACAAIAFBAXQQFgsIACAAIAEQFguDAgENfyMAQYAEayIHJABBICEFIAAhAgNAIAYgAUgEQCABIAUgBSABShsgCGoiA0EAIANBAEobIgtBAnQhDCABIAZrQSAgBkEgaiIGIAFKGyEKQQAhCSAHIQQgACEDA0AgCSALRgRAIAcgCiACECQgCEFgaiEIIAVBIGohBSACIApBA3RqIQIgACAMQQF0aiEADAMFIAMuAQAhDSADLgECIQ4gAy4BBCEPIARBgICA/AM2AgwgBCAPskOAAIA3lDgCCCAEIA6yQ4AAgDeUOAIEIAQgDbJDgACAN5Q4AgAgCUEBaiEJIARBEGohBCADQQhqIQMMAQsAAAsACwsgB0GABGokAAv2AQEMfyMAQYAGayIHJABBwAAhBSAAIQIDQCAGIAFIBEAgASAFIAUgAUobIAhqIgNBACADQQBKGyILQQNsIQwgASAGa0HAACAGQUBrIgYgAUobIQpBACEJIAchBCAAIQMDQCAJIAtGBEAgByAKIAIQJSAIQUBqIQggBUFAayEFIAIgCkEGbGohAiAAIAxBAXRqIQAMAwUgAy8BACENIAMvAQIhDiAEIAMvAQSzQ4AAgDeUOAIIIAQgDrNDgACAN5Q4AgQgBCANs0OAAIA3lDgCACAJQQFqIQkgBEEMaiEEIANBBmohAwwBCwAACwALCyAHQYAGaiQAC3IBAX8jAEEgayIDJAAgAyAANgIMIANBtIaAHDYCCCADIAI2AhQgAyACQQRtNgIcIAMgATYCECADIAFBBG02AhggA0EIaiABIAJsQQJ0IgAQBCIBEA0hAkH00wAgADYCAEHw0wAgATYCACADQSBqJAAgAgvhAQELfyMAQYAEayIGJABBwAAhAyAAIQgDQCAEIAFIBEAgASADIAMgAUobIAdqIgJBACACQQBKGyILQQF0IQwgASAEa0HAACAEQUBrIgQgAUobIQpBACEJIAYhAiAAIQUDQCAJIAtGBEAgBiAKIAgQJiAHQUBqIQcgA0FAayEDIAggCkECdGohCCAAIAxBAXRqIQAMAwUgBS8BACENIAIgBS8BArNDgACAN5Q4AgQgAiANs0OAAIA3lDgCACAJQQFqIQkgAkEIaiECIAVBBGohBQwBCwAACwALCyAGQYAEaiQAC8cBAQl/IwBBgAJrIgIkAEHAACEEIAAhBwNAIAUgAUgEQCABIAQgBCABShsgBmoiA0EAIANBAEobIQogASAFa0HAACAFQUBrIgUgAUobIQtBACEIIAIhAyAAIQkDQCAIIApGBEAgAiALIAcQJyAGQUBqIQYgBEFAayEEIAcgC0EBdGohByAAIApBAXRqIQAMAwUgAyAJLwEAs0OAAIA3lDgCACAIQQFqIQggA0EEaiEDIAlBAmohCQwBCwAACwALCyACQYACaiQAC3cBAn8gAUEAIAFBAEobIQQDQCADIARHBEAgAiAAKAIAIgFBGHZBgQJsrUIwhiABQQh2Qf8BcUGAgIQIbCABQf8BcUGBAmxyrYQgAUEQdkH/AXFBgQJsrUIghoQ3AwAgA0EBaiEDIAJBCGohAiAAQQRqIQAMAQsLC3IBAn8gAUEAIAFBAEobIQQDQCADIARHBEAgAiAAKAIAIgFBEHZB/wFxQYECbK1CIIYgAUEIdkH/AXFBgICECGwgAUH/AXFBgQJscq2EQoCAgICAgECENwMAIANBAWohAyACQQhqIQIgAEEEaiEADAELCwtkAQN/IAFBACABQQBKGyEBA0AgASADRwRAIAAtAAAhBCAALQABIQUgAiAALQACQYECbDsBBCACIAVBgQJsOwECIAIgBEGBAmw7AQAgA0EBaiEDIAJBBmohAiAAQQNqIQAMAQsLC1IBAn8gAUEAIAFBAEobIQEDQCABIANHBEAgAiAALwEAIgRBCHZBgICECGwgBEH/AXFBgQJscjYCACADQQFqIQMgAkEEaiECIABBAmohAAwBCwsLQAEBfyABQQAgAUEAShshAQNAIAEgA0cEQCACIAAtAABBgQJsOwEAIANBAWohAyACQQJqIQIgAEEBaiEADAELCwuiAQICfwF+IAFBACABQQBKGyEBA0AgASADRwRAIAIgACkDACIFQjCIp0H/AWxBgf0BakH//wNuQRh0IAWnIgRB//8DcUH/AWxBgf0BakH//wNuciAEQRB2Qf8BbEGB/QFqQf//A25BCHRyIAVCIIinQf//A3FB/wFsQYH9AWpB//8DbkEQdHI2AgAgA0EBaiEDIAJBBGohAiAAQQhqIQAMAQsLC3IBAX8jAEEgayIDJAAgAyAANgIMIANBoIaACDYCCCADIAI2AhQgAyACQQRtNgIcIAMgATYCECADIAFBBG02AhggA0EIaiABIAJsQQJ0IgAQBCIBEA0hAkH00wAgADYCAEHw0wAgATYCACADQSBqJAAgAguFAQECfyABQQAgAUEAShshAQNAIAEgA0cEQCACIAAoAgAiBEH//wNxQf8BbEGB/QFqQf//A24gBEEQdkH/AWxBgf0BakH//wNuQQh0ciAALwEEQf8BbEGB/QFqQf//A25BEHRyQYCAgHhyNgIAIANBAWohAyACQQRqIQIgAEEIaiEADAELCwuCAQEDfyABQQAgAUEAShshAQNAIAEgA0cEQCAALwEAIQQgAC8BAiEFIAIgAC8BBEH/AWxBgf0BakH//wNuOgACIAIgBUH/AWxBgf0BakH//wNuOgABIAIgBEH/AWxBgf0BakH//wNuOgAAIANBAWohAyACQQNqIQIgAEEGaiEADAELCwtoAQJ/IAFBACABQQBKGyEBA0AgASADRwRAIAIgACgCACIEQRB2Qf8BbEGB/QFqQf//A25BCHQgBEH//wNxQf8BbEGB/QFqQf//A25yOwEAIANBAWohAyACQQJqIQIgAEEEaiEADAELCwtKAQF/IAFBACABQQBKGyEBA0AgASADRwRAIAIgAC8BAEH/AWxBgf0BakH//wNuOgAAIANBAWohAyACQQFqIQIgAEECaiEADAELCwtCAQF/IAFBACABQQBKGyEBA0AgASADRwRAIAIgAC8BAEGAgIB4cjYCACADQQFqIQMgAkEEaiECIABBAmohAAwBCwsLQgEBfyABQQAgAUEAShshAQNAIAEgA0cEQCACIAAtAABBgICAeHI2AgAgA0EBaiEDIAJBBGohAiAAQQFqIQAMAQsLCzwBAX8gAUEAIAFBAEobIQEDQCABIANHBEAgAiAALwAAOwAAIANBAWohAyACQQJqIQIgAEEDaiEADAELCws8AQF/IAFBACABQQBKGyEBA0AgASADRwRAIAIgAC0AADoAACADQQFqIQMgAkEBaiECIABBA2ohAAwBCwsLPAEBfyABQQAgAUEAShshAQNAIAEgA0cEQCACIAAoAgA7AQAgA0EBaiEDIAJBAmohAiAAQQRqIQAMAQsLCzwBAX8gAUEAIAFBAEobIQEDQCABIANHBEAgAiAAKAIAOgAAIANBAWohAyACQQFqIQIgAEEEaiEADAELCwsGACAAEBILBgAgACQACxAAIwAgAGtBcHEiACQAIAALBAAjAAsjACAAPwBBEHRrQf//A2pBEHZAAEF/RgRAQQAPC0EAEABBAQs7AQF/IAIEQANAIAAgASACQfwDIAJB/ANJGyIDEAUhACABQfwDaiEBIABB/ANqIQAgAiADayICDQALCwtjAQN/QfDDACEBA0AgASIAQQRqIQEgACgCACICQX9zIAJB//37d2pxQYCBgoR4cUUNAAsgAkH/AXFFBEAgAEHwwwBrDwsDQCAALQABIQIgAEEBaiIBIQAgAg0ACyABQfDDAGsLqQEBA38CQCACKAIQIgQEfyAEBSACEIQBDQEgAigCEAsgAigCFCIFayABSQRAIAIgACABIAIoAiQRAgAaDwsCQCACLABLQQBIDQAgASEEA0AgBCIDRQ0BIAAgA0F/aiIEai0AAEEKRw0ACyACIAAgAyACKAIkEQIAIANJDQEgASADayEBIAAgA2ohACACKAIUIQULIAUgACABEAUaIAIgAigCFCABajYCFAsLWQEBfyAAIAAtAEoiAUF/aiABcjoASiAAKAIAIgFBCHEEQCAAIAFBIHI2AgBBfw8LIABCADcCBCAAIAAoAiwiATYCHCAAIAE2AhQgACABIAAoAjBqNgIQQQALVAEBfyABQQAgAUEAShshAQNAIAEgA0cEQCACIAAtAAIgAC0AAEEQdHIgAC0AAUEIdHJBgICAeHI2AgAgA0EBaiEDIAJBBGohAiAAQQNqIQAMAQsLC5oBAAJAIAFBgAFOBEAgAEMAAAB/lCEAIAFB/wFIBEAgAUGBf2ohAQwCCyAAQwAAAH+UIQAgAUH9AiABQf0CSBtBgn5qIQEMAQsgAUGBf0oNACAAQwAAgACUIQAgAUGDfkoEQCABQf4AaiEBDAELIABDAACAAJQhACABQYZ9IAFBhn1KG0H8AWohAQsgACABQRd0QYCAgPwDar6UC9kDAgJ/An4jAEEgayICJAACQCABQv///////////wCDIgVCgICAgICAwP9DfCAFQoCAgICAgMCAvH98VARAIAFCBIYgAEI8iIQhBCAAQv//////////D4MiAEKBgICAgICAgAhaBEAgBEKBgICAgICAgMAAfCEEDAILIARCgICAgICAgIBAfSEEIABCgICAgICAgIAIhUIAUg0BIARCAYMgBHwhBAwBCyAAUCAFQoCAgICAgMD//wBUIAVCgICAgICAwP//AFEbRQRAIAFCBIYgAEI8iIRC/////////wODQoCAgICAgID8/wCEIQQMAQtCgICAgICAgPj/ACEEIAVC////////v//DAFYNAEIAIQQgBUIwiKciA0GR9wBJDQAgAkEQaiAAIAFC////////P4NCgICAgICAwACEIgQgA0H/iH9qEIkBIAIgACAEQYH4ACADaxCIASACKQMIQgSGIAIpAwAiAEI8iIQhBCACKQMQIAIpAxiEQgBSrSAAQv//////////D4OEIgBCgYCAgICAgIAIWgRAIARCAXwhBAwBCyAAQoCAgICAgICACIVCAFINACAEQgGDIAR8IQQLIAJBIGokACAEIAFCgICAgICAgICAf4OEvwtQAQF+AkAgA0HAAHEEQCACIANBQGqtiCEBQgAhAgwBCyADRQ0AIAJBwAAgA2uthiABIAOtIgSIhCEBIAIgBIghAgsgACABNwMAIAAgAjcDCAtQAQF+AkAgA0HAAHEEQCABIANBQGqthiECQgAhAQwBCyADRQ0AIAIgA60iBIYgAUHAACADa62IhCECIAEgBIYhAQsgACABNwMAIAAgAjcDCAu8AQEBfyABQQBHIQICQAJAAkACQCABRSAAQQNxRXINAANAIAAtAABFDQIgAEEBaiEAIAFBf2oiAUEARyECIAFFDQEgAEEDcQ0ACwsgAkUNAQsgAC0AAEUNAQJAIAFBBE8EQANAIAAoAgAiAkF/cyACQf/9+3dqcUGAgYKEeHENAiAAQQRqIQAgAUF8aiIBQQNLDQALCyABRQ0BCwNAIAAtAABFDQIgAEEBaiEAIAFBf2oiAQ0ACwtBAA8LIAALXgEBfkEAIQIgAUEAIAFBAEobIQEDQCABIAJHBEAgACAAKQMAIgNCgID8/4+AQIMgA0IgiEL//wODhCADQiCGQoCAgIDw/z+DhDcDACACQQFqIQIgAEEIaiEADAELCwszAQF/IAAoAhQiAyABIAIgACgCECADayIBIAEgAksbIgEQBRogACAAKAIUIAFqNgIUIAILNQAgAFBFBEADQCABQX9qIgEgAKdBD3FBoMkAai0AACACcjoAACAAQgSIIgBCAFINAAsLIAELLQAgAFBFBEADQCABQX9qIgEgAKdBB3FBMHI6AAAgAEIDiCIAQgBSDQALCyABC1cBAX9BACECIAFBACABQQBKGyEDA0AgAiADRwRAIAAgACgCACIBQYD+g3hxIAFBEHZB/wFxciABQRB0QYCA/AdxcjYCACACQQFqIQIgAEEEaiEADAELCwvrAgEDfyMAQdABayIDJAAgAyACNgLMAUEAIQIgA0GgAWpBAEEoEBsgAyADKALMATYCyAECQEEAIAEgA0HIAWogA0HQAGogA0GgAWoQHEEASARAQX8hAQwBCyAAKAJMQQBOBEBBASECCyAAKAIAIQQgACwASkEATARAIAAgBEFfcTYCAAsgBEEgcSEFAn8gACgCMARAIAAgASADQcgBaiADQdAAaiADQaABahAcDAELIABB0AA2AjAgACADQdAAajYCECAAIAM2AhwgACADNgIUIAAoAiwhBCAAIAM2AiwgACABIANByAFqIANB0ABqIANBoAFqEBwiASAERQ0AGiAAQQBBACAAKAIkEQIAGiAAQQA2AjAgACAENgIsIABBADYCHCAAQQA2AhAgACgCFCEEIABBADYCFCABQX8gBBsLIQEgACAAKAIAIgAgBXI2AgBBfyABIABBIHEbIQEgAkUNAAsgA0HQAWokACABC4sCAAJAIAAEfyABQf8ATQ0BAkBBsNMAKAIAKAIARQRAIAFBgH9xQYC/A0YNAwwBCyABQf8PTQRAIAAgAUE/cUGAAXI6AAEgACABQQZ2QcABcjoAAEECDwsgAUGAsANPQQAgAUGAQHFBgMADRxtFBEAgACABQT9xQYABcjoAAiAAIAFBDHZB4AFyOgAAIAAgAUEGdkE/cUGAAXI6AAFBAw8LIAFBgIB8akH//z9NBEAgACABQT9xQYABcjoAAyAAIAFBEnZB8AFyOgAAIAAgAUEGdkE/cUGAAXI6AAIgACABQQx2QT9xQYABcjoAAUEEDwsLQcDUAEEZNgIAQX8FQQELDwsgACABOgAAQQELYAECfyMAQRBrIgMkACADIAI2AgwgAyACNgIIQX8hBAJAQQBBACABIAIQLCICQQBIDQAgACACQQFqIgIQBCIANgIAIABFDQAgACACIAEgAygCDBAsIQQLIANBEGokACAECwMAAQtlAQF/IwBBkAJrIgMkAAJ/IABBf0EAIANBEGogAUEWdkH8B3FBoMQAaigCABEBAEUEQCADIAE2AgBB8MQAIAMQE0EADAELIANBEGpBECABQf//A3EgAhAiCyEAIANBkAJqJAAgAAuXAQID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AQEAAAEAQaYOC4oJAQAAAQEBAAABAAAAAAAAAQAAAQEBAAABAAAAAQEAAQEAAAEAAAEAAAEBAAABAQABAQABAQAAAQAAAQABAQAAAAEBAQAAAQEBAAAAAAEBAQAAAQEBAAAAAQEAAAEBAAEBAAABAQAAAQAAAQABAQAAAAEBAAABAQEAAAEAAQEBAQEBAAEAAAAAAAABAAAAAQEAAAABAQEAAAEBAQAAAAABAQEBAAABAQAAAQEAAAEBAAABAQEBAQEAAAAAAAABAAAAAQABAQEAAQEBAAABAAAAAQAAAAEBAQABAQEAAAEBAAABAQACAgECAgICAAAAAQAAAQECAgEBAgICAQAAAAACAAABAgIBAQICAQEAAgICAAACAgAAAQEAAQEBAAAAAAAAAAABAQICAQECAgAAAQEAAAEBAAACAgAAAgIAAAICAAACAgEBAQEBAQEBAAABAQAAAQECAgEBAgIBAQAAAAAAAAAAAQEBAQICAgIAAAAAAQEBAQEBAQECAgICAAAAAAEBAQECAgICAgICAgAAAQIAAAECAAABAgAAAQIAAQECAAEBAgABAQIAAQECAAECAgABAgIAAQICAAECAgAAAQEAAQECAQECAgECAgIAAAEBAgAAAQICAAACAgIAAAAAAQAAAQEAAQECAQECAgABAQEAAAEBAgAAAQICAAAAAAAAAQECAgEBAgIBAQICAAACAgAAAgIAAAICAQEBAQABAQEAAQEBAAICAgACAgIAAAABAAAAAQICAgECAgIBAAAAAAAAAQEAAQICAAECAgAAAAABAQAAAgIBAAICAQAAAQICAAECAgAAAQEAAAAAAAABAgAAAQIBAQICAgICAgABAQABAgIBAQICAQABAQAAAAAAAAEBAAECAgEBAgIBAAACAgEBAAIBAQACAAACAgABAQAAAQEAAgAAAgICAgIAAAEBAAECAgABAgIAAAEBAAAAAAIAAAACAgEBAgICAQAAAAAAAAACAQECAgECAgIAAgICAAACAgAAAQIAAAEBAAABAQAAAQIAAAICAAICAgABAgAAAQIAAAECAAABAgAAAAAAAQEBAQICAgIAAAAAAAECAAECAAECAAECAAECAAABAgACAAECAQIAAQABAgAAAAEBAgIAAAEBAgIAAAEBAAABAQEBAgICAgAAAAABAQABAAEAAQABAgICAgICAgIAAAAAAAAAAAIBAgECAQIBAAACAgEBAgIAAAICAQECAgAAAgIAAAEBAAACAgAAAQEAAgIAAQICAQACAgABAgIBAAEAAQICAgICAgICAAEAAQAAAAACAQIBAgECAQIBAgEAAQABAAEAAQABAAECAgICAAICAgABAQEAAgICAAEBAQAAAAIBAQECAAAAAgEBAQIAAAAAAgEBAgIBAQICAQECAAICAgABAQEAAQEBAAICAgAAAAIBAQECAQEBAgAAAAIAAQEAAAEBAAABAQACAgICAAAAAAAAAAACAQECAgEBAgABAQAAAQEAAgICAgICAgIAAAICAAABAQAAAQEAAAICAAACAgEBAgIBAQICAAACAgBBvBcLiwICAQECAAAAAgAAAAEAAAACAAAAAQACAgIBAgICAAICAgECAgIAAQABAgICAgICAgICAgICAAEBAQIAAQECAgABAgICAA8PDw8PDw8PDw8PDw8PDw8PAggCAggIDwIIAgIICAICDw8GCAIIDw8CCAICAg8PBgYCBggPDwICDw8PDw8CAg8DAw8PCAMPDwgIBgYGBQMDAwMIDwMDBgoFCAgGCAUPDwgPAwUGCggPDwMPBQ8PDw8DDwUFBQgFCgUKCA0PDAMDDwgIAw8PAwgPDw8PDw8PCA8IDwMPCA8IAw8GCg8PCggPAw8KCggJCgYPCA8DBgYIDwMPDw8PDw8PDw8PAw8PCAAAFQArAEAAQdIZCy0JABIAGwAlAC4ANwBAAAAABAAJAA0AEQAVABoAHgAiACYAKwAvADMANwA8AEAAQYAcC5EqAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4CBgoOEhYaHiImKi4yNjo+QkZKTlJWWl5iZmpucnZ6foKGio6SlpqeoqaqrrK2ur7CxsrO0tba3uLm6u7y9vr/AwcLDxMXGx8jJysvMzc7P0NHS09TV1tfY2drb3N3e3+Dh4uPk5ebn6Onq6+zt7u/w8fLz9PX29/j5+vv8/f7//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////2RldGV4Q29udmVydFBpeGVsczogVW5hYmxlIHRvIGZpbmQgY29udmVyc2lvbiBwYXRoAFVuYWJsZSB0byBmaW5kIGluLXBsYWNlIGNvbnZlcnNpb24gcGF0aABkZXRleENvbnZlcnRQaXhlbHM6IFRvbyBtYW55IHRlbXBvcmFyeSBidWZmZXJzIG5lZWRlZAAKBwsLCwkICAgGCgsMEAAAAAECCv//Awv//wQM//8FDf//Bv///wf///8I////Cf8AAAAAAwIAAAMCAwIBAQECBAYGBgAAAAYAAAAAAgIAAAMDAgIDAgQCAwMCAgICBAIC/wEBAwMDAgQGBQcFBwcFAAAAAAYIBwUFBwUIBQcIBgAAAAAGCAgGAAAAAAAAAAD9+vfxAgUIDv359vMCBgkM/vv48wEEBwz+/PrzAQMFDP36+PQCBQcL/fn39QIGCAr8+fj1AwYHCv37+PUCBAcK/vr49gEFBwn++/j2AQQHCf78+PYBAwcJ/vv59gEEBgn9/Pn2AgMGCf/+/fYAAQIJ/Pr49wMFBwj9+/n3AgQGCAAAAAAIAAAAEAAAABgAAADg////6P////D////4////AgAAAAgAAAD+////+P///wUAAAARAAAA+////+////8JAAAAHQAAAPf////j////DQAAACoAAADz////1v///xIAAAA8AAAA7v///8T///8YAAAAUAAAAOj///+w////IQAAAGoAAADf////lv///y8AAAC3AAAA0f///0n///8DAAAABgAAAAsAAAAQAAAAFwAAACAAAAApAAAAQAAAAAAAAAAIAAAAAAAAAPj///8AAAAAEQAAAAAAAADv////AAAAAB0AAAAAAAAA4////wAAAAAqAAAAAAAAANb///8AAAAAPAAAAAAA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', imports)}

class Detex {
    static #webAssembly;
    static #HEAPU8;
    static async decode(format, width, height, input, output) {
        switch (format) {
            case ImageFormat.Bc1:
                return this.decodeBC1(width, height, input, output);
            case ImageFormat.Bc2:
                return this.decodeBC2(width, height, input, output);
            case ImageFormat.Bc3:
                return this.decodeBC3(width, height, input, output);
            case ImageFormat.Bc4:
                return this.decodeBC4(width, height, input, output);
            case ImageFormat.Bc7:
                return this.decodeBC7(width, height, input, output);
            default:
                console.error('bad texture format in Detex.decode: ' + format);
        }
    }
    static async decodeBC1(width, height, input, output) {
        const wa = await this.getWebAssembly();
        const api = wa.instance.exports;
        const p = api.create_buffer(width * height * 0.5);
        this.#HEAPU8.set(input, p);
        api.decode_BC1(p, width, height);
        const resultPointer = api.get_result_pointer();
        const resultSize = api.get_result_size();
        const resultView = new Uint8ClampedArray(this.#HEAPU8.buffer, resultPointer, resultSize);
        output.set(resultView);
        api.destroy_buffer(p);
        api.destroy_buffer(resultPointer);
    }
    static async decodeBC2(width, height, input, output) {
        const wa = await this.getWebAssembly();
        const api = wa.instance.exports;
        const p = api.create_buffer(width * height * 4);
        this.#HEAPU8.set(input, p);
        api.decode_BC2(p, width, height);
        const resultPointer = api.get_result_pointer();
        const resultSize = api.get_result_size();
        const resultView = new Uint8ClampedArray(this.#HEAPU8.buffer, resultPointer, resultSize);
        output.set(resultView);
        api.destroy_buffer(p);
        api.destroy_buffer(resultPointer);
    }
    static async decodeBC3(width, height, input, output) {
        const wa = await this.getWebAssembly();
        const api = wa.instance.exports;
        const p = api.create_buffer(width * height * 4);
        this.#HEAPU8.set(input, p);
        api.decode_BC3(p, width, height);
        const resultPointer = api.get_result_pointer();
        const resultSize = api.get_result_size();
        const resultView = new Uint8ClampedArray(this.#HEAPU8.buffer, resultPointer, resultSize);
        output.set(resultView);
        api.destroy_buffer(p);
        api.destroy_buffer(resultPointer);
    }
    static async decodeBC4(width, height, input, output) {
        const wa = await this.getWebAssembly();
        const api = wa.instance.exports;
        const p = api.create_buffer(width * height * 0.5);
        this.#HEAPU8.set(input, p);
        api.decode_BC4(p, width, height);
        const resultPointer = api.get_result_pointer();
        const resultSize = api.get_result_size();
        //console.error('decodeBC7', width, height, resultSize);
        const resultView = new Uint8ClampedArray(this.#HEAPU8.buffer, resultPointer, resultSize);
        //const result = new Uint8ClampedArray(resultView);
        output.set(resultView);
        api.destroy_buffer(p);
        api.destroy_buffer(resultPointer);
    }
    static async decodeBC7(width, height, input, output) {
        const wa = await this.getWebAssembly();
        const api = wa.instance.exports;
        const p = api.create_buffer(width * height * 4);
        this.#HEAPU8.set(input, p);
        api.decode_BC7(p, width, height);
        const resultPointer = api.get_result_pointer();
        const resultSize = api.get_result_size();
        //console.error('decodeBC7', width, height, resultSize);
        const resultView = new Uint8ClampedArray(this.#HEAPU8.buffer, resultPointer, resultSize);
        //const result = new Uint8ClampedArray(resultView);
        output.set(resultView);
        api.destroy_buffer(p);
        api.destroy_buffer(resultPointer);
    }
    static async getWebAssembly() {
        if (this.#webAssembly) {
            return this.#webAssembly;
        }
        const env = {
            'abortStackOverflow': (_) => { throw new Error('overflow'); },
            'emscripten_notify_memory_growth': (_) => { /*console.error('growth ', this.#webAssembly.instance.exports.memory.buffer.byteLength);*/ this.#initHeap(); },
            'table': new WebAssembly.Table({ initial: 0, maximum: 0, element: 'anyfunc' }),
            'tableBase': 0,
            'memoryBase': 1024,
            'STACKTOP': 0,
        };
        this.#webAssembly = await detex({ env }); //WebAssembly.instantiateStreaming(fetch('detex.wasm'), {env});
        this.#initHeap();
        return this.#webAssembly;
    }
    static #initHeap() {
        this.#HEAPU8 = new Uint8Array(this.#webAssembly.instance.exports.memory.buffer);
    }
}

const VTF_ENTRY_IMAGE_DATAS = 48;
class Source1Vtf {
    repository;
    fileName;
    versionMaj = 0;
    versionMin = 0;
    width = 0;
    height = 0;
    flags = 0;
    frames = 1;
    faceCount = 1;
    firstFrame = 0;
    reflectivity = vec3.create();
    bumpmapScale = 0;
    highResImageFormat = 0; /*TODO: create enume*/
    mipmapCount = 0;
    lowResImageFormat = 0;
    lowResImageWidth = 0;
    lowResImageHeight = 0;
    depth = 0;
    resEntries = [];
    currentFrame = 0;
    //filled = false;
    numResources = 0;
    headerSize = 0;
    sheet = null; //TODO: rename to spritesheet
    constructor(repository, fileName) {
        this.repository = repository;
        this.fileName = fileName;
    }
    setVerionMin(value) {
        this.versionMin = value;
    }
    /**
     * TODO
     */
    setFlags(flags) {
        this.flags = flags;
        if (flags & TEXTUREFLAGS_ENVMAP) {
            if (this.isHigherThan74()) {
                this.faceCount = 6;
            }
            else {
                this.faceCount = 7; // WTF ?
            }
        }
    }
    getFlag(flag) {
        return (this.flags & flag) == flag;
    }
    getAlphaBits() {
        if ((this.flags & TEXTUREFLAGS_ONEBITALPHA) == TEXTUREFLAGS_ONEBITALPHA) {
            return 1;
        }
        if ((this.flags & TEXTUREFLAGS_EIGHTBITALPHA) == TEXTUREFLAGS_EIGHTBITALPHA) {
            return 8;
        }
        return 0;
    }
    /**
     * TODO
     */
    setVerionMaj(value) {
        this.versionMaj = value;
    }
    /**
     * TODO
     */
    isHigherThan71() {
        if (this.versionMaj >= 7 && this.versionMin > 1) {
            return true;
        }
        return false;
    }
    /**
     * TODO
     */
    isHigherThan72() {
        if (this.versionMaj >= 7 && this.versionMin > 2) {
            return true;
        }
        return false;
    }
    /**
     * TODO
     */
    isHigherThan73() {
        if (this.versionMaj >= 7 && this.versionMin > 3) {
            return true;
        }
        return false;
    }
    /**
     * TODO
     */
    isHigherThan74() {
        if (this.versionMaj >= 7 && this.versionMin > 4) {
            return true;
        }
        return false;
    }
    /**
     * TODO
     */
    getResource(type) {
        for (const entry of this.resEntries) {
            //const entry = this.resEntries[i];
            if (entry.type == type) {
                return entry;
            }
        }
        return null;
    }
    /*
    getImageDatas(mipmapLvl: number) {
        let entry = this.getResource(VTF_ENTRY_IMAGE_DATAS);
        if (!entry) {
            entry = this.getResource(1);
            if (entry) {
                return entry.imageData;
            } else {
                return null;
            }
        }
        return entry.mipMaps[mipmapLvl];
    }
    */
    fillTexture(glContext, texture, mipmapLvl, frame1 = 0, srgb = true) {
        if (this.flags & TEXTUREFLAGS_ENVMAP) {
            this.#fillCubeMapTexture(glContext, texture.texture, mipmapLvl, srgb);
        }
        else {
            this.#fillTexture(glContext, texture, mipmapLvl, frame1, srgb);
        }
    }
    #fillTexture(glContext, texture, mipmapLvl, frame1 = 0, srgb) {
        /*
        if (this.filled && (this.frames == 1)) {
            return;
        }
        */
        if (mipmapLvl == undefined) {
            mipmapLvl = this.mipmapCount - 1;
        }
        else {
            mipmapLvl = Math.min(mipmapLvl, this.mipmapCount - 1);
        }
        const face = 0;
        let frame = 0;
        this.currentFrame = frame1;
        frame = Math.round(frame1) % this.frames;
        this.currentFrame = frame;
        const res48 = this.getResource(VTF_ENTRY_IMAGE_DATAS);
        if (!res48) {
            //TODO: show error
            return;
        }
        const mipmap = res48.mipMaps[mipmapLvl];
        if (!mipmap) {
            //TODO: show error
            return;
        }
        const webGLTexture = texture.texture;
        glContext.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        glContext.bindTexture(GL_TEXTURE_2D, webGLTexture);
        const clampS = (this.flags & TEXTUREFLAGS_CLAMPS) == TEXTUREFLAGS_CLAMPS;
        const clampT = (this.flags & TEXTUREFLAGS_CLAMPT) == TEXTUREFLAGS_CLAMPT;
        texture.width = mipmap.width;
        texture.height = mipmap.height;
        const data = mipmap.frames[frame]?.[face];
        if (data) {
            if (this.isDxtCompressed()) {
                fillTextureDxt(glContext, webGLTexture, GL_TEXTURE_2D, mipmap.width, mipmap.height, vtfToImageFormat(this.highResImageFormat), data, clampS, clampT, srgb && this.isSRGB());
            }
            else {
                glContext.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, false);
                glContext.texImage2D(GL_TEXTURE_2D, 0, this.#getInternalFormat(srgb), mipmap.width, mipmap.height, 0, this.getFormat(), this.getType(), data);
            }
        }
        glContext.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glContext.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glContext.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, clampS ? GL_CLAMP_TO_EDGE : GL_REPEAT);
        glContext.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, clampT ? GL_CLAMP_TO_EDGE : GL_REPEAT);
        glContext.bindTexture(GL_TEXTURE_2D, null);
        glContext.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, false);
        //this.filled = true;
    }
    /**
     * TODO
     */
    #fillCubeMapTexture(glContext, texture, mipmapLvl, srgb) {
        if (mipmapLvl == undefined) {
            mipmapLvl = this.mipmapCount - 1;
        }
        else {
            mipmapLvl = Math.min(mipmapLvl, this.mipmapCount - 1);
        }
        const frame = 0;
        //TODOv3: removeme
        /*if (delta!=undefined) {
            this.currentFrame += delta / 100.0;
            frame = Math.min(Math.round(this.currentFrame), this.frames-1);
            if (this.currentFrame>this.frames) { // TODO: loop
                this.currentFrame =0;
            }
        }*/
        const res48 = this.getResource(VTF_ENTRY_IMAGE_DATAS);
        if (!res48) {
            //TODO: show error
            return;
        }
        const mipmap = res48.mipMaps[mipmapLvl];
        if (!mipmap) {
            //TODO: show error
            return;
        }
        glContext.bindTexture(GL_TEXTURE_CUBE_MAP, texture);
        glContext.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        const clampS = (this.flags & TEXTUREFLAGS_CLAMPS) == TEXTUREFLAGS_CLAMPS;
        const clampT = (this.flags & TEXTUREFLAGS_CLAMPT) == TEXTUREFLAGS_CLAMPT;
        const data0 = mipmap.frames[frame]?.[0];
        const data1 = mipmap.frames[frame]?.[1];
        const data2 = mipmap.frames[frame]?.[2];
        const data3 = mipmap.frames[frame]?.[3];
        const data4 = mipmap.frames[frame]?.[4];
        const data5 = mipmap.frames[frame]?.[5];
        if (data0 && data1 && data2 && data3 && data4 && data5) {
            if (this.isDxtCompressed()) {
                const isSRGB = srgb && this.isSRGB();
                const st3cFormat = vtfToImageFormat(this.highResImageFormat);
                fillTextureDxt(glContext, texture, GL_TEXTURE_CUBE_MAP_POSITIVE_X, mipmap.width, mipmap.height, st3cFormat, data0, clampS, clampT, isSRGB);
                fillTextureDxt(glContext, texture, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, mipmap.width, mipmap.height, st3cFormat, data1, clampS, clampT, isSRGB);
                fillTextureDxt(glContext, texture, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, mipmap.width, mipmap.height, st3cFormat, data2, clampS, clampT, isSRGB);
                fillTextureDxt(glContext, texture, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, mipmap.width, mipmap.height, st3cFormat, data3, clampS, clampT, isSRGB);
                fillTextureDxt(glContext, texture, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, mipmap.width, mipmap.height, st3cFormat, data4, clampS, clampT, isSRGB);
                fillTextureDxt(glContext, texture, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, mipmap.width, mipmap.height, st3cFormat, data5, clampS, clampT, isSRGB);
            }
            else {
                glContext.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, false);
                glContext.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, this.#getInternalFormat(srgb), mipmap.width, mipmap.height, 0, this.getFormat(), this.getType(), data0);
                glContext.texImage2D(GL_TEXTURE_CUBE_MAP_NEGATIVE_X, 0, this.#getInternalFormat(srgb), mipmap.width, mipmap.height, 0, this.getFormat(), this.getType(), data1);
                glContext.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_Y, 0, this.#getInternalFormat(srgb), mipmap.width, mipmap.height, 0, this.getFormat(), this.getType(), data2);
                glContext.texImage2D(GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, this.#getInternalFormat(srgb), mipmap.width, mipmap.height, 0, this.getFormat(), this.getType(), data3);
                glContext.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_Z, 0, this.#getInternalFormat(srgb), mipmap.width, mipmap.height, 0, this.getFormat(), this.getType(), data4);
                glContext.texImage2D(GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, this.#getInternalFormat(srgb), mipmap.width, mipmap.height, 0, this.getFormat(), this.getType(), data5);
            }
        }
        glContext.texParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glContext.texParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glContext.texParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, clampS ? GL_CLAMP_TO_EDGE : GL_REPEAT);
        glContext.texParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, clampT ? GL_CLAMP_TO_EDGE : GL_REPEAT);
        glContext.bindTexture(GL_TEXTURE_CUBE_MAP, null);
        //this.filled = true;
    }
    /*
    getDxtFormat(s3tc) {
        switch (this.highResImageFormat) {
            case IMAGE_FORMAT_DXT1:
                return s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            case IMAGE_FORMAT_DXT3:
                return s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            case IMAGE_FORMAT_DXT5:
                return s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            /* TODO: check format */
    /*case IMAGE_FORMAT_DXT1_ONEBITALPHA:
        return s3tc.COMPRESSED_RGB_S3TC_DXT1_EXT;* /
}
return 0;
}
*/
    getFormat() {
        switch (this.highResImageFormat) {
            case IMAGE_FORMAT_RGB888:
            case IMAGE_FORMAT_BGR888: // Note: format has been inverted at load time
                return GL_RGB;
            case IMAGE_FORMAT_RGBA8888:
            case IMAGE_FORMAT_BGRA8888: // Note: format has been inverted at load time
            case IMAGE_FORMAT_ABGR8888: // Note: format has been inverted at load time
            case IMAGE_FORMAT_RGBA16161616F: // Note: format has been inverted at load time
                return GL_RGBA;
        }
        return 0;
    }
    #getInternalFormat(allowSrgb = true) {
        switch (this.highResImageFormat) {
            case IMAGE_FORMAT_RGB888:
            case IMAGE_FORMAT_BGR888:
                return this.isSRGB() && allowSrgb ? GL_SRGB8 : GL_RGB;
            case IMAGE_FORMAT_RGBA8888:
            case IMAGE_FORMAT_BGRA8888:
            case IMAGE_FORMAT_ABGR8888:
                return this.isSRGB() && allowSrgb ? GL_SRGB8_ALPHA8 : GL_RGBA;
            case IMAGE_FORMAT_RGBA16161616F: // Note: format has been inverted at load time
                return GL_RGBA16F;
        }
        return 0;
    }
    getType() {
        switch (this.highResImageFormat) {
            case IMAGE_FORMAT_RGBA16161616F:
                return GL_FLOAT;
            default:
                return GL_UNSIGNED_BYTE;
        }
    }
    /**
     * Return whether the texture is compressed or not
     * @return {bool} true if texture is dxt compressed
     */
    isDxtCompressed() {
        switch (this.highResImageFormat) {
            case IMAGE_FORMAT_DXT1:
            case IMAGE_FORMAT_DXT3:
            case IMAGE_FORMAT_DXT5:
                return true;
        }
        return false;
    }
    isSRGB() {
        return ((this.flags & TEXTUREFLAGS_SRGB) == TEXTUREFLAGS_SRGB);
    }
    async getImageData(mipmap, frame = 0, face = 0) {
        frame = Math.round(frame) % this.frames;
        const highResDatas = this.getResource(VTF_ENTRY_IMAGE_DATAS);
        if (!highResDatas) {
            return null;
        }
        if (mipmap == undefined) {
            mipmap = this.mipmapCount - 1;
        }
        else {
            mipmap = Math.min(mipmap, this.mipmapCount - 1);
        }
        const mipmapDatas = highResDatas.mipMaps[mipmap];
        if (!mipmapDatas) {
            return null;
        }
        let datas;
        const mipmapWidth = mipmapDatas.width;
        const mipmapHeight = mipmapDatas.height;
        const mipmapFaceDatas = mipmapDatas.frames[frame]?.[face];
        if (!mipmapFaceDatas) {
            return null;
        }
        if (this.isDxtCompressed()) {
            datas = await decompressDxt(vtfToImageFormat(this.highResImageFormat), mipmapWidth, mipmapHeight, mipmapFaceDatas);
        }
        else {
            datas = new Uint8ClampedArray(mipmapWidth * mipmapHeight * 4);
            datas.set(mipmapFaceDatas);
        }
        return new ImageData(datas, mipmapWidth, mipmapHeight);
    }
}
const IMAGE_FORMAT_RGBA8888 = 0;
const IMAGE_FORMAT_ABGR8888 = 1;
const IMAGE_FORMAT_RGB888 = 2;
const IMAGE_FORMAT_BGR888 = 3;
const IMAGE_FORMAT_RGB888_BLUESCREEN = 9;
const IMAGE_FORMAT_BGR888_BLUESCREEN = 10;
const IMAGE_FORMAT_BGRA8888 = 12;
const IMAGE_FORMAT_DXT1 = 13;
const IMAGE_FORMAT_DXT3 = 14;
const IMAGE_FORMAT_DXT5 = 15;
const IMAGE_FORMAT_RGBA16161616F = 24;
// TODO: move this function elsewhere
async function decompressDxt(format, width, height, datas) {
    const uncompressedData = new Uint8ClampedArray(width * height * 4);
    await Detex.decode(format, width, height, datas, uncompressedData);
    return uncompressedData;
}
function fillTextureDxt(glContext, texture, target, width, height, dxtLevel, datas, clampS, clampT, srgb) {
    const s3tc = Graphics$1.getExtension('WEBGL_compressed_texture_s3tc');
    const s3tcSRGB = Graphics$1.getExtension('WEBGL_compressed_texture_s3tc_srgb');
    glContext.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    //glContext.bindTexture(target, texture);
    if (s3tc) {
        let dxtFormat = 0;
        switch (dxtLevel) {
            case ImageFormat.Bc1:
                dxtFormat = srgb ? s3tcSRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT : s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                break;
            case ImageFormat.Bc2:
                dxtFormat = srgb ? s3tcSRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT : s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                break;
            case ImageFormat.Bc3:
                dxtFormat = srgb ? s3tcSRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT : s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                break;
        }
        glContext.compressedTexImage2D(target, 0, dxtFormat, width, height, 0, datas);
    }
    else {
        glContext.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, false);
        (async () => {
            const uncompressedData = await decompressDxt(dxtLevel, width, height, datas); //new Uint8Array(width * height * 4);
            glContext.bindTexture(GL_TEXTURE_2D, texture);
            glContext.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, uncompressedData); //TODO: params
            glContext.bindTexture(GL_TEXTURE_2D, null);
        })();
        /*
        let decompressFunc = null;
        switch (dxtLevel) {
            case 1: decompressFunc = 'decodeBC1'; break;
            case 2: decompressFunc = 'decodeBC2'; break;
            case 3: decompressFunc = 'decodeBC3'; break;
        }
        if (decompressFunc) {
            (Detex as any)[decompressFunc](width, height, datas, uncompressedData).then(
                () => {
                    glContext.bindTexture(GL_TEXTURE_2D, texture);
                    glContext.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, uncompressedData);//TODO: params
                    glContext.bindTexture(GL_TEXTURE_2D, null);
                }
            );
        }
        */
        /*const dxtflag = dxtLevel == 1 ? (1 << 0) : (1 << 2);
        let uncompressedData;
        if (datas.uncompressedData) {
            uncompressedData = datas.uncompressedData;
        } else {
            uncompressedData = decompress(datas, width, height, dxtflag);
            datas.uncompressedData = uncompressedData;
        }
        glContext.texImage2D(target, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, uncompressedData);//TODO: params*/
    }
    //glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_MAG_FILTER, glContext.LINEAR);
    //glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_MIN_FILTER, glContext.LINEAR);
    //glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_WRAP_S, clampS ? glContext.CLAMP_TO_EDGE : glContext.REPEAT);
    //glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_WRAP_T, clampT ? glContext.CLAMP_TO_EDGE : glContext.REPEAT);
    //glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_WRAP_S, glContext.CLAMP_TO_EDGE);
    //glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_WRAP_T, glContext.CLAMP_TO_EDGE);
    //glContext.bindTexture(glContext.TEXTURE_2D, null);
    glContext.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, false);
}
function vtfToImageFormat(vtfImageFormat) {
    switch (vtfImageFormat) {
        case IMAGE_FORMAT_DXT1:
            return ImageFormat.Bc1;
        case IMAGE_FORMAT_DXT3:
            return ImageFormat.Bc2;
        case IMAGE_FORMAT_DXT5:
            return ImageFormat.Bc3;
        default:
            console.error('missing image format ' + vtfImageFormat);
        //TODO: populate
    }
    return ImageFormat.Unknown;
}

const VTEX_FLAG_CUBE_TEXTURE = 0x10;
const VTEX_FORMAT_DXT1 = 0x01; // 1
const VTEX_FORMAT_DXT5 = 0x02; // 2
const VTEX_FORMAT_R8 = 0x03; // 3
const VTEX_FORMAT_R8G8B8A8_UINT = 0x04; // 4
const VTEX_FORMAT_BC7 = 0x14; // 20
const VTEX_FORMAT_BC5 = 0x15; // 21
const VTEX_FORMAT_BC4 = 0x1B; // 27
const VTEX_FORMAT_BGRA8888 = 0x1C; // 28

const TEXTURE_FORMAT_UNKNOWN = 0;
const TEXTURE_FORMAT_UNCOMPRESSED = 1 << 10;
const TEXTURE_FORMAT_COMPRESSED_S3TC = 1 << 11;
const TEXTURE_FORMAT_COMPRESSED_RGTC = 1 << 12;
const TEXTURE_FORMAT_COMPRESSED_BPTC = 1 << 13;
const TEXTURE_FORMAT_UNCOMPRESSED_RGB = TEXTURE_FORMAT_UNCOMPRESSED | 1;
const TEXTURE_FORMAT_UNCOMPRESSED_RGBA = TEXTURE_FORMAT_UNCOMPRESSED | 2;
const TEXTURE_FORMAT_UNCOMPRESSED_R8 = TEXTURE_FORMAT_UNCOMPRESSED | 3;
const TEXTURE_FORMAT_UNCOMPRESSED_BGRA8888 = TEXTURE_FORMAT_UNCOMPRESSED | 4;
const TEXTURE_FORMAT_COMPRESSED_RGB_DXT1 = TEXTURE_FORMAT_COMPRESSED_S3TC | 1;
const TEXTURE_FORMAT_COMPRESSED_RGBA_DXT1 = TEXTURE_FORMAT_COMPRESSED_S3TC | 2;
const TEXTURE_FORMAT_COMPRESSED_RGBA_DXT3 = TEXTURE_FORMAT_COMPRESSED_S3TC | 3;
const TEXTURE_FORMAT_COMPRESSED_RGBA_DXT5 = TEXTURE_FORMAT_COMPRESSED_S3TC | 4;
const TEXTURE_FORMAT_COMPRESSED_RGBA_BC4 = TEXTURE_FORMAT_COMPRESSED_RGTC | 1;
const TEXTURE_FORMAT_COMPRESSED_RGBA_BC5 = TEXTURE_FORMAT_COMPRESSED_RGTC | 2;
const TEXTURE_FORMAT_COMPRESSED_RGBA_BC7 = TEXTURE_FORMAT_COMPRESSED_BPTC | 1;

var Kv3Type;
(function (Kv3Type) {
    Kv3Type[Kv3Type["Unknown"] = 0] = "Unknown";
    Kv3Type[Kv3Type["Null"] = 1] = "Null";
    Kv3Type[Kv3Type["Bool"] = 2] = "Bool";
    Kv3Type[Kv3Type["Int64"] = 3] = "Int64";
    Kv3Type[Kv3Type["UnsignedInt64"] = 4] = "UnsignedInt64";
    Kv3Type[Kv3Type["Double"] = 5] = "Double";
    Kv3Type[Kv3Type["String"] = 6] = "String";
    Kv3Type[Kv3Type["Blob"] = 7] = "Blob";
    Kv3Type[Kv3Type["Array"] = 8] = "Array";
    Kv3Type[Kv3Type["Element"] = 9] = "Element";
    Kv3Type[Kv3Type["TypedArray"] = 10] = "TypedArray";
    Kv3Type[Kv3Type["Int32"] = 11] = "Int32";
    Kv3Type[Kv3Type["UnsignedInt32"] = 12] = "UnsignedInt32";
    Kv3Type[Kv3Type["True"] = 13] = "True";
    Kv3Type[Kv3Type["False"] = 14] = "False";
    Kv3Type[Kv3Type["IntZero"] = 15] = "IntZero";
    Kv3Type[Kv3Type["IntOne"] = 16] = "IntOne";
    Kv3Type[Kv3Type["DoubleZero"] = 17] = "DoubleZero";
    Kv3Type[Kv3Type["DoubleOne"] = 18] = "DoubleOne";
    Kv3Type[Kv3Type["Float"] = 19] = "Float";
    Kv3Type[Kv3Type["Byte"] = 23] = "Byte";
    Kv3Type[Kv3Type["TypedArray2"] = 24] = "TypedArray2";
    Kv3Type[Kv3Type["TypedArray3"] = 25] = "TypedArray3";
    Kv3Type[Kv3Type["Resource"] = 134] = "Resource";
    Kv3Type[Kv3Type["Subclass"] = 137] = "Subclass";
})(Kv3Type || (Kv3Type = {}));
class Kv3Value {
    isKv3Value = true;
    #type;
    #subType;
    #value;
    constructor(type, value, subType) {
        this.#type = type;
        this.#value = value;
        this.#subType = subType ?? Kv3Type.Unknown;
    }
    getType() {
        return this.#type;
    }
    getSubType() {
        return this.#subType;
    }
    isBoolean() {
        switch (this.#type) {
            case Kv3Type.Bool:
            case Kv3Type.True:
            case Kv3Type.False:
                return true;
        }
        return false;
    }
    isNumber() {
        switch (this.#type) {
            case Kv3Type.Int32:
            case Kv3Type.UnsignedInt32:
            case Kv3Type.IntZero:
            case Kv3Type.IntOne:
            case Kv3Type.Float:
            case Kv3Type.Double:
            case Kv3Type.DoubleZero:
            case Kv3Type.DoubleOne:
                return true;
        }
        return false;
    }
    isBigint() {
        switch (this.#type) {
            case Kv3Type.Int64:
            case Kv3Type.UnsignedInt64:
                return true;
        }
        return false;
    }
    isNumberArray() {
        switch (this.#subType) {
            case Kv3Type.Int32:
            case Kv3Type.UnsignedInt32:
            case Kv3Type.IntZero:
            case Kv3Type.IntOne:
            case Kv3Type.DoubleZero:
            case Kv3Type.DoubleOne:
            case Kv3Type.Float:
            case Kv3Type.Double:
                return this.isArray();
        }
        return false;
    }
    isBigintArray() {
        switch (this.#subType) {
            case Kv3Type.Int64:
            case Kv3Type.UnsignedInt64:
                return this.isArray();
        }
        return false;
    }
    isArray() {
        switch (this.#type) {
            case Kv3Type.Array:
            case Kv3Type.TypedArray:
            case Kv3Type.TypedArray2:
            case Kv3Type.TypedArray3:
                return true;
        }
        return false;
    }
    isVector() {
        switch (this.#subType) {
            case Kv3Type.TypedArray:
            case Kv3Type.TypedArray2:
            case Kv3Type.TypedArray3:
                return true;
        }
        return false;
    }
    getValue() {
        return this.#value;
    }
    exportAsText(linePrefix) {
        linePrefix = linePrefix ?? '';
        switch (this.#type) {
            case 6:
                return '"' + this.#value + '"';
            case Kv3Type.TypedArray:
            case Kv3Type.TypedArray2:
            case Kv3Type.TypedArray3:
                let typedArrayString = '';
                const linePrefix2 = linePrefix + '\t';
                for (const value of this.#value) {
                    switch (this.#subType) {
                        case Kv3Type.Resource:
                            typedArrayString += linePrefix2 + 'resource_name:"' + value + '",\n';
                            break;
                        case Kv3Type.Subclass:
                            typedArrayString += linePrefix2 + 'subclass:"' + value + '",\n';
                            break;
                        default:
                            typedArrayString += linePrefix2 + value + ',\n';
                            break;
                    }
                }
                return `\n${linePrefix}[\n${typedArrayString}${linePrefix}]\n`;
            case Kv3Type.Resource:
                return 'resource_name:"' + this.#value + '"';
            case Kv3Type.Subclass:
                return 'subclass:' + this.#value.exportAsText(linePrefix) + '';
        }
        return String(this.#value);
    }
}

const VTEX_TO_INTERNAL_IMAGE_FORMAT = {}; //TODO: create an enum
VTEX_TO_INTERNAL_IMAGE_FORMAT[VTEX_FORMAT_DXT1] = TEXTURE_FORMAT_COMPRESSED_RGBA_DXT1;
VTEX_TO_INTERNAL_IMAGE_FORMAT[VTEX_FORMAT_DXT5] = TEXTURE_FORMAT_COMPRESSED_RGBA_DXT5;
VTEX_TO_INTERNAL_IMAGE_FORMAT[VTEX_FORMAT_R8] = TEXTURE_FORMAT_UNCOMPRESSED_R8;
VTEX_TO_INTERNAL_IMAGE_FORMAT[VTEX_FORMAT_BC4] = TEXTURE_FORMAT_COMPRESSED_RGBA_BC4;
VTEX_TO_INTERNAL_IMAGE_FORMAT[VTEX_FORMAT_BC5] = TEXTURE_FORMAT_COMPRESSED_RGBA_BC5;
VTEX_TO_INTERNAL_IMAGE_FORMAT[VTEX_FORMAT_BC7] = TEXTURE_FORMAT_COMPRESSED_RGBA_BC7;
VTEX_TO_INTERNAL_IMAGE_FORMAT[VTEX_FORMAT_R8G8B8A8_UINT] = TEXTURE_FORMAT_UNCOMPRESSED_RGBA;
VTEX_TO_INTERNAL_IMAGE_FORMAT[VTEX_FORMAT_BGRA8888] = TEXTURE_FORMAT_UNCOMPRESSED_BGRA8888;
/*VTEX_FORMAT_DXT1 : TEXTURE_FORMAT_COMPRESSED_RGBA_DXT1,
VTEX_FORMAT_DXT5 : TEXTURE_FORMAT_COMPRESSED_RGBA_DXT5,
VTEX_FORMAT_BC7 : TEXTURE_FORMAT_COMPRESSED_RGBA_BC7,
}*/
//TODOv3: improve
/*export const TEXTURE_FORMAT_UNKNOWN = 0;
export const TEXTURE_FORMAT_UNCOMPRESSED_RGB = 1;
export const TEXTURE_FORMAT_UNCOMPRESSED_RGBA = 2;
export const TEXTURE_FORMAT_COMPRESSED_RGB_DXT1 = 1000;
export const TEXTURE_FORMAT_COMPRESSED_RGBA_DXT1 = 1001;
export const TEXTURE_FORMAT_COMPRESSED_RGBA_DXT3 = 1002;
export const TEXTURE_FORMAT_COMPRESSED_RGBA_DXT5 = 1003;
export const TEXTURE_FORMAT_COMPRESSED_RGBA_BC7 = 1004;


export const VTEX_FORMAT_DXT1 = 0x01;
export const VTEX_FORMAT_DXT5 = 0x02;
export const VTEX_FORMAT_R8G8B8A8_UINT = 0x04;
export const VTEX_FORMAT_PNG_R8G8B8A8_UINT = 0x10;
export const VTEX_FORMAT_BC7 = 0x14;//not sure*/
/**
 * Source2 common file
 */
class Source2File {
    repository;
    fileName;
    // blocks stores the first occurence of a block type
    // some blocks (MBUF, MDAT) may have multiple occurences that can be accessed via blocksArray
    blocks = {};
    blocksArray = [];
    fileLength = 0;
    versionMaj = 0;
    versionMin = 0;
    maxBlockOffset = 0;
    indices = new Map();
    vertices = new Map();
    constructor(repository, fileName) {
        this.repository = repository;
        this.fileName = fileName;
    }
    addBlock(block) {
        this.blocksArray.push(block);
        if (this.blocks[block.type] === undefined) {
            this.blocks[block.type] = block;
        }
    }
    getBlockByType(type) {
        return this.blocks[type] ?? null;
    }
    getBlockById(id) {
        return this.blocksArray[id] ?? null;
    }
    /*
        getVertexCount(blockId: number, bufferId: number): number {
            /*
            const block = this.blocks.VBIB || this.blocks.MBUF;
            if (!block) {
                return 0;
            }
            * /

            return this.indices?.[bufferId].indices.length;
        }
        */
    /*
        getIndices(bufferId: number): number[] | null {
            /*
            const block = this.blocks.VBIB || this.blocks.MBUF;
            if (!block) {
                return null;
            }
            * /

            const indexBuffer = this.indices?.[bufferId];

            return indexBuffer ? indexBuffer.indices : [];
        }
            */
    /*
getVertices(bufferId: number): number[] | null {
    /*
    const block = this.blocks.VBIB || this.blocks.MBUF;
    if (!block) {
        return null;
    }
    * /

    const vertexBuffer = this.vertices?.[bufferId];

    return vertexBuffer ? vertexBuffer.vertices : [];
}

getNormals(bufferId: number): number[] | null {
    /*
    const block = this.blocks.VBIB || this.blocks.MBUF;
    if (!block) {
        return null;
    }
    * /

    const vertexBuffer = this.vertices?.[bufferId];
    const normals = vertexBuffer.normals;
    const ret = [];
    const normalVec4 = vec4.create();
    let normalVec3;
    for (let i = 0, l = normals.length; i < l; i += 4) {
        normalVec4[0] = normals[i + 0];
        normalVec4[1] = normals[i + 1];
        normalVec4[2] = normals[i + 2];
        normalVec4[3] = normals[i + 3];

        normalVec3 = DecompressNormal(normalVec4);
        ret.push(normalVec3[0]);
        ret.push(normalVec3[1]);
        ret.push(normalVec3[2]);
    }
    return ret;//vertexBuffer ? vertexBuffer.normals : [];
}

getCoords(bufferId: number): number[] | null {
    /*
    const block = this.blocks.VBIB || this.blocks.MBUF;
    if (!block) {
        return null;
    }
    * /

    const vertexBuffer = this.vertices?.[bufferId];

    return vertexBuffer ? vertexBuffer.coords : [];
}

getBoneIndices(bufferId: number): number[] | null {
    /*
    const block = this.blocks.VBIB || this.blocks.MBUF;
    if (!block) {
        return null;
    }
    * /

    const vertexBuffer = this.vertices?.[bufferId];

    return vertexBuffer ? vertexBuffer.boneIndices : [];
}

getBoneWeight(bufferId: number): number[] | null {
    /*
    const block = this.blocks.VBIB || this.blocks.MBUF;
    if (!block) {
        return null;
    }
    * /

    const vertexBuffer = this.vertices?.[bufferId];

    return vertexBuffer ? vertexBuffer.boneWeight : [];
}*/
    /*
    getPositionArray(bufferId: number) {
        const block = this.blocks.VBIB || this.blocks.MBUF;
        if (!block) {
            return null;
        }

        const vertexBuffer = block.vertices[bufferId];
        const indexBuffer = block.indices[bufferId];

        const vertices = vertexBuffer ? vertexBuffer.vertices : [];
        const indices = indexBuffer ? indexBuffer.indices : [];

        const ret = [];
        const indicesLength = indices.length;
        for (let i = 0; i < indicesLength; i++) {
            const vertexId = indices[i] * 3;
            ret.push(vertices[vertexId + 0]);
            ret.push(vertices[vertexId + 1]);
            ret.push(vertices[vertexId + 2]);
        }
        return ret;
    }

    getNormalArray(bufferId) {

        /*function DecompressNormal(float2 inputTangent, out float4 outputTangent) {//_DecompressShort2Tangent
            const ztSigns		= sign(inputTangent);				// sign bits for z and tangent (+1 or -1)
            float2 xyAbs		= abs(inputTangent);				// 1..32767
            outputTangent.xy	= (xyAbs - 16384.0) / 16384.0;	// x and y
            outputTangent.z		= ztSigns.x * sqrt(saturate(1.0 - dot(outputTangent.xy, outputTangent.xy)));
            //outputTangent.w		= ztSigns.y;
        }* /


        function DecompressNormal(inputNormal) {				// {nX, nY, nZ}//_DecompressUByte4Normal
            const fOne = 1.0;
            const outputNormal = vec3.create();

            //float2 ztSigns		= (inputNormal.xy - 128.0) < 0;				// sign bits for zs and binormal (1 or 0) set-less-than (slt) asm instruction
            const ztSigns = vec2.fromValues(Number((inputNormal[0] - 128.0) < 0), Number((inputNormal[1] - 128.0) < 0));				// sign bits for zs and binormal (1 or 0) set-less-than (slt) asm instruction
            //float2 xyAbs		= abs(inputNormal.xy - 128.0) - ztSigns;		// 0..127
            const xyAbs = vec2.fromValues(Math.abs(inputNormal[0] - 128.0) - ztSigns[0], Math.abs(inputNormal[1] - 128.0) - ztSigns[1]);		// 0..127
            //float2 xySigns		= (xyAbs - 64.0) < 0;						// sign bits for xs and ys (1 or 0)
            const xySigns = vec2.fromValues(Number((xyAbs[0] - 64.0) < 0), Number((xyAbs[1] - 64.0) < 0));						// sign bits for xs and ys (1 or 0)
            //outputNormal.xy		= (abs(xyAbs - 64.0) - xySigns) / 63.0;	// abs({nX, nY})
            outputNormal[0] = (Math.abs(xyAbs[0] - 64.0) - xySigns[0]) / 63.0;	// abs({nX, nY})
            outputNormal[1] = (Math.abs(xyAbs[1] - 64.0) - xySigns[1]) / 63.0;	// abs({nX, nY})

            //outputNormal.z		= 1.0 - outputNormal.x - outputNormal.y;		// Project onto x+y+z=1
            outputNormal[2] = 1.0 - outputNormal[0] - outputNormal[1];		// Project onto x+y+z=1
            //outputNormal.xyz	= normalize(outputNormal.xyz);				// Normalize onto unit sphere
            vec3.normalize(outputNormal, outputNormal);

            //outputNormal.xy	 *= lerp(fOne.xx, -fOne.xx, xySigns);			// Restore x and y signs
            //outputNormal.z	 *= lerp(fOne.x, -fOne.x, ztSigns.x);			// Restore z sign
            outputNormal[0] *= (1 - xySigns[0]) - xySigns[0];
            outputNormal[1] *= (1 - xySigns[1]) - xySigns[1];
            return vec3.normalize(outputNormal, outputNormal);
        }

        const block = this.blocks.VBIB || this.blocks.MBUF;
        if (!block) {
            return null;
        }

        const vertexBuffer = block.vertices[bufferId];
        const indexBuffer = block.indices[bufferId];
        const normals = vertexBuffer ? vertexBuffer.normals : [];
        const indices = indexBuffer ? indexBuffer.indices : [];

        const ret = [];
        const indicesLength = indices.length;
        const normalVec4 = vec4.create();
        let normalVec3;
        for (let i = 0; i < indicesLength; i++) {
            const vertexId = indices[i] * 4;
            normalVec4[0] = normals[vertexId + 0];
            normalVec4[1] = normals[vertexId + 1];
            normalVec4[2] = normals[vertexId + 2];
            normalVec4[3] = normals[vertexId + 3];

            normalVec3 = DecompressNormal(normalVec4);
            ret.push(normalVec3[0]);
            ret.push(normalVec3[1]);
            ret.push(normalVec3[2]);
            //ret.push(0);

            //ret.push(normals[vertexId + 0] / 255.0);
            //ret.push(normals[vertexId + 1] / 255.0);
            //ret.push(normals[vertexId + 2] / 255.0);
            //ret.push(normals[vertexId + 3] / 255.0);
        }
        return ret;
    }

    getCoordArray(bufferId) {
        const block = this.blocks.VBIB || this.blocks.MBUF;
        if (!block) {
            return null;
        }

        const vertexBuffer = block.vertices[bufferId];
        const indexBuffer = block.indices[bufferId];
        const coords = vertexBuffer ? vertexBuffer.coords : [];
        const indices = indexBuffer ? indexBuffer.indices : [];
        //var coords = block.vertices[bufferId].coords;
        //var indices = block.indices[bufferId].indices;

        const ret = [];
        const indicesLength = indices.length;
        for (let i = 0; i < indicesLength; i++) {
            const vertexId = indices[i] * 2;
            ret.push(coords[vertexId + 0]);
            ret.push(coords[vertexId + 1]);
        }
        return ret;
    }

    getBoneIndiceArray(bufferId) {
        const block = this.blocks.VBIB || this.blocks.MBUF;
        if (!block) {
            return null;
        }


        const vertexBuffer = block.vertices[bufferId];
        const indexBuffer = block.indices[bufferId];
        const vertices = vertexBuffer ? vertexBuffer.boneIndices : [];
        const indices = indexBuffer ? indexBuffer.indices : [];
        //var vertices = block.vertices[bufferId].boneIndices;
        //var indices = block.indices[bufferId].indices;

        const ret = [];
        const indicesLength = indices.length;
        for (let i = 0; i < indicesLength; i++) {
            const vertexId = indices[i] * 4;
            ret.push(vertices[vertexId + 0]);
            ret.push(vertices[vertexId + 1]);
            ret.push(vertices[vertexId + 2]);
            //ret.push(vertices[vertexId + 3]);TODO
        }
        return ret;
    }

    getBoneWeightArray(bufferId) {
        const block = this.blocks.VBIB || this.blocks.MBUF;
        if (!block) {
            return null;
        }

        const vertexBuffer = block.vertices[bufferId];
        const indexBuffer = block.indices[bufferId];
        const vertices = vertexBuffer ? vertexBuffer.boneWeight : [];
        const indices = indexBuffer ? indexBuffer.indices : [];
        //var vertices = block.vertices[bufferId].boneWeight;
        //var indices = block.indices[bufferId].indices;

        const ret = [];
        const indicesLength = indices.length;
        for (let i = 0; i < indicesLength; i++) {
            const vertexId = indices[i] * 4;
            ret.push(vertices[vertexId + 0] / 255);//TODO: optimise
            ret.push(vertices[vertexId + 1] / 255);
            ret.push(vertices[vertexId + 2] / 255);
            //ret.push(vertices[vertexId + 3]);TODO
        }
        return ret;
    }

    getTangentArray(bufferId) {
        const block = this.blocks.VBIB || this.blocks.MBUF;
        if (!block) {
            return null;
        }
        const vertexBuffer = block.vertices[bufferId];
        const indexBuffer = block.indices[bufferId];
        const vertices = vertexBuffer ? vertexBuffer.boneIndices : [];
        const indices = indexBuffer ? indexBuffer.indices : [];
        //var vertices = block.vertices[bufferId].boneIndices;
        //var indices = block.indices[bufferId].indices;

        const ret = [];
        const indicesLength = indices.length;
        for (let i = 0; i < indicesLength; i++) {
            const vertexId = indices[i] * 4;
            ret.push(vertices[vertexId + 0]);
            ret.push(vertices[vertexId + 1]);
            ret.push(vertices[vertexId + 2]);
            //ret.push(vertices[vertexId + 3]);TODO
        }
        return ret;
    }

    getBinormalArray(bufferId) {
        const block = this.blocks.VBIB || this.blocks.MBUF;
        if (!block) {
            return null;
        }

        const vertexBuffer = block.vertices[bufferId];
        const indexBuffer = block.indices[bufferId];
        const vertices = vertexBuffer ? vertexBuffer.boneIndices : [];
        const indices = indexBuffer ? indexBuffer.indices : [];
        //var vertices = block.vertices[bufferId].boneIndices;
        //var indices = block.indices[bufferId].indices;

        const ret = [];
        const indicesLength = indices.length;
        for (let i = 0; i < indicesLength; i++) {
            const vertexId = indices[i] * 4;
            ret.push(vertices[vertexId + 0]);
            ret.push(vertices[vertexId + 1]);
            ret.push(vertices[vertexId + 2]);
            //ret.push(vertices[vertexId + 3]);TODO
        }
        return ret;
    }
    */
    getBlockStruct(block, path) {
        console.assert(path != null, 'path is null', block, path);
        console.assert(path != '', 'path is empty, use getBlockKeyValues', block, path);
        //const arr = path.split('.');
        const b = this.blocks[block];
        if (!b) {
            return null;
        }
        const value = b.getKeyValue(path);
        //console.assert(value != null, 'value is null', block, path, b);
        /*
        if ((value as (Kv3Value | undefined))?.isKv3Value) {
            return (value as Kv3Value).getValue();
        }
        */
        return value;
    }
    getBlockStructAsArray(block, path) {
        const prop = this.getBlockStruct(block, path);
        if (prop?.isKv3Value && prop.isArray()) {
            return prop.getValue();
        }
        return null;
    }
    getBlockStructAsElement(block, path) {
        const prop = this.getBlockStruct(block, path);
        if (prop?.isKv3Element) {
            return prop;
        }
        if (prop?.isKv3Value && prop.getType() == Kv3Type.Element) {
            return prop.getValue();
        }
        return null;
    }
    getBlockStructAsElementArray(block, path) {
        const prop = this.getBlockStruct(block, path);
        if (prop?.isKv3Value && prop.getSubType() == Kv3Type.Element) {
            return prop.getValue();
        }
        return null;
    }
    getBlockStructAsString(block, path) {
        const prop = this.getBlockStruct(block, path);
        if (prop?.isKv3Value && prop.getType() == Kv3Type.String) {
            return prop.getValue();
        }
        return null;
    }
    getBlockStructAsStringArray(block, path) {
        const prop = this.getBlockStruct(block, path);
        if (prop?.isKv3Value && prop.getSubType() == Kv3Type.String) {
            return prop.getValue();
        }
        return null;
    }
    getBlockStructAsResourceArray(block, path) {
        const prop = this.getBlockStruct(block, path);
        if (prop?.isKv3Value && prop.isArray() && prop.getSubType() == Kv3Type.Resource) {
            return prop.getValue();
        }
        return null;
    }
    getBlockStructAsBigintArray(block, path) {
        const prop = this.getBlockStruct(block, path);
        if (prop?.isKv3Value && prop.isBigintArray()) {
            return prop.getValue();
        }
        return null;
    }
    getBlockStructAsNumberArray(block, path) {
        const prop = this.getBlockStruct(block, path);
        if (prop?.isKv3Value && prop.isNumberArray()) {
            return prop.getValue();
        }
        return null;
    }
    getBlockKeyValues(block) {
        const b = this.blocks[block];
        if (!b) {
            return null;
        }
        return b.keyValue?.root ?? null;
    }
    getPermModelData(path) {
        //return this.getBlockStruct('DATA.structs.PermModelData_t.' + path) || this.getBlockStruct('DATA.keyValue.root.' + path);
        return this.getBlockStruct('DATA', 'PermModelData_t.' + path) ?? this.getBlockStruct('DATA', path);
    }
    getMaterialResourceData(path) {
        return this.getBlockStructAsElementArray('DATA', 'MaterialResourceData_t' + path) ?? this.getBlockStructAsElementArray('DATA', path); // ?? this.getBlockStruct('DATA', path);
    }
    getExternalFiles() {
        const rerl = this.blocks['RERL'];
        return rerl?.externalFiles2 ?? [];
    }
    getExternalFile(fileIndex) {
        const externalFiles = this.getExternalFiles();
        return externalFiles?.[fileIndex] ?? null;
    }
    getKeyValue(path) {
        const dataBlock = this.blocks['DATA'];
        if (dataBlock) {
            const keyValue = dataBlock.keyValue;
            if (keyValue) {
                return keyValue.getValue(path);
            }
        }
        return null;
    }
    getKeyValueRoot() {
        const dataBlock = this.blocks['DATA'];
        if (dataBlock) {
            return dataBlock.keyValue;
        }
        return null;
    }
    /**
     * @deprecated use getDisplayName() instead
     */
    get displayName() {
        return this.getDisplayName();
    }
    getDisplayName() {
        const fileName = this.fileName;
        if (fileName) {
            const result = /(\w+)\.\w+$/.exec(fileName);
            if (result && result.length == 2) {
                return result[1];
            }
        }
        return '';
    }
    getRemappingTable(meshIndex) {
        const remappingTableStarts = this.getBlockStructAsBigintArray('DATA', 'm_remappingTableStarts') ?? this.getBlockStructAsNumberArray('DATA', 'm_remappingTableStarts');
        if (!remappingTableStarts || meshIndex > remappingTableStarts.length) {
            return null;
        }
        const remappingTable = this.getBlockStructAsBigintArray('DATA', 'm_remappingTable') ?? this.getBlockStructAsNumberArray('DATA', 'm_remappingTable');
        if (!remappingTable) {
            return null;
        }
        const starts = remappingTableStarts[meshIndex];
        if (starts === undefined || starts > remappingTable.length) {
            return null;
        }
        let end = remappingTableStarts[meshIndex + 1];
        if (end !== undefined) {
            end = Number(end); // Converts bigint
        }
        return remappingTable.slice(Number(starts), end /*TODO: remove this cast. for some reason it is needed in non strict mode*/);
    }
    remapBuffer(buffer, remappingTable) {
        const inArr = new Float32Array(buffer);
        const outArr = new Float32Array(new ArrayBuffer(buffer.byteLength));
        if (remappingTable) {
            inArr.forEach((element, index) => {
                outArr[index] = Number(remappingTable[element] ?? element);
            });
        }
        return outArr;
    }
}

const TEXTURE_COMPILER = 'CompileTexture';
const TEXTURE_YCOCG = 'Texture Compiler Version Image YCoCg Conversion';
const TEXTURE_NORMALIZED_NORMALS = 'Texture Compiler Version Image NormalizeNormals';
var VtexImageFormat;
(function (VtexImageFormat) {
    VtexImageFormat[VtexImageFormat["Unknown"] = 0] = "Unknown";
    VtexImageFormat[VtexImageFormat["Dxt1"] = 1] = "Dxt1";
    VtexImageFormat[VtexImageFormat["Dxt5"] = 2] = "Dxt5";
    VtexImageFormat[VtexImageFormat["R8"] = 3] = "R8";
    VtexImageFormat[VtexImageFormat["R8G8B8A8Uint"] = 4] = "R8G8B8A8Uint";
    VtexImageFormat[VtexImageFormat["PngR8G8B8A8Uint"] = 16] = "PngR8G8B8A8Uint";
    VtexImageFormat[VtexImageFormat["PngDXT5"] = 18] = "PngDXT5";
    VtexImageFormat[VtexImageFormat["Bc7"] = 20] = "Bc7";
    VtexImageFormat[VtexImageFormat["Bc5"] = 21] = "Bc5";
    VtexImageFormat[VtexImageFormat["Bc4"] = 27] = "Bc4";
    VtexImageFormat[VtexImageFormat["BGRA8888"] = 28] = "BGRA8888";
})(VtexImageFormat || (VtexImageFormat = {}));
var TextureCodec;
(function (TextureCodec) {
    TextureCodec[TextureCodec["YCoCg"] = 1] = "YCoCg";
    TextureCodec[TextureCodec["NormalizeNormals"] = 2] = "NormalizeNormals";
})(TextureCodec || (TextureCodec = {}));
class Source2Texture extends Source2File {
    #vtexImageFormat = VtexImageFormat.Unknown; // original image format
    #compressionMethod = TextureCompressionMethod.Uncompressed; // TODO: remove
    #imageFormat = ImageFormat.Unknown;
    #codecs = 0;
    spriteSheet = null;
    constructor(repository, path) {
        super(repository, path);
    }
    getAlphaBits() {
        return 8; //TODO: fix that
    }
    getWidth() {
        const block = this.blocks.DATA;
        if (!block) {
            return 0;
        }
        return block.width;
    }
    getHeight() {
        const block = this.blocks.DATA;
        if (!block) {
            return 0;
        }
        return block.height;
    }
    getDxtLevel() {
        const block = this.blocks.DATA;
        if (!block) {
            return 0;
        }
        switch (this.#vtexImageFormat) {
            case 1: //TODO DXT1
                return 1;
            case 2: //TODO DXT5
                return 5;
        }
        return 0;
    }
    isCompressed() {
        const block = this.blocks.DATA;
        if (!block) {
            return false;
        }
        return this.#vtexImageFormat <= 2; //DXT1 or DXT5
    }
    isCubeTexture() {
        const block = this.blocks.DATA;
        if (!block) {
            return false;
        }
        return (block.flags & VTEX_FLAG_CUBE_TEXTURE) == VTEX_FLAG_CUBE_TEXTURE;
    }
    setImageFormat(imageFormat) {
        this.#vtexImageFormat = imageFormat;
        // TODO: improve code
        switch (imageFormat) {
            case VtexImageFormat.Dxt1:
                this.#compressionMethod = TextureCompressionMethod.St3c;
                this.#imageFormat = ImageFormat.Bc1;
                break;
            case VtexImageFormat.Dxt5:
                this.#compressionMethod = TextureCompressionMethod.St3c;
                this.#imageFormat = ImageFormat.Bc3;
                break;
            case VtexImageFormat.R8:
                this.#compressionMethod = TextureCompressionMethod.Uncompressed;
                this.#imageFormat = ImageFormat.R8;
                break;
            case VtexImageFormat.Bc4:
                this.#compressionMethod = TextureCompressionMethod.Bptc;
                this.#imageFormat = ImageFormat.Bc4;
                break;
            case VtexImageFormat.Bc5:
                this.#compressionMethod = TextureCompressionMethod.Bptc;
                this.#imageFormat = ImageFormat.Bc5;
                break;
            case VtexImageFormat.Bc7:
                this.#compressionMethod = TextureCompressionMethod.Bptc;
                this.#imageFormat = ImageFormat.Bc7;
                break;
            case VtexImageFormat.R8G8B8A8Uint:
                this.#compressionMethod = TextureCompressionMethod.Uncompressed;
                this.#imageFormat = ImageFormat.R8G8B8A8Uint;
                break;
            case VtexImageFormat.BGRA8888:
                this.#compressionMethod = TextureCompressionMethod.Uncompressed;
                this.#imageFormat = ImageFormat.BGRA8888;
                break;
            case VtexImageFormat.PngR8G8B8A8Uint:
                this.#compressionMethod = TextureCompressionMethod.Uncompressed;
                this.#imageFormat = ImageFormat.PngR8G8B8A8Uint;
                break;
            case VtexImageFormat.PngDXT5:
                this.#compressionMethod = TextureCompressionMethod.Uncompressed;
                this.#imageFormat = ImageFormat.PngDXT5;
                break;
            default:
                console.error(`Unknown vtex format ${imageFormat}`);
                break;
        }
    }
    getVtexImageFormat() {
        return this.#vtexImageFormat;
    }
    getImageFormat() {
        return this.#imageFormat;
    }
    async getImageData(mipmap, frame = 0, face = 0) {
        const imageData = this.blocks.DATA.imageData[0];
        const imageWidth = this.blocks.DATA.width;
        const imageHeight = this.blocks.DATA.height;
        let datas;
        switch (formatCompression(this.#imageFormat)) {
            case TextureCompressionMethod.Uncompressed:
                switch (this.#imageFormat) {
                    case ImageFormat.PngR8G8B8A8Uint:
                    case ImageFormat.PngDXT5:
                        datas = new Uint8ClampedArray(imageWidth * imageHeight * 4);
                        const png = decode(imageData);
                        if (png) {
                            datas.set(png.data);
                        }
                        break;
                    default:
                        datas = new Uint8ClampedArray(imageWidth * imageHeight * 4);
                        datas.set(imageData);
                        break;
                }
                break;
            case TextureCompressionMethod.St3c:
            case TextureCompressionMethod.Rgtc:
            case TextureCompressionMethod.Bptc:
                datas = await decompressDxt(this.#imageFormat, imageWidth, imageHeight, imageData);
                break;
            default:
                console.error(this.#imageFormat);
                datas = new Uint8ClampedArray(imageWidth * imageHeight * 4);
        }
        if (this.decodeYCoCg()) {
            decodeYCoCg(datas);
        }
        if (this.decodeNormalizeNormals()) {
            decodeNormals(datas);
        }
        return new ImageData(datas, imageWidth, imageHeight);
    }
    setCodec(codec) {
        this.#codecs |= codec;
    }
    decodeYCoCg() {
        return (this.#codecs & TextureCodec.YCoCg) == TextureCodec.YCoCg;
    }
    decodeNormalizeNormals() {
        return (this.#codecs & TextureCodec.NormalizeNormals) == TextureCodec.NormalizeNormals;
    }
    setSpecialDependency(compilerIdentifier, string) {
        if (compilerIdentifier == TEXTURE_COMPILER) {
            //const s =  specialDependency.getSubValueAsString('m_String');
            switch (string) {
                case TEXTURE_YCOCG:
                    this.setCodec(TextureCodec.YCoCg);
                    break;
                case TEXTURE_NORMALIZED_NORMALS:
                    this.setCodec(TextureCodec.NormalizeNormals);
                    break;
            }
        }
    }
}
function decodeYCoCg(datas) {
    for (let i = 0; i < datas.length; i += 4) {
        const scale = 1 / ((datas[i + 2] >> 3) + 1);
        const co = (datas[i + 0] - 128) * scale;
        const cg = (datas[i + 1] - 128) * scale;
        const y = datas[i + 3];
        const tmp = y - cg;
        datas[i] = tmp + co;
        datas[i + 1] = y + cg;
        datas[i + 2] = tmp - co;
        datas[i + 3] = 255;
    }
}
function decodeNormals(datas) {
    const v = vec2.create();
    for (let i = 0; i < datas.length; i += 4) {
        // map alpha, green to red, green. Blue is computed
        v[0] = datas[i + 3] * 2 - 255;
        v[1] = -(datas[i + 1] * 2 - 255);
        datas[i + 0] = v[0] * 0.5 + 128;
        datas[i + 1] = v[1] * 0.5 + 128;
        datas[i + 2] = Math.sqrt(255 * 255 - vec2.dot(v, v)) * 0.5 + 128;
    }
}

/**
 * Kv3Element
 */
class Kv3Element {
    isKv3Element = true;
    #properties = new Map();
    setProperty(property, value) {
        this.#properties.set(property, value);
    }
    getProperty(name) {
        return this.#properties.get(name);
    }
    getProperties() {
        return this.#properties;
    }
    getValue(name) {
        const prop = this.#properties.get(name);
        if (prop?.isKv3Element) {
            return prop;
        }
        if (prop?.isKv3Value) {
            return prop.getValue();
        }
        return null;
    }
    getValueAsString(name) {
        const prop = this.#properties.get(name);
        if (prop?.isKv3Value && prop.getType() == Kv3Type.String) {
            return prop.getValue();
        }
        return null;
    }
    getValueAsStringArray(name) {
        const prop = this.#properties.get(name);
        if (prop?.isKv3Value && prop.getSubType() == Kv3Type.String) {
            return prop.getValue();
        }
        return null;
    }
    getValueAsResource(name) {
        const prop = this.#properties.get(name);
        if (prop?.isKv3Value && prop.getType() == Kv3Type.Resource) {
            return prop.getValue();
        }
        return null;
    }
    getValueAsResourceArray(name) {
        const prop = this.#properties.get(name);
        if (prop?.isKv3Value && prop.getSubType() == Kv3Type.Resource) {
            return prop.getValue();
        }
        return null;
    }
    getValueAsBool(name) {
        const prop = this.#properties.get(name);
        if (prop?.isKv3Value && prop.isBoolean()) {
            return prop.getValue();
        }
        return null;
    }
    getValueAsNumber(name) {
        const prop = this.#properties.get(name);
        if (prop?.isKv3Value && prop.isNumber()) {
            return prop.getValue();
        }
        return null;
    }
    getValueAsNumberArray(name) {
        const prop = this.#properties.get(name);
        if (prop?.isKv3Value && prop.isNumberArray()) {
            return prop.getValue();
        }
        return null;
    }
    getValueAsVec4(name, out) {
        const prop = this.#properties.get(name);
        if (prop?.isKv3Value && prop.isNumberArray()) {
            const v = prop.getValue();
            if (v.length == 4) {
                vec4.copy(out, v);
                return out;
            }
        }
        return null;
    }
    getValueAsBigint(name) {
        const prop = this.#properties.get(name);
        if (prop?.isKv3Value && prop.isBigint()) {
            return prop.getValue();
        }
        return null;
    }
    getValueAsBigintArray(name) {
        const prop = this.#properties.get(name);
        if (prop?.isKv3Value && prop.isBigintArray()) {
            return prop.getValue();
        }
        return null;
    }
    getValueAsBlob(name) {
        const prop = this.#properties.get(name);
        if (prop?.isKv3Value && prop.getType() == Kv3Type.Blob) {
            return prop.getValue();
        }
        return null;
    }
    getValueAsElement(name) {
        const prop = this.#properties.get(name);
        if (prop?.isKv3Element) {
            return prop;
        }
        if (prop?.isKv3Value && prop.getType() == Kv3Type.Element) {
            return prop.getValue();
        }
        return null;
    }
    getValueAsElementArray(name) {
        const prop = this.#properties.get(name);
        if (prop?.isKv3Value && prop.getSubType() == Kv3Type.Element) {
            return prop.getValue();
        }
        return null;
    }
    getValueAsVectorArray(name) {
        const prop = this.#properties.get(name);
        if (prop?.isKv3Value && prop.isVector()) {
            return prop.getValue();
        }
        return null;
    }
    /*
        Unknown = 0,
        Null = 1,
        Bool = 2,
        Int64 = 3,
        UnsignedInt64 = 4,
        Double = 5,
        String = 6,
        Blob = 7,
        Array = 8,
        Object = 9,
        TypedArray = 10,
        Int32 = 11,
        UnsignedInt32 = 12,
        True = 13,
        False = 14,
        IntZero = 15,
        IntOne = 16,
        DoubleZero = 17,
        DoubleOne = 18,
        Float = 19,
        Byte = 23,
        TypedArray2 = 24,
        TypedArray3 = 25,
        Resource = 134,
        */
    getSubValue(path) {
        const arr = path.split('.');
        let data = this;
        for (const subPath of arr) {
            if (data.isKv3Value) {
                if (!data.isArray) {
                    return null;
                }
                const value = data.getValue()?.[Number(subPath)];
                if (!value || (!value.isKv3Element && !value.isKv3Value)) {
                    return null;
                }
                data = value;
            }
            else {
                if (data.isKv3Element) {
                    data = data.getProperty(subPath);
                    if (!data) {
                        return null;
                    }
                }
            }
        }
        return data;
    }
    getSubValueAsString(path) {
        const prop = this.getSubValue(path);
        if (prop?.isKv3Value && prop.getType() == Kv3Type.String) {
            return prop.getValue();
        }
        return null;
    }
    getSubValueAsUint8Array(path) {
        const prop = this.getSubValue(path);
        if (prop?.isKv3Value && prop.getType() == Kv3Type.Blob) {
            return prop.getValue();
        }
        return null;
    }
    getSubValueAsNumber(path) {
        const prop = this.getSubValue(path);
        if (prop?.isKv3Value && prop.isNumber()) {
            return prop.getValue();
        }
        return null;
    }
    getSubValueAsElement(path) {
        const prop = this.getSubValue(path);
        if (prop?.isKv3Element) {
            return prop;
        }
        if (prop?.isKv3Value && prop.getType() == Kv3Type.Element) {
            return prop.getValue();
        }
        return null;
    }
    getSubValueAsStringArray(path) {
        const prop = this.getSubValue(path);
        if (prop?.isKv3Value && prop.isArray() && prop.getSubType() == Kv3Type.String) {
            return prop.getValue();
        }
        return null;
    }
    getSubValueAsNumberArray(path) {
        const prop = this.getSubValue(path);
        if (prop?.isKv3Value && prop.isNumberArray()) {
            return prop.getValue();
        }
        return null;
    }
    getSubValueAsVec4(path, out) {
        const prop = this.getSubValue(path);
        if (prop?.isKv3Value && prop.isNumberArray()) {
            const v = prop.getValue();
            if (v.length == 4) {
                vec4.copy(out, v);
                return out;
            }
        }
        return null;
    }
    getSubValueAsElementArray(path) {
        const prop = this.getSubValue(path);
        if (prop?.isKv3Value && prop.isArray() && prop.getSubType() == Kv3Type.Element) {
            return prop.getValue();
        }
        return null;
    }
    getSubValueAsResource(path) {
        const prop = this.getSubValue(path);
        if (prop?.isKv3Value && prop.getType() == Kv3Type.Resource) {
            return prop.getValue();
        }
        return null;
    }
    exportAsText(linePrefix) {
        const out = [];
        //const keys = Object.keys(this);
        const linePrefix2 = linePrefix + '\t';
        //out.push(linePrefix);
        out.push(`\n${linePrefix}{\r\n`);
        for (const [key, val] of this.#properties) {
            out.push(linePrefix2);
            out.push(key);
            out.push(' = ');
            if (val) {
                out.push(val.exportAsText(linePrefix2));
            }
            out.push('\r\n');
        }
        out.push(linePrefix);
        out.push('}');
        return out.join('');
    }
}
class SourceKv3String {
    id;
    constructor(id) {
        this.id = id;
    }
}
class Source2Kv3Value {
    type;
    value;
    constructor(type /*TODO: create an enum*/) {
        this.type = type;
    }
}

/**
 * Kv3File
 */
class Kv3File {
    isKv3File = true;
    root = null;
    setRoot(root) {
        this.root = root;
    }
    exportAsText() {
        if (this.root) {
            return this.root.exportAsText('');
        }
        return null;
    }
    getValue(path) {
        const arr = path.split('.');
        let data = this.root;
        if (!data) {
            return null;
        }
        //let sub;
        for (const subPath of arr) {
            if (data.isKv3Value) {
                if (!data.isArray) {
                    return null;
                }
                const value = data.getValue()?.[Number(subPath)];
                if (!value || (!value.isKv3Element && !value.isKv3Value)) {
                    return null;
                }
                data = value;
            }
            else {
                if (data.isKv3Element) {
                    data = data.getProperty(subPath);
                    if (!data) {
                        return null;
                    }
                }
            }
            /*
            if (sub instanceof Kv3Array) {
                data = sub;
            } else {
                data = sub;
            }*/
        }
        /*
        if (data instanceof Kv3Value) {
            return data.getValue();
        } else {
            return data;
        }*/
        return data;
    }
    getValueAsNumber(path) {
        const value = this.getValue(path);
        if (value?.isKv3Value && value.isNumber()) {
            return value.getValue();
        }
        return null;
    }
    getValueAsStringArray(path) {
        const value = this.getValue(path);
        if (value?.isKv3Value && value.getSubType() == Kv3Type.String) {
            return value.getValue();
        }
        return null;
    }
    getValueAsElementArray(path) {
        const value = this.getValue(path);
        if (value?.isKv3Value && value.getSubType() == Kv3Type.Element) {
            return value.getValue();
        }
        return null;
    }
}
//export type Kv3ValueType = null | number | Kv3Element;

function decodeLz4(reader, decompressBlobArray, compressedSize, uncompressedSize, outputIndex = 0) {
    reader.tell() + compressedSize;
    //let outputIndex = 0;
    let decodedeBytes = 0;
    const decodeMask = reader.getUint8();
    let readBytes = (decodeMask & 0xF0) >> 4;
    if (readBytes == 0xF) {
        let a = 0;
        do {
            a = reader.getUint8();
            readBytes += a;
        } while (a == 0xFF);
    }
    let decodeLen = decodeMask & 0xF;
    //let buffer = new Uint8Array(reader.buffer);
    decodeLoop: while (true) {
        //console.error(readBytes);
        let offset = reader.tell();
        while (readBytes--) {
            decompressBlobArray[outputIndex++] = reader.getUint8(offset++); //buffer[offset++];offset++
            ++decodedeBytes;
        }
        if (decodedeBytes >= uncompressedSize) {
            break decodeLoop;
        }
        const decodeOffset = reader.getUint16(offset);
        if (decodeLen == 0xF) {
            let a = 0;
            do {
                a = reader.getUint8();
                decodeLen += a;
            } while (a == 0xFF);
        }
        const decodeMask = reader.getUint8();
        const nextLen = decodeMask & 0xF;
        readBytes = (decodeMask & 0xF0) >> 4;
        if (readBytes == 0xF) {
            let a = 0;
            do {
                a = reader.getUint8();
                readBytes += a;
            } while (a == 0xFF);
        }
        for (let k = 0; k < decodeLen + 4; k++) {
            decompressBlobArray[outputIndex] = decompressBlobArray[outputIndex - decodeOffset];
            ++decodedeBytes;
            if (decodedeBytes >= uncompressedSize) {
                break decodeLoop;
            }
            ++outputIndex;
        }
        decodeLen = nextLen;
    }
    return decodedeBytes;
}

function zstd(imports){return _loadWasmModule(0, null, 'AGFzbQEAAAABvAEYYAF/AX9gAn9/AX9gA39/fwF/YAV/f39/fwF/YAF/AGACf38AYAN/f38AYAR/f39/AX9gBn9/f39/fwF/YAABf2AHf39/f39/fwF/YAd/f39/f39/AGABfwF+YAN/fn8BfmACfn4BfmAAAGAFf39/f38AYAl/f39/f39/f38AYAp/f39/f39/f39/AGACf34AYAh/f39/f39/fwF/YA9/f39/f39/f39/f39/f38Bf2ACfn4Bf2ACf38BfgInAQNlbnYfZW1zY3JpcHRlbl9ub3RpZnlfbWVtb3J5X2dyb3d0aAAEA4sBiQEAAQAFAgECDhMAAgUABQIAAAABAQUGBAMFCwUABg4UFQACBRcCAAcCAAQGDwoDEAkGAwMDAwMHBwADBgQEBwcBAwgFAQUCAAEMBgwKAwoKAAYABwsCBAUIBAMIAwEIAxIRCQgJAQEBBgEWAgIHAAcDAggEBgEEAAkABgIAAQEABQ0BAAQHCAQEAAQFAXABBQUFBAEAgAIGCQF/AUHQrMACCwejAQsGbWVtb3J5AgANY3JlYXRlX2J1ZmZlcgCJAQ5kZXN0cm95X2J1ZmZlcgBzD2RlY29tcHJlc3NfWlNURABtCmRlY29tcHJlc3MAaRJnZXRfcmVzdWx0X3BvaW50ZXIAZA9nZXRfcmVzdWx0X3NpemUAYgZfc3RhcnQALAlzdGFja1NhdmUAeApzdGFja0FsbG9jAHcMc3RhY2tSZXN0b3JlAHYJCwEAQQELBCyBAUZ/Cu3HAokBCAAgAEGIf0sLGQAgACgCACAAKAIEQR9xdEEAIAFrQR9xdgt+AQR/QQMhASAAKAIEIgNBIE0EQCAAKAIIIgEgACgCEE8EQCAAEA0PCyAAKAIMIgIgAUYEQEEBQQIgA0EgSRsPCyAAIAEgASACayADQQN2IgQgASAEayACSSIBGyICayIENgIIIAAgAyACQQN0azYCBCAAIAQoAAA2AgALIAELFgAgACABKQAANwAAIAAgASkACDcACAuBBAEDfyACQYAETwRAIAAgASACEHogAA8LIAAgAmohAwJAIAAgAXNBA3FFBEACQCACQQFIBEAgACECDAELIABBA3FFBEAgACECDAELIAAhAgNAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIANPDQEgAkEDcQ0ACwsCQCADQXxxIgRBwABJDQAgAiAEQUBqIgVLDQADQCACIAEoAgA2AgAgAiABKAIENgIEIAIgASgCCDYCCCACIAEoAgw2AgwgAiABKAIQNgIQIAIgASgCFDYCFCACIAEoAhg2AhggAiABKAIcNgIcIAIgASgCIDYCICACIAEoAiQ2AiQgAiABKAIoNgIoIAIgASgCLDYCLCACIAEoAjA2AjAgAiABKAI0NgI0IAIgASgCODYCOCACIAEoAjw2AjwgAUFAayEBIAJBQGsiAiAFTQ0ACwsgAiAETw0BA0AgAiABKAIANgIAIAFBBGohASACQQRqIgIgBEkNAAsMAQsgA0EESQRAIAAhAgwBCyADQXxqIgQgAEkEQCAAIQIMAQsgACECA0AgAiABLQAAOgAAIAIgAS0AAToAASACIAEtAAI6AAIgAiABLQADOgADIAFBBGohASACQQRqIgIgBE0NAAsLIAIgA0kEQANAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIANHDQALCyAACxsBAX8gACABEAIhAiAAIAAoAgQgAWo2AgQgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQEGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQECACQQN0ams2AgQgAgshACABQs/W077Sx6vZQn4gAHxCH4lCh5Wvr5i23puef34LCQAgACABNwAACx0BAX8gACgCCCAAKAIMRgR/IAAoAgRBIEYFQQALC/MCAgJ/AX4CQCACRQ0AIAAgAmoiA0F/aiABOgAAIAAgAToAACACQQNJDQAgA0F+aiABOgAAIAAgAToAASADQX1qIAE6AAAgACABOgACIAJBB0kNACADQXxqIAE6AAAgACABOgADIAJBCUkNACAAQQAgAGtBA3EiBGoiAyABQf8BcUGBgoQIbCIBNgIAIAMgAiAEa0F8cSIEaiICQXxq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mCwtAABBBHENBAJAAkBB9CgoAgAiAwRAQZwsIQADQCAAKAIAIgggA00EQCAIIAAoAgRqIANLDQMLIAAoAggiAA0ACwtBABARIgFBf0YNBSACIQZBuCwoAgAiAEF/aiIDIAFxBEAgAiABayABIANqQQAgAGtxaiEGCyAGIAVNIAZB/v///wdLcg0FQZQsKAIAIgAEQEGMLCgCACIDIAZqIgcgA00gByAAS3INBgsgBhARIgAgAUcNAQwHCyAGIAFrIAdxIgZB/v///wdLDQQgBhARIgEgACgCACAAKAIEakYNAyABIQALIABBf0YgBUEwaiAGTXJFBEBBvCwoAgAiASAEIAZrakEAIAFrcSIBQf7///8HSwRAIAAhAQwHCyABEBFBf0cEQCABIAZqIQYgACEBDAcLQQAgBmsQERoMBAsgACIBQX9HDQUMAwtBACEEDAcLQQAhAQwFCyABQX9HDQILQZgsQZgsKAIAQQRyNgIACyACQf7///8HSw0BIAIQESIBQQAQESIATyABQX9GciAAQX9Gcg0BIAAgAWsiBiAFQShqTQ0BC0GMLEGMLCgCACAGaiIANgIAIABBkCwoAgBLBEBBkCwgADYCAAsCQAJAAkBB9CgoAgAiAwRAQZwsIQADQCABIAAoAgAiAiAAKAIEIgRqRg0CIAAoAggiAA0ACwwCC0HsKCgCACIAQQAgASAATxtFBEBB7CggATYCAAtBACEAQaAsIAY2AgBBnCwgATYCAEH8KEF/NgIAQYApQbQsKAIANgIAQagsQQA2AgADQCAAQQN0IgJBjClqIAJBhClqIgM2AgAgAkGQKWogAzYCACAAQQFqIgBBIEcNAAtB6CggBkFYaiIAQXggAWtBB3FBACABQQhqQQdxGyICayIDNgIAQfQoIAEgAmoiAjYCACACIANBAXI2AgQgACABakEoNgIEQfgoQcQsKAIANgIADAILIAAtAAxBCHEgASADTXIgAiADS3INACAAIAQgBmo2AgRB9CggA0F4IANrQQdxQQAgA0EIakEHcRsiAGoiATYCAEHoKEHoKCgCACAGaiICIABrIgA2AgAgASAAQQFyNgIEIAIgA2pBKDYCBEH4KEHELCgCADYCAAwBCyABQewoKAIAIgRJBEBB7CggATYCACABIQQLIAEgBmohAkGcLCEAAkACQAJAAkACQAJAA0Ag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QQAhBCAIQQAgCEEAShshByAAIQEDQCAEIAdGDQIgDyABQQF0aiICIAwgBCANamotAAAgCkH/AXEQJCIREAkgAkEIaiAREAkgBEEBaiEEIAFBCGohAQwAAAsAC0EAIQkgCEEAIAhBAEobIQcgACEBA0AgByAJRg0BIA8gAUEBdGohAkEAIQQgDCAJIA1qai0AACAKQf8BcRAkIREDQCAEIAtIBEAgAiAEQQF0aiIGIBEQCSAGQQhqIBEQCSAGQRBqIBEQCSAGQRhqIBEQCSAEQRBqIQQMAQsLIAlBAWohCSABIAtqIQEMAAALAAsgDkEBaiEOIAggDWohDSAIIAtsIABqIQAgBSgCDCEJDAAACwAFIAMgBEECdCICaigCACEAIAIgCmogATYCACAEQQFqIQQgACABaiEBDAELAAALAAsgECEECyAFQRBqJAAgBAscACABIAMgASADSRsiAQRAIAAgAiABEAUaCyABCwwAIAAoAvzpAUEHRgvaAQEBfyAAEDkhBQJAAkAgACgC6OsBRQRAAn8gBQRAIAAoAsjrASEBQQAMAQsgACgCxOsBIAAoAsjrASIBawshAiAAIAAoAsDrASABaiACIAMgBBBBIgMQAQ0CIAMgBXJFBEAgAEECNgKs6wEMAgsgAEEENgKs6wEgACAAKALI6wEgA2o2AszrAQwBCwJ/IAUEQCABKAIAIQVBAAwBCyACIAEoAgAiBWsLIQIgACAFIAIgAyAEEEEiAxABDQEgASABKAIAIANqNgIAIABBAjYCrOsBC0EAIQMLIAMLQQECfyAAIAAoAqzpASIDNgK46QEgACgCsOkBIQQgACABNgKw6QEgACABIAJqNgKs6QEgACABIAQgA2tqNgK06QELsgEBAX8gACAAKALk6gEQHDYCvOkBIABCADcCrOkBIABBtOkBakIANwIAIABCADcD6OkBIABB8OkBakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOsBIABCADcDgOoBIABCAzcD+OkBIABBrNABakHgDykCADcCACAAQbTQAWpB6A8oAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALTQEBfwJAIAAoApTrAUUNACAAKAKk6wEgAEHc6QFqKAIAEGYiAUUNACAAECogAEF/NgKg6wEgACAB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QSAgBGsQKyAAIAApAwggAikAABAINwMIIAAgACkDECAAKQAwEAg3AxAgACAAKQMYIAApADgQCDcDGCAAIAApAyAgAEFAaykAABAINwMgIAAoAkghAiAAQQA2AkggASACa0EgaiEBCyABQSBqIANLCwRAIAEhAgwBCyADQWBqIQQgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAghCCAHIAEpAAgQCCEHIAYgASkAEBAIIQYgBSABKQAYEAghBSABQSBqIgIhASACIARNDQALIAAgBTcDICAAIAY3AxggACAHNwMQIAAgCDcDCAsgAiADTw0BIABBKGogAiADIAJrIgMQKwsgACADNgJICwviAwICfwF+IABBBGohAgJAIABBB3FFBEAgACEBQsnP2bLx5brqJyEDA0AgAUEIaiIAIAJNBEBCACABKQMAEAggA4VCG4lCh5Wvr5i23puef35C49zKlfzO8vWFf3whAyAAIQEMAQsLAkAgAUEEaiIAIAJLBEAgASEADAELIAE1AgBCh5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACTw0CIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwAAAsACyAAIQFCyc/ZsvHluuonIQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCCADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACTw0BIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwAAAsACyADQiGIIAOFQs/W077Sx6vZQn4iA0IdiCADhUL5893xmfaZqxZ+IgNCIIggA4ULoQMBA39BuH8hBwJAIAVFDQAgBCwAACIIQf8BcSEJAkAgCEF/TARAIAlBgn9qQQF2IgggBU8NAkFsIQcgCUGBf2oiBkGAAk8NAiAEQQFqIQRBACEFA0AgBSAGTwRAIAYhByAIIQkMAwUgACAFaiAEIAVBAXZqIgctAABBBHY6AAAgACAFQQFy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', imports)}

const Zstd = new (function () {
    class Zstd {
        #webAssembly;
        #HEAPU8;
        async decompress(compressedDatas) {
            const wa = await this.getWebAssembly();
            if (!wa) {
                return null;
            }
            if (!this.#HEAPU8) {
                return null;
            }
            const api = wa.instance.exports;
            const srcSize = compressedDatas.length;
            const src = api.create_buffer(srcSize);
            this.#HEAPU8.set(compressedDatas, src);
            const result = api.decompress(src, srcSize);
            api.destroy_buffer(src);
            if (result >= 0) {
                const resultPointer = api.get_result_pointer();
                const temp = new Uint8Array(new Uint8Array(this.#HEAPU8.buffer, resultPointer, api.get_result_size()));
                api.destroy_buffer(resultPointer);
                return temp;
            }
            return null;
        }
        async decompress_ZSTD(compressedDatas, uncompressedDatas) {
            if (!this.#HEAPU8) {
                return null;
            }
            const wa = await this.getWebAssembly();
            const api = wa.instance.exports;
            const srcSize = compressedDatas.length;
            const dstSize = uncompressedDatas.length;
            const src = api.create_buffer(srcSize);
            const dst = api.create_buffer(dstSize);
            this.#HEAPU8.set(compressedDatas, src);
            const result = api.decompress_ZSTD(dst, dstSize, src, srcSize);
            console.error(result);
            const resultView = new Uint8ClampedArray(this.#HEAPU8.buffer, dst, dstSize);
            uncompressedDatas.set(resultView);
            api.destroy_buffer(src);
            api.destroy_buffer(dst);
            return result;
        }
        async getWebAssembly() {
            if (this.#webAssembly) {
                return this.#webAssembly;
            }
            const env = {
                'abortStackOverflow': (_) => { throw new Error('overflow'); },
                'emscripten_notify_memory_growth': (_) => { this.#initHeap(); },
                'table': new WebAssembly.Table({ initial: 0, maximum: 0, element: 'anyfunc' }),
                'tableBase': 0,
                'memoryBase': 1024,
                'STACKTOP': 0,
            };
            this.#webAssembly = await zstd({ env }); //await WebAssembly.instantiateStreaming(fetch('zstd.wasm'), {env});
            this.#initHeap();
            return this.#webAssembly;
        }
        #initHeap() {
            this.#HEAPU8 = new Uint8Array(this.#webAssembly.instance.exports.memory.buffer);
        }
    }
    return Zstd;
}());

const DATA_TYPE_NULL = 0x01;
const DATA_TYPE_BOOL = 0x02;
const DATA_TYPE_INT64$1 = 0x03;
const DATA_TYPE_UINT64$1 = 0x04;
const DATA_TYPE_DOUBLE = 0x05;
const DATA_TYPE_STRING = 0x06;
const DATA_TYPE_ARRAY = 0x08;
const DATA_TYPE_OBJECT = 0x09;
//const DATA_TYPE_TYPED_ARRAY = 0x0A;
const DATA_TYPE_INT32 = 0x0B;
const DATA_TYPE_UINT32 = 0x0C;
const DATA_TYPE_TRUE = 0x0D;
const DATA_TYPE_FALSE = 0x0E;
const DATA_TYPE_INT_ZERO = 0x0F;
const DATA_TYPE_INT_ONE = 0x10;
const DATA_TYPE_DOUBLE_ZERO = 0x11;
const DATA_TYPE_DOUBLE_ONE = 0x12;
const DATA_TYPE_FLOAT$1 = 0x13;
const DATA_TYPE_BYTE$1 = 0x17;
const BinaryKv3Loader = new (function () {
    class BinaryKv3Loader {
        getBinaryVkv3(binaryString) {
            const reader = new BinaryReader(binaryString);
            const binaryKv3 = new Kv3File();
            const stringDictionary = [];
            readStringDictionary(reader, stringDictionary);
            const element = readElement(reader, stringDictionary);
            if (element instanceof Kv3Element) {
                binaryKv3.setRoot(element);
            }
            return binaryKv3;
        }
        getBinaryKv3(version, binaryString, singleByteCount, doubleByteCount, quadByteCount, eightByteCount, dictionaryTypeLength, blobCount, totalUncompressedBlobSize, compressedBlobReader, uncompressedBlobReader, compressionFrameSize, bufferId, stringDictionary, objectCount, arrayCount /*TODO: use it*/, buffer0) {
            const reader = new BinaryReader(binaryString);
            if (!stringDictionary) {
                stringDictionary = [];
            }
            //let offset = reader.byteLength - 4;//TODO: check last 4 bytes (0x00 0xDD 0xEE 0xFF)
            let offset;
            let byteCursor = 0;
            if (version >= 5 && bufferId == 1) {
                byteCursor = objectCount * 4;
            }
            const doubleCursor = Math.ceil((byteCursor + singleByteCount[bufferId]) / 2) * 2; //Math.ceil(byteCursor + singleByteCount[bufferId] / 2) * 2;
            const quadCursor = Math.ceil((doubleCursor + doubleByteCount[bufferId] * 2) / 4) * 4; //Math.ceil(singleByteCount / 4) * 4;
            let eightCursor = Math.ceil((quadCursor + quadByteCount[bufferId] * 4) / 8) * 8;
            if (version >= 5 && eightByteCount[bufferId] == 0) {
                // In this case, don't align cursor
                eightCursor = quadCursor + quadByteCount[bufferId] * 4;
            }
            //console.info(byteCursor, doubleCursor, quadCursor, eightCursor);
            let dictionaryOffset = eightCursor + eightByteCount[bufferId] * 8;
            if (version >= 5 && bufferId == 0) {
                dictionaryOffset = 0;
            }
            let uncompressedBlobSizeReader, compressedBlobSizeReader;
            const blobOffset = dictionaryOffset + dictionaryTypeLength;
            if (version >= 2 && blobCount != 0) {
                if (compressedBlobReader) {
                    const uncompressedLength = blobCount * 4;
                    uncompressedBlobSizeReader = new BinaryReader(reader, blobOffset, uncompressedLength);
                    compressedBlobSizeReader = new BinaryReader(reader, blobOffset + 4 + uncompressedLength);
                }
                else {
                    if (uncompressedBlobReader) {
                        uncompressedBlobSizeReader = new BinaryReader(reader, reader.byteLength - blobCount * 4 - 4, blobCount * 4);
                    }
                }
            }
            if (version == 1) { //v1
                offset = reader.byteLength - 4;
            }
            else if (version < 5) { //v2-v4
                offset = blobOffset;
            }
            else {
                offset = 0 /*TODO: check*/;
            }
            const typeArray = [];
            const valueArray = [];
            if (version < 5) {
                do {
                    --offset;
                    const type = reader.getUint8(offset);
                    //typeArray.unshift(type);
                    if (type) {
                        typeArray.unshift(type);
                    }
                    else {
                        break;
                    }
                } while (offset >= 0);
            }
            else {
                if (bufferId == 1) {
                    reader.seek(dictionaryOffset);
                    for (let i = 0; i < dictionaryTypeLength; i++) {
                        const type = reader.getUint8();
                        if (type) {
                            typeArray.push(type);
                        }
                    }
                }
            }
            const byteReader = new BinaryReader(reader);
            const doubleReader = new BinaryReader(reader);
            const quadReader = new BinaryReader(reader);
            const eightReader = new BinaryReader(reader);
            let byteReaderBuf0;
            let doubleReaderBuf0;
            let quadReaderBuf0;
            let eightReaderBuf0;
            byteReader.seek(byteCursor);
            doubleReader.seek(doubleCursor);
            quadReader.seek(quadCursor);
            eightReader.seek(eightCursor);
            reader.seek(); // skip blob data
            const readers = {};
            let objectsSizeReader = quadReader;
            if (bufferId == 0) {
                // In v5, strings are in buffer 0
                const stringCount = quadReader.getUint32();
                reader.seek(dictionaryOffset);
                readStringDictionary(reader, stringDictionary, stringCount);
                if (version >= 5) {
                    return stringDictionary;
                }
            }
            else {
                objectsSizeReader = new BinaryReader(reader);
                const reader0 = new BinaryReader(buffer0);
                const byteCursorBuf0 = 0;
                const doubleCursorBuf0 = Math.ceil(singleByteCount[0] / 2) * 2;
                const quadCursorBuf0 = Math.ceil((doubleCursorBuf0 + doubleByteCount[0] * 2) / 4) * 4;
                const eightCursorBuf0 = Math.ceil((quadCursorBuf0 + quadByteCount[0] * 4) / 8) * 8;
                //console.info('cursor buff 0', byteCursorBuf0, doubleCursorBuf0, quadCursorBuf0, eightCursorBuf0)
                byteReaderBuf0 = new BinaryReader(reader0);
                doubleReaderBuf0 = new BinaryReader(reader0);
                quadReaderBuf0 = new BinaryReader(reader0);
                eightReaderBuf0 = new BinaryReader(reader0);
                byteReaderBuf0.seek(byteCursorBuf0);
                doubleReaderBuf0.seek(doubleCursorBuf0);
                quadReaderBuf0.seek(quadCursorBuf0 + 4); // Eat a quad (string dictionnary length)
                eightReaderBuf0.seek(eightCursorBuf0);
                readers.reader1 = byteReaderBuf0;
                readers.reader2 = doubleReaderBuf0;
                readers.reader4 = quadReaderBuf0;
                readers.reader8 = eightReaderBuf0;
            }
            let decompressBlobBuffer;
            let decompressBlobArray;
            if (compressedBlobReader) { //if a compressed reader is provided, we have to uncompress the blobs
                decompressBlobBuffer = new ArrayBuffer(totalUncompressedBlobSize);
                decompressBlobArray =
                    { array: new Uint8Array(decompressBlobBuffer), offset: 0 };
                //decompressBlobArray.decompressOffset = 0;
            }
            const rootElement = readBinaryKv3Element({ dictionary: stringDictionary }, version, byteReader, doubleReader, quadReader, eightReader, objectsSizeReader, uncompressedBlobSizeReader, compressedBlobSizeReader, blobCount, decompressBlobBuffer, decompressBlobArray, compressedBlobReader, uncompressedBlobReader, typeArray, valueArray, undefined, false, compressionFrameSize, readers);
            // return it in a suitable format
            const binaryKv3 = new Kv3File();
            if (rootElement.isKv3Element) {
                //binaryKv3.setRoot(binaryKv32KV3(rootElement, stringDictionary));
                binaryKv3.setRoot(rootElement);
            }
            return binaryKv3;
        }
    }
    return BinaryKv3Loader;
}());
function readStringDictionary(reader, stringDictionary, stringCount) {
    stringCount = stringCount ?? reader.getUint32();
    for (let i = 0; i < stringCount; i++) {
        stringDictionary.push(reader.getNullString());
    }
}
function readBinaryKv3Element(context, version, byteReader, doubleReader, quadReader, eightReader, objectsSizeReader, uncompressedBlobSizeReader, compressedBlobSizeReader, blobCount, decompressBlobBuffer, decompressBlob, compressedBlobReader, uncompressedBlobReader, typeArray, valueArray /*TODO: remove me ?*/, elementType, isArray, compressionFrameSize, readers0) {
    function shiftArray() {
        const elementType = typeArray.shift();
        if (elementType == Kv3Type.Resource) {
            // Why do we do that ?
            typeArray.shift();
        }
        if (elementType == Kv3Type.Subclass) {
            // Why do we do that ?
            typeArray.shift();
        }
        return elementType;
    }
    elementType = elementType || shiftArray() /*typeArray.shift()*/;
    if (elementType == undefined) {
        return null;
    }
    //let count;
    //let elements: SourceKv3Value[];
    switch (elementType) {
        case DATA_TYPE_NULL:
            return null;
        case DATA_TYPE_BOOL:
            return new Kv3Value(elementType, byteReader.getUint8() ? true : false);
        /*
            if (isArray) {
                //return byteReader.getUint8() ? true : false;
                return new Kv3Value(elementType, byteReader.getUint8() ? true : false);
            } else {
                const value = new Source2Kv3Value(elementType);
                valueArray.push(value);
                value.value = byteReader.getUint8() ? true : false;
                return value;
            }
        */
        case DATA_TYPE_INT64$1:
            return new Kv3Value(elementType, eightReader.getBigInt64());
        /*
            if (isArray) {
                return eightReader.getBigInt64();
            } else {
                const value = new Source2Kv3Value(elementType);
                value.value = eightReader.getBigInt64();
                valueArray.push(value);
                return value;
            }
        */
        case DATA_TYPE_UINT64$1:
            return new Kv3Value(elementType, eightReader.getBigUint64());
        /*
            if (isArray) {
                return eightReader.getBigUint64();
            } else {
                const value = new Source2Kv3Value(elementType);
                value.value = eightReader.getBigUint64();
                valueArray.push(value);
                return value;
            }
        */
        case DATA_TYPE_DOUBLE:
            return new Kv3Value(elementType, eightReader.getFloat64());
        /*
            if (isArray) {
                return eightReader.getFloat64();
            } else {
                const value = new Source2Kv3Value(elementType);
                value.value = eightReader.getFloat64();
                valueArray.push(value);
                return value;
            }
        */
        case DATA_TYPE_BYTE$1:
            return new Kv3Value(elementType, byteReader.getInt8());
        /*
            if (isArray) {
                return byteReader.getInt8();
            } else {
                const value = new Source2Kv3Value(elementType);
                value.value = byteReader.getInt8();
                valueArray.push(value);
                return value;
            }
        */
        case DATA_TYPE_STRING:
            return new Kv3Value(elementType, context.dictionary[quadReader.getInt32()] ?? '');
        //return new SourceKv3String(quadReader.getInt32());
        case Kv3Type.Blob:
            if (blobCount == 0) {
                const blobCount = quadReader.getUint32();
                const blobArray = new Uint8Array(blobCount);
                for (let i = 0; i < blobCount; i++) {
                    blobArray[i] = byteReader.getUint8();
                }
                return new Kv3Value(elementType, blobArray);
            }
            else {
                if (compressedBlobReader && uncompressedBlobSizeReader && compressedBlobSizeReader && decompressBlobBuffer && decompressBlob) { //if we have a decompress buffer, that means we have to decompress the blobs
                    let uncompressedBlobSize = uncompressedBlobSizeReader.getUint32();
                    //let decompressBuffer = new ArrayBuffer(uncompressedBlobSize);
                    const decompressArray = new Uint8Array(decompressBlobBuffer, decompressBlob.offset, uncompressedBlobSize);
                    /*
                    TODO: test blobs version 5 compression method 1 (lz4)
                    let compressedBlobSize: number;
                    if (version < 5) {
                        compressedBlobSize = compressedBlobSizeReader.getUint16();
                    } else {
                        compressedBlobSize = quadReader.getUint32();
                    }*/
                    while (true) {
                        const compressedBlobSize = compressedBlobSizeReader.getUint16();
                        if (uncompressedBlobSize > compressionFrameSize) {
                            const uncompressedFrameSize = decodeLz4(compressedBlobReader, decompressBlob.array, compressedBlobSize, compressionFrameSize, decompressBlob.offset);
                            decompressBlob.offset += uncompressedFrameSize;
                            uncompressedBlobSize -= uncompressedFrameSize;
                        }
                        else {
                            uncompressedBlobSize = decodeLz4(compressedBlobReader, decompressBlob.array, compressedBlobSize, uncompressedBlobSize, decompressBlob.offset);
                            decompressBlob.offset += uncompressedBlobSize;
                            break;
                        }
                    }
                    /*if (uncompressedBlobSize > compressionFrameSize) {
                        let uncompressedBlobSize2;
                        uncompressedBlobSize2 = decodeLz4(compressedBlobReader, decompressBlobArray, compressedBlobSize, compressionFrameSize, decompressBlobArray.decompressOffset);
                        decompressBlobArray.decompressOffset += uncompressedBlobSize2;
                        uncompressedBlobSize2 = decodeLz4(compressedBlobReader, decompressBlobArray, compressedBlobSize, uncompressedBlobSize - compressionFrameSize, decompressBlobArray.decompressOffset);
                        decompressBlobArray.decompressOffset += uncompressedBlobSize2;
                        //uncompressedBlobSize = decodeLz4(compressedBlobReader, decompressBlobArray, compressedBlobSize, uncompressedBlobSize, decompressBlobArray.decompressOffset);
                    } else {
                        uncompressedBlobSize = decodeLz4(compressedBlobReader, decompressBlobArray, compressedBlobSize, uncompressedBlobSize, decompressBlobArray.decompressOffset);
                        decompressBlobArray.decompressOffset += uncompressedBlobSize;
                    }*/
                    //return decompressArray;
                    return new Kv3Value(elementType, decompressArray);
                }
                else {
                    if (uncompressedBlobReader && uncompressedBlobSizeReader) { //blobs have already been uncompressed
                        const uncompressedBlobSize = uncompressedBlobSizeReader.getUint32();
                        //return uncompressedBlobReader.getBytes(uncompressedBlobSize);
                        return new Kv3Value(elementType, uncompressedBlobReader.getBytes(uncompressedBlobSize));
                    }
                    else {
                        //should not happend
                        throw 'Missing reader';
                    }
                }
            }
        case DATA_TYPE_ARRAY:
            const arrayCount = quadReader.getUint32();
            const arrayElements = new Array(arrayCount);
            for (let i = 0; i < arrayCount; i++) {
                arrayElements[i] = readBinaryKv3Element(context, version, byteReader, doubleReader, quadReader, eightReader, objectsSizeReader, uncompressedBlobSizeReader, compressedBlobSizeReader, blobCount, decompressBlobBuffer, decompressBlob, compressedBlobReader, uncompressedBlobReader, typeArray, valueArray, undefined, true, compressionFrameSize, readers0);
            }
            //return arrayElements;
            return new Kv3Value(elementType, arrayElements);
        case DATA_TYPE_OBJECT:
            const objectCount = objectsSizeReader.getUint32();
            //elements = new Kv3Element();
            const objectElements = new Kv3Element(); //new Map<number, Source2Kv3Value>();
            const stringDictionary = context.dictionary;
            for (let i = 0; i < objectCount; i++) {
                const nameId = quadReader.getUint32();
                const element = readBinaryKv3Element(context, version, byteReader, doubleReader, quadReader, eightReader, objectsSizeReader, uncompressedBlobSizeReader, compressedBlobSizeReader, blobCount, decompressBlobBuffer, decompressBlob, compressedBlobReader, uncompressedBlobReader, typeArray, valueArray, undefined, false, compressionFrameSize, readers0);
                const name = stringDictionary[nameId];
                if (name !== undefined) {
                    objectElements.setProperty(name, element);
                }
                //elements.setProperty(nameId, element);
            }
            return objectElements;
        case Kv3Type.TypedArray:
            {
                const typedArrayCount = quadReader.getUint32();
                const subType = shiftArray() /*typeArray.shift()*/;
                const typesArrayElements = new Array(typedArrayCount);
                for (let i = 0; i < typedArrayCount; i++) {
                    const value = readBinaryKv3Element(context, version, byteReader, doubleReader, quadReader, eightReader, objectsSizeReader, uncompressedBlobSizeReader, compressedBlobSizeReader, blobCount, decompressBlobBuffer, decompressBlob, compressedBlobReader, uncompressedBlobReader, typeArray, valueArray, subType, true, compressionFrameSize, readers0);
                    if (value && value.isKv3Value) {
                        typesArrayElements[i] = value.getValue() /*TODO: check that*/;
                    }
                    else {
                        typesArrayElements[i] = value;
                    }
                }
                //return typesArrayElements;
                return new Kv3Value(elementType, typesArrayElements, subType);
            }
        case DATA_TYPE_INT32:
            return new Kv3Value(elementType, quadReader.getInt32());
        case DATA_TYPE_UINT32:
            return new Kv3Value(elementType, quadReader.getUint32());
        case DATA_TYPE_TRUE:
            return new Kv3Value(elementType, true);
        case DATA_TYPE_FALSE:
            return new Kv3Value(elementType, false);
        case DATA_TYPE_INT_ZERO:
        case DATA_TYPE_DOUBLE_ZERO:
            return new Kv3Value(elementType, 0);
        case DATA_TYPE_INT_ONE:
        case DATA_TYPE_DOUBLE_ONE:
            return new Kv3Value(elementType, 1);
        case DATA_TYPE_FLOAT$1:
            return new Kv3Value(elementType, quadReader.getFloat32());
        /*
            if (isArray) {
                return quadReader.getFloat32();
            } else {
                const value = new Source2Kv3Value(elementType);
                value.value = quadReader.getFloat32();
                valueArray.push(value);
                return value;
            }
        */
        case Kv3Type.TypedArray2:
            {
                const typedArray2Count = byteReader.getUint8();
                const subType2 = shiftArray() /*typeArray.shift()*/;
                const typesArray2Elements = new Array(typedArray2Count);
                for (let i = 0; i < typedArray2Count; i++) {
                    const value = readBinaryKv3Element(context, version, byteReader, doubleReader, quadReader, eightReader, objectsSizeReader, uncompressedBlobSizeReader, compressedBlobSizeReader, blobCount, decompressBlobBuffer, decompressBlob, compressedBlobReader, uncompressedBlobReader, typeArray, valueArray, subType2, true, compressionFrameSize, readers0);
                    if (value.isKv3Value) {
                        typesArray2Elements[i] = value.getValue();
                    }
                    else {
                        typesArray2Elements[i] = value;
                    }
                }
                //return typesArray2Elements;
                return new Kv3Value(elementType, typesArray2Elements, subType2);
            }
        case Kv3Type.TypedArray3:
            {
                const typedArray3Count = byteReader.getUint8();
                const subType3 = shiftArray() /*typeArray.shift()*/;
                const typesArray3Elements = new Array(typedArray3Count);
                for (let i = 0; i < typedArray3Count; i++) {
                    const value = readBinaryKv3Element(context, version, readers0.reader1, readers0.reader2, readers0.reader4, readers0.reader8, objectsSizeReader, uncompressedBlobSizeReader, compressedBlobSizeReader, blobCount, decompressBlobBuffer, decompressBlob, compressedBlobReader, uncompressedBlobReader, typeArray, valueArray, subType3, true, compressionFrameSize, readers0);
                    if (value.isKv3Value) {
                        typesArray3Elements[i] = value.getValue();
                    }
                    else {
                        typesArray3Elements[i] = value;
                    }
                }
                //return typesArray3Elements;
                return new Kv3Value(elementType, typesArray3Elements, subType3);
            }
        case Kv3Type.Resource:
            //return new SourceKv3String(quadReader.getInt32());
            return new Kv3Value(elementType, context.dictionary[quadReader.getInt32()] ?? '');
        case Kv3Type.Subclass:
            const objectCount2 = objectsSizeReader.getUint32();
            const objectElements2 = new Kv3Element();
            const stringDictionary2 = context.dictionary;
            for (let i = 0; i < objectCount2; i++) {
                const nameId = quadReader.getUint32();
                const element = readBinaryKv3Element(context, version, byteReader, doubleReader, quadReader, eightReader, objectsSizeReader, uncompressedBlobSizeReader, compressedBlobSizeReader, blobCount, decompressBlobBuffer, decompressBlob, compressedBlobReader, uncompressedBlobReader, typeArray, valueArray, undefined, false, compressionFrameSize, readers0);
                const name = stringDictionary2[nameId];
                if (name !== undefined) {
                    objectElements2.setProperty(name, element);
                }
            }
            return new Kv3Value(elementType, objectElements2);
        default:
            console.error('Unknown element type : ', elementType);
    }
    return null;
}
/*

function binaryKv32KV3_removeme(elementKv3: Source2Kv3Value | Map<Number, Source2Kv3ValueType> | Array<never>, stringDictionary: string[]): Kv3Element {
    let element: Kv3Element;

    if (elementKv3 instanceof Map || elementKv3 instanceof Array) {
        if (elementKv3 instanceof Map) {
            element = new Kv3Element();
        } else {
            element = [];
        }

        function iterateMap(value, key, map) {
            let newKey;
            if (elementKv3 instanceof Map) {
                newKey = stringDictionary[key];
            } else {
                //console.log(key, value);
            }

            if (value instanceof Map) {
                value = binaryKv32KV3(value, stringDictionary);
            } else if (value instanceof SourceKv3String) {
                value = stringDictionary[value.id];
            } else if (value instanceof Array) {
                value = binaryKv32KV3(value, stringDictionary);
            } else if (value instanceof Source2Kv3Value) {
                value = value.value;
            }

            if (elementKv3 instanceof Map) {
                element.setProperty(newKey, value);
            } else {
                element[key] = value;
            }
        }
        elementKv3.forEach(iterateMap);
    }
    return element;
}
    */
function readElement(reader, stringDictionary, occurences) {
    const type = reader.getUint8();
    //console.log(type);
    switch (type) {
        /*
        kv element:
        2: bool (len 1)
        3:int (len 8)
        5:float (len 8)
        6: string (len 4, index to string dict)
        8:array (len 4 + content)
        9:element
        uint32: properties count
        propertie index uint32
        property type uint8
        property value (len depends on type)


        86: resource(len 1 + 4, index to string dict)*/
        case 0:
            break;
        case 1:
            //return null;
            return new Kv3Value(type, null);
        case 2: // Bool
            if (occurences) {
                const arr = [];
                for (let i = 0; i < occurences; i++) {
                    arr.push(reader.getUint8() ? true : false);
                }
                //return arr;//new SE2Kv3Value(type, arr);
                return new Kv3Value(type, arr);
            }
            else {
                //return reader.getUint8() ? true : false;//new SE2Kv3Value(type, reader.getUint8() ? true:false);
                return new Kv3Value(type, reader.getUint8() ? true : false);
            }
        case 3: // Int 64
            if (occurences) {
                const arr = [];
                for (let i = 0; i < occurences; i++) {
                    const int64 = reader.getBigInt64(); //TODO: handle int64
                    arr.push(int64 /*(int64.hi << 32) + int64.lo*/);
                }
                //return arr;//new SE2Kv3Value(type, arr);
                return new Kv3Value(type, arr);
            }
            else {
                const int64 = reader.getBigInt64(); //TODO: handle int64
                //return int64;//(int64.hi << 32) + int64.lo;//new SE2Kv3Value(type, (int64.hi << 32) + int64.lo);
                return new Kv3Value(type, int64);
            }
        case 5: // Float 64
            if (occurences) {
                const arr = [];
                for (let i = 0; i < occurences; i++) {
                    arr.push(reader.getFloat64());
                }
                //return arr;//new SE2Kv3Value(type, arr);
                return new Kv3Value(type, arr);
            }
            else {
                //return reader.getFloat64();//new SE2Kv3Value(type, reader.getFloat64());
                return new Kv3Value(type, reader.getFloat64());
            }
        case 6: // String
            if (occurences) {
                const arr = [];
                for (let i = 0; i < occurences; i++) {
                    propertyIndex = reader.getUint32();
                    propertyName = stringDictionary[propertyIndex];
                    arr.push(propertyName ?? '');
                }
                //return arr;//new SE2Kv3Value(type, arr);
                return new Kv3Value(type, arr);
            }
            else {
                propertyIndex = reader.getUint32();
                propertyName = stringDictionary[propertyIndex];
                //return propertyName;//new SE2Kv3Value(type, propertyName);
                return new Kv3Value(type, propertyName ?? '');
            }
        case 0x07: // byte array
            var propertiesCount = reader.getUint32();
            var element = new Uint8Array(propertiesCount); //new Kv3Array();
            for (let i = 0; i < propertiesCount; i++) {
                element[i] = reader.getUint8();
            }
            //return element;
            return new Kv3Value(type, element);
        case 8: // Array
            var propertiesCount = reader.getUint32();
            var elementArray = new Array(propertiesCount);
            var propertyName = null;
            var propertyIndex = null;
            var property = null;
            for (var i = 0; i < propertiesCount; i++) {
                //propertyIndex = reader.getUint32();
                //propertyName = stringDictionary(propertyIndex);
                //property = readElement(reader, stringDictionary);
                //element.setProperty(property);
                elementArray[i] = readElement(reader, stringDictionary);
            }
            //return elementArray;
            return new Kv3Value(type, elementArray);
        case 9: // Element
            if (occurences) {
                const arr = new Array(occurences);
                for (let i = 0; i < occurences; i++) {
                    const propertiesCount = reader.getUint32();
                    const element = new Kv3Element();
                    var propertyName = null;
                    var propertyIndex = null;
                    var property = null;
                    for (let ii = 0; ii < propertiesCount; ii++) {
                        propertyIndex = reader.getUint32();
                        propertyName = stringDictionary[propertyIndex];
                        property = readElement(reader, stringDictionary);
                        if (propertyName !== undefined) {
                            element.setProperty(propertyName, property);
                        }
                    }
                    arr[i] = element;
                }
                //return arr;
                return new Kv3Value(type, arr);
            }
            else {
                var propertiesCount = reader.getUint32();
                const element = new Kv3Element();
                var propertyName = null;
                var propertyIndex = null;
                var property = null;
                for (var i = 0; i < propertiesCount; i++) {
                    propertyIndex = reader.getUint32();
                    propertyName = stringDictionary[propertyIndex];
                    property = readElement(reader, stringDictionary);
                    if (propertyName !== undefined) {
                        element.setProperty(propertyName, property);
                    }
                }
                //return element;
                return new Kv3Value(type, element);
            }
        case 0x0A: // vector
            if (occurences) {
                const arr = new Array(occurences);
                for (let i = 0; i < occurences; i++) {
                    const count = reader.getUint32();
                    arr[i] = readElement(reader, stringDictionary, count);
                }
                //return arr;//new SE2Kv3Value(type, arr);
                return new Kv3Value(type, arr);
            }
            else {
                const count = reader.getUint32();
                return readElement(reader, stringDictionary, count);
            }
        case 0x0B: // int32
            if (occurences) {
                const arr = new Array(occurences);
                for (let i = 0; i < occurences; i++) {
                    arr[i] = reader.getInt32();
                }
                //return arr;//new SE2Kv3Value(type, arr);
                return new Kv3Value(type, arr);
            }
            else {
                //return reader.getInt32();//new SE2Kv3Value(type, reader.getInt32());
                return new Kv3Value(type, reader.getInt32());
            }
        case Kv3Type.IntOne:
        case Kv3Type.DoubleOne:
            if (occurences) {
                const arr = new Array(occurences);
                for (let i = 0; i < occurences; i++) {
                    arr[i] = 1;
                }
                //return arr;//new SE2Kv3Value(type, arr);
                return new Kv3Value(type, arr);
            }
            else {
                //return 1;//new SE2Kv3Value(type, 1);
                return new Kv3Value(type, 1);
            }
        case Kv3Type.IntZero:
        case Kv3Type.DoubleZero:
            if (occurences) {
                const arr = new Array(occurences);
                for (let i = 0; i < occurences; i++) {
                    arr[i] = 0;
                }
                //return arr;//new SE2Kv3Value(type, arr);
                return new Kv3Value(type, arr);
            }
            else {
                //return 0;//new SE2Kv3Value(type, 0);
                return new Kv3Value(type, 0);
            }
        case Kv3Type.True:
            if (occurences) {
                const arr = new Array(occurences);
                for (let i = 0; i < occurences; i++) {
                    arr[i] = true;
                }
                //return arr;
                return new Kv3Value(type, arr);
            }
            else {
                //return true;
                return new Kv3Value(type, true);
            }
        case Kv3Type.False:
            if (occurences) {
                const arr = new Array(occurences);
                for (let i = 0; i < occurences; i++) {
                    arr[i] = false;
                }
                //return arr;
                return new Kv3Value(type, arr);
            }
            else {
                //return false;
                return new Kv3Value(type, false);
            }
        case Kv3Type.Resource:
            if (occurences) {
                const arr = [];
                reader.getUint8(); //todo: rename variable
                for (let i = 0; i < occurences; i++) {
                    propertyIndex = reader.getUint32();
                    propertyName = stringDictionary[propertyIndex];
                    arr.push(propertyName ?? '');
                }
                //return arr;//new SE2Kv3Value(type, arr);
                return new Kv3Value(type, arr);
            }
            else {
                reader.getUint8(); //todo: rename variable
                propertyIndex = reader.getUint32();
                propertyName = stringDictionary[propertyIndex];
                //console.error(propertyName, test);
                //return propertyName;//new SE2Kv3Value(type, propertyName);
                return new Kv3Value(type, propertyName ?? '');
            }
        default:
            console.error('Unknown value type : ' + type);
    }
    //return null;
    return new Kv3Value(type, null);
}

/*
Struct of a kv3 block
In a single lz4 compressed block:
uint32 string count
byte array
four bytes array
eight bytes array
array of null terminated strings
type array (1 byte)
V2 only : uint32 * blobCount array
0xFFDDEE00 // don't ask why this is no more at the end
V2 only : uint16 * blobCount array


Follows the compressed blobs
*/
async function loadDataKv3(reader, block, version) {
    reader.seek(block.offset);
    let bufferCount = 1;
    const uncompressedBufferSize = [];
    const compressedBufferSize = [];
    const bytesBufferSize1 = [];
    const bytesBufferSize2 = [];
    const bytesBufferSize4 = [];
    const bytesBufferSize8 = [];
    const objectCount = [];
    const arrayCount = [];
    reader.skip(4);
    reader.getString(16);
    const compressionMethod = reader.getUint32();
    let compressionFrameSize = 0;
    let dictionaryTypeLength = 0, blobCount = 0, totalUncompressedBlobSize = 0;
    if (version >= 2) {
        reader.getUint16();
        compressionFrameSize = reader.getUint16();
        //unknown1 = reader.getUint32();//0 or 0x40000000 depending on compression method
    }
    bytesBufferSize1.push(reader.getUint32());
    bytesBufferSize2.push(0);
    bytesBufferSize4.push(reader.getUint32());
    bytesBufferSize8.push(reader.getUint32());
    let compressedLength = block.length;
    if (version >= 2) {
        dictionaryTypeLength = reader.getUint32();
        objectCount.push(reader.getUint16());
        arrayCount.push(reader.getUint16());
    }
    const decodeLength = reader.getUint32();
    if (version >= 2) {
        compressedLength = reader.getUint32();
        blobCount = reader.getUint32();
        totalUncompressedBlobSize = reader.getUint32();
    }
    if (version >= 4) {
        reader.getUint32();
        reader.getUint32();
    }
    if (version >= 5) {
        bufferCount = 2;
        uncompressedBufferSize.push(reader.getUint32());
        compressedBufferSize.push(reader.getUint32());
        uncompressedBufferSize.push(reader.getUint32());
        compressedBufferSize.push(reader.getUint32());
        bytesBufferSize1.push(reader.getUint32());
        bytesBufferSize2.push(reader.getUint32());
        bytesBufferSize4.push(reader.getUint32());
        bytesBufferSize8.push(reader.getUint32());
        // TODO: use those values
        reader.getUint32();
        objectCount.push(reader.getUint32());
        arrayCount.push(reader.getUint32());
        reader.getUint32();
        //console.info(block.type, block, uncompressedBufferSize, compressedBufferSize, bytesBufferSize1, bytesBufferSize2, bytesBufferSize4, bytesBufferSize8)
    }
    else {
        uncompressedBufferSize.push(decodeLength);
        compressedBufferSize.push(compressedLength);
    }
    let sa = new Uint8Array();
    let compressedBlobReader;
    let uncompressedBlobReader;
    let stringDictionary = [];
    let buffer0 = new Uint8Array();
    for (let i = 0; i < bufferCount; i++) {
        switch (compressionMethod) {
            case 0:
                sa = reader.getBytes(uncompressedBufferSize[i]);
                break;
            case 1:
                const buf = new ArrayBuffer(uncompressedBufferSize[i]);
                sa = new Uint8Array(buf);
                if (blobCount > 0) {
                    compressedBlobReader = new BinaryReader(reader, reader.tell() + compressedBufferSize[i]);
                }
                decodeLz4(reader, sa, compressedBufferSize[i], uncompressedBufferSize[i]);
                break;
            case 2: //new since spectre arcana
                //SaveFile(new File([new Blob([reader.getBytes(block.length, block.offset)])], 'block_' + block.offset + '_' + block.length));
                const compressedBytes = reader.getBytes(compressedBufferSize[i]);
                //SaveFile(new File([new Blob([compressedBytes])], 'block_' + block.offset + '_' + block.length));
                const decompressedBytes = await Zstd.decompress(compressedBytes);
                if (!decompressedBytes) {
                    break;
                }
                sa = new Uint8Array(new Uint8Array(decompressedBytes.buffer, 0, uncompressedBufferSize[i]));
                if (blobCount > 0) {
                    if (version < 5) {
                        uncompressedBlobReader = new BinaryReader(decompressedBytes, uncompressedBufferSize[i]);
                    }
                    else {
                        if (i == 1) {
                            const compressedBlobSize = compressedLength - (compressedBufferSize[0] + compressedBufferSize[1]);
                            const compressedBlobBytes = reader.getBytes(compressedBlobSize);
                            //SaveFile(new File([new Blob([compressedBlobBytes])], 'compressed_zstd' + block.type + '_' + i + '_' + block.length + '_' + block.offset));
                            const decompressedBlobBytes = await Zstd.decompress(compressedBlobBytes);
                            //console.info(decompressedBlobBytes);
                            if (decompressedBlobBytes) {
                                uncompressedBlobReader = new BinaryReader(decompressedBlobBytes);
                            }
                            //SaveFile(new File([new Blob([decompressedBlobBytes])], 'decompressed_zstd' + block.type + '_' + i + '_' + block.length + '_' + block.offset));
                        }
                        //compressedBlobReader = new BinaryReader(reader, reader.tell());
                    }
                }
                //console.error(sa);
                //SaveFile(new File([new Blob([sa])], 'zstd'));
                break;
            default:
                throw 'Unknown kv3 compressionMethod ' + compressionMethod;
        }
        const result = BinaryKv3Loader.getBinaryKv3(version, sa, bytesBufferSize1, bytesBufferSize2, bytesBufferSize4, bytesBufferSize8, dictionaryTypeLength, blobCount, totalUncompressedBlobSize, compressedBlobReader, uncompressedBlobReader, compressionFrameSize, i, stringDictionary, objectCount[i], arrayCount[i], buffer0);
        if (version >= 5 && i == 0) {
            stringDictionary = result;
            buffer0 = sa;
        }
        else {
            //console.log(block.type, result);
            if (result.isKv3File) {
                block.keyValue = result;
            }
        }
    }
}

function decodeBlockCompressed(reader, sa, decodeLength) {
    let mask = null;
    let outputIndex = 0;
    let decodedeBytes = 0;
    decodeLoop: for (let i = 0;; i++) {
        mask = reader.getUint16();
        if (mask == 0) {
            /* TODO: copy 16 bytes at once */
            for (let j = 0; j < 16; j++) {
                sa[outputIndex++] = reader.getBytes(1)[0];
                ++decodedeBytes;
                if (decodedeBytes >= decodeLength) {
                    break decodeLoop;
                }
            }
        }
        else {
            for (let j = 0; j < 16; j++) {
                const decode = mask & (1 << j);
                if (decode) {
                    const decodeMask = reader.getUint16(); // offset 12 bits, len 4 bits
                    const decodeOffset = (decodeMask & 0xFFF0) >> 4;
                    const decodeLen = (decodeMask & 0xF) + 3; // Min len is 3
                    for (let k = 0; k < decodeLen; k++) {
                        sa[outputIndex] = sa[outputIndex - decodeOffset - 1];
                        ++decodedeBytes;
                        if (decodedeBytes >= decodeLength) {
                            break decodeLoop;
                        }
                        ++outputIndex;
                    }
                }
                else { // Single byte
                    sa[outputIndex++] = reader.getBytes(1)[0];
                    ++decodedeBytes;
                    if (decodedeBytes >= decodeLength) {
                        break decodeLoop;
                    }
                }
            }
        }
    }
}

function loadDataVkv(reader, block) {
    const KV3_ENCODING_BLOCK_COMPRESSED = '\x46\x1A\x79\x95\xBC\x95\x6C\x4F\xA7\x0B\x05\xBC\xA1\xB7\xDF\xD2';
    const KV3_ENCODING_BLOCK_COMPRESSED_LZ4 = '\x8A\x34\x47\x68\xA1\x63\x5C\x4F\xA1\x97\x53\x80\x6F\xD9\xB1\x19';
    //const KV3_ENCODING_BLOCK_COMPRESSED_UNKNOWN = '\x7C\x16\x12\x74\xE9\x06\x98\x46\xAF\xF2\xE6\x3E\xB5\x90\x37\xE7';
    reader.seek(block.offset);
    reader.skip(4); //TODO: improve detection
    const encoding = reader.getString(16);
    reader.getString(16);
    let decodeLength, sa;
    decodeLength = reader.getUint32();
    if ((decodeLength >>> 24) == 0x80) {
        sa = reader.getBytes(decodeLength & 0xFF);
        //sa = reader.getBytes(undefined, 0);
    }
    else {
        sa = new Uint8Array(new ArrayBuffer(decodeLength));
        switch (encoding) {
            case KV3_ENCODING_BLOCK_COMPRESSED:
                /*if ((decodeLength >>> 24) == 0x80) {

                } else {*/
                decodeBlockCompressed(reader, sa, decodeLength);
                //}
                break;
            case KV3_ENCODING_BLOCK_COMPRESSED_LZ4:
                decodeLz4(reader, sa, block.length, decodeLength);
                break;
            default:
                console.error('Unknown kv3 encoding ', encoding.split(''));
                break;
        }
    }
    block.keyValue = BinaryKv3Loader.getBinaryVkv3(ab2str(sa)); // TODO: pass uint8 array ?
}
function ab2str(arrayBuf) {
    let s = '';
    for (let i = 0; i < arrayBuf.length; i++) {
        s += String.fromCharCode(arrayBuf[i]);
    }
    return s;
}

async function loadKeyValue(reader, file, block) {
    const bytes = reader.getUint32(block.offset);
    switch (bytes) {
        case 0x03564B56: // VKV3
            loadDataVkv(reader, block);
            return true;
        case 0x4B563301: // kv31
            await loadDataKv3(reader, block, 1);
            return true;
        case 0x4B563302: // kv32 ?? new since wind ranger arcana
            await loadDataKv3(reader, block, 2);
            return true;
        case 0x4B563303: // KV3 v3 new since muerta
            await loadDataKv3(reader, block, 3);
            return true;
        case 0x4B563304: // KV3 v4 new since dota 7.33
            await loadDataKv3(reader, block, 4);
            return true;
        case 0x4B563305: // KV3 v5 new since frostivus 2024
            await loadDataKv3(reader, block, 5);
            return true;
        default:
            console.info('Unknown block data type:', bytes, block, file);
    }
    return false;
}

function readHandle(reader) {
    let str = '';
    let c;
    let hex;
    for (let i = 0; i < 8; i++) {
        c = reader.getUint8();
        hex = c.toString(16); // convert to hex
        hex = (hex.length == 1 ? '0' + hex : hex);
        str += hex;
    }
    return str;
}

const FIELD_SIZE = [0, 0 /*STRUCT*/, 0 /*ENUM*/, 8 /*HANDLE*/, 0, 0, 0, 0, 0, 0,
    1 /*BYTE*/, 1 /*BYTE*/, 2 /*SHORT*/, 2 /*SHORT*/, 4 /*INTEGER*/, 4 /*INTEGER*/, 8 /*INT64*/, 8 /*INT64*/,
    4 /*FLOAT*/, 0, 0, 0, 12 /*VECTOR3*/, 0, 0, 16 /*QUATERNION*/, 0, 16, 4, 0, 1, 4];
// TODO: create enum
const DATA_TYPE_STRUCT = 1;
const DATA_TYPE_ENUM = 2;
const DATA_TYPE_HANDLE = 3;
const DATA_TYPE_BYTE = 10;
const DATA_TYPE_UBYTE = 11;
const DATA_TYPE_SHORT = 12;
const DATA_TYPE_USHORT = 13;
const DATA_TYPE_INTEGER = 14;
const DATA_TYPE_UINTEGER = 15;
const DATA_TYPE_INT64 = 16;
const DATA_TYPE_UINT64 = 17;
const DATA_TYPE_FLOAT = 18;
const DATA_TYPE_VECTOR2 = 21;
const DATA_TYPE_VECTOR3 = 22;
const DATA_TYPE_VECTOR4 = 23;
const DATA_TYPE_QUATERNION = 25;
const DATA_TYPE_BOOLEAN = 30;
const DATA_TYPE_NAME = 31;
function loadStruct(reader, reference, struct, block, startOffset, introspection, depth) {
    //let dataStruct: Source2DataStruct = {};
    let element; // = new Kv3Element();
    if (struct.baseId) {
        //throw 'TODO: fix this loadStruct';
        const baseStruct = getStruct(introspection, struct.baseId);
        if (baseStruct) {
            element = loadStruct(reader, reference, baseStruct, block, startOffset, introspection);
        }
        else {
            element = new Kv3Element();
        }
    }
    else {
        element = new Kv3Element();
    }
    const fieldList = struct.fields;
    for (let fieldIndex = 0; fieldIndex < fieldList.length; fieldIndex++) {
        const field = fieldList[fieldIndex];
        if (field.count) {
            const data = /*dataStruct[field.name]*/ [];
            FIELD_SIZE[field.type2];
            for (let i = 0; i < field.count; i++) {
                data.push(255); //TODOv3 dafuck ?
            }
            element.setProperty(field.name, new Kv3Value(Kv3Type.TypedArray, data, Kv3Type.UnsignedInt32));
        }
        else {
            const f = loadField(reader, reference, field, block, startOffset, introspection, field.offset, field.indirectionByte, field.level);
            if (f) {
                //dataStruct[field.name] = f;
                element.setProperty(field.name, f);
            }
        }
    }
    //dataStruct._name = struct.name;
    return element;
}
function getStruct(block, structId) {
    return block.structs?.[structId];
}
function loadField(reader, reference, field, block, startOffset, introspection, fieldOffset, fieldIndirectionByte, fieldLevel, depth) {
    fieldOffset = startOffset + fieldOffset;
    if (fieldLevel > 0) {
        reader.getInt8(fieldOffset);
        if (fieldIndirectionByte == 3) { // Pointer
            var struct = introspection.structs?.[field.type];
            if (struct) {
                var pos = reader.getUint32(fieldOffset);
                return loadStruct(reader, reference, struct, null, fieldOffset + pos, introspection);
            }
            else {
                console.log('Unknown struct ' + field.type, fieldOffset);
            }
            console.log(fieldOffset);
            throw 'check this code loadField1';
            //return fieldOffset;
        }
        else if (fieldIndirectionByte == 4) { // Array
            //console.log("indirect type 4", reader.getUint32(fieldOffset));
            const arrayOffset2 = reader.getUint32(fieldOffset);
            if (arrayOffset2) {
                const arrayOffset = fieldOffset + arrayOffset2;
                const arrayCount = reader.getUint32();
                const values = [];
                if (field.type) {
                    if (field.type2 == DATA_TYPE_STRUCT) { // STRUCT
                        const struct = introspection.structs?.[field.type];
                        if (struct) {
                            const values = [];
                            for (var i = 0; i < arrayCount; i++) {
                                var pos = arrayOffset + struct.discSize * i;
                                //reader.seek(reader.getUint32(pos) + pos);
                                reader.seek(pos);
                                //var name = reader.getNullString();
                                //values[name] = this.loadStruct(reader, struct, null, pos, introspection);
                                values.push(loadStruct(reader, reference, struct, block, pos, introspection));
                            }
                            return new Kv3Value(Kv3Type.TypedArray, values, Kv3Type.Element);
                        }
                        else {
                            console.log('Unknown struct ' + field.type, fieldOffset);
                        }
                    }
                    else if (field.type2 == DATA_TYPE_HANDLE) { // HANDLE
                        // Handle to an external ressource in the RERL block
                        for (var i = 0; i < arrayCount; i++) {
                            var pos = arrayOffset + 8 * i;
                            reader.seek(pos);
                            var handle = readHandle(reader);
                            values[i] = reference.externalFiles[handle] ?? '';
                        }
                        //reader.seek(fieldOffset);
                        //var handle = readHandle(reader);
                        //return values;//this.reference.externalFiles[handle];
                        return new Kv3Value(Kv3Type.TypedArray, values, Kv3Type.String);
                    }
                    else {
                        console.log('Unknown struct type for array ' + field, fieldOffset);
                    }
                }
                else {
                    // single field
                    const values = [];
                    const fieldSize = FIELD_SIZE[field.type2] ?? 0;
                    if (field.type2 == 11) {
                        //console.log(field.type2);//TODOV2
                        const arr = new Uint8Array(arrayCount);
                        for (var i = 0; i < arrayCount; i++) {
                            arr[i] = reader.getUint8(arrayOffset + i);
                        }
                        return new Kv3Value(Kv3Type.Blob, arr);
                    }
                    // TODO: fix this: typed array must be loaded for all types
                    if (field.type2 == DATA_TYPE_NAME) {
                        const arr = new Array(arrayCount);
                        for (let i = 0; i < arrayCount; i++) {
                            let pos = arrayOffset + fieldSize * i;
                            let strOffset = reader.getInt32(pos);
                            reader.seek(pos + strOffset);
                            arr[i] = reader.getNullString(pos + strOffset);
                        }
                        return new Kv3Value(Kv3Type.TypedArray, arr, Kv3Type.String);
                    }
                    for (var i = 0; i < arrayCount; i++) {
                        var pos = arrayOffset + fieldSize * i;
                        /*reader.seek(reader.getUint32(pos) + pos);
                        var name = reader.getNullString();*/
                        values[i] = loadField(reader, reference, field, null, pos, introspection, 0, 0, 0);
                    }
                    //return values;
                    console.info(values);
                    //throw 'check array type';
                    return new Kv3Value(Kv3Type.Array, values);
                }
            }
            //throw 'check this code loadField2';
            return new Kv3Value(Kv3Type.Array, []);
            //return [];
        }
        else {
            // No indirection
            return null;
        }
    }
    else {
        //fieldOffset += field_offset;
        switch (field.type2) {
            case DATA_TYPE_STRUCT: //1
                const struct = introspection.structs?.[field.type];
                if (struct) {
                    return loadStruct(reader, reference, struct, null, fieldOffset, introspection);
                }
                console.log(fieldOffset);
                return null;
            case DATA_TYPE_ENUM: //2
                throw 'fix me';
            //return ['enum', field.name, field.type2, fieldOffset, reader.getInt32(fieldOffset)];
            case DATA_TYPE_HANDLE: //3
                // Handle to an external ressource in the RERL block
                reader.seek(fieldOffset);
                var handle = readHandle(reader);
                //return reference ? reference.externalFiles[handle] : null;
                return new Kv3Value(Kv3Type.Resource, reference.externalFiles[handle] ?? '');
            case DATA_TYPE_BYTE: //10
                return new Kv3Value(Kv3Type.Int32 /*TODO: check if there is a better type*/, reader.getInt8(fieldOffset));
            case DATA_TYPE_UBYTE: //11
                return new Kv3Value(Kv3Type.UnsignedInt32 /*TODO: check if there is a better type*/, reader.getUint8(fieldOffset));
            case DATA_TYPE_SHORT: //12
                throw 'fix me';
            //return reader.getInt16(fieldOffset);
            case DATA_TYPE_USHORT: //13
                throw 'fix me';
            //return reader.getUint16(fieldOffset);
            case DATA_TYPE_INTEGER: //14
                return new Kv3Value(Kv3Type.Int32, reader.getInt32(fieldOffset));
            //return reader.getInt32(fieldOffset);
            case DATA_TYPE_UINTEGER: //15
                return new Kv3Value(Kv3Type.UnsignedInt32, reader.getUint32(fieldOffset));
            //return reader.getUint32(fieldOffset);
            case DATA_TYPE_INT64: //16
                const i64 = reader.getBigInt64(fieldOffset);
                //return i64;//i64.lo + i64.hi * 4294967295;
                return new Kv3Value(Kv3Type.Int64, i64);
            case DATA_TYPE_UINT64: //17
                const ui64 = reader.getBigUint64(fieldOffset);
                //return ui64;//ui64.lo + ui64.hi * 4294967295;
                return new Kv3Value(Kv3Type.UnsignedInt64, ui64);
            case DATA_TYPE_FLOAT: //18
                //return reader.getFloat32(fieldOffset);
                return new Kv3Value(Kv3Type.Float, reader.getFloat32(fieldOffset));
            case DATA_TYPE_VECTOR2: //21
                throw 'fix me';
            //return reader.getVector2(fieldOffset);
            case DATA_TYPE_VECTOR3: //22
                throw 'fix me';
            //return reader.getVector3(fieldOffset);
            case DATA_TYPE_VECTOR4: //23
                //return reader.getVector4(fieldOffset);
                return new Kv3Value(Kv3Type.TypedArray2, reader.getVector4(fieldOffset), Kv3Type.Float);
            case DATA_TYPE_QUATERNION: //25
                //return reader.getVector4(fieldOffset);
                return new Kv3Value(Kv3Type.TypedArray2, reader.getVector4(fieldOffset), Kv3Type.Float);
            case DATA_TYPE_BOOLEAN: //30
                throw 'fix me';
            //return (reader.getInt8(fieldOffset)) ? true : false;
            case DATA_TYPE_NAME: //31
                var strOffset = reader.getInt32(fieldOffset);
                /*if ((strOffset<0) || (strOffset>10000)) {
                    console.log(strOffset);
                }*/
                reader.seek(fieldOffset + strOffset);
                //return reader.getNullString();
                return new Kv3Value(Kv3Type.String, reader.getNullString());
            case 40: //DATA_TYPE_VECTOR4://40
                throw 'fix me';
            //return reader.getVector4(fieldOffset);
            default:
                console.error(`Unknown field type: ${field.type2}`);
        }
    }
    return null;
}

class SpriteSheetCoord {
    uMin = 0;
    vMin = 0;
    uMax = 0;
    vMax = 0;
}
class SpriteSheetFrame {
    coords = [];
    duration = 0;
    addCoord() {
        const coord = new SpriteSheetCoord();
        this.coords.push(coord);
        return coord;
    }
}
class SpriteSheetSequence {
    frames = [];
    duration = 0;
    clamp = false;
    addFrame() {
        const frame = new SpriteSheetFrame();
        this.frames.push(frame);
        return frame;
    }
    getFrame(frame, channel = 0) {
        if (this.clamp) {
            frame = Math.min(frame, this.frames.length - 1);
        }
        else {
            frame = (frame % this.frames.length) << 0;
        }
        return this.frames[frame]?.coords[channel] ?? null;
    }
}
class SpriteSheet {
    sequences = [];
    addSequence() {
        const sequence = new SpriteSheetSequence();
        this.sequences.push(sequence);
        return sequence;
    }
    getFrame(sequenceId, frame, channel = 0) {
        const sequence = this.sequences[sequenceId] ?? this.sequences[0];
        if (sequence) {
            if (sequence.clamp) {
                frame = Math.min(frame, sequence.frames.length - 1);
            }
            else {
                frame = (frame % sequence.frames.length) << 0;
            }
            return sequence.frames[frame]?.coords[channel] ?? null;
        }
        return null;
    }
}

function loadDataVtex(reader, block, file) {
    const DATA_FALLBACK_BITS = 1;
    const DATA_SHEET = 2;
    const DATA_FILL_TO_POWER_OF_TWO = 3;
    const DATA_COMPRESSED_MIP_SIZE = 4;
    const DATA_CUBEMAP_RADIANCE = 5;
    reader.seek(block.offset);
    block.vtexVersion = reader.getUint16();
    block.flags = reader.getUint16();
    block.reflectivity = reader.getVector4();
    block.width = reader.getUint16();
    block.height = reader.getUint16();
    block.depth = reader.getUint16();
    file.setImageFormat(reader.getUint8());
    block.numMipLevels = reader.getUint8();
    block.picmip0Res = reader.getUint32();
    reader.tell() + reader.getUint32();
    const extraDataCount = reader.getUint32();
    let compressedMips = null; //new Uint32Array(mips);
    if (extraDataCount) {
        /* read headers */
        const headers = [];
        for (let i = 0; i < extraDataCount; i++) {
            const h = {
                type: reader.getUint32(),
                offset: reader.tell() + reader.getUint32(),
                size: reader.getUint32(),
            };
            headers.push(h);
        }
        for (let i = 0; i < extraDataCount; i++) {
            const h = headers[i];
            const type = h.type;
            const offset = h.offset;
            const size = h.size;
            reader.seek(offset);
            switch (type) {
                case DATA_FALLBACK_BITS:
                    reader.seek(offset + size);
                    break;
                case DATA_FILL_TO_POWER_OF_TWO:
                    reader.getUint16();
                    const nw = reader.getUint16();
                    const nh = reader.getUint16();
                    if (nw > 0 && nh > 0 && block.width >= nw && block.height >= nh) {
                        console.error('code me');
                    }
                    break;
                case DATA_COMPRESSED_MIP_SIZE:
                    const unk1 = reader.getUint32();
                    const unk2 = reader.getUint32();
                    const mips = reader.getUint32();
                    compressedMips = new Array(mips); // we can't upe pop() on a Uint32Array
                    for (let i = 0; i < mips; i++) {
                        compressedMips[i] = reader.getUint32();
                    }
                    console.warn(`compressed mips : ${unk1} ${unk2} ${mips}`, compressedMips);
                    break;
                case DATA_SHEET:
                    loadVtexSpriteSheet(reader, block, offset);
                    /*if (TESTING) {
                        SaveFile(new File([new Blob([reader.getBytes(size, offset)])], 'block_' + size + '_' + offset));
                    }*/
                    break;
                case DATA_CUBEMAP_RADIANCE:
                    loadVtexCubemapRadiance(reader, block, offset);
                    break;
                default:
                    /*if (TESTING) {
                        SaveFile(new File([new Blob([reader.getBytes(size, offset)])], 'block_' + size + '_' + offset));
                    }*/
                    console.error(`Unknown type : ${type}`);
            }
        }
    }
    loadDataVtexImageData(reader, file, block, compressedMips);
}
function loadDataVtexImageData(reader, file, block, compressedMips) {
    let faceCount = 1;
    if ((block.flags & VTEX_FLAG_CUBE_TEXTURE) == VTEX_FLAG_CUBE_TEXTURE) { // Handle cube texture
        faceCount = 6;
    }
    // Goto
    reader.seek(block.file.fileLength);
    let mipmapWidth = block.width * Math.pow(0.5, block.numMipLevels - 1);
    let mipmapHeight = block.height * Math.pow(0.5, block.numMipLevels - 1);
    block.imageData = [];
    // Only keep last (biggest) mipmap
    for (let mipmapIndex = 0; mipmapIndex < block.numMipLevels; mipmapIndex++) {
        // Todo : add frame support + depth support
        for (let faceIndex = 0; faceIndex < faceCount; faceIndex++) {
            const compressedLength = compressedMips?.pop() ?? null; //TODO: check how this actually works with depth / frames
            block.imageData[faceIndex] = getImage(reader, mipmapWidth, mipmapHeight, file.getVtexImageFormat(), compressedLength);
        }
        mipmapWidth *= 2;
        mipmapHeight *= 2;
    }
}
function getImage(reader, mipmapWidth, mipmapHeight, imageFormat, compressedLength) {
    let entrySize = 0;
    switch (imageFormat) {
        case VtexImageFormat.Dxt1:
            entrySize = Math.max(mipmapWidth * mipmapHeight * 0.5, 8); // 0.5 byte per pixel
            break;
        case VtexImageFormat.Dxt5:
            entrySize = Math.max(mipmapWidth, 4) * Math.max(mipmapHeight, 4); // 1 byte per pixel
            break;
        case VtexImageFormat.R8:
            entrySize = Math.max(mipmapWidth, 1) * Math.max(mipmapHeight, 1); // 1 byte per pixel;
            break;
        case VtexImageFormat.R8G8B8A8Uint:
        case VtexImageFormat.BGRA8888:
            // 4 bytes per pixel
            entrySize = mipmapWidth * mipmapHeight * 4;
            break;
        case VtexImageFormat.PngR8G8B8A8Uint:
        case VtexImageFormat.PngDXT5:
            entrySize = reader.byteLength - reader.tell();
            /*
            const a = reader.tell();
            SaveFile('loadout.obj', b64toBlob(encode64(reader.getString(entrySize))));//TODOv3: removeme
            reader.seek(a);
            */
            break;
        case VtexImageFormat.Bc4:
        case VtexImageFormat.Bc5:
            entrySize = Math.ceil(mipmapWidth / 4) * Math.ceil(mipmapHeight / 4) * 8; // 0.5 byte per pixel
            break;
        case VtexImageFormat.Bc7:
            entrySize = Math.max(mipmapWidth, 4) * Math.max(mipmapHeight, 4); // 1 byte per pixel, blocks of 16 bytes
            break;
        default:
            console.error('Unknown image format ' + imageFormat, reader, mipmapWidth, mipmapHeight, compressedLength);
    }
    let imageDatas;
    if (compressedLength === null || compressedLength === entrySize) {
        const start = reader.tell();
        //return reader.getString(entrySize);
        imageDatas = new Uint8Array(reader.buffer, reader.tell(), entrySize);
        reader.seek(start + entrySize);
    }
    else {
        const start = reader.tell();
        const buf = new ArrayBuffer(entrySize);
        imageDatas = new Uint8Array(buf);
        decodeLz4(reader, imageDatas, compressedLength, entrySize);
        reader.seek(start + compressedLength); // decoder may overread, place the reader at the start of the next image block
        if ((start + compressedLength) != reader.tell()) {
            console.error('error decoding texture: wrong decompressed size: ', start, compressedLength, entrySize);
        }
    }
    if (imageDatas && imageFormat == VTEX_FORMAT_BGRA8888) {
        for (let i = 0, l = imageDatas.length; i < l; i += 4) {
            const b = imageDatas[i];
            imageDatas[i] = imageDatas[i + 2];
            imageDatas[i + 2] = b;
        }
    }
    return imageDatas;
}
function loadVtexSpriteSheet(reader, block, offset, size) {
    reader.seek(offset);
    reader.getUint32();
    let sequenceCount = reader.getUint32();
    let headerOffset = reader.tell();
    const spriteSheet = new SpriteSheet();
    block.spriteSheet = spriteSheet;
    while (sequenceCount--) {
        const spriteSheetSequence = spriteSheet.addSequence();
        reader.getUint32(headerOffset);
        reader.getUint32(); //1 ? probably some flag -> clamp //0 in materials/particle/water_ripples/allripples
        //unknown1 is most likely 2 uint16 -> see dota2 texture materials/particle/smoke3/smoke3b
        const sequenceDataOffset = reader.tell() + reader.getUint32();
        const frameCount = reader.getUint32();
        spriteSheetSequence.duration = reader.getFloat32();
        reader.getUint32(); //offset to 'CDmeSheetSequence'
        reader.getUint32(); //0
        reader.getUint32(); //0
        headerOffset = reader.tell();
        reader.seek(sequenceDataOffset);
        let frameHeaderOffset = reader.tell();
        let frameIndex = frameCount;
        while (frameIndex--) {
            const spriteSheetFrame = spriteSheetSequence.addFrame();
            spriteSheetFrame.duration = reader.getFloat32(frameHeaderOffset);
            const frameOffset = reader.tell() + reader.getUint32();
            reader.getUint32();
            frameHeaderOffset = reader.tell();
            reader.seek(frameOffset);
            //while (frameCoords--) we should use all coords but they are identical ? probably one per channel
            {
                const coords = spriteSheetFrame.addCoord();
                coords.uMin = reader.getFloat32();
                coords.vMin = reader.getFloat32();
                coords.uMax = reader.getFloat32();
                coords.vMax = reader.getFloat32();
            }
        }
        //console.error(sequenceId, frameCount, spriteSheetSequence.duration, sequenceDataOffset);
        //console.error(unknown1, unknown2, unknown3, unknown4);
    }
    //console.error(version, sequenceCount);
}
function loadVtexCubemapRadiance(reader, block, offset, size) {
    reader.seek(offset);
    const coeffOffset = reader.getUint32();
    const coeffCount = reader.getUint32();
    //Spherical Harmonics
    const coefficients = new Array(coeffCount);
    reader.seek(offset + coeffOffset);
    for (let i = 0; i < coeffCount; i++) {
        coefficients[i] = reader.getFloat32();
    }
    block.cubemapRadiance = coefficients;
}

async function loadData(reader, file, reference, block, introspection, parseVtex) {
    if (await loadKeyValue(reader, file, block)) {
        return true;
    }
    if (!introspection || !introspection.structsArray) {
        if (parseVtex) { //TODO
            loadDataVtex(reader, block, file);
            return true;
        }
        return false;
    }
    block.keyValue = new Kv3File();
    const rootElement = new Kv3Element();
    block.keyValue.setRoot(rootElement);
    const structList = introspection.structsArray;
    let startOffset = block.offset;
    for (let structIndex = 0; structIndex < 1 /*TODO:removeme*/ /*structList.length*/; structIndex++) {
        const struct = structList[structIndex]; //introspection.firstStruct;
        //block.structs[struct.name] = ;
        rootElement.setProperty(struct.name, loadStruct(reader, reference, struct, block, startOffset, introspection));
        startOffset += struct.discSize;
    }
    return true;
}

class ArgumentDependency {
    parameterName = '';
    parameterType = '';
    fingerprint = 0;
    fingerprintDefault = 0;
    getLength() {
        return 4 * 4;
    }
    fromReader(reader) {
        const parameterNameOffset = reader.tell() + reader.getUint32();
        const parameterTypeOffset = reader.tell() + reader.getUint32();
        this.fingerprint = reader.getUint32();
        this.fingerprintDefault = reader.getUint32();
        this.parameterName = reader.getNullString(parameterNameOffset);
        this.parameterType = reader.getNullString(parameterTypeOffset);
    }
}

class InputDependency {
    relativeFilename = '';
    searchPath = '';
    fileCrc = 0;
    optional = false;
    exists = false;
    isGameFile = false;
    getLength() {
        return 4 * 4;
    }
    fromReader(reader) {
        const relativeFilenameOffset = reader.tell() + reader.getUint32();
        const searchPathOffset = reader.tell() + reader.getUint32();
        this.fileCrc = reader.getUint32();
        const flags = reader.getUint32();
        this.relativeFilename = reader.getNullString(relativeFilenameOffset);
        this.searchPath = reader.getNullString(searchPathOffset);
        this.optional = (flags & 1) != 0;
        this.exists = (flags & 2) != 0;
        this.isGameFile = (flags & 4) != 0;
    }
}

class SpecialDependency {
    string = '';
    compilerIdentifier = '';
    fingerprint = 0;
    userData = 0;
    getLength() {
        return 4 * 4;
    }
    fromReader(reader) {
        const stringOffset = reader.tell() + reader.getUint32();
        const compilerIdentifierOffset = reader.tell() + reader.getUint32();
        this.fingerprint = reader.getUint32();
        this.userData = reader.getUint32();
        this.string = reader.getNullString(stringOffset);
        this.compilerIdentifier = reader.getNullString(compilerIdentifierOffset);
    }
}

const rediBlockConstructors = [
    [InputDependency, 'inputDependencies'],
    [InputDependency, 'additionalInputDependencies'],
    [ArgumentDependency, 'argumentDependencies'],
    [SpecialDependency, 'specialDependencies'],
    // TODO: add other stuff
];
async function loadRedi(reader, file, block) {
    if (await loadKeyValue(reader, file, block)) {
        return true;
    }
    block.inputDependencies = [];
    block.additionalInputDependencies = [];
    block.argumentDependencies = [];
    block.specialDependencies = [];
    reader = new BinaryReader(reader, block.offset);
    for (let i = 0; i < rediBlockConstructors.length; i++) {
        reader.seek(i * 8 /*size of offset + count*/);
        const startOffset = reader.tell() + reader.getUint32();
        const count = reader.getUint32();
        let offset = startOffset;
        for (let j = 0; j < count; j++) {
            const rediBock = new rediBlockConstructors[i][0]();
            rediBock.fromReader(new BinaryReader(reader, offset));
            offset += rediBock.getLength();
            //console.info(rediBock);
            block[rediBlockConstructors[i][1]].push(rediBock /*evil*/);
        }
    }
    return true;
}

const DXGI_FORMAT_R32G32B32A32_FLOAT = 2;
const DXGI_FORMAT_R32G32B32_FLOAT = 6;
const DXGI_FORMAT_R16G16B16A16_SINT = 14;
const DXGI_FORMAT_R32G32_FLOAT = 16;
const DXGI_FORMAT_R8G8B8A8_UNORM = 28;
const DXGI_FORMAT_R8G8B8A8_UINT = 30;
const DXGI_FORMAT_R16G16_FLOAT = 34;
const DXGI_FORMAT_R16G16_SNORM = 37;
const DXGI_FORMAT_R16G16_SINT = 38;
const DXGI_FORMAT_R32_FLOAT = 41;
const DXGI_FORMAT_R32_UINT = 42;

function sNormUint16(uint16) {
    //https://www.khronos.org/opengl/wiki/Normalized_Integer
    return Math.max(uint16 / 0x7FFF, -1.0);
}
const Source2BlockLoader = new (function () {
    class Source2BlockLoader {
        async parseBlock(reader, file, block, parseVtex, context) {
            const introspection = file.blocks['NTRO'];
            const reference = file.blocks['RERL'];
            switch (block.type) {
                case 'RERL':
                    loadRerl(reader, block);
                    break;
                case 'NTRO':
                    loadNtro(reader, block);
                    break;
                //case 'DATA':
                case 'ANIM':
                case 'CTRL':
                case 'MRPH':
                case 'MDAT':
                case 'ASEQ':
                case 'AGRP':
                case 'PHYS':
                case 'LaCo':
                    await loadData(reader, file, reference, block, introspection, false);
                    break;
                case 'DATA':
                    await loadData(reader, file, reference, block, introspection, parseVtex);
                    break;
                case 'REDI':
                case 'RED2':
                    await loadRedi(reader, file, block);
                    break;
                case 'VBIB':
                case 'MBUF':
                    loadVbib(reader, block, context.meshIndex++);
                    break;
                case 'SNAP':
                    let decodeLength, sa;
                    decodeLength = reader.getUint32(block.offset);
                    if ((decodeLength >>> 24) == 0x80) {
                        //no compression see particles/models/heroes/antimage/antimage_weapon_primary.vsnap_c
                        sa = reader.getBytes(decodeLength & 0xFFFFFF);
                    }
                    else {
                        sa = new Uint8Array(new ArrayBuffer(decodeLength));
                        decodeBlockCompressed(reader, sa, decodeLength);
                    }
                    block.datas = sa;
                    break;
                case 'MVTX':
                case 'MIDX':
                    // Loaded along CTRL block
                    break;
                default:
                    console.info('Unknown block type ' + block.type, block.offset, block.length, block);
            }
        }
    }
    return Source2BlockLoader;
}());
function loadRerl(reader, block) {
    reader.seek(block.offset);
    const resOffset = reader.getInt32(); // Seems to be always 0x00000008
    const resCount = reader.getInt32();
    block.externalFiles = {};
    block.externalFiles2 = [];
    reader.seek(block.offset + resOffset);
    for (let resIndex = 0; resIndex < resCount; resIndex++) {
        reader.seek(block.offset + resOffset + 16 * resIndex);
        const handle = readHandle(reader); //reader.getUint64(fieldOffset);
        const strOffset = reader.getInt32();
        reader.skip(strOffset - 4);
        const s = reader.getNullString();
        block.externalFiles[handle] = s;
        block.externalFiles2[resIndex] = s;
    }
}
function loadNtro(reader, block) {
    const _NTRO_STRUCT_LENGTH_ = 40;
    const _NTRO_FIELD_LENGTH_ = 24;
    reader.seek(block.offset);
    // NTRO header
    reader.getInt32(); //TODO: check version
    const ntroOffset = reader.getInt32();
    const structCount = reader.getInt32();
    block.structs = {};
    block.structsArray = [];
    block.firstStruct = null;
    for (let structIndex = 0; structIndex < structCount; structIndex++) {
        reader.seek(block.offset + ntroOffset + 4 + _NTRO_STRUCT_LENGTH_ * structIndex);
        const ntroStruct = {};
        ntroStruct.version = reader.getInt32();
        //console.log(ntroStruct.version);
        ntroStruct._offset = reader.tell();
        ntroStruct.id = reader.getUint32();
        var strStart = reader.tell();
        var strOffset = reader.getInt32();
        ntroStruct.crc = reader.getInt32();
        ntroStruct.unknown1 = reader.getInt32();
        ntroStruct.discSize = reader.getInt16();
        ntroStruct.unknown = reader.getInt16(); //TODO
        ntroStruct.baseId = reader.getUint32();
        const fieldStart = reader.tell();
        const fieldOffset = reader.getInt32();
        const fieldCount = reader.getInt32();
        ntroStruct.flags = reader.getInt32();
        // Read struct Name
        reader.seek(strStart + strOffset);
        ntroStruct.name = reader.getNullString();
        //Read struct fields
        ntroStruct.fields = [];
        for (let fieldIndex = 0; fieldIndex < fieldCount; fieldIndex++) {
            reader.seek(fieldStart + fieldOffset + _NTRO_FIELD_LENGTH_ * fieldIndex);
            const field = {};
            field._offset = fieldStart + fieldOffset + _NTRO_FIELD_LENGTH_ * fieldIndex;
            var strStart = reader.tell();
            var strOffset = reader.getInt32();
            field.count = reader.getInt16();
            field.offset = reader.getInt16();
            const indStart = reader.tell();
            field.indirectionOffset = reader.getInt32();
            field.level = reader.getInt32();
            field.typeOffset = reader.tell();
            field.type = reader.getUint32();
            field.type2 = reader.getUint16();
            // Read field Name
            reader.seek(strStart + strOffset);
            field.name = reader.getNullString();
            ntroStruct.fields.push(field);
            if (field.indirectionOffset) {
                field.indirectionByte = reader.getInt8(indStart + field.indirectionOffset);
                field.indirectionByte1 = indStart + field.indirectionOffset; //TODO: wtf ?
            }
        }
        block.structs[ntroStruct.id] = ntroStruct;
        block.structsArray.push(ntroStruct);
        if (block.firstStruct == null) {
            block.firstStruct = ntroStruct;
        }
    }
}
const defaultValuesPosition = vec3.create();
const defaultValuesNormal = vec3.create();
const defaultValuesTangent = vec4.create();
const defaultValuesCoord = vec2.create();
const defaultValuesBoneIndice = vec4.create();
const defaultValuesBoneWeight = vec4.fromValues(1.0, 0, 0, 0);
const VERTEX_POSITION_LEN = 3;
const VERTEX_NORMAL_LEN = 4;
const VERTEX_TANGENT_LEN = 4;
const VERTEX_COORD_LEN = 2;
const VERTEX_BONE_INDICE_LEN = 4;
const VERTEX_BONE_WEIGHT_LEN = 4;
const BYTES_PER_VERTEX_POSITION = VERTEX_POSITION_LEN * 4;
const BYTES_PER_VERTEX_NORMAL = VERTEX_NORMAL_LEN * 4;
const BYTES_PER_VERTEX_TANGENT = VERTEX_TANGENT_LEN * 4;
const BYTES_PER_VERTEX_COORD = VERTEX_COORD_LEN * 4;
const BYTES_PER_VERTEX_BONE_INDICE = VERTEX_BONE_INDICE_LEN * 4;
const BYTES_PER_VERTEX_BONE_WEIGHT = VERTEX_BONE_WEIGHT_LEN * 4;
const BYTES_PER_INDEX = 1 * 4;
function loadVbib(reader, block, meshIndex) {
    const VERTEX_HEADER_SIZE = 24;
    const INDEX_HEADER_SIZE = 24;
    const DESC_HEADER_SIZE = 56;
    const DESC_HEADER_NAME_SIZE = 36;
    reader.seek(block.offset);
    const vertexOffset = reader.tell() + reader.getInt32();
    const vertexCount = reader.getInt32();
    const indexOffset = reader.tell() + reader.getInt32();
    const indexCount = reader.getInt32();
    //block.file.vertices = [];
    //block.file.indices = [];
    const blockVertices = [];
    const blockIndices = [];
    block.file.vertices.set(meshIndex, blockVertices);
    block.file.indices.set(meshIndex, blockIndices);
    for (var i = 0; i < vertexCount; i++) { // header size: 24 bytes
        reader.seek(vertexOffset + i * VERTEX_HEADER_SIZE);
        const s1 /*TODO: fix typer*/ = {};
        s1.vertexCount = reader.getInt32();
        s1.bytesPerVertex = reader.getInt16();
        reader.skip(2); // TODO: figure out what it is. Used to be 0, now 1024 for pudge model spring 2025
        s1.headerOffset = reader.tell() + reader.getInt32();
        s1.headerCount = reader.getInt32();
        s1.dataOffset = reader.tell() + reader.getInt32();
        s1.dataLength = reader.getInt32();
        const vertexDataSize = s1.vertexCount * s1.bytesPerVertex;
        let vertexReader = reader;
        if (vertexDataSize != s1.dataLength) {
            const vertexBuffer = new Uint8Array(new ArrayBuffer(vertexDataSize));
            MeshoptDecoder.decodeVertexBuffer(vertexBuffer, s1.vertexCount, s1.bytesPerVertex, new Uint8Array(reader.buffer.slice(s1.dataOffset, s1.dataOffset + s1.dataLength)));
            //SaveFile('sa.obj', new Blob([vertexBuffer]));
            vertexReader = new BinaryReader(vertexBuffer);
            s1.dataOffset = 0;
        }
        s1.headers = [];
        for (let j = 0; j < s1.headerCount; j++) { // header size: 24 bytes
            const header = {};
            const headerOffset = s1.headerOffset + j * DESC_HEADER_SIZE;
            reader.seek(headerOffset);
            header.name = reader.getNullString();
            reader.seek(headerOffset + DESC_HEADER_NAME_SIZE);
            header.type = reader.getUint32();
            header.offset = reader.getUint32();
            s1.headers.push(header);
        }
        s1.vertices = new ArrayBuffer(s1.vertexCount * BYTES_PER_VERTEX_POSITION);
        s1.normals = new ArrayBuffer(s1.vertexCount * BYTES_PER_VERTEX_NORMAL);
        s1.tangents = new ArrayBuffer(s1.vertexCount * BYTES_PER_VERTEX_TANGENT);
        s1.coords = new ArrayBuffer(s1.vertexCount * BYTES_PER_VERTEX_COORD);
        s1.boneIndices = new ArrayBuffer(s1.vertexCount * BYTES_PER_VERTEX_BONE_INDICE);
        s1.boneWeight = new ArrayBuffer(s1.vertexCount * BYTES_PER_VERTEX_BONE_WEIGHT);
        const s1Vertices = new Float32Array(s1.vertices);
        const s1Normals = new Float32Array(s1.normals);
        const s1Tangents = new Float32Array(s1.tangents);
        const s1Coords = new Float32Array(s1.coords);
        const s1BoneIndices = new Float32Array(s1.boneIndices);
        const s1BoneWeight = new Float32Array(s1.boneWeight);
        for (let vertexIndex = 0; vertexIndex < s1.vertexCount; vertexIndex++) {
            vertexReader.seek(s1.dataOffset + vertexIndex * s1.bytesPerVertex);
            let positionFilled = false; //TODOv3: remove this
            let normalFilled = false;
            let tangentFilled = false;
            let texCoordFilled = false;
            let blendIndicesFilled = false;
            let blendWeightFilled = false;
            for (let headerIndex = 0; headerIndex < s1.headers.length; headerIndex++) {
                const headerName = s1.headers[headerIndex].name;
                const headerType = s1.headers[headerIndex].type;
                let tempValue; // = vec4.create();//TODO: optimize
                vertexReader.seek(s1.dataOffset + vertexIndex * s1.bytesPerVertex + s1.headers[headerIndex].offset);
                switch (headerType) {
                    case DXGI_FORMAT_R32G32B32A32_FLOAT:
                        tempValue = vec4.create(); //TODO: optimize
                        tempValue[0] = vertexReader.getFloat32();
                        tempValue[1] = vertexReader.getFloat32();
                        tempValue[2] = vertexReader.getFloat32();
                        tempValue[3] = vertexReader.getFloat32();
                        break;
                    case DXGI_FORMAT_R32G32B32_FLOAT: // 3 * float32
                        tempValue = vec3.create(); //TODO: optimize
                        tempValue[0] = vertexReader.getFloat32();
                        tempValue[1] = vertexReader.getFloat32();
                        tempValue[2] = vertexReader.getFloat32();
                        break;
                    case DXGI_FORMAT_R16G16B16A16_SINT:
                        tempValue = vec4.create(); //TODO: optimize
                        tempValue[0] = vertexReader.getInt16();
                        tempValue[1] = vertexReader.getInt16();
                        tempValue[2] = vertexReader.getInt16();
                        tempValue[3] = vertexReader.getInt16();
                        break;
                    case DXGI_FORMAT_R32G32_FLOAT: // 2 * float32
                        tempValue = vec2.create(); //TODO: optimize
                        tempValue[0] = vertexReader.getFloat32();
                        tempValue[1] = vertexReader.getFloat32();
                        break;
                    case DXGI_FORMAT_R8G8B8A8_UNORM:
                        tempValue = vec4.create(); //TODO: optimize
                        tempValue[0] = vertexReader.getUint8() / 255;
                        tempValue[1] = vertexReader.getUint8() / 255;
                        tempValue[2] = vertexReader.getUint8() / 255;
                        tempValue[3] = vertexReader.getUint8() / 255;
                        //vertexReader.getUint8();
                        break;
                    case DXGI_FORMAT_R8G8B8A8_UINT: // 4 * uint8
                        tempValue = vec4.create(); //TODO: optimize
                        tempValue[0] = vertexReader.getUint8();
                        tempValue[1] = vertexReader.getUint8();
                        tempValue[2] = vertexReader.getUint8();
                        tempValue[3] = vertexReader.getUint8();
                        break;
                    case DXGI_FORMAT_R16G16_FLOAT: // 2 * float16
                        tempValue = vec2.create(); //TODO: optimize
                        tempValue[0] = vertexReader.getFloat16();
                        tempValue[1] = vertexReader.getFloat16();
                        break;
                    case DXGI_FORMAT_R16G16_SNORM: //New with battlepass 2022
                        tempValue = vec2.create(); //TODO: optimize
                        tempValue[0] = sNormUint16(vertexReader.getInt16());
                        tempValue[1] = sNormUint16(vertexReader.getInt16());
                        break;
                    case DXGI_FORMAT_R16G16_SINT:
                        tempValue = vec2.create(); //TODO: optimize
                        tempValue[0] = vertexReader.getInt16();
                        tempValue[1] = vertexReader.getInt16();
                        break;
                    case DXGI_FORMAT_R32_FLOAT: // single float32 ??? new in half-life Alyx
                        tempValue = [];
                        tempValue[0] = vertexReader.getFloat32();
                        break;
                    case DXGI_FORMAT_R32_UINT: // single uint32 ??? new since DOTA2 2023_08_30
                        tempValue = [];
                        tempValue[0] = vertexReader.getUint32();
                        s1.decompressTangentV2 = true;
                        break;
                    default:
                        //TODO add types when needed. see DxgiFormat.js
                        console.error('Warning: unknown type ' + headerType + ' for value ' + headerName);
                        tempValue = vec4.create(); //TODO: optimize
                        tempValue[0] = 0;
                        tempValue[1] = 0;
                        tempValue[2] = 0;
                        tempValue[3] = 0;
                }
                switch (headerName) {
                    case 'POSITION':
                        s1Vertices.set(tempValue, vertexIndex * VERTEX_POSITION_LEN);
                        positionFilled = true;
                        break;
                    case 'NORMAL':
                        s1Normals.set(tempValue, vertexIndex * VERTEX_NORMAL_LEN); //TODOv3
                        normalFilled = true;
                        break;
                    case 'TANGENT':
                        s1Tangents.set(tempValue, vertexIndex * VERTEX_TANGENT_LEN); //TODOv3
                        tangentFilled = true;
                        break;
                    case 'TEXCOORD':
                        if (!texCoordFilled) { //TODO: handle 2 TEXCOORD
                            const test = vec2.clone(tempValue); //todov3: fixme see //./Alyx/models/props_industrial/hideout_doorway.vmdl_c
                            s1Coords.set(test /*tempValue*/, vertexIndex * VERTEX_COORD_LEN);
                            texCoordFilled = true;
                        }
                        break;
                    case 'BLENDINDICES':
                        /*s1.boneIndices.push(tempValue[0]);
                        s1.boneIndices.push(tempValue[1]);
                        s1.boneIndices.push(tempValue[2]);
                        s1.boneIndices.push(tempValue[3]);*/
                        s1BoneIndices.set(tempValue, vertexIndex * VERTEX_BONE_INDICE_LEN);
                        blendIndicesFilled = true;
                        break;
                    case 'BLENDWEIGHT':
                        /*s1.boneWeight.push(tempValue[0]);
                        s1.boneWeight.push(tempValue[1]);
                        s1.boneWeight.push(tempValue[2]);
                        s1.boneWeight.push(tempValue[3]);*/
                        //vec4.scale(tempValue, tempValue, 1 / 255.0);
                        s1BoneWeight.set(tempValue, vertexIndex * VERTEX_BONE_WEIGHT_LEN);
                        blendWeightFilled = true;
                        break;
                    //TODOv3: add "texcoord" lowercase maybe a z- tex coord ?
                }
            }
            //TODOv3: remove this
            if (!positionFilled) {
                /*s1.vertices.push(0);
                s1.vertices.push(0);
                s1.vertices.push(0);*/
                s1Vertices.set(defaultValuesPosition, vertexIndex * VERTEX_POSITION_LEN);
            }
            if (!normalFilled) {
                /*s1.normals.push(0);
                s1.normals.push(0);
                s1.normals.push(0);*/
                s1Normals.set(defaultValuesNormal, vertexIndex * VERTEX_NORMAL_LEN);
            }
            if (!tangentFilled) {
                s1Tangents.set(defaultValuesTangent, vertexIndex * VERTEX_TANGENT_LEN);
            }
            if (!texCoordFilled) {
                /*s1.coords.push(0);
                s1.coords.push(0);*/
                s1Coords.set(defaultValuesCoord, vertexIndex * VERTEX_COORD_LEN);
            }
            if (!blendIndicesFilled) {
                /*s1.boneIndices.push(0);
                s1.boneIndices.push(0);
                s1.boneIndices.push(0);
                s1.boneIndices.push(0);*/
                s1BoneIndices.set(defaultValuesBoneIndice, vertexIndex * VERTEX_BONE_INDICE_LEN);
            }
            if (!blendWeightFilled) {
                /*s1.boneWeight.push(255);
                s1.boneWeight.push(0);
                s1.boneWeight.push(0);
                s1.boneWeight.push(0);*/
                s1BoneWeight.set(defaultValuesBoneWeight, vertexIndex * VERTEX_BONE_WEIGHT_LEN);
            }
        }
        blockVertices.push(s1);
    }
    //console.log(block.vertices);
    for (var i = 0; i < indexCount; i++) { // header size: 24 bytes
        reader.seek(indexOffset + i * INDEX_HEADER_SIZE);
        const s2 = {};
        s2.indexCount = reader.getInt32();
        s2.bytesPerIndex = reader.getInt32();
        s2.headerOffset = reader.tell() + reader.getInt32();
        s2.headerCount = reader.getInt32();
        s2.dataOffset = reader.tell() + reader.getInt32();
        s2.dataLength = reader.getInt32();
        const indexDataSize = s2.indexCount * s2.bytesPerIndex;
        let indexReader = reader;
        if (indexDataSize != s2.dataLength) {
            const indexBuffer = new Uint8Array(new ArrayBuffer(indexDataSize));
            MeshoptDecoder.decodeIndexBuffer(indexBuffer, s2.indexCount, s2.bytesPerIndex, new Uint8Array(reader.buffer.slice(s2.dataOffset, s2.dataOffset + s2.dataLength)));
            indexReader = new BinaryReader(indexBuffer);
            s2.dataOffset = 0;
        }
        s2.indices = new ArrayBuffer(s2.indexCount * BYTES_PER_INDEX); /*TODO; use s2.bytesPerIndex and create a Uint16Array / Uint32Array depending on bytesPerIndex*/
        const s2Indices = new Uint32Array(s2.indices);
        for (let indicesIndex = 0; indicesIndex < s2.indexCount; indicesIndex++) {
            indexReader.seek(s2.dataOffset + indicesIndex * s2.bytesPerIndex);
            //s2.indices.push(indexReader.getUint16());
            if (s2.bytesPerIndex == 2) {
                s2Indices[indicesIndex] = indexReader.getUint16();
            }
            else {
                s2Indices[indicesIndex] = indexReader.getUint32();
            }
        }
        blockIndices.push(s2);
    }
}
//KV3_ENCODING_BLOCK_COMPRESSED = '\x46, \x1A, \x79, \x95, \xBC, \x95, \x6C, \x4F, \xA7, \x0B, \x05, \xBC, \xA1, \xB7, \xDF, \xD2';

/**
 * Source2 common file block
 */
class Source2FileBlock {
    file;
    type;
    //id: number;
    reader; // TODO: try to improve that, this may be overkill
    offset;
    length;
    //indices?: any/*TODO: create struct*/[];
    //vertices?: any/*TODO: create struct*/[];
    keyValue = null;
    //structs?: never;//TODO: remove me
    constructor(file, id, type /*TODO: create enum*/, reader, offset, length) {
        //this.id = id;
        this.file = file;
        this.type = type;
        this.reader = reader;
        this.offset = offset;
        this.length = length;
    }
    getKeyValue(path) {
        const keyValue = this.keyValue;
        if (keyValue) {
            return keyValue.getValue(path);
        }
        return undefined;
    }
    getKeyValueAsNumber(path) {
        return this.keyValue?.getValueAsNumber(path) ?? null;
    }
    getKeyValueAsStringArray(path) {
        return this.keyValue?.getValueAsStringArray(path) ?? null;
    }
    getKeyValueAsElementArray(path) {
        return this.keyValue?.getValueAsElementArray(path) ?? null;
    }
    // TODO: move getIndices getVertices getNormalsTangents getCoords getNormal getTangent getBoneIndices getBoneWeight
    getIndices(meshIndex, bufferId) {
        const indexBuffer = this.file.indices.get(meshIndex)?.at(bufferId);
        return indexBuffer ? indexBuffer.indices : [];
    }
    getVertices(meshIndex, bufferId) {
        const vertexBuffer = this.file.vertices.get(meshIndex)?.at(bufferId);
        return vertexBuffer ? vertexBuffer.vertices : [];
    }
    getNormalsTangents(meshIndex, bufferId) {
        function decompressNormal(inputNormal, outputNormal) {
            //let outputNormal = vec3.create();
            //float2 ztSigns		= ( inputNormal.xy - 128.0 ) < 0;				// sign bits for zs and binormal (1 or 0)  set-less-than (slt) asm instruction
            const ztSigns = vec2.fromValues(Number((inputNormal[0] - 128.0) < 0), Number((inputNormal[1] - 128.0) < 0)); // sign bits for zs and binormal (1 or 0)  set-less-than (slt) asm instruction
            //float2 xyAbs		= abs( inputNormal.xy - 128.0 ) - ztSigns;		// 0..127
            const xyAbs = vec2.fromValues(Math.abs(inputNormal[0] - 128.0) - ztSigns[0], Math.abs(inputNormal[1] - 128.0) - ztSigns[1]); // 0..127
            //float2 xySigns		= ( xyAbs -  64.0 ) < 0;						// sign bits for xs and ys (1 or 0)
            const xySigns = vec2.fromValues(Number((xyAbs[0] - 64.0) < 0), Number((xyAbs[1] - 64.0) < 0)); // sign bits for xs and ys (1 or 0)
            //outputNormal.xy		= ( abs( xyAbs - 64.0 ) - xySigns ) / 63.0;	// abs({nX, nY})
            outputNormal[0] = (Math.abs(xyAbs[0] - 64.0) - xySigns[0]) / 63.0; // abs({nX, nY})
            outputNormal[1] = (Math.abs(xyAbs[1] - 64.0) - xySigns[1]) / 63.0; // abs({nX, nY})
            //outputNormal.z		= 1.0 - outputNormal.x - outputNormal.y;		// Project onto x+y+z=1
            outputNormal[2] = 1.0 - outputNormal[0] - outputNormal[1]; // Project onto x+y+z=1
            //outputNormal.xyz	= normalize( outputNormal.xyz );				// Normalize onto unit sphere
            vec3.normalize(outputNormal, outputNormal);
            //outputNormal.xy	   *= lerp( fOne.xx, -fOne.xx, xySigns   );			// Restore x and y signs
            //outputNormal.z	   *= lerp( fOne.x,  -fOne.x,  ztSigns.x );			// Restore z sign
            outputNormal[0] *= (1 - xySigns[0]) - xySigns[0];
            outputNormal[1] *= (1 - xySigns[1]) - xySigns[1];
            return vec3.normalize(outputNormal, outputNormal);
        }
        function decompressTangent(compressedTangent, outputTangent) {
            decompressNormal(compressedTangent, outputTangent);
            const tSign = compressedTangent[1] - 128.0 < 0 ? -1.0 : 1.0;
            outputTangent[3] = tSign;
        }
        function decompressNormal2(inputNormal) {
            let normals;
            let tangents;
            const SignBit = inputNormal & 1; // LSB bit
            const Tbits = (inputNormal >> 1) & 0x7ff; // 11 bits
            const Xbits = (inputNormal >> 12) & 0x3ff; // 10 bits
            const Ybits = (inputNormal >> 22) & 0x3ff; // 10 bits
            // Unpack from 0..1 to -1..1
            const nPackedFrameX = (Xbits / 1023.0) * 2.0 - 1.0;
            const nPackedFrameY = (Ybits / 1023.0) * 2.0 - 1.0;
            // Z is never given a sign, meaning negative values are caused by abs(packedframexy) adding up to over 1.0
            const derivedNormalZ = 1.0 - Math.abs(nPackedFrameX) - Math.abs(nPackedFrameY); // Project onto x+y+z=1
            const unpackedNormal = vec3.fromValues(nPackedFrameX, nPackedFrameY, derivedNormalZ);
            // If Z is negative, X and Y has had extra amounts (TODO: find the logic behind this value) added into them so they would add up to over 1.0
            // Thus, we take the negative components of Z and add them back into XY to get the correct original values.
            const negativeZCompensation = clamp$1(-derivedNormalZ, 0.0, 1.0); // Isolate the negative 0..1 range of derived Z
            const unpackedNormalXPositive = unpackedNormal[0] >= 0.0 ? 1.0 : 0.0;
            const unpackedNormalYPositive = unpackedNormal[1] >= 0.0 ? 1.0 : 0.0;
            unpackedNormal[0] += negativeZCompensation * (1 - unpackedNormalXPositive) + -negativeZCompensation * unpackedNormalXPositive; // mix() - x×(1−a)+y×a
            unpackedNormal[1] += negativeZCompensation * (1 - unpackedNormalYPositive) + -negativeZCompensation * unpackedNormalYPositive;
            const normal = vec3.normalize(unpackedNormal, unpackedNormal); // Get final normal by normalizing it onto the unit sphere
            normals = normal;
            // Invert tangent when normal Z is negative
            const tangentSign = (normal[2] >= 0.0) ? 1.0 : -1.0;
            // equal to tangentSign * (1.0 + abs(normal.z))
            const rcpTangentZ = 1.0 / (tangentSign + normal[2]);
            // Be careful of rearranging ops here, could lead to differences in float precision, especially when dealing with compressed data.
            const unalignedTangent = vec3.create();
            // Unoptimized (but clean) form:
            // tangent.X = -(normal.x * normal.x) / (tangentSign + normal.z) + 1.0
            // tangent.Y = -(normal.x * normal.y) / (tangentSign + normal.z)
            // tangent.Z = -(normal.x)
            unalignedTangent[0] = -tangentSign * (normal[0] * normal[0]) * rcpTangentZ + 1.0;
            unalignedTangent[1] = -tangentSign * ((normal[0] * normal[1]) * rcpTangentZ);
            unalignedTangent[2] = -tangentSign * normal[0];
            // This establishes a single direction on the tangent plane that derived from only the normal (has no texcoord info).
            // But it doesn't line up with the texcoords. For that, it uses nPackedFrameT, which is the rotation.
            // Angle to use to rotate tangent
            const nPackedFrameT = Tbits / 2047.0 * TWO_PI;
            // Rotate tangent to the correct angle that aligns with texcoords.
            //let tangent = unalignedTangent * Math.cos(nPackedFrameT) + Vector3.Cross(normal, unalignedTangent) * Math.sin(nPackedFrameT);
            const tangent = vec3.scale(vec3.create(), unalignedTangent, Math.cos(nPackedFrameT));
            const c = vec3.cross(vec3.create(), normal, unalignedTangent);
            vec3.scale(c, c, Math.sin(nPackedFrameT));
            vec3.add(tangent, tangent, c);
            tangents = vec4.fromValues(tangent[0], tangent[1], tangent[2], (SignBit == 0) ? -1.0 : 1.0); // Bitangent sign bit... inverted (0 = negative
            return [normals, tangents];
        }
        const vertexBuffer = this.file.vertices.get(meshIndex)?.[bufferId];
        const normals = new Float32Array(vertexBuffer.normals);
        const normalArray = [];
        const tangentArray = [];
        const compressedNormal = vec2.create();
        const compressedTangent = vec2.create();
        let normalTemp = vec3.create();
        let tangentTemp = vec4.create();
        for (let i = 0, l = normals.length; i < l; i += 4) {
            if (!vertexBuffer.decompressTangentV2) {
                compressedNormal[0] = normals[i + 0] * 255.0;
                compressedNormal[1] = normals[i + 1] * 255.0;
                compressedTangent[0] = normals[i + 2] * 255.0;
                compressedTangent[1] = normals[i + 3] * 255.0;
                decompressNormal(compressedNormal, normalTemp);
                decompressTangent(compressedTangent, tangentTemp);
            }
            else {
                [normalTemp, tangentTemp] = decompressNormal2(normals[i]);
            }
            normalArray.push(normalTemp[0]);
            normalArray.push(normalTemp[1]);
            normalArray.push(normalTemp[2]);
            tangentArray.push(tangentTemp[0]);
            tangentArray.push(tangentTemp[1]);
            tangentArray.push(tangentTemp[2]);
            tangentArray.push(1.0);
        }
        return [normalArray, tangentArray];
    }
    getCoords(meshIndex, bufferId) {
        const vertexBuffer = this.file.vertices.get(meshIndex)?.at(bufferId);
        return vertexBuffer ? vertexBuffer.coords : [];
    }
    getNormal(meshIndex, bufferId) {
        const vertexBuffer = this.file.vertices.get(meshIndex)?.at(bufferId);
        return vertexBuffer ? vertexBuffer.normals : [];
    }
    getTangent(meshIndex, bufferId) {
        const vertexBuffer = this.file.vertices.get(meshIndex)?.at(bufferId);
        return vertexBuffer ? vertexBuffer.tangents : [];
    }
    getBoneIndices(meshIndex, bufferId) {
        const vertexBuffer = this.file.vertices.get(meshIndex)?.at(bufferId);
        return vertexBuffer ? vertexBuffer.boneIndices : new ArrayBuffer();
    }
    getBoneWeight(meshIndex, bufferId) {
        const vertexBuffer = this.file.vertices.get(meshIndex)?.at(bufferId);
        return vertexBuffer ? vertexBuffer.boneWeight : [];
    }
}

class Source2FileLoader extends SourceBinaryLoader {
    vtex;
    constructor(vtex = false) {
        super();
        this.vtex = vtex;
    }
    async parse(repository, path, arrayBuffer) {
        const reader = new BinaryReader(arrayBuffer);
        let file;
        if (this.vtex) {
            file = new Source2Texture(repository, path);
        }
        else {
            file = new Source2File(repository, path);
        }
        await this.#parseHeader(reader, file, this.vtex);
        if (this.vtex) {
            file.spriteSheet = file.getBlockByType('DATA')?.spriteSheet ?? null;
            // TODO: improve detection
            const specialDependencies = file.getBlockStructAsElementArray('RED2', 'm_SpecialDependencies');
            if (specialDependencies) {
                for (const specialDependency of specialDependencies) {
                    const compilerIdentifier = specialDependency.getSubValueAsString('m_CompilerIdentifier');
                    const string = specialDependency.getSubValueAsString('m_String');
                    if (compilerIdentifier && string) {
                        file.setSpecialDependency(compilerIdentifier, string);
                    }
                }
            }
            else {
                const res = (file.getBlockByType('RED2') ?? file.getBlockByType('REDI'));
                if (res) {
                    for (const specialDependency of res.specialDependencies) {
                        file.setSpecialDependency(specialDependency.compilerIdentifier, specialDependency.string);
                    }
                }
            }
        }
        return file;
    }
    async #parseHeader(reader, file, parseVtex) {
        //const startOffset = reader.tell();
        file.fileLength = reader.getUint32();
        file.versionMaj = reader.getUint16();
        file.versionMin = reader.getUint16();
        const headerOffset = reader.tell() + reader.getUint32();
        const resCount = reader.getUint32();
        let resType, resOffset, resLength, block;
        file.maxBlockOffset = 0;
        reader.seek(headerOffset); //Should already be at the right place, but just in case
        for (let i = 0; i < resCount; i++) {
            resType = reader.getString(4);
            resOffset = reader.tell() + reader.getUint32();
            resLength = reader.getUint32();
            file.maxBlockOffset = Math.max(file.maxBlockOffset, resOffset + resLength);
            block = new Source2FileBlock(file, i, resType, new BinaryReader(reader, resOffset, resLength), resOffset, resLength);
            file.addBlock(block);
        }
        const context = { meshIndex: 0 };
        for (const block of file.blocksArray) {
            if (block.length > 0) {
                await Source2BlockLoader.parseBlock(reader, file, block, parseVtex, context);
            }
        }
        //return;
    }
}

class Source2MaterialLoader {
    static #materials = new Map();
    static async load(repository, path) {
        // TODO: use cleanSource2MaterialName
        path = path.replace(/\.vmat_c$/, '');
        const source2File = await new Source2FileLoader().load(repository, path + '.vmat_c');
        if (!source2File) {
            return null;
        }
        const material = this.#loadMaterial(repository, source2File);
        return material;
    }
    static async #loadMaterial(repository, file) {
        //TODO: use getMaterialResourceData()
        const shaderName = file.getBlockStructAsString('DATA', 'm_shaderName') ?? file.getBlockStructAsString('DATA', 'MaterialResourceData_t.m_shaderName'); // || file.getBlockStruct('DATA.structs.MaterialResourceData_t.m_shaderName');
        if (shaderName === null) {
            return null;
        }
        let material = null;
        const materialClass = this.#materials.get(shaderName.toLowerCase());
        if (materialClass !== undefined) {
            material = new materialClass(repository, shaderName, file);
        }
        else {
            console.error(`Unknown material : ${shaderName} in ${file.fileName}`);
        }
        return material;
    }
    static registerMaterial(materialName, materialClass) {
        this.#materials.set(materialName.toLowerCase(), materialClass);
    }
}

function cleanSource2MaterialName(name) {
    name = name.replace(/\\/g, '/').toLowerCase().replace(/\.vmat_c$/, '').replace(/\.vmat$/, '');
    name = name + '.vmat_c';
    return name;
}
class Source2MaterialManager {
    static #materialList = new Map(); // TODO: turn to Map2
    static #materialList2 = new Set();
    static addMaterial(material) {
        this.#materialList2.add(material);
    }
    static removeMaterial(material) {
        this.#materialList2.delete(material);
    }
    static getMaterial(repository, path) {
        path = cleanSource2MaterialName(path);
        return this.#getMaterial(repository, path);
    }
    static #getMaterial(repository, path) {
        const material = this.#materialList.get(path);
        if (material instanceof Promise) {
            const promise = new Promise(resolve => {
                material.then(material => {
                    if (!material) {
                        resolve(material);
                    }
                    else {
                        const newMaterial = material.clone();
                        this.#materialList2.add(newMaterial);
                        resolve(newMaterial);
                    }
                });
            });
            return promise;
        }
        if (material !== undefined) {
            return new Promise(resolve => {
                const newMaterial = material.clone();
                this.#materialList2.add(newMaterial);
                resolve(newMaterial);
            });
        }
        else {
            const promise = new Promise(resolve => {
                Source2MaterialLoader.load(repository, path).then((material) => {
                    if (!material) {
                        resolve(material);
                        return;
                    }
                    this.#materialList.set(path, material);
                    const newMaterial = material.clone();
                    this.#materialList2.add(newMaterial);
                    resolve(newMaterial);
                });
            });
            this.#materialList.set(path, promise);
            return promise;
        }
    }
}

/**
 * Mesh manager
 */
class MeshManager {
    static meshList = {}; //TODO: create map
    //this.renderMode = 2;
    static async getMesh(repository, meshName) {
        meshName = meshName.toLowerCase();
        meshName = meshName.replace(/\.vmesh_c$/, '');
        meshName = meshName.replace(/\.vmesh$/, '');
        let mesh = this.meshList[meshName];
        if (!mesh) {
            mesh = await new Source2FileLoader().load(repository, meshName + '.vmesh_c');
        }
        if (mesh) {
            this.meshList[meshName] = mesh;
        }
        else {
            //TODO; create a dummy mesh
            console.error('No mesh loaded');
        }
        return mesh;
    }
    static removeMesh(meshName) {
        delete this.meshList[meshName];
    }
}

const EMPTY_MODIFIERS = new Set();
class Source2Animations {
    #animations = [];
    addAnimations(animations) {
        this.#animations.push(...animations);
    }
    getAnimations() {
        return this.#animations;
    }
    getAnimation(activityName, activityModifiers = EMPTY_MODIFIERS) {
        for (const animation of this.#animations) {
            if (animation.matchModifiers(activityName, activityModifiers)) {
                return animation;
            }
        }
        // Try without modifiers
        for (const animation of this.#animations) {
            if (animation.matchModifiers(activityName, EMPTY_MODIFIERS)) {
                return animation;
            }
        }
        return null;
    }
    getBestAnimation(activityName, activityModifiers) {
        let bestMatch = this.getAnimation(activityName);
        let bestScore = bestMatch ? 0 : -1;
        for (const animDesc of this.#animations) {
            /*if (animDesc.matchModifiers(activityName, activityModifiers)) {
                return animDesc;
            }*/
            const score = animDesc.modifiersScore(activityName, activityModifiers);
            if (score > bestScore) {
                bestMatch = animDesc;
                bestScore = score;
            }
        }
        return bestMatch;
    }
}

const BASE_BYTES_PER_BONE = 4 * 3;
const DELTA_BYTES_PER_BONE = 2 * 3;
let baseX, baseY, baseZ, deltaX, deltaY, deltaZ;
function decodeCCompressedDeltaVector3(reader, elementCount, elementIndex, frame) {
    baseX = reader.getFloat32(8 + elementCount * 2 + elementIndex * BASE_BYTES_PER_BONE);
    baseY = reader.getFloat32();
    baseZ = reader.getFloat32();
    deltaX = reader.getFloat16(8 + elementCount * (2 + BASE_BYTES_PER_BONE) + elementCount * frame * DELTA_BYTES_PER_BONE + elementIndex * DELTA_BYTES_PER_BONE);
    deltaY = reader.getFloat16();
    deltaZ = reader.getFloat16();
    return vec3.fromValues(baseX + deltaX, baseY + deltaY, baseZ + deltaZ);
}

class Source2AnimationDesc {
    #source2Model;
    #fps;
    #lastFrame = 0;
    data;
    #animationResource;
    #frameBlockArray = null;
    #segmentReaders = new Map;
    constructor(source2Model, data, animationResource) {
        this.#source2Model = source2Model;
        this.data = data;
        this.#animationResource = animationResource;
        this.#fps = data.getValueAsNumber('fps') ?? 30;
        const frameDatas = data.getValueAsElement('m_pData');
        if (frameDatas) {
            this.#lastFrame = (frameDatas.getValueAsNumber('m_nFrames') ?? 1) - 1;
            this.#frameBlockArray = frameDatas.getValueAsElementArray('m_frameblockArray');
        }
    }
    get fps() {
        return this.#getActualAnimDesc()?.fps ?? this.#fps;
    }
    get lastFrame() {
        return this.#getActualAnimDesc()?.lastFrame ?? this.#lastFrame;
    }
    #getActualAnimDesc() {
        const fetch = this.data.getValueAsElement('m_fetch');
        if (fetch) {
            const localReferenceArray = fetch.getValueAsNumberArray('m_localReferenceArray');
            //TODO: mix multiple anims
            if (localReferenceArray && localReferenceArray[0] !== undefined && this.#animationResource.localSequenceNameArray) {
                const animName = this.#animationResource.localSequenceNameArray[localReferenceArray[0]];
                if (animName) {
                    const animDesc = this.#source2Model.getAnimationByName(animName);
                    if (animDesc) {
                        return animDesc;
                    }
                }
            }
        }
        return null;
    }
    getFrame(frameIndex) {
        frameIndex = clamp$1(frameIndex, 0, this.lastFrame);
        const frameBlockArray = this.#frameBlockArray;
        let segmentIndexArray = null;
        const decodeKey = this.#animationResource.getDecodeKey();
        const decodeArray = this.#animationResource.getDecoderArray();
        const boneArray = [];
        const decodeKeyBoneArray = decodeKey?.getValueAsElementArray('m_boneArray');
        const decodeKeyDataChannelArray = decodeKey?.getValueAsElementArray('m_dataChannelArray');
        /*
        let fetch = this.data?.m_fetch;
        if (fetch) {
            let localReferenceArray = fetch.m_localReferenceArray;
            //TODO: mix multiple anims
            if (localReferenceArray[0] !== undefined) {
                let animName = this.animationResource.localSequenceNameArray[localReferenceArray[0]];
                if (animName) {
                    //console.log(localReference);
                    let animDesc = this.#source2Model.getAnimationByName(animName);
                    if (animDesc) {
                        return animDesc.getFrame(frameIndex);
                    }
                }
                return [];
            }
        }*/
        const actualAnimDesc = this.#getActualAnimDesc();
        if (actualAnimDesc) {
            return actualAnimDesc.getFrame(frameIndex);
        }
        if (frameBlockArray && decodeArray && decodeKeyBoneArray && decodeKeyDataChannelArray) {
            for (const decodeKeyBone of decodeKeyBoneArray) {
                boneArray.push({ name: decodeKeyBone.getValueAsString('m_name') });
            }
            for (const frameBlock of frameBlockArray) {
                const startFrame = frameBlock.getValueAsNumber('m_nStartFrame') ?? 0;
                const endFrame = frameBlock.getValueAsNumber('m_nEndFrame') ?? 0;
                if ((startFrame <= frameIndex) && (endFrame >= frameIndex)) {
                    segmentIndexArray = frameBlock.getValueAsNumberArray('m_segmentIndexArray');
                    //console.log(this);
                    //console.log(decodeKey);
                    if (segmentIndexArray) {
                        for (const segmentIndex of segmentIndexArray) {
                            const segment = this.#animationResource.getSegment(segmentIndex);
                            //console.log(frameIndex, frameIndex - frameBlock.m_nStartFrame);
                            //console.log(frameIndex);
                            if (segment) {
                                this.#readSegment(frameIndex - startFrame, segment, boneArray, decodeKeyDataChannelArray, decodeArray);
                            }
                        }
                    }
                }
            }
        }
        //console.log(boneArray);
        return boneArray;
    }
    #getReader(segment, container) {
        let reader = this.#segmentReaders.get(segment);
        if (!reader) {
            reader = new BinaryReader(segment.getValueAsBlob('m_container') ?? '');
            this.#segmentReaders.set(segment, reader);
        }
        return reader;
    }
    #readSegment(frameIndex, segment, boneArray, dataChannelArray, decodeArray) {
        //console.log(segment);
        const channel = dataChannelArray[segment.getValueAsNumber('m_nLocalChannel') ?? 0];
        if (!channel) {
            return;
        }
        const segmentToBoneIndex = new Map();
        const channelVar = channel.getValueAsString('m_szVariableName');
        const container = segment.getValueAsBlob('m_container');
        if (!channelVar || !container || container.length < 8) {
            return;
        }
        const reader = this.#getReader(segment, container); //segment.dataReader;
        const decoderId = container[0] + (container[1] << 8);
        let bytesPerBone = container[2] + (container[3] << 8);
        const boneCount = container[4] + (container[5] << 8);
        container[6] + (container[7] << 8);
        bytesPerBone = 0;
        const segmentBoneArray = [];
        const elementIndexArray = channel.getValueAsNumberArray('m_nElementIndexArray');
        if (elementIndexArray) {
            for (let i = 0; i < elementIndexArray.length; i++) {
                segmentToBoneIndex.set(elementIndexArray[i], i);
            }
        }
        else {
            //TODO
            return;
        }
        const decoder = decodeArray[decoderId];
        if (!decoder) {
            return;
        }
        const decoderName = decoder.name;
        //console.log(decoderId, bytesPerBone, boneCount, dataLength);
        if (decoder && decoderName) {
            //console.log(decoderName);
            switch (decoderName) {
                case 'CCompressedStaticFullVector3':
                    bytesPerBone = 12;
                    frameIndex = 0;
                    break;
                case 'CCompressedAnimQuaternion':
                    bytesPerBone = 6;
                    break;
                case 'CCompressedStaticVector3':
                    bytesPerBone = 6;
                    frameIndex = 0;
                    break;
                case 'CCompressedFullVector3':
                    bytesPerBone = 12;
                    break;
                case 'CCompressedDeltaVector3':
                    break;
                case 'CCompressedAnimVector3':
                    bytesPerBone = 12;
                    frameIndex = 0;
                    //TODO
                    break;
                case 'CCompressedFullFloat':
                case 'CCompressedStaticFloat':
                    bytesPerBone = 4;
                    frameIndex = 0;
                    //TODO
                    break;
                default:
                    return;
            }
            var byteIndex = 8;
            for (var boneIndex = 0; boneIndex < boneCount; boneIndex++, byteIndex += 2) {
                segmentBoneArray.push(container[byteIndex + 0] /*TODO: actually check value*/ + (container[byteIndex + 1] /*TODO: actually check value*/ << 8));
            }
            var byteIndex = 8 + boneCount * 2 + frameIndex * boneCount * bytesPerBone;
            for (var boneIndex = 0; boneIndex < boneCount; boneIndex++) {
                const boneIndex2 = segmentToBoneIndex.get(segmentBoneArray[boneIndex] /*TODO: actually check value*/);
                if (boneIndex2 === undefined) { //removeme
                    continue;
                }
                const bytes = [];
                const byteIndex2 = byteIndex + boneIndex * bytesPerBone;
                for (let j = 0; j < bytesPerBone; j++) {
                    bytes.push(container[byteIndex2 + j] ?? 0);
                }
                let tmpValue = null;
                switch (decoderName) {
                    case 'CCompressedFullFloat':
                    case 'CCompressedStaticFloat':
                        tmpValue = getFloat32$1(bytes, 0);
                        break;
                    case 'CCompressedStaticFullVector3':
                    case 'CCompressedFullVector3':
                        //case 'CCompressedAnimVector3':
                        var x = getFloat32$1(bytes, 0);
                        var y = getFloat32$1(bytes, 4);
                        var z = getFloat32$1(bytes, 8);
                        tmpValue = vec3.fromValues(x, y, z);
                        break;
                    case 'CCompressedDeltaVector3':
                        tmpValue = decodeCCompressedDeltaVector3(reader, boneCount, boneIndex, frameIndex);
                        break;
                    case 'CCompressedStaticVector3':
                        var x = getFloat16(bytes, 0);
                        var y = getFloat16(bytes, 2);
                        var z = getFloat16(bytes, 4);
                        tmpValue = vec3.fromValues(x, y, z);
                        break;
                    case 'CCompressedAnimQuaternion':
                        tmpValue = readQuaternion48$1(bytes);
                        break;
                    //TODO
                }
                if (tmpValue && boneArray[boneIndex2]) {
                    boneArray[boneIndex2][channelVar] = tmpValue;
                }
            }
        }
    }
    matchActivity(activityName) {
        const activityArray = this.data.getValueAsElementArray('m_activityArray');
        if (activityArray) {
            for (const activity of activityArray) {
                if (activity.getValueAsString('m_name') == activityName) {
                    return true;
                }
            }
        }
        return false;
    }
    /*
    getActivityName() {
        return this.data?.m_activityArray?.[0]?.m_name;
    }

    hasModifiers() {
        return this.data?.m_activityArray?.length > 1;
    }
    */
    modifiersScore(activityName, modifiers) {
        const activityArray = this.data?.getSubValueAsElementArray('m_activityArray');
        if (activityArray && activityArray.length > 0) {
            if (activityArray[0].getSubValueAsString('m_name') != activityName) {
                return -1;
            }
            if (activityArray.length == 1 && modifiers.size == 0) {
                // We have no modifiers and activityArray only contains the activity
                return 1;
            }
            const matchingModifiers = {};
            for (const modifier of modifiers) {
                for (const activity of activityArray) {
                    const name = activity.getSubValueAsString('m_name');
                    if (activityName == name) {
                        continue;
                    }
                    if (modifier == name) {
                        matchingModifiers[modifier] = 1;
                        break;
                    }
                }
            }
            return Object.keys(matchingModifiers).length;
        }
        return -1;
    }
    matchModifiers(activityName, modifiers) {
        const activityArray = this.data.getValueAsElementArray('m_activityArray');
        if (activityArray && activityArray.length > 0) {
            if (activityArray[0].getValueAsString('m_name') != activityName) {
                return false;
            }
            if (activityArray.length == 1 && modifiers.size == 0) {
                // We have no modifiers and activityArray only contains the activity
                return true;
            }
            if (activityArray.length - 1 != modifiers.size) {
                return false;
            }
            const matchingModifiers = {};
            for (const modifier of modifiers) {
                for (const activity of activityArray) {
                    const name = activity.getSubValueAsString('m_name');
                    if (activityName == name) {
                        continue;
                    }
                    if (modifier == name) {
                        matchingModifiers[modifier] = 1;
                        break;
                    }
                }
            }
            return (Object.keys(matchingModifiers).length == modifiers.size);
        }
        return false;
    }
}
function getFloat16(b, offset) {
    const sign = b[1 + offset] >> 7;
    const exponent = ((b[1 + offset] & 0x7C) >> 2);
    const mantissa = ((b[1 + offset] & 0x03) << 8) | b[0 + offset];
    if (exponent == 0) {
        return (sign ? -1 : 1) * Math.pow(2, -14) * (mantissa / Math.pow(2, 10));
    }
    else if (exponent == 0x1F) {
        return mantissa ? NaN : ((sign ? -1 : 1) * Infinity);
    }
    return (sign ? -1 : 1) * Math.pow(2, exponent - 15) * (1 + (mantissa / Math.pow(2, 10)));
}
function getFloat32$1(b, offset) {
    const sign = 1 - (2 * (b[3 + offset] >> 7)), exponent = (((b[3 + offset] << 1) & 0xff) | (b[2 + offset] >> 7)) - 127, mantissa = ((b[2 + offset] & 0x7f) << 16) | (b[1 + offset] << 8) | b[0 + offset];
    if (exponent === 128) {
        if (mantissa !== 0) {
            return NaN;
        }
        else {
            return sign * Infinity;
        }
    }
    if (exponent === -127) { // Denormalized
        return sign * mantissa * pow2(-126 - 23);
    }
    return sign * (1 + mantissa * pow2(-23)) * pow2(exponent);
}
const QUATERNION48_SCALE = Math.SQRT1_2 / 0x4000;
function readQuaternion48$1(bytes) {
    // Values
    const i1 = bytes[0] + ((bytes[1] & 127) << 8) - 0x4000;
    const i2 = bytes[2] + ((bytes[3] & 127) << 8) - 0x4000;
    const i3 = bytes[4] + ((bytes[5] & 127) << 8) - 0x4000;
    // Signs
    const s1 = bytes[1] & 128;
    const s2 = bytes[3] & 128;
    const s3 = bytes[5] & 128;
    const x = QUATERNION48_SCALE * i1;
    const y = QUATERNION48_SCALE * i2;
    const z = QUATERNION48_SCALE * i3;
    let w = Math.sqrt(1 - (x * x) - (y * y) - (z * z));
    // Apply sign 3
    if (s3 == 128) {
        w *= -1;
    }
    // Apply sign 1 and 2
    if (s1 == 128) {
        return s2 == 128 ? quat.fromValues(y, z, w, x) : quat.fromValues(z, w, x, y);
    }
    else {
        return s2 == 128 ? quat.fromValues(w, x, y, z) : quat.fromValues(x, y, z, w);
    }
}

function kv3ElementToDecoderArray(elements) {
    if (!elements) {
        return [];
    }
    const decoders = new Array(elements.length);
    for (let i = 0, l = elements.length; i < l; i++) {
        const element = elements[i];
        decoders[i] = {
            name: element.getValueAsString('m_szName') ?? '',
            version: element.getValueAsNumber('m_nVersion') ?? 0,
            type: element.getValueAsNumber('m_nType') ?? 0,
        };
    }
    return decoders;
}

class Source2Animation {
    #animArray = [];
    #animNames = new Map();
    #animGroup;
    file;
    #decoderArray = [];
    #segmentArray = [];
    //#frameData;
    constructor(animGroup) {
        this.#animGroup = animGroup;
    }
    setFile(sourceFile) {
        this.file = sourceFile;
        const animDatas = 
        //sourceFile.getBlockStruct('DATA.structs.AnimationResourceData_t')
        sourceFile.getBlockKeyValues('DATA')
            //?? sourceFile.getBlockStruct('DATA', 'm_localS1SeqDescArray')
            ?? sourceFile.getBlockKeyValues('ANIM');
        if (animDatas) {
            this.setAnimDatas(animDatas);
        }
    }
    setAnimDatas(data) {
        if (data) {
            this.#animArray = data.getValueAsElementArray('m_animArray') ?? []; //data.m_animArray ?? [];
            //console.error('data.m_animArray', data.m_animArray);
            this.#decoderArray = kv3ElementToDecoderArray(data.getValueAsElementArray('m_decoderArray')); //this.decoderArray = data.m_decoderArray;
            this.#segmentArray = data.getValueAsElementArray('m_segmentArray') ?? []; //data.m_segmentArray;
            //this.#frameData = data.m_frameData;
            //for (let i = 0; i < this.#animArray.length; i++) {
            for (const anim of this.#animArray) {
                //const anim = this.#animArray[i];
                const animName = anim.getValueAsString('m_name');
                if (animName) {
                    this.#animNames.set(animName, new Source2AnimationDesc(this.#animGroup.source2Model, anim, this));
                }
            }
        }
    }
    getAnimDesc(name) {
        return this.#animNames.get(name);
    }
    getDecodeKey() {
        return this.#animGroup.decodeKey;
    }
    getDecoderArray() {
        return this.#decoderArray;
    }
    getSegment(segmentIndex) {
        //TODO: check segement
        return this.#segmentArray[segmentIndex] ?? null;
    }
    async getAnimations(animations = new Set()) {
        for (const anim of this.#animArray) {
            const animName = anim.getSubValueAsString('m_name');
            if (animName) {
                animations.add(animName);
            }
            const activityArray = anim.getSubValueAsElementArray('m_activityArray');
            if (activityArray) {
                for (const activity of activityArray) {
                    const activityName = activity.getSubValueAsString('m_name');
                    if (activityName) {
                        animations.add(activityName);
                    }
                }
            }
        }
        return animations;
    }
    /* disabled for now
    getAnimationByActivity(activityName, activityModifiers) {
        if (!this.#animArray) {
            return [,];
        }
        const anims = new Map();
        let bestMatch;
        let bestScore = Infinity;
        for (const anim of this.#animArray) {
            if (!anim.m_activityArray) {
                continue;
            }
            let matchingActivity = false;
            let unmatchingModifiers = 0;
            for (const activity of anim.m_activityArray ?? []) {
                if (activity.m_name == activityName) {
                    matchingActivity = true;
                }
                let modifierMatching = false;
                for (const activityModifier of activityModifiers) {
                    if (activity.m_name == activityModifier) {
                        modifierMatching = true;
                        break;
                    }
                }
                if (!modifierMatching) {
                    ++unmatchingModifiers;
                }
            }

            if (matchingActivity) {
                for (const activityModifier of activityModifiers) {
                    let modifierMatching = false;
                    for (const activity of anim.m_activityArray ?? []) {
                        if (activity.m_name == activityModifier) {
                            modifierMatching = true;
                            break;
                        }
                    }
                    if (!modifierMatching) {
                        ++unmatchingModifiers;
                    }
                }
                if (unmatchingModifiers < bestScore) {
                    const animDesc = this.#animNames.get(anim.m_name);
                    if (animDesc) {
                        bestMatch = animDesc;
                        bestScore = unmatchingModifiers;
                    }
                }
            }
        }
        return [bestMatch, bestScore];
    }
    */
    getAnimationsByActivity(activityName) {
        const anims = [];
        for (const [animName, animDesc] of this.#animNames) {
            if (animDesc.matchActivity(activityName)) {
                anims.push(animDesc);
            }
        }
        return anims;
    }
    get animArray() {
        return this.#animArray;
    }
    getAnimationByName(animName) {
        return this.#animNames.get(animName);
        //return this.#internalAnimGroup?.getAnimationByName(animName);
        /*for (let source2Animation in this.#animArray) {
            let anim = source2Animation.getAnimationByName(animName);
            if (anim) {
                return anim;
            }
        }*/
    }
}

class Source2Activity {
    name;
    weight;
    flags;
    activity;
    constructor(name, weight, flags, activity) {
        this.name = name;
        this.weight = weight;
        this.flags = flags;
        this.activity = activity;
        if (flags != 0) {
            throw 'Check this: flags != 0';
        }
        if (activity != 0) {
            throw 'Check this: activity != 0';
        }
    }
}

class Source2Sequence {
    name;
    fps;
    frameCount;
    activities;
    animNames;
    constructor(name, params = {}) {
        this.name = name;
        this.fps = params.fps ?? 30;
        this.frameCount = params.frameCount ?? 0;
        if (params.activities) {
            this.activities = params.activities;
        }
        if (params.animNames) {
            this.animNames = params.animNames;
        }
    }
    matchActivity(activity, modifiers) {
        if (modifiers) {
            if (this.activities.length == modifiers.length + 1) {
                if (this.activities[0].name == activity) {
                    let matchCount = 0;
                    for (let i = 1; i < this.activities.length; i++) {
                        for (const modifier of modifiers) {
                            if (this.activities[i] == modifier) {
                                ++matchCount;
                            }
                        }
                    }
                    if (matchCount == modifiers.length) {
                        return true;
                    }
                }
            }
            return false;
        }
        else {
            if (this.activities[0]?.name == activity) {
                return true;
            }
        }
    }
}

class Source2SeqGroup {
    #animNames = new Map();
    #animGroup;
    #localSequenceNameArray = null;
    sequences = [];
    file;
    #m_localS1SeqDescArray = null;
    #animArray = null;
    loaded = false;
    constructor(animGroup) {
        this.#animGroup = animGroup;
    }
    setFile(sourceFile) {
        this.file = sourceFile;
        const sequenceGroupResourceData_t = sourceFile.getBlockStruct('DATA', 'structs.SequenceGroupResourceData_t' /*TODO: check that*/);
        let localSequenceNameArray;
        if (sequenceGroupResourceData_t) {
            // TODO: this part is not tested find a test case
            this.#m_localS1SeqDescArray = sequenceGroupResourceData_t.getSubValueAsElementArray('m_localS1SeqDescArray');
            localSequenceNameArray = sequenceGroupResourceData_t.getSubValueAsStringArray('m_localSequenceNameArray');
        }
        else {
            this.#m_localS1SeqDescArray = sourceFile.getBlockStructAsElementArray('DATA', 'm_localS1SeqDescArray') ?? sourceFile.getBlockStructAsElementArray('ASEQ', 'm_localS1SeqDescArray');
            localSequenceNameArray = sourceFile.getBlockStructAsStringArray('DATA', 'm_localSequenceNameArray') ?? sourceFile.getBlockStructAsStringArray('ASEQ', 'm_localSequenceNameArray');
        }
        this.#localSequenceNameArray = localSequenceNameArray;
        if (this.#m_localS1SeqDescArray && localSequenceNameArray) {
            this.#processSeqDesc(this.#m_localS1SeqDescArray, localSequenceNameArray);
        }
        this.#animArray = this.#m_localS1SeqDescArray;
        if (this.#animArray) {
            for (const anim of this.#animArray) {
                const animName = anim.getValueAsString('m_sName');
                if (animName) {
                    this.#animNames.set(animName, new Source2AnimationDesc(this.#animGroup.source2Model, anim, this));
                }
            }
        }
        const anims = sourceFile.getBlockKeyValues('DATA'); // ?? sourceFile.getBlockStruct('DATA', ''/*.structs.SequenceGroupResourceData_t'*/);
        if (anims) {
            const loadedAnim = new Source2Animation(this /*TODO: fix this*/);
            loadedAnim.setAnimDatas(anims);
            this.#animGroup._changemyname = this.#animGroup._changemyname || [];
            this.#animGroup._changemyname.push(loadedAnim);
        }
        this.loaded = true;
    }
    getAnimDesc(name) {
        return this.#animNames.get(name);
    }
    #processSeqDesc(m_localS1SeqDescArray, localSequenceNameArray) {
        for (const sequence of m_localS1SeqDescArray) {
            //const sequence = m_localS1SeqDescArray[i];
            const activities = [];
            const activityArray = sequence.getValueAsElementArray('m_activityArray');
            const sequenceName = sequence.getValueAsString('m_sName');
            if (!sequenceName) {
                continue;
            }
            if (activityArray) {
                for (const activity of activityArray) {
                    //const activity = activityArray[j];
                    const name = activity.getValueAsString('m_name') ?? '';
                    const weight = activity.getValueAsNumber('m_nWeight') ?? 0;
                    const flags = activity.getValueAsNumber('m_nFlags') ?? 0;
                    const act = activity.getValueAsNumber('m_nActivity') ?? 0;
                    activities.push(new Source2Activity(name, weight, flags, act));
                }
            }
            const localReferenceArray = sequence.getSubValueAsNumberArray('m_fetch.m_localReferenceArray'); //?.m_fetch?.m_localReferenceArray;
            const animNames = [];
            if (localReferenceArray) {
                for (const localReference of localReferenceArray) {
                    animNames.push(localSequenceNameArray[localReference]);
                }
            }
            const s2Seq = new Source2Sequence(sequenceName, { activities: activities, animNames: animNames });
            //console.error(s2Seq);
            this.sequences.push(s2Seq);
        }
    }
    matchActivity(activity, modifiers) {
        for (const sequence of this.sequences) {
            if (sequence.matchActivity(activity, modifiers)) {
                return sequence.animNames[0]; //TODO
            }
        }
        return null;
    }
    getAnimationsByActivity(activityName) {
        const anims = [];
        for (const [animName, animDesc] of this.#animNames) {
            if (animDesc.matchActivity(activityName)) {
                anims.push(animDesc);
            }
        }
        return anims;
    }
    getDecodeKey() {
        return this.#animGroup.getDecodeKey();
    }
    getDecoderArray() {
        return this.#animGroup.decoderArray;
    }
    get localSequenceNameArray() {
        return this.#localSequenceNameArray;
    }
}

class Source2AnimGroup {
    #source2Model;
    #_changemyname = [];
    repository;
    file;
    decoderArray = [];
    localAnimArray = null;
    decodeKey;
    directHSeqGroup;
    loaded = false;
    constructor(source2Model, repository) {
        //TODO: remove repository param. redundant with model
        this.#source2Model = source2Model;
        this.repository = repository;
    }
    setFile(sourceFile) {
        this.file = sourceFile;
        let localAnimArray;
        let decodeKey;
        const animationGroupData = sourceFile.getBlockStruct('DATA', 'AnimationGroupResourceData_t');
        let directHSeqGroup;
        if (animationGroupData) {
            // TODO: this part is not tested find a test case
            localAnimArray = animationGroupData.getValueAsResourceArray('m_localHAnimArray');
            decodeKey = animationGroupData.getSubValueAsElement('m_decodeKey');
            directHSeqGroup = animationGroupData.getSubValueAsElement('m_directHSeqGroup');
        }
        else {
            localAnimArray = sourceFile.getBlockStructAsResourceArray('DATA', 'm_localHAnimArray');
            decodeKey = sourceFile.getBlockStruct('DATA', 'm_decodeKey') /*TODO: check type*/;
            directHSeqGroup = sourceFile.getBlockStruct('DATA', 'm_directHSeqGroup');
        }
        this.decoderArray = kv3ElementToDecoderArray(sourceFile.getBlockStructAsElementArray('ANIM', 'm_decoderArray'));
        if (directHSeqGroup) {
            // TODO: this part is not tested find a test case
            (async () => {
                this.directHSeqGroup = await getSequenceGroup(this.repository, directHSeqGroup, this);
            })();
        }
        if (decodeKey) {
            this.setAnimationGroupResourceData(localAnimArray, decodeKey);
        }
        const anims = sourceFile.getBlockKeyValues('ANIM');
        if (anims) {
            const loadedAnim = new Source2Animation(this);
            loadedAnim.setAnimDatas(anims);
            this._changemyname = this._changemyname || [];
            this._changemyname.push(loadedAnim);
            /*let m_animArray = anims.m_animArray;
            for (let i = 0; i < m_animArray.length; i++) {
            }*/
        }
        this.loaded = true;
    }
    setAnimationGroupResourceData(localAnimArray, decodeKey) {
        this.localAnimArray = localAnimArray;
        this.decodeKey = decodeKey;
        //this.getAnim(0);
        if (localAnimArray) {
            for (const localAnim of localAnimArray) {
                getAnim(this.repository, localAnim, this);
                //console.info(anim);
            }
        }
    }
    getAnim(animIndex) {
        if (this.localAnimArray && this.localAnimArray[animIndex]) {
            return getAnim(this.repository, this.localAnimArray[animIndex], this);
        }
        return null;
    }
    getAnimDesc(name) {
        let animation;
        for (const a of this.#_changemyname) {
            animation = a.getAnimDesc(name);
            if (animation) {
                return animation;
            }
        }
    }
    matchActivity(activity, modifiers) {
        if (this.directHSeqGroup) {
            return this.directHSeqGroup.matchActivity(activity, modifiers);
        }
    }
    getAnims() {
        const anims = new Set();
        for (const anim of this._changemyname) {
            if (anim) {
                anims.add(anim);
            }
        }
        if (this.localAnimArray) {
            for (const animName of this.localAnimArray) {
                if (animName) {
                    const anim = getAnim(this.repository, animName, this);
                    if (anim) {
                        anims.add(anim);
                    }
                }
            }
        }
        return anims;
    }
    getAnimationsByActivity(activityName) {
        const anims = [];
        for (const anim of this._changemyname) {
            if (anim) {
                anims.push(...anim.getAnimationsByActivity(activityName));
            }
        }
        if (this.localAnimArray) {
            for (const animName of this.localAnimArray) {
                if (animName) {
                    const anim = getAnim(this.repository, animName, this);
                    if (anim) {
                        anims.push(...anim.getAnimationsByActivity(activityName));
                    }
                }
            }
        }
        if (this.directHSeqGroup) {
            anims.push(...this.directHSeqGroup.getAnimationsByActivity(activityName));
        }
        return anims;
    }
    getDecodeKey() {
        return this.decodeKey;
    }
    get source2Model() {
        return this.#source2Model;
    }
    getAnimationByName(animName) {
        //return this.#internalAnimGroup?.getAnimationByName(animName);
        for (const source2Animation of this.getAnims()) {
            const anim = source2Animation.getAnimationByName(animName);
            if (anim) {
                return anim;
            }
        }
        return null;
    }
    //TODO: remove setter and getter
    set _changemyname(_changemyname) {
        this.#_changemyname = _changemyname;
    }
    get _changemyname() {
        return this.#_changemyname;
    }
}
const seqGroupList = {};
async function getSequenceGroup(repository, seqGroupName, animGroup) {
    let seqGroup = seqGroupList[seqGroupName];
    if (!seqGroup) {
        seqGroup = await loadSequenceGroup(repository, seqGroupName, animGroup);
    }
    if (seqGroup) {
        seqGroupList[seqGroupName] = seqGroup;
    }
    else {
        //TODO; create dummy
        console.error('No anim group loaded');
    }
    return seqGroup;
}
async function loadSequenceGroup(repository, seqGroupName, animGroup) {
    repository = repository.toLowerCase();
    seqGroupName = seqGroupName.replace(/\.(vseq_c$|vseq)/, '');
    //seqGroupName = repository + seqGroupName;
    const seqGroup = new Source2SeqGroup(animGroup);
    await getVseq(repository, seqGroupName, seqGroup);
    return seqGroup;
}
const pending$1 = {};
async function getVseq(repository, seqGroupName, seqGroup) {
    const seqFile = seqGroupName + '.vseq_c';
    if (pending$1[seqFile]) {
        return true;
    }
    pending$1[seqFile] = true;
    await loadVseq(repository, seqFile, seqGroup);
    /*
    let promise = new Promise((resolve) => {
        fetch(new Request(seqFile)).then((response) => {
            response.arrayBuffer().then(async (arrayBuffer) => {
                await this.loadVseq(repository, seqFile, arrayBuffer, seqGroup);
                pending[seqFile] = null;
                resolve(true);
            })
        });
    });
    */
    return true;
}
async function loadVseq(repository, fileName, seqGroup) {
    const vseq = await new Source2FileLoader().load(repository, fileName);
    if (vseq) {
        seqGroup.setFile(vseq);
    }
}
const animList = {};
function getAnim(repository, animName, animGroup) {
    if (!animName) {
        return null;
    }
    const anim = animList[animName];
    if (anim === undefined) {
        loadAnim(repository, animName, animGroup).then(anim => {
            animList[animName] = anim;
            animGroup._changemyname.push(anim);
        });
        return null;
    }
    else {
        return anim;
    }
}
async function loadAnim(repository, animName, animGroup) {
    animName = animName.toLowerCase();
    animName = animName.replace(/\.(vanim_c$|vanim$)/, '');
    //this.fileName = animName;
    //animName = repository + animName;
    //this.animName = animName;
    const anim = new Source2Animation(animGroup);
    await getVanim(repository, animName, anim);
    return anim;
}
async function getVanim(repository, animName, anim) {
    const animFile = animName + '.vanim_c';
    if (pending$1[animFile]) {
        return true;
    }
    pending$1[animFile] = true;
    /*
                fetch(new Request(animFile)).then((response) => {
                    response.arrayBuffer().then((arrayBuffer) => {
                        this.loadVanim(repository, animFile, arrayBuffer, anim);
                    })
                });
                */
    loadVanim(repository, animFile, anim);
    /*
    let promise = new Promise((resolve) => {
        fetch(new Request(animFile)).then((response) => {
            response.arrayBuffer().then(async (arrayBuffer) => {
                this.loadVanim(repository, animFile, arrayBuffer, anim);
                pending[animFile] = null;
                resolve(true);
            })
        });
    });
    */
    return true;
}
async function loadVanim(repository, fileName, anim) {
    const vanim = await new Source2FileLoader().load(repository, fileName);
    if (vanim) {
        anim.setFile(vanim);
        const dataBlock = vanim.getBlockStructAsElement('DATA', '');
        if (dataBlock) {
            anim.setAnimDatas(dataBlock); // || vanim.getBlockStruct('DATA.keyValue.root'));
        }
    }
    //this.fileLoaded(model);TODOv3
}

const pending = {};
async function loadAnimGroup(source2Model, repository, animGroupName) {
    animGroupName = animGroupName.toLowerCase();
    animGroupName = animGroupName.replace(/\.(vagrp_c$|vagrp$)/, '');
    const animGroup = new Source2AnimGroup(source2Model, repository);
    await getVagrp(repository, animGroupName, animGroup);
    return animGroup;
}
async function getVagrp(repository, animGroupName, animGroup) {
    const agrpFile = animGroupName + '.vagrp_c';
    if (pending[agrpFile]) {
        return true;
    }
    pending[agrpFile] = true;
    await loadVagrp(repository, agrpFile, animGroup);
    return true;
}
async function loadVagrp(repository, fileName, animGroup) {
    const vagrp = await new Source2FileLoader().load(repository, fileName);
    if (vagrp) {
        animGroup.setFile(vagrp);
        const dataBlock = vagrp.blocks.DATA;
        if (dataBlock) {
            //animGroup.meshesNames = vagrp.getPermModelData('m_meshGroups');
            vagrp.getPermModelData('m_refMeshes');
        }
    }
    //this.fileLoaded(model);TODOv3
}

const AnimManager = new (function () {
    const animGroupList = {};
    class AnimManager {
        async getAnimGroup(source2Model, repository, animGroupName) {
            let animGroup = animGroupList[animGroupName];
            if (!animGroup) {
                animGroup = await loadAnimGroup(source2Model, repository, animGroupName);
            }
            if (animGroup) {
                animGroupList[animGroupName] = animGroup;
            }
            else {
                //TODO; create dummy
                console.error('No anim group loaded');
            }
            return animGroup;
        }
        removeAnimGroup(animGroupName) {
            delete animGroupList[animGroupName];
        }
    }
    return AnimManager;
}());

const tempPos$1 = vec3.create();
const tempQuat$6 = quat.create();
class Source2ModelAttachment {
    name;
    ignoreRotation = false;
    influenceNames = [];
    influenceWeights = [];
    influenceOffsets = [];
    influenceRotations = [];
    constructor(name) {
        this.name = name;
    }
}
class Source2ModelAttachmentInstance extends Entity {
    model;
    attachment;
    constructor(model, attachment) {
        super({ name: attachment.name });
        this.model = model;
        this.attachment = attachment;
    }
    #getBone(boneName) {
        return this.model?.skeleton?.getBoneByName(boneName) ?? null;
    }
    //TODO: compute with all bones, not only the first one
    getWorldPosition(vec = vec3.create()) {
        const bone = this.#getBone(this.attachment.influenceNames[0] ?? '');
        if (bone) {
            bone.getWorldPosition(vec);
            bone.getWorldQuaternion(tempQuat$6);
            const offset0 = this.attachment.influenceOffsets[0];
            if (offset0) {
                vec3.transformQuat(tempPos$1, offset0, tempQuat$6);
                vec3.add(vec, vec, tempPos$1);
            }
        }
        else {
            vec3.copy(vec, this._position);
        }
        return vec;
    }
    //TODO: compute with all bones, not only the first one
    getWorldQuaternion(q = quat.create()) {
        const bone = this.#getBone(this.attachment.influenceNames[0] ?? '');
        if (bone) {
            bone.getWorldQuaternion(q);
            const quat0 = this.attachment.influenceRotations[0];
            if (quat0) {
                quat.mul(q, q, quat0);
            }
        }
        else {
            quat.copy(q, this._quaternion);
        }
        return q;
    }
}

const SOURCE2_DEFAULT_BODY_GROUP = 'autodefault';
const identityVec3$1 = vec3.create();
const identityQuat = quat.create();
const initSkeletonTempVec3 = vec3.create();
const initSkeletonTempQuat = quat.create();
let animSpeed = 1.0;
const defaultMaterial$2 = new MeshBasicMaterial();
class Source2ModelInstance extends Entity {
    isSource2ModelInstance = true;
    #skeleton = null;
    #skin = 0;
    #materialsUsed = new Set();
    #animName;
    animable = true;
    #lod = 1n;
    bodyParts = {};
    poseParameters = {};
    meshes = new Set();
    attachments = new Map();
    activity = '';
    activityModifiers = new Set();
    sequences = {};
    mainAnimFrame = 0;
    animationSpeed = 1.0;
    sourceModel;
    hasAnimations = true;
    #bodyGroups = new Map();
    static {
        defaultMaterial$2.addUser(Source2ModelInstance);
    }
    constructor(sourceModel, isDynamic) {
        super();
        this.sourceModel = sourceModel;
        this.name = sourceModel?.vmdl?.getDisplayName();
        if (isDynamic) {
            this.#skeleton = new Skeleton({ name: `Skeleton ${this.name}` });
            this.addChild(this.#skeleton);
        }
        if (isDynamic) {
            this.#initSkeleton();
            this.#initAttachments();
        }
        this.#init();
        this.#updateMaterials();
    }
    #initDefaultBodyGroups() {
        this.#bodyGroups.set(SOURCE2_DEFAULT_BODY_GROUP, undefined);
        for (const bodyGroup of this.sourceModel.bodyGroups) {
            this.#bodyGroups.set(bodyGroup, 0);
        }
        this.#refreshMeshesVisibility();
    }
    setBodyGroup(name, choice) {
        if (this.sourceModel.bodyGroups.has(name)) {
            this.#bodyGroups.set(name, choice);
        }
        this.#refreshMeshesVisibility();
    }
    resetBodyGroups() {
        this.#bodyGroups.clear();
        this.#refreshMeshesVisibility();
    }
    #refreshMeshesVisibility() {
        let mask = 0n;
        for (const bodyGroupsChoice of this.sourceModel.bodyGroupsChoices) {
            const choice = this.#bodyGroups.get(bodyGroupsChoice.bodyGroup);
            if (bodyGroupsChoice.bodyGroup == SOURCE2_DEFAULT_BODY_GROUP || (choice === undefined) || (bodyGroupsChoice.choice.startsWith(`${bodyGroupsChoice.bodyGroup}_@${choice}`))) {
                mask += BigInt(Math.pow(2, bodyGroupsChoice.bodyGroupId));
            }
        }
        if (mask == 0n) {
            mask = 0xffffffffffffffffn;
        }
        for (const mesh of this.meshes) {
            const geometry = mesh.geometry;
            mesh.setVisible(undefined);
            if (geometry) {
                const meshGroupMask = geometry.properties.getBigint('mesh_group_mask') ?? 0xffffffffffffffffn;
                const lodGroupMask = BigInt(geometry.properties.getBigint('lodGroupMask') ?? geometry.properties.getNumber('lodGroupMask') ?? 0);
                mesh.setVisible((meshGroupMask & mask) > 0 ? undefined : false);
                if (lodGroupMask && ((lodGroupMask & this.#lod) == 0n)) {
                    mesh.setVisible(false);
                }
            }
        }
    }
    get skeleton() {
        return this.#skeleton;
    }
    setPosition(position) {
        super.setPosition(position);
        if (this.#skeleton) {
            this.#skeleton.dirty();
        }
    }
    addChild(child) {
        if (!child) {
            return;
        }
        const ret = super.addChild(child);
        if (child.skeleton) {
            child.skeleton.setParentSkeleton(this.#skeleton);
        }
        /*if (child instanceof Source2ModelInstance) {
            for (let mesh of child.meshes) {
                if (mesh.skeleton) {
                    mesh.skeleton.setParentSkeleton(this.#skeleton);
                }
            }
        }*/
        if ((this.#skeleton != child) && child instanceof Skeleton) {
            child.setParentSkeleton(this.#skeleton);
        }
        return ret;
    }
    removeChild(child) {
        super.removeChild(child);
        if (child.skeleton) {
            child.skeleton.setParentSkeleton(null);
        }
    }
    set skin(skin) {
        this.#skin = skin;
        this.#updateMaterials();
    }
    get skin() {
        return this.#skin;
    }
    async setSkin(skin) {
        this.#skin = Number(skin);
        await this.#updateMaterials();
    }
    setLOD(lod) {
        this.#lod = BigInt(lod);
        this.#refreshMeshesVisibility();
        this.forEach((child) => {
            if (child != this && child.setLOD) {
                child.setLOD(lod);
            }
        });
    }
    setPoseParameter(paramName, paramValue) {
        this.poseParameters[paramName] = paramValue;
    }
    playSequence(activity, activityModifiers = []) {
        this.activity = activity;
        this.setActivityModifiers(activityModifiers);
    }
    playAnimation(name) {
        this.#animName = name;
    }
    async setAnimation(id, name, weight) {
        this.#animName = name;
    }
    setActivityModifiers(activityModifiers = []) {
        this.activityModifiers.clear();
        for (const modifier of activityModifiers) {
            if (modifier) {
                this.activityModifiers.add(modifier);
            }
        }
    }
    update(scene, camera, delta) {
        if (this.#skeleton && this.isPlaying()) {
            this.#playSequences(delta * animSpeed * this.animationSpeed);
            this.#skeleton.setBonesMatrix();
        }
        for (const mesh of this.meshes) {
            mesh.skeleton?.setBonesMatrix();
        }
    }
    #playSequences(delta) {
        if (this.#skeleton === null) {
            return;
        }
        let animDesc;
        if (this.#animName) {
            animDesc = this.sourceModel.getAnimation(this.#animName);
        }
        else {
            animDesc = this.sourceModel.getAnim(this.activity, this.activityModifiers);
        }
        if (animDesc) {
            const posArray = animDesc.getFrame(Math.floor(this.mainAnimFrame % (animDesc.lastFrame + 1)));
            this.mainAnimFrame += delta * animDesc.fps;
            for (let i = 0; i < posArray.length; ++i) {
                const pos = posArray[i];
                const boneName = pos.name.toLowerCase();
                const propBone = this.#skeleton.getBoneByName(boneName);
                if (propBone) {
                    if (!propBone.locked) {
                        propBone.quaternion = pos.Angle || identityQuat;
                        propBone.position = pos.Position || identityVec3$1;
                    }
                }
            }
        }
        else {
            for (const bone of this.#skeleton.bones) {
                if (!bone.locked) {
                    bone.quaternion = bone.refQuaternion;
                    bone.position = bone.refPosition;
                }
            }
        }
    }
    #updateMaterials() {
        //console.error(this);
        const materials0 = this.sourceModel.getSkinMaterials(0);
        const materials = this.sourceModel.getSkinMaterials(this.#skin);
        /*if (!materials) {
            return;
        }*/
        //console.error(materials, this);
        for (const mesh of this.meshes) {
            if (materials0 && materials) {
                for (const i in materials0) {
                    if (materials0[i] == mesh.geometry?.properties.getString('materialPath')) {
                        const materialPath = materials[i];
                        if (materialPath) {
                            mesh.properties.setString('materialPath', materialPath);
                        }
                        break;
                    }
                }
                /*let materialPath = materials[mesh.geometry.materialId];
                if (materialPath) {
                    mesh.materialPath = materialPath;
                }*/
            }
            else {
                const materialPath = mesh.geometry?.properties.getString('materialPath');
                if (materialPath) {
                    mesh.properties.setString('materialPath', materialPath);
                }
            }
            const materialPath = mesh.properties.getString('materialPath');
            if (materialPath) {
                Source2MaterialManager.getMaterial(this.sourceModel.repository, materialPath).then(material => {
                    if (material) {
                        material.addUser(this);
                        mesh.setMaterial(material);
                        this.#materialsUsed.add(material);
                    }
                });
            }
        }
    }
    async getSkins() {
        const skins = this.sourceModel.getSkinList();
        if (skins.length == 0) {
            skins.push('default');
        }
        return new Set(skins);
    }
    async getMaterialsName(skin) {
        const materials = this.sourceModel.getSkinMaterials(Number(skin));
        const s = new Set();
        if (materials) {
            for (const material of materials) {
                s.add(material.replace(/\.vmat_c$/, '').replace(/\.vmat$/, '') + '.vmat_c');
            }
        }
        else {
            // No material groups
            for (const mesh of this.meshes) {
                const material = mesh.getGeometry()?.properties.getString('materialPath');
                if (material) {
                    s.add(material);
                }
            }
        }
        return [this.sourceModel.repository, s];
    }
    #init() {
        const sourceModel = this.sourceModel;
        for (const [bodyPartName, bodyPart] of sourceModel.bodyParts) {
            const newBodyPart = [];
            for (const model of bodyPart) {
                if (model) {
                    const newModel = [];
                    for (const geometry of model) {
                        let mesh;
                        if (this.#skeleton) {
                            mesh = new SkeletalMesh({ geometry: geometry, material: defaultMaterial$2, skeleton: this.#skeleton });
                            mesh.name = bodyPartName;
                            mesh.bonesPerVertex = 4;
                        }
                        else {
                            mesh = new Mesh({ geometry: geometry, material: defaultMaterial$2 });
                        }
                        if (geometry.hasAttribute('aVertexTangent')) {
                            mesh.setDefine('USE_VERTEX_TANGENT');
                        }
                        mesh.setVisible(undefined);
                        const materialPath = geometry.properties.getString('materialPath');
                        if (materialPath) {
                            mesh.properties.setString('materialPath', materialPath);
                        }
                        newModel.push(mesh);
                        this.addChild(mesh);
                        this.meshes.add(mesh);
                        mesh.setGeometry(geometry);
                    }
                    newBodyPart.push(newModel);
                }
            }
            this.bodyParts[bodyPartName] = newBodyPart;
        }
        this.#refreshMeshesVisibility();
        this.#initDefaultBodyGroups();
    }
    #initSkeleton() {
        const bones = this.sourceModel.getBones();
        if (bones) {
            const bonesName = bones.getValueAsStringArray('m_boneName');
            const bonePosParent = bones.getValueAsVectorArray('m_bonePosParent');
            const boneRotParent = bones.getValueAsVectorArray('m_boneRotParent');
            const boneParent = bones.getValueAsBigintArray('m_nParent') ?? bones.getValueAsNumberArray('m_nParent');
            if (bonesName && bonePosParent && boneRotParent && boneParent && this.#skeleton) {
                for (const [modelBoneIndex, boneName] of bonesName.entries()) {
                    const bone = this.#skeleton.addBone(modelBoneIndex, boneName);
                    //bone.name = boneName;
                    bone.quaternion = boneRotParent[modelBoneIndex];
                    bone.position = bonePosParent[modelBoneIndex];
                    bone.refQuaternion = boneRotParent[modelBoneIndex];
                    bone.refPosition = bonePosParent[modelBoneIndex];
                    //const poseToBone = mat4.fromRotationTranslation(mat4.create(), bone.refQuaternion, bone.refPosition);//TODO: optimize
                    //mat4.invert(poseToBone, poseToBone);
                    const parentIndex = Number(boneParent[modelBoneIndex]);
                    const parentName = bonesName[parentIndex];
                    if (parentName) {
                        //bone.parent = this.#skeleton.getBoneByName(bonesName[parent]);
                        const parentBone = this.#skeleton.getBoneByName(parentName);
                        if (parentBone) {
                            parentBone.addChild(bone);
                            bone.getTotalRefQuaternion(initSkeletonTempQuat);
                            quat.normalize(initSkeletonTempQuat, initSkeletonTempQuat);
                            const poseToBone = mat4.fromRotationTranslation(mat4.create(), initSkeletonTempQuat, bone.getTotalRefPosition(initSkeletonTempVec3));
                            mat4.invert(poseToBone, poseToBone);
                            bone.poseToBone = poseToBone;
                        }
                    }
                    else {
                        this.#skeleton.addChild(bone);
                        const poseToBone = mat4.fromRotationTranslation(mat4.create(), bone.refQuaternion, bone.refPosition); //TODO: optimize
                        mat4.invert(poseToBone, poseToBone);
                        bone.poseToBone = poseToBone;
                    }
                }
            }
            else {
                console.error('source2 #initSkeleton check code');
            }
        }
    }
    #initAttachments() {
        const attachments = new Group({ name: 'Attachments' });
        this.addChild(attachments);
        for (const attachment of this.sourceModel.attachments.values()) {
            const attachmentInstance = new Source2ModelAttachmentInstance(this, attachment);
            this.attachments.set(attachment.name, attachmentInstance);
            attachments.addChild(attachmentInstance);
        }
    }
    getAnimations() {
        return this.sourceModel.getAnimations();
    }
    buildContextMenu() {
        const skins = this.sourceModel.getSkinList();
        const skinMenu = [];
        for (const [skinId, skin] of skins.entries()) {
            const item = {};
            item.name = skin;
            item.f = () => this.skin = skinId;
            skinMenu.push(item);
        }
        return Object.assign(super.buildContextMenu(), {
            Source2ModelInstance_1: null,
            skin: { i18n: '#skin', submenu: skinMenu },
            animation: { i18n: '#animation', f: async (entity) => { const animation = await new Interaction().getString(0, 0, await entity.sourceModel.getAnimations()); if (animation) {
                    entity.playAnimation(animation);
                } } },
            Source2ModelInstance_2: null,
            animate: { i18n: '#animate', selected: this.animationSpeed != 0.0, f: () => this.animationSpeed == 0 ? this.animationSpeed = 1 : this.animationSpeed = 0 },
            frame: { i18n: '#frame', f: () => { const frame = prompt('Frame', String(this.mainAnimFrame)); if (frame) {
                    this.animationSpeed = 0;
                    this.mainAnimFrame = Number(frame);
                } } },
        });
    }
    getParentModel() {
        return this;
    }
    getRandomPointOnModel(vec, initialVec, bones) {
        const meshes = this.meshes;
        for (const mesh of meshes) {
            mesh.getRandomPointOnModel(vec, initialVec, bones);
            return vec;
        }
        return vec;
    }
    getAttachment(name) {
        return this.attachments.get(name.toLowerCase());
    }
    static set animSpeed(speed) {
        const s = Number(speed);
        animSpeed = Number.isNaN(s) ? 1 : s;
    }
    dispose() {
        super.dispose();
        this.#skeleton?.dispose();
        for (const material of this.#materialsUsed) {
            material.removeUser(this);
        }
        for (const mesh of this.meshes) {
            mesh.dispose();
        }
    }
    static getEntityName() {
        return 'Source 2 model';
    }
}

class Source2Model {
    #internalAnimGroup;
    #includeModels = [];
    repository;
    vmdl;
    requiredLod = 0;
    drawBodyPart = {};
    currentSkin = 0;
    currentSheen = null;
    animLayers = [];
    animGroups = new Set();
    materialRepository = null;
    dirty = true;
    geometries = new Set();
    bodyParts = new Map();
    attachments = new Map();
    #seqGroup;
    bodyGroups = new Set();
    bodyGroupsChoices = new Set();
    constructor(repository, vmdl) {
        this.repository = repository;
        this.vmdl = vmdl;
        this.#loadInternalAnimGroup();
        this.#createAnimGroup();
        this.#createBodyGroups();
    }
    #createAnimGroup() {
        const aseq = this.vmdl.getBlockByType('ASEQ');
        if (aseq && this.#internalAnimGroup) {
            this.#seqGroup = new Source2SeqGroup(this.#internalAnimGroup);
            this.#seqGroup.setFile(this.vmdl);
        }
    }
    #createBodyGroups() {
        const meshGroups = this.vmdl.getBlockStructAsArray('DATA', 'm_meshGroups');
        if (meshGroups) {
            let bodyGroupId = 0;
            let bodyGroup;
            for (const choice of meshGroups) {
                if (choice == SOURCE2_DEFAULT_BODY_GROUP) {
                    bodyGroup = choice;
                }
                else {
                    const result = /(.*)_@\d(_#&(.*))?$/.exec(choice);
                    bodyGroup = result?.[1];
                }
                if (bodyGroup) {
                    this.bodyGroups.add(bodyGroup);
                    this.bodyGroupsChoices.add({ choice: choice, bodyGroup: bodyGroup, bodyGroupId: bodyGroupId });
                }
                bodyGroupId++;
            }
        }
    }
    matchActivity(activity, modifiers) {
        if (this.#seqGroup) {
            return this.#seqGroup.matchActivity(activity, modifiers);
        }
        return null;
    }
    addGeometry(geometry, bodyPartName, bodyPartModelId) {
        if (bodyPartName !== undefined) {
            let bodyPart = this.bodyParts.get(bodyPartName);
            if (bodyPart === undefined) {
                bodyPart = [];
                this.bodyParts.set(bodyPartName, bodyPart);
            }
            if (bodyPartModelId !== undefined) {
                let meshes = bodyPart[bodyPartModelId];
                if (meshes === undefined) {
                    meshes = [];
                    bodyPart[bodyPartModelId] = meshes;
                }
                meshes.push(geometry);
            }
        }
        this.geometries.add(geometry);
    }
    createInstance(isDynamic) {
        return new Source2ModelInstance(this, isDynamic);
    }
    getBones() {
        const skeleton = this.vmdl.getBlockStructAsElement('DATA', 'm_modelSkeleton'); //this.vmdl.getPermModelData('m_modelSkeleton');
        if (skeleton) {
            return skeleton;
        }
        return null;
    }
    /*
    getAttachments() {
        if (this.mdl) {
            return this.mdl.getAttachments();
        }
        return null;
    }

    getBone(boneIndex) {
        if (this.mdl) {
            return this.mdl.getBone(boneIndex);
        }
        return null;
    }

    getAttachmentById(attachmentIndex) {
        if (this.mdl) {
            return this.mdl.getAttachmentById(attachmentIndex);
        }
        return null;
    }

    getBoneByName(boneName) {
        if (this.mdl) {
            return this.mdl.getBoneByName(boneName);
        }
        return null;
    }

    getAttachment(attachmentName) {
        if (this.mdl) {
            return this.mdl.getAttachment(attachmentName);
        }
        return null;
    }

    getBodyPart(bodyPartId) {
        if (this.mdl) {
            return this.mdl.getBodyPart(bodyPartId);
        }
        return null;
    }

    getBodyParts() {
        if (this.mdl) {
            return this.mdl.getBodyParts();
        }
        return null;
    }
*/
    getSkinMaterials(skin) {
        const materialGroups = this.vmdl.getBlockStructAsElementArray('DATA', 'm_materialGroups');
        if (materialGroups) {
            const materials = materialGroups[skin];
            if (materials) {
                return materials.getValueAsResourceArray('m_materials');
            }
        }
        return null;
    }
    getSkinList() {
        const skinList = [];
        const materialGroups = this.vmdl.getBlockStructAsElementArray('DATA', 'm_materialGroups');
        if (materialGroups) {
            for (const materialGroup of materialGroups) {
                const skin = materialGroup.getSubValueAsString('m_name');
                if (skin !== null) {
                    skinList.push(skin);
                }
            }
        }
        return skinList;
    }
    async loadAnimGroups() {
        if (this.vmdl) {
            const m_refAnimGroups = this.vmdl.getBlockStructAsArray('DATA', 'm_refAnimGroups');
            if (m_refAnimGroups) {
                for (const meshName of m_refAnimGroups) {
                    // TODO: not tested: find a test case
                    const animGroup = await AnimManager.getAnimGroup(this, this.repository, meshName);
                    this.animGroups.add(animGroup);
                }
            }
        }
    }
    #loadInternalAnimGroup() {
        //TODOv3: make a common code where external and internal group are loaded
        if (this.vmdl) {
            const sourceFile = this.vmdl;
            const localAnimArray = sourceFile.getBlockStructAsResourceArray('AGRP', 'm_localHAnimArray');
            const decodeKey = sourceFile.getBlockStruct('AGRP', 'm_decodeKey');
            if (localAnimArray && decodeKey?.isKv3Element) {
                const animGroup = new Source2AnimGroup(this, this.repository);
                animGroup.setFile(this.vmdl);
                animGroup.setAnimationGroupResourceData(localAnimArray, decodeKey);
                this.#internalAnimGroup = animGroup;
                const anims = sourceFile.getBlockKeyValues('ANIM');
                if (anims) {
                    const loadedAnim = new Source2Animation(animGroup);
                    loadedAnim.setAnimDatas(anims);
                    animGroup._changemyname = animGroup._changemyname || [];
                    animGroup._changemyname.push(loadedAnim);
                }
                this.animGroups.add(animGroup);
            }
        }
    }
    getIncludeModels() {
        /*
        if (!this.vmdl) {
            return [];
        }
            */
        return this.vmdl.getBlockStructAsArray('DATA', 'm_refAnimIncludeModels') ?? [];
        //return refAnimIncludeModels ?? [];
    }
    addIncludeModel(includeModel) {
        this.#includeModels.push(includeModel);
    }
    getAnim(activityName, activityModifiers) {
        const animations = this.getAnimationsByActivity(activityName);
        for (const model of this.#includeModels) {
            model.getAnimationsByActivity(activityName, animations);
        }
        return animations.getBestAnimation(activityName, activityModifiers);
        /*
        let bestMatch = animations.getAnimation(activityName);
        let bestScore = bestMatch ? 0 : -1;
        animations.getAnimation(activityName);
        for (const animDesc of animations.getAnimations()) {

            /*if (animDesc.matchModifiers(activityName, activityModifiers)) {
                return animDesc;
            }* /
            const score = animDesc.matchModifiers(activityName, activityModifiers);
            if (score > bestScore) {
                bestMatch = animDesc;
                bestScore = score;
            }
        }
        return bestMatch;
        */
        // Fallback to no modifier
        /*for (let animDesc of animations) {
            if (animDesc.matchModifiers(activityName)) {
                return animDesc;
            }
        }*/
    }
    getAnimation(name) {
        let animation;
        animation = this.#seqGroup?.getAnimDesc(name);
        if (animation) {
            return animation;
        }
        for (const animGroup of this.animGroups) {
            animation = animGroup?.getAnimDesc(name);
            if (animation) {
                return animation;
            }
        }
        return null;
    }
    getAnimationsByActivity(activityName, animations = new Source2Animations()) {
        const anims = [];
        if (this.#seqGroup) {
            anims.push(...this.#seqGroup.getAnimationsByActivity(activityName));
        }
        for (const animGroup of this.animGroups) {
            anims.push(...animGroup.getAnimationsByActivity(activityName));
        }
        animations.addAnimations(anims);
        return animations;
    }
    async getAnimations() {
        const animations = new Set();
        for (const animGroup of this.animGroups) {
            if (animGroup.localAnimArray) {
                for (let localAnimIndex = 0; localAnimIndex < animGroup.localAnimArray.length; localAnimIndex++) {
                    const animRemoveMe = await animGroup.getAnim(localAnimIndex);
                    if (animRemoveMe) {
                        animRemoveMe.getAnimations(animations);
                    }
                }
            }
            if (animGroup._changemyname) {
                for (let animResIndex = 0; animResIndex < animGroup._changemyname.length; animResIndex++) {
                    const animRemoveMe = animGroup._changemyname[animResIndex];
                    if (animRemoveMe) {
                        animRemoveMe.getAnimations(animations);
                    }
                }
            }
        }
        return animations;
    }
    _addAttachments(attachments) {
        for (const attachment of attachments) {
            //throw 'fix attachments type';
            const attachmentValue = attachment.getValueAsElement('value'); //TODO: use property 'key'
            if (attachmentValue) {
                const name = attachmentValue.getValueAsString('m_name')?.toLowerCase();
                if (!name) {
                    continue;
                }
                const source2ModelAttachment = new Source2ModelAttachment(name);
                this.attachments.set(name, source2ModelAttachment);
                source2ModelAttachment.ignoreRotation = attachmentValue.getValueAsBool('m_bIgnoreRotation') ?? false /*TODO: check default value*/;
                const influencesCount = attachmentValue.getValueAsNumber('m_nInfluences');
                if (influencesCount) {
                    const influenceNames = attachmentValue.getValueAsStringArray('m_influenceNames');
                    const influenceWeights = attachmentValue.getValueAsNumberArray('m_influenceWeights');
                    const influenceOffsets = attachmentValue.getValueAsVectorArray('m_vInfluenceOffsets');
                    const influenceRotations = attachmentValue.getValueAsVectorArray('m_vInfluenceRotations');
                    if (influenceNames && influenceWeights && influenceOffsets && influenceRotations) {
                        for (let influenceIndex = 0; influenceIndex < influencesCount; ++influenceIndex) {
                            const influenceName = influenceNames[influenceIndex];
                            const influenceWeight = influenceWeights[influenceIndex];
                            const influenceOffset = influenceOffsets[influenceIndex];
                            const influenceRotation = influenceRotations[influenceIndex];
                            if (influenceName) {
                                source2ModelAttachment.influenceNames.push(influenceName.toLowerCase());
                                source2ModelAttachment.influenceWeights.push(influenceWeight);
                                source2ModelAttachment.influenceOffsets.push(vec3.clone(influenceOffset));
                                source2ModelAttachment.influenceRotations.push(quat.clone(influenceRotation));
                            }
                        }
                    }
                }
            }
        }
    }
    getAnimationByName(animName) {
        //return this.#internalAnimGroup?.getAnimationByName(animName);
        for (const animGroup of this.animGroups) {
            const anim = animGroup.getAnimationByName(animName);
            if (anim) {
                return anim;
            }
        }
    }
}

var _a$3;
const defaultMaterial$1 = new MeshBasicMaterial();
class Source2ModelLoader {
    static #loadPromisesPerRepo = {}; //TODO: create map
    static {
        defaultMaterial$1.addUser(_a$3);
    }
    async load(repository, path) {
        // Cleanup filename
        path = path.replace(/\.vmdl_c$/, '').replace(/\.vmdl$/, '');
        let repoPromises = _a$3.#loadPromisesPerRepo[repository];
        if (!repoPromises) {
            repoPromises = {};
            _a$3.#loadPromisesPerRepo[repository] = repoPromises;
        }
        let promise = repoPromises[path];
        if (promise) {
            return promise;
        }
        promise = new Promise(resolve => {
            const vmdlPromise = new Source2FileLoader().load(repository, path + '.vmdl_c');
            vmdlPromise.then(async (source2File) => {
                if (!source2File) {
                    resolve(null);
                    return;
                }
                const newSourceModel = new Source2Model(repository, source2File);
                this.#loadIncludeModels(newSourceModel);
                await this.testProcess2(source2File, newSourceModel, repository);
                newSourceModel.loadAnimGroups();
                resolve(newSourceModel);
            });
            return;
        });
        repoPromises[path] = promise;
        return promise;
    }
    async testProcess2 /*TODO: rename*/(vmdl, model, repository) {
        const group = new Entity();
        const ctrlRoot = vmdl.getBlockKeyValues('CTRL');
        const m_refLODGroupMasks = vmdl.getBlockStructAsBigintArray('DATA', 'm_refLODGroupMasks') ?? vmdl.getBlockStructAsNumberArray('DATA', 'm_refLODGroupMasks'); // ?? vmdl.getBlockStruct('DATA.keyValue.root.m_refLODGroupMasks');
        const m_refMeshGroupMasks = vmdl.getBlockStructAsNumberArray('DATA', 'm_refMeshGroupMasks'); // ?? vmdl.getBlockStruct('DATA.keyValue.root.m_refMeshGroupMasks');
        const embeddedMeshes = ctrlRoot?.getValueAsElementArray('embedded_meshes');
        if (ctrlRoot && m_refLODGroupMasks && embeddedMeshes) {
            for (const [meshIndex, embeddedMesh] of embeddedMeshes.entries()) {
                const vbibBlockId = embeddedMesh.getValueAsNumber('vbib_block');
                if (vbibBlockId != null) { //TODO: use  m_nVBIBBlock ?
                    this.#loadEmbeddedMeshesFromVbib(vmdl, model, repository, group, meshIndex, m_refLODGroupMasks, m_refMeshGroupMasks, embeddedMesh);
                }
                else {
                    this.#loadEmbeddedMeshesFromVtxIdx(vmdl, model, repository, group, meshIndex, m_refLODGroupMasks, m_refMeshGroupMasks, embeddedMesh);
                }
            }
        }
        await this.#loadExternalMeshes(group, vmdl, model, repository);
        return group;
    }
    #loadEmbeddedMeshesFromVbib(vmdl, model, repository, group, meshIndex, m_refLODGroupMasks, m_refMeshGroupMasks, embeddedMesh) {
        const lodGroupMask = Number(m_refLODGroupMasks[meshIndex]);
        const meshGroupMask = m_refMeshGroupMasks?.[meshIndex];
        //const embeddedMesh = embeddedMeshes[meshIndex]!;
        const dataBlockId = embeddedMesh.getValueAsNumber('data_block');
        const vbibBlockId = embeddedMesh.getValueAsNumber('vbib_block') ?? embeddedMesh.getValueAsNumber('m_nVBIBBlock');
        if (dataBlockId === null || vbibBlockId === null) {
            console.error('missing dataBlockId / vbibBlockId', embeddedMesh);
            return;
        }
        const dataBlock = vmdl.getBlockById(dataBlockId);
        const vbibBlock = vmdl.getBlockById(vbibBlockId);
        if (dataBlock === null || vbibBlock === null) {
            console.error('missing dataBlock / vbibBlock', embeddedMesh, dataBlockId, vbibBlockId, vmdl);
            return;
        }
        this.#loadMesh(repository, embeddedMesh.getValueAsString('name') ?? '', model, group, dataBlock, vbibBlock, lodGroupMask, vmdl, meshIndex, meshGroupMask);
        /*data_block: 1
        mesh_index: 0
        morph_block: 0
        morph_texture: "models/heroes/antimage_female/antimage_female/antimage_female_base_vmorf.vtex"
        name: "antimage_female_base"
        vbib_block: 2*/
    }
    #loadEmbeddedMeshesFromVtxIdx(vmdl, model, repository, group, meshIndex, m_refLODGroupMasks, m_refMeshGroupMasks, embeddedMesh) {
        const dataBlockId = embeddedMesh.getValueAsNumber('m_nDataBlock') ?? -1;
        if (dataBlockId < 0) {
            return;
        }
        const dataBlock = vmdl.getBlockById(dataBlockId);
        if (!dataBlock) {
            return;
        }
        //const vbibBlockId = embeddedMesh.getValueAsNumber('m_nVBIBBlock');
        const lodGroupMask = Number(m_refLODGroupMasks[meshIndex]);
        const meshGroupMask = m_refMeshGroupMasks?.[meshIndex];
        //vmdl.vertices = [];
        //vmdl.indices = [];
        // Load vertex buffers
        vmdl.vertices.set(meshIndex, []);
        vmdl.indices.set(meshIndex, []);
        this.#loadBuffer('m_vertexBuffers', vmdl, meshIndex, embeddedMesh, true);
        this.#loadBuffer('m_indexBuffers', vmdl, meshIndex, embeddedMesh, false);
        this.#loadMesh(repository, embeddedMesh.getValueAsString('m_Name') ?? '', model, group, dataBlock, new Source2FileBlock(vmdl, -1 /*TODO: fix that*/, 'VBIB', new BinaryReader(''), 0, 0) /*TODO: remove*/, lodGroupMask, vmdl, meshIndex, meshGroupMask);
        //console.error(vertexBuffers);
    }
    #loadBuffer(bufferName, vmdl, meshIndex, embeddedMesh, isVertex) {
        const buffers = embeddedMesh.getValueAsElementArray(bufferName);
        if (!buffers) {
            return;
        }
        for (const buffer of buffers) {
            const blockIndex = buffer.getValueAsNumber('m_nBlockIndex') ?? -1;
            if (blockIndex < 0) {
                continue;
            }
            const sourceBlock = vmdl.blocksArray[blockIndex];
            if (!sourceBlock) {
                continue;
            }
            const elementCount = buffer.getValueAsNumber('m_nElementCount') ?? 0;
            const elementSizeInBytes = buffer.getValueAsNumber('m_nElementSizeInBytes') ?? 0;
            const inputLayoutFields = buffer.getValueAsElementArray('m_inputLayoutFields') ?? [];
            const meshoptCompressed = buffer.getValueAsBool('m_bMeshoptCompressed');
            // TODO: also use m_bCompressedZSTD
            const fieldsCount = inputLayoutFields.length;
            const fields = [];
            for (const inputLayoutField of inputLayoutFields) {
                //const semanticIndex = inputLayoutField.getValueAsNumber('m_nSemanticIndex') ?? 0;
                const semanticName = inputLayoutField.getValueAsString('m_pSemanticName') ?? '';
                const format = inputLayoutField.getValueAsNumber('m_Format') ?? 0;
                const offset = inputLayoutField.getValueAsNumber('m_nOffset') ?? 0;
                const slot = inputLayoutField.getValueAsNumber('m_nSlot') ?? 0;
                const slotType = inputLayoutField.getValueAsString('m_nSlotType') ?? ''; /*TODO: create enum*/
                fields.push({ name: semanticName, format: format, offset: offset, slot: slot, slotType: slotType });
            }
            let reader = sourceBlock.reader;
            if (meshoptCompressed) {
                const decompressBuffer = new Uint8Array(new ArrayBuffer(elementCount * elementSizeInBytes));
                if (isVertex) {
                    MeshoptDecoder.decodeVertexBuffer(decompressBuffer, elementCount, elementSizeInBytes, new Uint8Array(sourceBlock.reader.buffer.slice(sourceBlock.offset, sourceBlock.offset + sourceBlock.length)));
                }
                else {
                    MeshoptDecoder.decodeIndexBuffer(decompressBuffer, elementCount, elementSizeInBytes, new Uint8Array(sourceBlock.reader.buffer.slice(sourceBlock.offset, sourceBlock.offset + sourceBlock.length)));
                }
                reader = new BinaryReader(decompressBuffer);
            }
            const s1 /*TODO: fix typer*/ = { vertexCount: elementCount };
            s1.vertices = new ArrayBuffer(elementCount * BYTES_PER_VERTEX_POSITION);
            s1.normals = new ArrayBuffer(elementCount * BYTES_PER_VERTEX_NORMAL);
            s1.tangents = new ArrayBuffer(elementCount * BYTES_PER_VERTEX_TANGENT);
            s1.coords = new ArrayBuffer(elementCount * BYTES_PER_VERTEX_COORD);
            s1.boneIndices = new ArrayBuffer(elementCount * BYTES_PER_VERTEX_BONE_INDICE);
            s1.boneWeight = new ArrayBuffer(elementCount * BYTES_PER_VERTEX_BONE_WEIGHT);
            //TODO: optimize, we only need either s1 or s2
            const s2 /*TODO: fix typer*/ = { bytesPerIndex: 4 /*elementSizeInBytes*/ /*TODO: fix that: loadMesh only accept uint32*/ };
            s2.indexCount = elementCount;
            //s2.bytesPerIndex = reader.getInt32();
            //s2.headerOffset = reader.tell() + reader.getInt32();
            //s2.headerCount = reader.getInt32();
            //s2.dataOffset = reader.tell() + reader.getInt32();
            //s2.dataLength = reader.getInt32();
            const s1Vertices = new Float32Array(s1.vertices);
            const s1Normals = new Float32Array(s1.normals);
            const s1Tangents = new Float32Array(s1.tangents);
            const s1Coords = new Float32Array(s1.coords);
            const s1BoneIndices = new Float32Array(s1.boneIndices);
            const s1BoneWeight = new Float32Array(s1.boneWeight);
            s2.indices = new ArrayBuffer(s2.indexCount * s2.bytesPerIndex);
            const s2Indices = s2.bytesPerIndex == 4 ? new Uint32Array(s2.indices) : new Uint16Array(s2.indices);
            for (let elementIndex = 0; elementIndex < elementCount; elementIndex++) {
                const startOffset = elementIndex * elementSizeInBytes;
                if (isVertex) {
                    let tempValue;
                    let positionFilled = false; //TODOv3: remove this
                    let normalFilled = false;
                    let tangentFilled = false;
                    let texCoordFilled = false;
                    let blendIndicesFilled = false;
                    let blendWeightFilled = false;
                    for (let fieldIndex = 0; fieldIndex < fieldsCount; fieldIndex++) {
                        const field = fields[fieldIndex];
                        sourceBlock.reader.seek(startOffset + field.offset);
                        switch (field.format) {
                            case DXGI_FORMAT_R32G32B32A32_FLOAT:
                                tempValue = vec4.create(); //TODO: optimize
                                tempValue[0] = reader.getFloat32();
                                tempValue[1] = reader.getFloat32();
                                tempValue[2] = reader.getFloat32();
                                tempValue[3] = reader.getFloat32();
                                break;
                            case DXGI_FORMAT_R32G32B32_FLOAT: // 3 * float32
                                tempValue = vec3.create(); //TODO: optimize
                                tempValue[0] = reader.getFloat32();
                                tempValue[1] = reader.getFloat32();
                                tempValue[2] = reader.getFloat32();
                                break;
                            case DXGI_FORMAT_R16G16B16A16_SINT:
                                tempValue = vec4.create(); //TODO: optimize
                                tempValue[0] = reader.getInt16();
                                tempValue[1] = reader.getInt16();
                                tempValue[2] = reader.getInt16();
                                tempValue[3] = reader.getInt16();
                                break;
                            case DXGI_FORMAT_R32G32_FLOAT: // 2 * float32
                                tempValue = vec2.create(); //TODO: optimize
                                tempValue[0] = reader.getFloat32();
                                tempValue[1] = reader.getFloat32();
                                break;
                            case DXGI_FORMAT_R8G8B8A8_UNORM:
                                tempValue = vec4.create(); //TODO: optimize
                                tempValue[0] = reader.getUint8() / 255;
                                tempValue[1] = reader.getUint8() / 255;
                                tempValue[2] = reader.getUint8() / 255;
                                tempValue[3] = reader.getUint8() / 255;
                                //reader.getUint8();
                                break;
                            case DXGI_FORMAT_R8G8B8A8_UINT: // 4 * uint8
                                tempValue = vec4.create(); //TODO: optimize
                                tempValue[0] = reader.getUint8();
                                tempValue[1] = reader.getUint8();
                                tempValue[2] = reader.getUint8();
                                tempValue[3] = reader.getUint8();
                                break;
                            case DXGI_FORMAT_R16G16_FLOAT: // 2 * float16
                                tempValue = vec2.create(); //TODO: optimize
                                tempValue[0] = reader.getFloat16();
                                tempValue[1] = reader.getFloat16();
                                break;
                            case DXGI_FORMAT_R16G16_SNORM: //New with battlepass 2022
                                tempValue = vec2.create(); //TODO: optimize
                                tempValue[0] = sNormUint16(reader.getInt16());
                                tempValue[1] = sNormUint16(reader.getInt16());
                                break;
                            case DXGI_FORMAT_R16G16_SINT:
                                tempValue = vec2.create(); //TODO: optimize
                                tempValue[0] = reader.getInt16();
                                tempValue[1] = reader.getInt16();
                                break;
                            case DXGI_FORMAT_R32_FLOAT: // single float32 ??? new in half-life Alyx
                                tempValue = [];
                                tempValue[0] = reader.getFloat32();
                                break;
                            case DXGI_FORMAT_R32_UINT: // single uint32 ??? new since DOTA2 2023_08_30
                                tempValue = [];
                                tempValue[0] = reader.getUint32();
                                s1.decompressTangentV2 = true;
                                break;
                            default:
                                //TODO add types when needed. see DxgiFormat.js
                                console.error('Warning: unknown type ' + field.format + ' for value ' + field.name);
                                tempValue = vec4.create(); //TODO: optimize
                                tempValue[0] = 0;
                                tempValue[1] = 0;
                                tempValue[2] = 0;
                                tempValue[3] = 0;
                        }
                        switch (field.name) {
                            case 'POSITION':
                                s1Vertices.set(tempValue, elementIndex * VERTEX_POSITION_LEN);
                                positionFilled = true;
                                break;
                            case 'NORMAL':
                                s1Normals.set(tempValue, elementIndex * VERTEX_NORMAL_LEN); //TODOv3
                                normalFilled = true;
                                break;
                            case 'TANGENT':
                                s1Tangents.set(tempValue, elementIndex * VERTEX_TANGENT_LEN); //TODOv3
                                tangentFilled = true;
                                break;
                            case 'TEXCOORD':
                                if (!texCoordFilled) { //TODO: handle 2 TEXCOORD
                                    const test = vec2.clone(tempValue); //todov3: fixme see //./Alyx/models/props_industrial/hideout_doorway.vmdl_c
                                    s1Coords.set(test /*tempValue*/, elementIndex * VERTEX_COORD_LEN);
                                    texCoordFilled = true;
                                }
                                break;
                            case 'BLENDINDICES':
                                /*s1.boneIndices.push(tempValue[0]);
                                s1.boneIndices.push(tempValue[1]);
                                s1.boneIndices.push(tempValue[2]);
                                s1.boneIndices.push(tempValue[3]);*/
                                s1BoneIndices.set(tempValue, elementIndex * VERTEX_BONE_INDICE_LEN);
                                blendIndicesFilled = true;
                                break;
                            case 'BLENDWEIGHT':
                                /*s1.boneWeight.push(tempValue[0]);
                                s1.boneWeight.push(tempValue[1]);
                                s1.boneWeight.push(tempValue[2]);
                                s1.boneWeight.push(tempValue[3]);*/
                                //vec4.scale(tempValue, tempValue, 1 / 255.0);
                                s1BoneWeight.set(tempValue, elementIndex * VERTEX_BONE_WEIGHT_LEN);
                                blendWeightFilled = true;
                                break;
                            //TODOv3: add "texcoord" lowercase maybe a z- tex coord ?
                        }
                    }
                    if (!positionFilled) {
                        /*s1.vertices.push(0);
                        s1.vertices.push(0);
                        s1.vertices.push(0);*/
                        s1Vertices.set(defaultValuesPosition, elementIndex * VERTEX_POSITION_LEN);
                    }
                    if (!normalFilled) {
                        /*s1.normals.push(0);
                        s1.normals.push(0);
                        s1.normals.push(0);*/
                        s1Normals.set(defaultValuesNormal, elementIndex * VERTEX_NORMAL_LEN);
                    }
                    if (!tangentFilled) {
                        s1Tangents.set(defaultValuesTangent, elementIndex * VERTEX_TANGENT_LEN);
                    }
                    if (!texCoordFilled) {
                        /*s1.coords.push(0);
                        s1.coords.push(0);*/
                        s1Coords.set(defaultValuesCoord, elementIndex * VERTEX_COORD_LEN);
                    }
                    if (!blendIndicesFilled) {
                        /*s1.boneIndices.push(0);
                        s1.boneIndices.push(0);
                        s1.boneIndices.push(0);
                        s1.boneIndices.push(0);*/
                        s1BoneIndices.set(defaultValuesBoneIndice, elementIndex * VERTEX_BONE_INDICE_LEN);
                    }
                    if (!blendWeightFilled) {
                        /*s1.boneWeight.push(255);
                        s1.boneWeight.push(0);
                        s1.boneWeight.push(0);
                        s1.boneWeight.push(0);*/
                        s1BoneWeight.set(defaultValuesBoneWeight, elementIndex * VERTEX_BONE_WEIGHT_LEN);
                    }
                }
                else {
                    sourceBlock.reader.seek(startOffset);
                    //s2.indices.push(indexReader.getUint16());
                    if (elementSizeInBytes == 2) {
                        s2Indices[elementIndex] = reader.getUint16();
                    }
                    else {
                        s2Indices[elementIndex] = reader.getUint32();
                    }
                }
            }
            if (isVertex) {
                vmdl.vertices.get(meshIndex).push(s1);
            }
            else {
                vmdl.indices.get(meshIndex).push(s2);
            }
        }
    }
    #loadMesh(repository, name, model, group, dataBlock, vbibBlock, lodGroupMask, vmdl, meshIndex, meshGroupMask) {
        // TODO: remove vbibBlock
        const remappingTable = vmdl.getRemappingTable(meshIndex);
        const attachments = dataBlock.getKeyValueAsElementArray('m_attachments');
        if (attachments) {
            model._addAttachments(attachments);
        }
        const drawCalls = dataBlock.getKeyValueAsElementArray('m_sceneObjects.0.m_drawCalls'); // ?? dataBlock.getKeyValue('root.m_drawCalls');
        if (drawCalls) {
            // TODO: use m_nPrimitiveType
            for (const drawCall of drawCalls) { //TODOv3: mutualize buffer if used by multiple drawcalls
                //const drawCall = drawCalls[drawCallIndex];
                const useCompressedNormalTangent = drawCall.getValueAsBool('m_bUseCompressedNormalTangent'); //drawCall.m_nFlags?.includes('MESH_DRAW_FLAGS_USE_COMPRESSED_NORMAL_TANGENT');
                //console.assert(useCompressedNormalTangent !== null, 'missing m_bUseCompressedNormalTangent', drawCall);
                const vertexBuffers = drawCall.getValueAsElementArray('m_vertexBuffers')?.[0]; //TODOv3 why 0 ?
                if (!vertexBuffers) {
                    continue;
                }
                const indexBuffer = drawCall.getValueAsElement('m_indexBuffer');
                if (!indexBuffer) {
                    continue;
                }
                const bufferIndex = indexBuffer.getValueAsNumber('m_hBuffer');
                const startIndex = drawCall.getValueAsNumber('m_nStartIndex');
                const indexCount = drawCall.getValueAsNumber('m_nIndexCount');
                if (bufferIndex === null || startIndex === null || indexCount === null) {
                    console.error('missing vertexBuffers in loadMesh', vertexBuffers, bufferIndex, startIndex, indexCount);
                    continue;
                }
                const indices = new Uint32BufferAttribute(vbibBlock.getIndices(meshIndex, bufferIndex), 1, startIndex * 4, indexCount); //NOTE: number is here to convert bigint TODO: see if we can do better
                const vertexPosition = new Float32BufferAttribute(vbibBlock.getVertices(meshIndex, bufferIndex), 3);
                let vertexNormal, vertexTangent;
                if (useCompressedNormalTangent) {
                    const [normal, tangent] = vbibBlock.getNormalsTangents(meshIndex, bufferIndex);
                    vertexNormal = new Float32BufferAttribute(normal, 3);
                    vertexTangent = new Float32BufferAttribute(tangent, 4);
                }
                else {
                    vertexNormal = new Float32BufferAttribute(vbibBlock.getNormal(meshIndex, bufferIndex), 4);
                    vertexTangent = new Float32BufferAttribute(vbibBlock.getTangent(meshIndex, bufferIndex), 4);
                }
                const textureCoord = new Float32BufferAttribute(vbibBlock.getCoords(meshIndex, bufferIndex), 2);
                const vertexWeights = new Float32BufferAttribute(vbibBlock.getBoneWeight(meshIndex, bufferIndex), 4);
                const vertexBones = new Float32BufferAttribute(vmdl.remapBuffer(vbibBlock.getBoneIndices(meshIndex, bufferIndex), remappingTable), 4);
                const geometry = new BufferGeometry();
                geometry.properties.setNumber('lodGroupMask', lodGroupMask);
                geometry.properties.setBigint('mesh_group_mask', BigInt(meshGroupMask ?? 0xffffffffffffffffn));
                geometry.setIndex(indices);
                geometry.setAttribute('aVertexPosition', vertexPosition);
                geometry.setAttribute('aVertexNormal', vertexNormal);
                geometry.setAttribute('aVertexTangent', vertexTangent);
                geometry.setAttribute('aTextureCoord', textureCoord);
                geometry.setAttribute('aBoneWeight', vertexWeights);
                geometry.setAttribute('aBoneIndices', vertexBones);
                geometry.count = indexCount; //Number(drawCall.m_nIndexCount);//NOTE: number is here to convert bigint TODO: see if we can do better
                const bones = dataBlock.getKeyValueAsElementArray('m_skeleton.m_bones');
                if (bones) {
                    geometry.properties.set('bones', new Property(PropertyType.Array, bones));
                }
                else {
                    console.error('unable to find m_skeleton.m_bones in DATA block', dataBlock);
                }
                const material = defaultMaterial$1;
                const staticMesh = new Mesh({ geometry: geometry, material: material });
                group.addChild(staticMesh);
                const materialPath = drawCall.getValueAsResource('m_material');
                if (materialPath !== null) {
                    geometry.properties.setString('materialPath', materialPath);
                    Source2MaterialManager.getMaterial(repository, materialPath).then(material => {
                        if (material) {
                            staticMesh.setMaterial(material);
                        }
                        else {
                            console.error('unable to find material ' + materialPath);
                        }
                    });
                    model.addGeometry(geometry, name, 0 /*TODOv3*/);
                }
                else {
                    console.error('missing property m_material in draw call', drawCall);
                }
                //const materialPath = geometry.properties.getString('materialPath');
            }
        }
    }
    async #loadExternalMeshes(group, vmdl, model, repository) {
        const callback = (mesh, lodGroupMask, meshIndex, meshGroupMask) => {
            //TODO: only load highest LOD
            const dataBlock = mesh.getBlockByType('DATA');
            const vbibBlock = mesh.getBlockByType('VBIB');
            if (dataBlock && vbibBlock) {
                this.#loadMesh(repository, '' /*TODO: fix mesh name*/, model, group, dataBlock, vbibBlock, lodGroupMask, vmdl, meshIndex, meshGroupMask);
            }
        };
        await this.#loadMeshes(vmdl, callback);
    }
    async #loadMeshes(vmdl, callback /*TODO: remove callback*/) {
        const promises = new Set();
        //const m_refMeshes = vmdl.getBlockStruct('DATA.structs.PermModelData_t.m_refMeshes') || vmdl.getBlockStruct('DATA.keyValue.root.m_refMeshes');
        //const m_refLODGroupMasks = vmdl.getBlockStruct('DATA.structs.PermModelData_t.m_refLODGroupMasks') || vmdl.getBlockStruct('DATA.keyValue.root.m_refLODGroupMasks');
        //const m_refMeshGroupMasks = vmdl.getBlockStruct('DATA.structs.PermModelData_t.m_refMeshGroupMasks') || vmdl.getBlockStruct('DATA.keyValue.root.m_refMeshGroupMasks');
        const m_refMeshes = vmdl.getBlockStructAsResourceArray('DATA', 'm_refMeshes');
        const m_refLODGroupMasks = vmdl.getBlockStructAsBigintArray('DATA', 'm_refLODGroupMasks') ?? vmdl.getBlockStructAsNumberArray('DATA', 'm_refLODGroupMasks');
        const m_refMeshGroupMasks = vmdl.getBlockStructAsNumberArray('DATA', 'm_refMeshGroupMasks');
        if (m_refMeshes && m_refLODGroupMasks) {
            for (let meshIndex = 0; meshIndex < m_refMeshes.length; meshIndex++) { //TODOv3
                const meshName = m_refMeshes[meshIndex];
                const lodGroupMask = Number(m_refLODGroupMasks[meshIndex]);
                const meshGroupMask = m_refMeshGroupMasks?.[meshIndex];
                if (meshName) {
                    const promise = MeshManager.getMesh(vmdl.repository, meshName);
                    promises.add(promise);
                    promise.then((mesh) => {
                        callback(mesh, lodGroupMask, meshIndex, meshGroupMask);
                    });
                }
            }
        }
        await Promise.all(promises);
    }
    async #loadIncludeModels(model) {
        const includeModels = model.getIncludeModels();
        for (const includeModel of includeModels) {
            const refModel = await new _a$3().load(model.repository, includeModel);
            if (refModel) {
                model.addIncludeModel(refModel);
            }
        }
    }
}
_a$3 = Source2ModelLoader;

class Source2ModelManager {
    static #modelListPerRepository = {}; //TODO: use a map
    static #modelsPerRepository = {}; //TODO: use a map2
    static #modelList = new Map();
    static instances = new Set();
    static async #createModel(repository, path) {
        if (!path) {
            return;
        }
        path = path.replace(/\.vmdl_c$/, '').replace(/\.vmdl$/, '');
        /*let fullPath = repository + fileName;
        let model = this.#modelList.get(fullPath);*/
        let model = this.#getModel(repository, path);
        if (model) {
            return model;
        }
        model = await new Source2ModelLoader().load(repository, path);
        if (model) {
            this.#modelsPerRepository[repository][path] = model;
        }
        else {
            console.error('Model not found', repository, path);
        }
        return model;
        /*if (model) {
            return model;
        } else {
            model = await new Source2ModelLoader().load(repository, fileName);
            if (model) {
                this.#modelList.set(fullPath, model);
                return model;
            } else {
                console.error(`Model not found : ${fullPath}`);
            }
        }*/
    }
    static #getModel(repository, path) {
        if (!this.#modelsPerRepository[repository]) {
            this.#modelsPerRepository[repository] = {};
        }
        return this.#modelsPerRepository[repository][path] ?? null;
    }
    static async createInstance(repository, fileName, dynamic) {
        if (!repository) {
            //try to get repository from filename
            for (const repo in this.#modelListPerRepository) {
                if (fileName.startsWith(repo)) {
                    repository = repo;
                    fileName = fileName.replace(repo, '');
                    break;
                }
            }
        }
        const model = await this.#createModel(repository, fileName);
        if (model) {
            const instance = model.createInstance(dynamic);
            return instance;
        }
        return null;
    }
    static async loadManifest(repository) {
        const modelList = this.#modelListPerRepository[repository];
        if (modelList === undefined) {
            this.#modelListPerRepository[repository] = null;
        }
    }
    static async getModelList() {
        const repoList = [];
        const modelListPerRepository = this.#modelListPerRepository;
        for (const repositoryName in modelListPerRepository) {
            let repo = modelListPerRepository[repositoryName];
            if (repo === null) {
                //let response = await customFetch(new URL('models_manifest.json', repository.base));//todo variable
                //repo = await response.json();
                const response = await Repositories.getFileAsJson(repositoryName, 'models_manifest.json'); //todo variable
                if (!response.error) {
                    this.#modelListPerRepository[repositoryName] = response.json;
                    repo = response.json;
                }
            }
            if (repo) {
                repoList.push({ name: repositoryName, files: [repo] });
            }
        }
        return { name: '', path: '', files: repoList };
    }
}

class Source2ParticleManagerClass {
    #vpcfs = new Map2();
    #fileList = {}; //TODO: turn to map and improve type
    speed = 1.0;
    activeSystemList = new Set();
    visible;
    constructor() {
        GraphicsEvents.addEventListener(GraphicsEvent.Tick, (event) => {
            this.stepSystems(event.detail.delta); //TODOv3: improve this
        });
    }
    async #getVpcf(repository, path) {
        let vpcf = this.#vpcfs.get(repository, path);
        if (vpcf === undefined) {
            vpcf = await getLoader('Source2ParticleLoader').load(repository, path);
            this.#vpcfs.set(repository, path, vpcf);
        }
        return vpcf;
    }
    async getSystem(repository, vpcfPath, snapshotModifiers) {
        vpcfPath = vpcfPath.replace(/\.vpcf_c/, '').replace(/\.vpcf/, '');
        vpcfPath = vpcfPath + '.vpcf_c';
        const vpcf = await this.#getVpcf(repository, vpcfPath);
        if (vpcf) {
            return getLoader('Source2ParticleLoader').getSystem(repository, vpcf, snapshotModifiers);
        }
    }
    stepSystems(elapsedTime) {
        if (elapsedTime) {
            elapsedTime *= this.speed;
            elapsedTime = Math.min(elapsedTime, 0.1);
            for (const system of this.activeSystemList.values()) {
                if (!system.parentSystem) {
                    system.step(elapsedTime);
                }
            }
        }
    }
    setActive(system) {
        this.activeSystemList.add(system);
    }
    setInactive(system) {
        this.activeSystemList.delete(system);
    }
    renderSystems(render) {
        this.visible = render ? undefined : false;
    }
    async getSystemList() {
        const repoList = [];
        for (const repoName in this.#fileList) {
            if (this.#fileList[repoName]) {
                continue;
            }
            await this.#loadManifest(repoName);
            const repo = this.#fileList[repoName];
            repoList.push({ name: repoName, files: repo });
        }
        return { name: '', path: '', files: repoList };
    }
    async loadManifests(...repositories) {
        for (const repository of repositories) {
            this.#fileList[repository] = undefined;
        }
    }
    async #loadManifest(repositoryName) {
        //const manifestUrl = new URL('particles_manifest.json', repository.base);//todo variable
        const response = await Repositories.getFileAsJson(repositoryName, 'particles_manifest.json'); //TODO const
        //const response = await customFetch(new Request(manifestUrl));
        if (response.error) {
            return;
        }
        const json = response.json;
        if (json && json.files) {
            this.#fileList[repositoryName] = json.files;
        }
    }
}
const Source2ParticleManager = new Source2ParticleManagerClass();

var _a$2;
const MAX_ANIMATIONS = 2;
let dataListId = 0;
function getDataListId() {
    return `animations-datalist${++dataListId}`;
}
class SceneExplorerEntity extends HTMLElement {
    #doOnce;
    #entity;
    #htmlHeader;
    #htmlContent;
    #htmlAnimations;
    #htmlInputDataList;
    #htmlChilds;
    #htmlTitle;
    #htmlVisible;
    #htmlPlaying;
    #htmlAnimationsButton;
    #htmlLoopedButton;
    #htmlLockedButton;
    #htmlReset;
    static #entitiesHTML = new Map();
    static #selectedEntity;
    static #explorer;
    static #draggedEntity;
    static {
        EntityObserver.addEventListener(EntityObserverEventType.ChildAdded, (event) => _a$2.#expandEntityChilds(event.detail.parent));
        EntityObserver.addEventListener(EntityObserverEventType.ChildRemoved, (event) => _a$2.#expandEntityChilds(event.detail.parent));
        EntityObserver.addEventListener(EntityObserverEventType.PropertyChanged, (event) => _a$2.#handlePropertyChanged(event.detail));
        EntityObserver.addEventListener(EntityObserverEventType.EntityDeleted, (event) => _a$2.#handleEntityDeleted(event.detail));
    }
    constructor() {
        super();
        this.#doOnce = true;
        defineHarmonyToggleButton();
        this.#htmlHeader = createElement('div', {
            class: 'scene-explorer-entity-header',
            childs: [
                this.#htmlTitle = createElement('div', {
                    class: 'scene-explorer-entity-title',
                    events: {
                        click: () => this.#titleClick(),
                    }
                }),
                createElement('div', {
                    class: 'scene-explorer-entity-buttons',
                    childs: [
                        this.#htmlVisible = createElement('div', {
                            class: 'scene-explorer-entity-button-visible',
                            events: {
                                click: () => {
                                    this.#entity?.toggleVisibility();
                                },
                            }
                        }),
                        this.#htmlPlaying = createElement('div', {
                            hidden: true,
                            class: 'scene-explorer-entity-button-play',
                            events: {
                                click: () => {
                                    this.#entity?.togglePlaying();
                                },
                            }
                        }),
                        this.#htmlAnimationsButton = createElement('harmony-toggle-button', {
                            hidden: true,
                            childs: [
                                createElement('div', {
                                    slot: 'off',
                                    innerHTML: runSVG,
                                }),
                                createElement('div', {
                                    slot: 'on',
                                    innerHTML: walkSVG,
                                }),
                            ],
                            events: {
                                change: (event) => this.#displayAnimations(event.target.state),
                            }
                        }),
                        this.#htmlLoopedButton = createElement('harmony-toggle-button', {
                            hidden: true,
                            childs: [
                                createElement('div', {
                                    slot: 'off',
                                    innerHTML: repeatSVG,
                                }),
                                createElement('div', {
                                    slot: 'on',
                                    innerHTML: repeatOnSVG,
                                }),
                            ],
                            events: {
                                change: (event) => this.#entity?.setLooping(event.target.state),
                            }
                        }),
                        this.#htmlLockedButton = createElement('harmony-toggle-button', {
                            hidden: true,
                            childs: [
                                createElement('div', {
                                    slot: 'off',
                                    innerHTML: lockOpenRightSVG,
                                }),
                                createElement('div', {
                                    slot: 'on',
                                    innerHTML: lockSVG,
                                }),
                            ],
                            events: {
                                change: (event) => this.#entity?.setLocked(event.target.state),
                            }
                        }),
                        this.#htmlReset = createElement('div', {
                            hidden: true,
                            class: 'scene-explorer-entity-button-reset',
                            innerHTML: restartSVG,
                            events: {
                                click: () => {
                                    this.#entity?.do('reset');
                                },
                            }
                        }),
                    ]
                }),
            ]
        });
        this.#htmlContent = createElement('div', {
            class: 'scene-explorer-entity-content',
            hidden: true,
        });
        this.#htmlChilds = createElement('div', {
            class: 'scene-explorer-entity-childs',
            hidden: true,
        });
    }
    connectedCallback() {
        if (this.#doOnce) {
            this.#doOnce = false;
            this.#htmlHeader.draggable = true;
            this.append(this.#htmlHeader, this.#htmlContent, this.#htmlChilds);
            this.addEventListener('contextmenu', event => this.#contextMenuHandler(event));
            this.addEventListener('dragstart', event => {
                if (event.dataTransfer) {
                    event.dataTransfer.effectAllowed = 'link';
                }
                _a$2.#draggedEntity = this.#entity;
                event.stopPropagation();
            });
            this.addEventListener('dragenter', event => {
                this.classList.add('dragged-over');
            });
            this.addEventListener('dragleave', event => {
                this.classList.remove('dragged-over');
            });
            this.addEventListener('dragover', event => {
                event.preventDefault();
                event.stopPropagation();
            });
            this.addEventListener('drop', event => {
                const draggedEntity = _a$2.#draggedEntity;
                if (draggedEntity) {
                    this.classList.remove('dragged-over');
                    this.#entity?.addChild(draggedEntity);
                    event.stopPropagation();
                }
            });
            this.addEventListener('dragend', () => {
                _a$2.#draggedEntity = undefined;
            });
        }
    }
    /**
     * @deprecated Please use `setEntity` instead.
     */
    set entity(entity) {
        //TODO: deprecate
        console.warn('deprecated, use setEntity instaed');
        this.setEntity(entity);
    }
    setEntity(entity) {
        this.#entity = entity;
        this.#update();
        this.#updateVisibility();
        this.#updatePlaying();
        display(this.#htmlPlaying, entity?.animable);
        display(this.#htmlAnimationsButton, entity?.hasAnimations);
        display(this.#htmlReset, entity?.resetable);
        display(this.#htmlLoopedButton, entity?.isLoopable);
        display(this.#htmlLockedButton, entity?.isLockable);
    }
    static setExplorer(explorer) {
        _a$2.#explorer = explorer;
    }
    /*
    static get selectedEntity() {
        return SceneExplorerEntity.#selectedEntity.#entity;
    }
    */
    select() {
        this.classList.add('selected');
        const selectedEntity = _a$2.#selectedEntity;
        if (selectedEntity != this) {
            selectedEntity?.unselect();
        }
        _a$2.#selectedEntity = this;
    }
    display() {
        this.#display();
        this.scrollIntoView();
    }
    #display() {
        const parentEntity = this.#entity?.parent;
        if (parentEntity) {
            const htmlParent = _a$2.getEntityElement(parentEntity);
            if (htmlParent) {
                htmlParent.#display();
                htmlParent.expand();
            }
        }
    }
    unselect() {
        this.classList.remove('selected');
    }
    static getEntityElement(entity) {
        if (entity.hideInExplorer) {
            return null;
        }
        let entityElement = _a$2.#entitiesHTML.get(entity);
        if (!entityElement) {
            entityElement = createElement('scene-explorer-entity');
            entityElement.setEntity(entity);
            _a$2.#entitiesHTML.set(entity, entityElement);
        }
        return entityElement;
    }
    static #handlePropertyChanged(detail) {
        const entity = detail.entity;
        _a$2.#updateEntity(entity);
        switch (detail.propertyName) {
            case 'visible':
                this.#updateEntityVisibility(entity);
                for (const child of entity.children) {
                    this.#updateEntityVisibility(child);
                }
                break;
            case 'playing':
                this.#updateEntityPlaying(entity);
                break;
        }
    }
    static #handleEntityDeleted(detail) {
        _a$2.#entitiesHTML.delete(detail.entity);
        //console.log('deleted entity', detail.entity);
    }
    static #updateEntity(entity) {
        const entityElement = _a$2.#entitiesHTML.get(entity);
        if (entityElement) {
            entityElement.#update();
        }
    }
    static #expandEntityChilds(entity) {
        const entityElement = _a$2.#entitiesHTML.get(entity);
        if (entityElement) {
            entityElement.#expandChilds();
        }
    }
    #update() {
        const entity = this.#entity;
        if (entity) {
            const className = entity.constructor.getEntityName();
            this.#htmlTitle.innerText = entity.name ? `${entity.name} (${className})` : className;
        }
    }
    static #updateEntityVisibility(entity) {
        const entityElement = _a$2.#entitiesHTML.get(entity);
        if (entityElement) {
            entityElement.#updateVisibility();
        }
    }
    #updateVisibility() {
        if (this.#entity?.isVisible()) {
            this.#htmlVisible.innerHTML = visibilityOnSVG;
        }
        else {
            this.#htmlVisible.innerHTML = visibilityOffSVG;
        }
    }
    static #updateEntityPlaying(entity) {
        const entityElement = _a$2.#entitiesHTML.get(entity);
        if (entityElement) {
            entityElement.#updatePlaying();
        }
    }
    #updatePlaying() {
        if (this.#entity?.isPlaying()) {
            this.#htmlPlaying.innerHTML = playSVG;
        }
        else {
            this.#htmlPlaying.innerHTML = pauseSVG;
        }
    }
    expand() {
        show(this.#htmlChilds);
        this.#expandChilds();
        //this.select();
    }
    #expandChilds() {
        this.#htmlChilds.innerText = '';
        const entity = this.#entity;
        if (!entity) {
            return;
        }
        for (const child of entity.children) {
            const childHtml = _a$2.getEntityElement(child);
            if (childHtml) {
                this.#htmlChilds.append(childHtml);
            }
        }
    }
    #titleClick() {
        if (this == _a$2.#selectedEntity) {
            toggle(this.#htmlChilds);
        }
        else {
            show(this.#htmlChilds);
        }
        this.#expandChilds();
        _a$2.#explorer?.selectEntity(this.#entity);
    }
    #contextMenuHandler(event) {
        if (!event.shiftKey && this.#entity) {
            _a$2.#explorer?.showContextMenu(this.#entity.buildContextMenu(), event.clientX, event.clientY, this.#entity);
            event.preventDefault();
            event.stopPropagation();
        }
    }
    async #displayAnimations(display) {
        if (!this.#entity) {
            return;
        }
        if (this.#htmlAnimations && !display) {
            hide(this.#htmlAnimations);
            return;
        }
        this.#initAnimations();
        //SceneExplorerEntity.#explorer?.showAnimations(this.#entity);
        const animList = await this.#entity.getAnimations?.();
        if (!animList) {
            return;
        }
        this.#htmlInputDataList.innerText = '';
        for (const value of animList) {
            createElement('option', {
                innerText: value,
                parent: this.#htmlInputDataList,
            });
        }
        show(this.#htmlAnimations);
        show(this.#htmlContent);
    }
    #initAnimations() {
        if (this.#htmlAnimations) {
            return;
        }
        this.#htmlAnimations = createElement('div', {
            class: 'animations',
            parent: this.#htmlContent,
        });
        const dataListId = getDataListId();
        for (let i = 0; i < MAX_ANIMATIONS; i++) {
            createElement('div', {
                class: 'animation',
                parent: this.#htmlAnimations,
                childs: [
                    createElement('input', {
                        list: dataListId,
                        events: {
                            change: (event) => this.#setAnimName(i, event.target.value)
                        }
                    }),
                ],
            });
        }
        this.#htmlInputDataList = createElement('datalist', {
            id: dataListId,
            parent: this.#htmlAnimations,
        });
    }
    #setAnimName(id, name) {
        if (!this.#entity) {
            return;
        }
        this.#entity.playAnimation(name);
        this.#entity.setAnimation(id, name, 1); //TODO: weight
    }
}
_a$2 = SceneExplorerEntity;
if (window.customElements) {
    customElements.define('scene-explorer-entity', SceneExplorerEntity);
}

function FormatArray(array) {
    const arr = [];
    array.forEach((element) => arr.push(element.toFixed(2)));
    return arr.join(' ');
}
const ENTITIES = [
    '',
    'AmbientLight',
    'Bone',
    'ControlPoint',
    'Light',
    'Camera',
    'PointLight',
    'Source1ModelInstance',
    'Source2ModelInstance',
];
let sceneExplorer = null;
function getSceneExplorer() {
    if (!sceneExplorer) {
        sceneExplorer = new SceneExplorer();
    }
    return sceneExplorer;
}
class SceneExplorer {
    static #instance;
    #scene;
    #selectedEntity;
    #manipulator;
    #skeletonHelper = new SkeletonHelper({ visible: false });
    #htmlProperties;
    #htmlFileExplorer;
    #htmlMaterialEditor;
    #htmlExtra;
    #htmlHeader;
    htmlFileSelector;
    #htmlNameFilter;
    #htmlContextMenu;
    #htmlTypeFilter;
    #htmlDisplayBoneJoints;
    #shadowRoot;
    #htmlName;
    #htmlId;
    #htmlPos;
    #htmlQuat;
    #htmlScale;
    #htmlWorldPos;
    #htmlWorldQuat;
    #htmlWorldScale;
    //#htmlVisible!: HTMLInputElement;
    #htmlScene;
    #filterName = '';
    #filterType = '';
    #isVisible = false;
    //selectedEntity?: Entity;
    constructor() {
        if (SceneExplorer.#instance) {
            return SceneExplorer.#instance;
        }
        this.#initHtml();
        SceneExplorer.#instance = this;
        initEntitySubmenu();
        SceneExplorerEntity.setExplorer(this);
        this.#manipulator = new Manipulator({ visible: false });
        new IntersectionObserver((entries, observer) => {
            const isVisible = this.#isVisible;
            for (const e of entries) {
                this.#isVisible = e.isIntersecting;
            }
            if (this.#isVisible && (this.#isVisible != isVisible)) {
                this.applyFilter();
                if (this.#selectedEntity) {
                    SceneExplorerEntity.getEntityElement(this.#selectedEntity)?.select();
                }
            }
        }).observe(this.#shadowRoot.host);
        EntityObserver.addEventListener(EntityObserverEventType.PropertyChanged, (event) => this.#handlePropertyChanged(event.detail));
        SceneExplorerEvents.addEventListener('bonepicked', (event) => this.selectEntity(event.detail.bone, true));
    }
    /**
     * @deprecated Please use `setScene` instead.
     */
    set scene(scene) {
        console.warn('deprecated, use setScene instead');
        this.setScene(scene);
    }
    setScene(scene) {
        this.#scene = scene;
        this.selectEntity(scene, true);
        this.applyFilter();
    }
    get scene() {
        return this.#scene;
    }
    #refreshScene() {
        if (this.#scene) {
            this.#htmlScene.innerText = '';
            this.#htmlScene.append(this.#createEntityElement(this.#scene, true));
        }
    }
    get htmlElement() {
        return this.#shadowRoot.host;
    }
    #initHtml() {
        defineHarmonyAccordion();
        this.#shadowRoot = createShadowRoot('scene-explorer', {
            attributes: { tabindex: 1, },
            adoptStyle: sceneExplorerCSS,
            childs: [
                this.#htmlHeader = createElement('div', { class: 'scene-explorer-header' }),
                this.#htmlScene = createElement('div', { class: 'scene-explorer-scene', attributes: { tabindex: 1, }, }),
                this.htmlFileSelector = createElement('div', {
                    class: 'scene-explorer-file-selector',
                    hidden: true,
                    attributes: { tabindex: 1, },
                }),
                this.#htmlExtra = createElement('harmony-accordion', {
                    multiple: 1,
                    childs: [
                        createElement('harmony-item', {
                            id: 'properties',
                            childs: [
                                createElement('div', {
                                    slot: 'header',
                                    i18n: '#properties',
                                }),
                                this.#htmlProperties = createElement('div', {
                                    class: 'scene-explorer-properties',
                                    slot: 'content',
                                    attributes: {
                                        tabindex: 1,
                                    },
                                }),
                            ],
                        }),
                        createElement('harmony-item', {
                            id: 'files',
                            hidden: true,
                            childs: [
                                createElement('div', {
                                    slot: 'header',
                                    i18n: '#files',
                                }),
                                this.#htmlFileExplorer = createElement('div', {
                                    class: 'file-explorer',
                                    slot: 'content',
                                    attributes: {
                                        tabindex: 1,
                                    },
                                }),
                            ],
                        }),
                        createElement('harmony-item', {
                            id: 'material',
                            hidden: true,
                            childs: [
                                createElement('div', {
                                    slot: 'header',
                                    i18n: '#material_editor',
                                }),
                                this.#htmlMaterialEditor = createElement('div', {
                                    class: 'material-editor',
                                    slot: 'content',
                                    attributes: {
                                        tabindex: 1,
                                    },
                                }),
                            ],
                        }),
                    ],
                }),
            ],
        });
        I18n.observeElement(this.#shadowRoot);
        defineHarmonyMenu();
        this.#htmlContextMenu = createElement('harmony-menu');
        this.#initHtmlHeader();
        this.#initHtmlProperties();
        this.applyFilter();
        ShortcutHandler.addContext('scene-explorer,scene-explorer-nodes', this.#htmlScene);
        ShortcutHandler.addContext('scene-explorer,scene-explorer-files', this.htmlFileSelector);
        ShortcutHandler.addContext('scene-explorer,scene-explorer-properties', this.#htmlProperties);
    }
    #initHtmlHeader() {
        this.#htmlNameFilter = createElement('input', {
            parent: this.#htmlHeader,
        });
        this.#htmlTypeFilter = createElement('select', {
            parent: this.#htmlHeader,
        });
        let htmlManipulator;
        createElement('span', {
            class: 'manipulator',
            parent: this.#htmlHeader,
            childs: [
                createElement('label', {
                    childs: [
                        htmlManipulator = createElement('input', {
                            type: 'checkbox',
                            events: {
                                change: (event) => this.#manipulator.setVisible(event.target.checked),
                            },
                        }),
                        createElement('span', { i18n: '#display_manipulator', }),
                    ],
                }),
                createElement('span', {
                    class: 'manipulator-button',
                    innerHTML: dragPanSVG,
                    events: {
                        click: () => {
                            this.#manipulator.setMode(ManipulatorMode.Translation);
                            htmlManipulator.checked = true;
                            this.#manipulator.setVisible(true);
                        },
                    }
                }),
                createElement('span', {
                    class: 'manipulator-button',
                    innerHTML: rotateSVG,
                    events: {
                        click: () => {
                            this.#manipulator.setMode(ManipulatorMode.Rotation);
                            htmlManipulator.checked = true;
                            this.#manipulator.setVisible(true);
                        },
                    }
                }),
                createElement('span', {
                    class: 'manipulator-button',
                    innerHTML: panZoomSVG,
                    events: {
                        click: () => {
                            this.#manipulator.setMode(ManipulatorMode.Scale);
                            htmlManipulator.checked = true;
                            this.#manipulator.setVisible(true);
                        },
                    }
                }),
            ],
        });
        createElement('label', {
            parent: this.#htmlHeader,
            childs: [
                createElement('input', {
                    type: 'checkbox',
                    events: {
                        change: (event) => {
                            const checked = event.target.checked;
                            this.#skeletonHelper.setVisible(checked);
                            display(this.#htmlDisplayBoneJoints, checked);
                        }
                    }
                }),
                createElement('span', {
                    i18n: '#display_skeleton',
                }),
            ]
        });
        this.#htmlDisplayBoneJoints = createElement('label', {
            parent: this.#htmlHeader,
            hidden: true,
            childs: [
                createElement('input', {
                    type: 'checkbox',
                    checked: true,
                    events: {
                        change: (event) => this.#skeletonHelper.displayBoneJoints(event.target.checked)
                    }
                }),
                createElement('span', {
                    i18n: '#display_bone_joints',
                }),
            ]
        });
        /*
        let propertiesId = 'display_properties';
        let htmlDisplayProperties = createElement('input') as HTMLInputElement;
        htmlDisplayProperties.type = 'checkbox';
        htmlDisplayProperties.id = propertiesId;
        htmlDisplayProperties.checked = false;

        /*
        let htmlDisplayPropertiesSpan = createElement('span');
        let htmlDisplayPropertiesLabel = createElement('label', { i18n: '#display_properties', htmlFor: propertiesId });

        this.#htmlHeader.append(htmlDisplayPropertiesSpan);
        htmlDisplayPropertiesSpan.append(htmlDisplayProperties, htmlDisplayPropertiesLabel);
        */
        this.#htmlNameFilter.addEventListener('change', (event) => { this.#filterName = event.target.value.toLowerCase(); this.applyFilter(); });
        this.#htmlTypeFilter.addEventListener('change', (event) => { this.#filterType = event.target.value; this.applyFilter(); });
        //htmlDisplayProperties.addEventListener('change', (event) => toggle(this.#htmlProperties));
        this.#populateTypeFilter();
    }
    #populateTypeFilter() {
        for (const type of ENTITIES) {
            const option = createElement('option', { innerText: type, value: type });
            this.#htmlTypeFilter.append(option);
        }
    }
    applyFilter() {
        if (this.#isVisible) {
            if (this.#filterName == '' && this.#filterType == '') {
                this.#refreshScene();
            }
            else {
                if (this.#scene) {
                    const allEntities = this.#scene.getChildList();
                    this.#htmlScene.innerText = '';
                    for (const entity of allEntities) {
                        if (this.#matchFilter(entity, this.#filterName, this.#filterType)) {
                            const htmlEntityElement = this.#createEntityElement(entity);
                            if (htmlEntityElement) {
                                this.#htmlScene.append();
                            }
                        }
                    }
                }
            }
        }
    }
    #matchFilter(entity, name, type) {
        return (name ? entity.name && entity.name.toLowerCase().includes(name) : true) && (type ? entity.is(type) : true);
    }
    #initHtmlProperties() {
        this.#htmlName = createElement('div', { class: 'scene-explorer-entity-title' });
        const htmlIdLabel = createElement('label', { i18n: '#id' });
        this.#htmlId = createElement('div', { class: 'scene-explorer-entity-id' });
        const htmlPosLabel = createElement('label', { i18n: '#position' });
        this.#htmlPos = createElement('div', { class: 'scene-explorer-entity-pos' });
        const htmlQuatLabel = createElement('label', { i18n: '#quaternion' });
        this.#htmlQuat = createElement('div', { class: 'scene-explorer-entity-quat' });
        const htmlScaleLabel = createElement('label', { i18n: '#scale' });
        this.#htmlScale = createElement('div', { class: 'scene-explorer-entity-scale' });
        const htmlWorldPosLabel = createElement('label', { i18n: '#world_position' });
        this.#htmlWorldPos = createElement('div', { class: 'scene-explorer-entity-world-pos' });
        const htmlWorldQuatLabel = createElement('label', { i18n: '#world_quaternion' });
        this.#htmlWorldQuat = createElement('div', { class: 'scene-explorer-entity-world-quat' });
        const htmlWorldScaleLabel = createElement('label', { i18n: '#world_scale' });
        this.#htmlWorldScale = createElement('div', { class: 'scene-explorer-entity-world-scale' });
        /*
        const htmlVisibleLabel = createElement('label', { i18n: '#visible' });
        this.#htmlVisible = createElement('input', {
            class: 'scene-explorer-entity-visible',
            type: 'checkbox',
            events: {
                input: () => this.#selectedEntity?.toggleVisibility?.()
            }
        }) as HTMLInputElement;
        */
        //this.htmlVisible.addEventListener('input', () => {if (this._currentEntity) this._currentEntity.toggleVisibility()});
        this.#htmlProperties.append(this.#htmlName, htmlIdLabel, this.#htmlId, htmlPosLabel, this.#htmlPos, htmlQuatLabel, this.#htmlQuat, htmlScaleLabel, this.#htmlScale, htmlWorldPosLabel, this.#htmlWorldPos, htmlWorldQuatLabel, this.#htmlWorldQuat, htmlWorldScaleLabel, this.#htmlWorldScale /*, htmlVisibleLabel, this.#htmlVisible*/);
    }
    #createEntityElement(entity, createExpanded = false) {
        const htmlEntityElement = SceneExplorerEntity.getEntityElement(entity);
        if (createExpanded) {
            htmlEntityElement?.expand();
        }
        return htmlEntityElement;
    }
    selectEntity(entity, scrollIntoView = false) {
        if (this.#selectedEntity == entity) {
            return;
        }
        this.#selectedEntity = entity;
        entity?.addChild(this.#manipulator);
        entity?.addChild(this.#skeletonHelper);
        if (this.#isVisible) {
            this.#updateEntityElement(entity);
            if (entity) {
                SceneExplorerEntity.getEntityElement(entity)?.select();
                if (scrollIntoView) {
                    SceneExplorerEntity.getEntityElement(entity)?.display();
                }
            }
        }
    }
    getSelectedEntity() {
        return this.#selectedEntity;
    }
    #updateEntityElement(entity) {
        if (entity) {
            //this.#updateEntityTitle(entity);
            this.#htmlName.innerText = entity.name ?? entity.constructor.getEntityName();
            this.#htmlId.innerText = entity.id;
            this.#htmlPos.innerText = FormatArray(entity.position);
            this.#htmlQuat.innerText = FormatArray(entity.quaternion);
            this.#htmlScale.innerText = FormatArray(entity.scale);
            this.#htmlWorldPos.innerText = FormatArray(entity.getWorldPosition());
            this.#htmlWorldQuat.innerText = FormatArray(entity.getWorldQuaternion());
            this.#htmlWorldScale.innerText = FormatArray(entity.getWorldScale());
            //this.#htmlVisible.checked = entity.visible;
            /*
            if (entity.visibleSelf === undefined) {
                this.#htmlVisible.indeterminate = true;
            } else {
                this.#htmlVisible.indeterminate = false;
            }
            */
        }
    }
    getEntityHtml(entity) {
        throw 'remove me';
        //return this._entitiesHtml.get(entity);
    }
    #handlePropertyChanged(detail) {
        if (this.#isVisible && detail.entity == this.#selectedEntity) {
            this.#updateEntityElement(this.#selectedEntity);
        }
        /*const entity = detail.entity;
        SceneExplorerEntity.#updateEntity(entity);
        if (detail.name === 'visible') {
            for (let child of entity.children) {
                SceneExplorerEntity.#updateEntity(child);
            }
        }*/
    }
    showContextMenu(contextMenu, x, y, entity) {
        this.#htmlContextMenu.showContextual(contextMenu, x, y, entity);
    }
    editMaterial(material) {
        const materialEditor = getMaterialEditor();
        materialEditor.editMaterial(material);
        this.#htmlMaterialEditor.append(materialEditor.getHTML());
        this.#htmlExtra.expand('material');
    }
    setJointsRadius(radius) {
        this.#skeletonHelper.setJointsRadius(radius);
    }
}
function initEntitySubmenu() {
    Entity.addSubMenu = [
        {
            i18n: '#primitives', submenu: [
                { i18n: '#box', f: (entity) => entity.addChild(new Box()) },
                { i18n: '#cone', f: (entity) => entity.addChild(new Cone()) },
                { i18n: '#cylinder', f: (entity) => entity.addChild(new Cylinder()) },
                { i18n: '#fullscreenquad', f: (entity) => entity.addChild(new FullScreenQuad()) },
                { i18n: '#metaballs', f: (entity) => entity.addChild(new Metaballs()) },
                { i18n: '#plane', f: (entity) => entity.addChild(new Plane({ width: 1000, height: 1000 })) },
                { i18n: '#sphere', f: (entity) => entity.addChild(new Sphere()) },
                { i18n: '#text', f: (entity) => entity.addChild(new Text3D()) },
            ]
        },
        {
            i18n: '#entities', submenu: [
                { i18n: '#group', f: (entity) => entity.addChild(new Group()) },
                { i18n: '#target', f: (entity) => entity.addChild(new Target()) },
                { i18n: '#keeponlylastchild', f: (entity) => entity.addChild(new KeepOnlyLastChild()) },
                { i18n: '#decal', f: (entity) => entity.addChild(new Decal()) },
            ]
        },
        {
            i18n: '#lights', submenu: [
                { i18n: '#ambient_light', f: (entity) => entity.addChild(new AmbientLight()) },
                { i18n: '#point_light', f: (entity) => entity.addChild(new PointLight()) },
                { i18n: '#spot_light', f: (entity) => entity.addChild(new SpotLight()) },
            ]
        },
        { i18n: '#camera', f: (entity) => ContextObserver.observe(GraphicsEvents, entity.addChild(new Camera())) },
        {
            i18n: '#control', submenu: [
                {
                    i18n: '#rotation_control', f: (entity) => {
                        new RotationControl({ parent: entity });
                    }
                },
                {
                    i18n: '#translation_control', f: (entity) => {
                        const control = new TranslationControl();
                        const parent = entity.parent;
                        if (parent) {
                            parent.addChild(control);
                        }
                        control.addChild(entity);
                    }
                },
            ]
        },
        { i18n: '#helper', f: (entity) => { const helper = getHelper(entity); if (helper) {
                entity.addChild(helper);
            } } },
        { i18n: '#wireframe', f: (entity) => entity.addChild(new WireframeHelper()) },
        { i18n: '#wireframe2', f: (entity) => entity.addChild(new Wireframe()) },
        { i18n: '#hitboxes', f: (entity) => entity.addChild(new HitboxHelper()) },
        {
            i18n: '#source1', submenu: [
                {
                    i18n: '#model', f: async (entity) => {
                        show(new SceneExplorer().htmlFileSelector);
                        new Interaction().selectFile(new SceneExplorer().htmlFileSelector, await Source1ModelManager.getModelList(), async (repository, modelName) => {
                            console.error(modelName);
                            //let instance = await Source1ModelManager.createInstance(modelName.repository, modelName.path + modelName.name, true);
                            const instance = await Source1ModelManager.createInstance(repository, modelName, true);
                            if (!instance) {
                                return;
                            }
                            (new SceneExplorer().getSelectedEntity() ?? entity).addChild(instance);
                            const seq = instance.sourceModel.mdl.getSequenceById(0);
                            if (seq) {
                                instance.playSequence(seq.name);
                            }
                        });
                    }
                },
                {
                    i18n: '#particle_system', f: async (entity) => {
                        show(new SceneExplorer().htmlFileSelector);
                        new Interaction().selectFile(new SceneExplorer().htmlFileSelector, await Source1ParticleControler.getSystemList(), async (repository, systemPath) => {
                            const systemName = systemPath.split('/');
                            const sys = await Source1ParticleControler.createSystem(repository, systemName[systemName.length - 1]);
                            sys.start();
                            (new SceneExplorer().getSelectedEntity() ?? entity).addChild(sys);
                        });
                    }
                },
            ]
        },
        {
            i18n: '#source2', submenu: [
                {
                    i18n: '#model', f: async (entity) => {
                        show(new SceneExplorer().htmlFileSelector);
                        new Interaction().selectFile(new SceneExplorer().htmlFileSelector, await Source2ModelManager.getModelList(), async (repository, modelName) => {
                            console.error(modelName);
                            const instance = await Source2ModelManager.createInstance(repository, modelName, true);
                            (new SceneExplorer().getSelectedEntity() ?? entity).addChild(instance);
                            /*let seq = instance.sourceModel.mdl.getSequenceById(0);
                            if (seq) {
                                instance.playSequence(seq.name);
                            }*/
                        });
                    }
                },
                {
                    i18n: '#particle_system', f: async (entity) => {
                        show(new SceneExplorer().htmlFileSelector);
                        new Interaction().selectFile(new SceneExplorer().htmlFileSelector, await Source2ParticleManager.getSystemList(), async (repository, systemPath) => {
                            const systemName = systemPath.split('/');
                            const sys = await Source2ParticleManager.getSystem(repository, systemPath);
                            sys.name = systemName[systemName.length - 1];
                            sys.start();
                            (new SceneExplorer().getSelectedEntity() ?? entity).addChild(sys);
                        });
                    }
                },
            ]
        },
    ];
}
Entity.editMaterial = function (entity) {
    const material = entity.material;
    if (!material) {
        return;
    }
    const sceneExplorer = getSceneExplorer();
    sceneExplorer.editMaterial(material);
    //materialEditor.editEntity(entity);
    //this.#htmlMaterialEditor.append(materialEditor.getHTML());
    /*
    let entityHtml = SceneExplorer.getEntityHtml(entity);
    if (entityHtml) {
        entityHtml.append(MaterialEditor.html);
    }
        */
};

var compute_fragment_cube_map = `
vec3 cameraToFrag = normalize (vVertexPositionWorldSpace.xyz - uCameraPosition);
vec3 reflectDir = reflect(cameraToFrag, normalize(vVertexNormalWorldSpace));
#ifdef USE_CUBE_MAP
	vec4 cubeMapColor = textureCube(cubeMap, reflectDir);
#endif
`;

var compute_fragment_detail_map = `
#ifdef USE_DETAIL_MAP
	vec4 texelDetail = texture2D(detailMap, vDetailTextureCoord.xy);
#else
	vec4 texelDetail = vec4(0.0);
#endif
`;

var compute_fragment_diffuse = `
#ifdef USE_MESH_COLOR
	vec4 diffuseColor = uColor;
#else
	#ifdef USE_VERTEX_COLOR
		vec4 diffuseColor = vVertexColor;
	#else
		vec4 diffuseColor = vec4(1.0);
	#endif
#endif
`;

var compute_fragment_mask_map = `
#ifdef USE_MASK_MAP
	vec4 texelMask = texture2D(maskMap, vTextureCoord.xy);
#endif
`;

var compute_fragment_mask1_map = `
#ifdef USE_MASK1_MAP
	vec4 texelMask1 = texture2D(mask1Map, vTextureCoord.xy);
#endif
`;

var compute_fragment_mask2_map = `
#ifdef USE_MASK2_MAP
	vec4 texelMask2 = texture2D(mask2Map, vTextureCoord.xy);
#endif
`;

var compute_fragment_normal_map = `
#ifdef USE_NORMAL_MAP
	vec4 texelNormal = texture2D(normalMap, vTextureCoord.xy);
#else
	vec4 texelNormal = vec4(0.5, 0.5, 1.0, 0.0);
#endif
`;

var compute_fragment_normal_world_space = `
#ifdef FLAT_SHADING
	vec3 fdx = vec3(dFdx(vVertexPositionWorldSpace.x), dFdx(vVertexPositionWorldSpace.y), dFdx(vVertexPositionWorldSpace.z));
	vec3 fdy = vec3(dFdy(vVertexPositionWorldSpace.x), dFdy(vVertexPositionWorldSpace.y), dFdy(vVertexPositionWorldSpace.z));
	vec3 fragmentNormalWorldSpace = normalize(cross(fdx, fdy));
	vec3 fragmentTangentWorldSpace = normalize(fdx);
	vec3 fragmentBitangentWorldSpace = normalize(fdy);
#else
	vec3 fragmentNormalWorldSpace = normalize(vVertexNormalWorldSpace.xyz);
	vec3 fragmentTangentWorldSpace = normalize(vVertexTangentWorldSpace.xyz);
	vec3 fragmentBitangentWorldSpace = normalize(vVertexBitangentWorldSpace.xyz);
#endif
mat3 TBNMatrixWorldSpace = mat3(fragmentTangentWorldSpace, fragmentBitangentWorldSpace, fragmentNormalWorldSpace);
`;

var compute_fragment_phong_exponent_map = `
#ifdef USE_PHONG_EXPONENT_MAP
	vec4 texelPhongExponent = texture2D(phongExponentMap, vTextureCoord.xy);
#endif
`;

var compute_fragment_specular_map = `
#ifdef USE_SPECULAR_MAP
	vec4 texelSpecular = texture2D(specularMap, vTextureCoord.xy);
#endif
`;

var compute_pbr = `

const vec3 Fdielectric = vec3(0.04);

#ifndef NUM_PBR_LIGHTS
	#define NUM_PBR_LIGHTS 0
#endif

struct PBRLight {
	vec3 position;
	vec3 radiance;
};

#if NUM_PBR_LIGHTS > 0
	uniform PBRLight uPbrLights[NUM_PBR_LIGHTS];
#endif

// GGX/Towbridge-Reitz normal distribution function.
// Uses Disney's reparametrization of alpha = roughness^2.
float ndfGGX(float cosLh, float roughness)
{
	float alpha   = roughness * roughness;
	float alphaSq = alpha * alpha;

	float denom = (cosLh * cosLh) * (alphaSq - 1.0) + 1.0;
	return alphaSq / (PI * denom * denom);
}

// Single term for separable Schlick-GGX below.
float gaSchlickG1(float cosTheta, float k)
{
	return cosTheta / (cosTheta * (1.0 - k) + k);
}

// Schlick-GGX approximation of geometric attenuation function using Smith's method.
float gaSchlickGGX(float cosLi, float cosLo, float roughness)
{
	float r = roughness + 1.0;
	float k = (r * r) / 8.0; // Epic suggests using this roughness remapping for analytic lights.
	return gaSchlickG1(cosLi, k) * gaSchlickG1(cosLo, k);
}

// Shlick's approximation of the Fresnel factor.
vec3 fresnelSchlick(vec3 F0, float cosTheta)
{
	return F0 + (vec3(1.0) - F0) * pow(1.0 - cosTheta, 5.0);
}

vec3 computeLightPBR(PBRLight light, vec3 normal, vec3 fragmentPositionWorldSpace, vec3 Lo, float cosLo, vec3 F0, float metalness, float roughness, vec3 albedo) {
		vec3 Li = light.position - fragmentPositionWorldSpace;
		float d = length(Li);
		Li = normalize(Li);
		vec3 Lradiance = light.radiance / (d * d);

		// Half-vector between Li and Lo.
		vec3 Lh = normalize(Li + Lo);

		// Calculate angles between surface normal and various light vectors.
		float cosLi = max(0.0, dot(normal, Li));
		float cosLh = max(0.0, dot(normal, Lh));

		// Calculate Fresnel term for direct lighting.
		vec3 F  = fresnelSchlick(F0, max(0.0, dot(Lh, Lo)));
		// Calculate normal distribution for specular BRDF.
		float D = ndfGGX(cosLh, roughness);
		// Calculate geometric attenuation for specular BRDF.
		float G = gaSchlickGGX(cosLi, cosLo, roughness);

		// Diffuse scattering happens due to light being refracted multiple times by a dielectric medium.
		// Metals on the other hand either reflect or absorb energy, so diffuse contribution is always zero.
		// To be energy conserving we must scale diffuse BRDF contribution based on Fresnel factor & metalness.
		vec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);

		// Lambert diffuse BRDF.
		// We don't scale by 1/PI for lighting & material units to be more convenient.
		// See: https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/
		vec3 diffuseBRDF = kd * albedo;

		// Cook-Torrance specular microfacet BRDF.
		vec3 specularBRDF = (F * D * G) / max(EPSILON, 4.0 * cosLi * cosLo);

		// Total contribution for this light.
		return (diffuseBRDF + specularBRDF) * Lradiance * cosLi;
}

#if NUM_PBR_LIGHTS > 0
	vec3 computePBR(PBRLight light[NUM_PBR_LIGHTS], vec3 normal, vec3 cameraPosition, vec3 fragmentPositionWorldSpace, vec3 F0, float metalness, float roughness, vec3 albedo, float ao) {
		vec3 Lo = normalize(cameraPosition - fragmentPositionWorldSpace);//vec3 Lo = normalize(eyePosition - vin.position);
		float cosLo = max(0.0, dot(normal, Lo));

		vec3 directLighting = vec3(0);
		for(int i=0; i<NUM_PBR_LIGHTS; ++i) {
			directLighting += computeLightPBR(light[i], normal, fragmentPositionWorldSpace, Lo, cosLo, F0, metalness, roughness, albedo);
		}

		vec3 ambientLighting = uAmbientLight * albedo * ao;
		return directLighting + ambientLighting;
	}
#endif

`;

var compute_silhouette_color = `
#ifdef SILHOUETTE_MODE
	gl_FragColor = SILHOUETTE_COLOR;
#endif
`;

var compute_vertex_color = `
#ifdef USE_VERTEX_COLOR
	vVertexColor = aVertexColor;
#endif
`;

var compute_vertex_detail_uv = `
#ifdef USE_DETAIL_TEXTURE_TRANSFORM
	vDetailTextureCoord.xy = (uDetailTextureTransform * vec4(aTextureCoord, 1.0, 1.0)).st;
#else
	vDetailTextureCoord.xy = aTextureCoord;
#endif
`;

Includes['compute_fragment_cube_map'] = compute_fragment_cube_map;
Includes['compute_fragment_detail_map'] = compute_fragment_detail_map;
Includes['compute_fragment_diffuse'] = compute_fragment_diffuse;
Includes['compute_fragment_mask_map'] = compute_fragment_mask_map;
Includes['compute_fragment_mask1_map'] = compute_fragment_mask1_map;
Includes['compute_fragment_mask2_map'] = compute_fragment_mask2_map;
Includes['compute_fragment_normal_map'] = compute_fragment_normal_map;
Includes['compute_fragment_normal_world_space'] = compute_fragment_normal_world_space;
Includes['compute_fragment_phong_exponent_map'] = compute_fragment_phong_exponent_map;
Includes['compute_fragment_specular_map'] = compute_fragment_specular_map;
Includes['compute_pbr'] = compute_pbr;
Includes['compute_silhouette_color'] = compute_silhouette_color;
Includes['compute_vertex_color'] = compute_vertex_color;
Includes['compute_vertex_detail_uv'] = compute_vertex_detail_uv;

var compute_fragment_alpha_test = `
#ifndef EXPORT_TEXTURES
	#ifdef ALPHA_TEST
		if (diffuseColor.a < uAlphaTestReference) {
			discard;
		}
	#endif
#endif
`;

var compute_fragment_ao_map = `
#ifdef USE_AO_MAP
	vec4 texelAo = texture2D(aoMap, vTextureCoord.xy);
#endif
`;

var compute_fragment_color_map = `
#ifdef USE_COLOR_MAP
	vec4 texelColor = texture2D(colorMap, vTextureCoord.xy);
#else
	vec4 texelColor = vec4(1.0);
#endif
`;

var compute_fragment_depth = `
#ifdef ALWAYS_ON_TOP
	gl_FragDepth =  gl_FragCoord.z / 100.0;
#endif
#ifdef ALWAYS_BEHIND
	gl_FragDepth =  1.0 - EPSILON;
#endif
`;

var compute_fragment_exponent_map = `
#ifdef USE_EXPONENT_MAP
	vec4 texelExponent = texture2D(exponentMap, vTextureCoord.xy);
#endif
`;

var compute_fragment_lights = `
#if NUM_POINT_LIGHTS > 0
	#if defined(USE_SHADOW_MAPPING) && (NUM_POINT_LIGHT_SHADOWS > 0)
		PointLightShadow pointLightShadow;
	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			computePointLightIrradiance(uPointLights[i], geometry, directLight);
			#ifdef USE_SHADOW_MAPPING
				pointLightShadow = uPointLightShadows[ i ];
				directLight.color *= getPointShadow( uPointShadowMap[i], pointLightShadow.mapSize, /*pointLightShadow.shadowBias*/0.0, /*pointLightShadow.shadowRadius*/0.0, vPointShadowCoord[i], pointLightShadow.near, pointLightShadow.far);
			#endif
			RE_Direct( directLight, geometry, material, reflectedLight );
		}
	#endif

	#pragma unroll
	for ( int i = NUM_POINT_LIGHT_SHADOWS; i < NUM_POINT_LIGHTS; i ++ ) {
		computePointLightIrradiance(uPointLights[i], geometry, directLight);
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
#endif

#if NUM_SPOT_LIGHTS > 0
	#if defined(USE_SHADOW_MAPPING) && (NUM_SPOT_LIGHT_SHADOWS > 0)
		SpotLightShadow spotLightShadow;
	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0
		#pragma unroll
		for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
			computeSpotLightIrradiance(uSpotLights[i], geometry, directLight);
			#ifdef USE_SHADOW_MAPPING
				spotLightShadow = uSpotLightShadows[ i ];
				directLight.color *= getShadow( uSpotShadowMap[ i ], spotLightShadow.mapSize, /*spotLightShadow.shadowBias*/0.0, /*spotLightShadow.shadowRadius*/0.0, vSpotShadowCoord[ i ] );
			#endif
			RE_Direct( directLight, geometry, material, reflectedLight );
		}
	#endif

	#pragma unroll
	for ( int i = NUM_SPOT_LIGHT_SHADOWS; i < NUM_SPOT_LIGHTS; i ++ ) {
		computeSpotLightIrradiance(uSpotLights[i], geometry, directLight);
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( uAmbientLight );

	irradiance += getLightProbeIrradiance( lightProbe, geometry );

	#if ( NUM_HEMI_LIGHTS > 0 )

		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );

		}

	#endif

#endif

#if defined( RE_IndirectDiffuse )
	#ifndef SKIP_LIGHT_WARP
		#ifdef USE_LIGHT_WARP_MAP
			irradiance *= getLightWarp(saturate(luminance(irradiance)));
		#endif
	#endif

	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );

#endif

#if defined( RE_IndirectSpecular )

	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );

#endif
`;

var compute_fragment_log_depth = `
#ifdef USE_LOG_DEPTH
	#ifdef IS_PERSPECTIVE_CAMERA
		gl_FragDepthEXT = log2(vFragDepth) * uProjectionLogDepth * 0.5;
	#endif
	#ifdef IS_ORTHOGRAPHIC_CAMERA
		gl_FragDepthEXT = gl_FragCoord.z;
	#endif
#endif
`;

var compute_fragment_normal = `
#ifdef FLAT_SHADING
	vec3 fdx = vec3(dFdx(vVertexPositionCameraSpace.x), dFdx(vVertexPositionCameraSpace.y), dFdx(vVertexPositionCameraSpace.z));
	vec3 fdy = vec3(dFdy(vVertexPositionCameraSpace.x), dFdy(vVertexPositionCameraSpace.y), dFdy(vVertexPositionCameraSpace.z));
	vec3 fragmentNormalCameraSpace = normalize(cross(fdx, fdy));
	vec3 fragmentTangentCameraSpace = normalize(fdx);
	vec3 fragmentBitangentCameraSpace = normalize(fdy);
#else
	vec3 fragmentNormalCameraSpace = normalize(vVertexNormalCameraSpace.xyz);
	vec3 fragmentTangentCameraSpace = normalize(vVertexTangentCameraSpace.xyz);
	vec3 fragmentBitangentCameraSpace = normalize(vVertexBitangentCameraSpace.xyz);
#endif
mat3 TBNMatrixCameraSpace = mat3(fragmentTangentCameraSpace, fragmentBitangentCameraSpace, fragmentNormalCameraSpace);
`;

var compute_fragment_render_mode = `
#ifdef RENDER_MODE
	#if RENDER_MODE == 1
		#ifdef TESTING
			gl_FragColor = vec4(abs(vVertexNormalModelSpace.xyz), 1.0);
		#endif
	#elif RENDER_MODE == 2
		gl_FragColor = vec4(abs(vVertexNormalWorldSpace), 1.0);
	#elif RENDER_MODE == 3
		gl_FragColor = vec4(abs(vVertexNormalCameraSpace), 1.0);
	#elif RENDER_MODE == 4
		#ifdef TESTING
			gl_FragColor = vec4(abs(vVertexTangentModelSpace.xyz), 1.0);
		#endif
	#elif RENDER_MODE == 5
		#ifdef TESTING
			gl_FragColor = vec4(abs(vVertexTangentWorldSpace), 1.0);
		#endif
	#elif RENDER_MODE == 6
		gl_FragColor = vec4(abs(vVertexTangentCameraSpace), 1.0);
	#elif RENDER_MODE == 7
		#ifdef TESTING
			gl_FragColor = vec4(abs(vVertexBitangentWorldSpace), 1.0);
		#endif
	#elif RENDER_MODE == 8
		gl_FragColor = vec4(abs(vVertexBitangentCameraSpace), 1.0);
	#elif RENDER_MODE == 10
		gl_FragColor = vec4(tangentSpaceNormal, 1.0);
	#elif RENDER_MODE == 11
		gl_FragColor = vec4(abs(fragmentNormalCameraSpace), 1.0);
	#elif RENDER_MODE == 12
		#ifdef USE_NORMAL_MAP
			gl_FragColor = vec4(texelNormal.rgb, 1.0);
		#else
			gl_FragColor = vec4(0.5, 0.5, 1.0, 1.0);
		#endif
	#endif
#endif
`;

var compute_fragment_self_illum_mask_map = `
#ifdef USE_SELF_ILLUM_MASK_MAP
	vec4 texelSelfIllumMask = texture2D(selfIllumMaskMap, vTextureCoord.xy);
#endif
`;

var compute_fragment_standard = `
#include compute_fragment_depth
#include compute_silhouette_color
#ifdef PICKING_MODE
	gl_FragColor = vec4(uPickingColor, 1.0);
#endif
#ifdef WRITE_DEPTH_TO_COLOR
	#ifdef IS_POINT_LIGHT
		float dist = length( vVertexPositionWorldSpace.xyz - uLightPosition );
		dist = ( dist - uLightNear ) / ( uLightFar - uLightNear );
		gl_FragColor = PackDepth32(saturate(dist));
	#else
		gl_FragColor = PackDepth32(0.5 * vPosition.z / vPosition.w + 0.5);
	#endif
#endif
#ifdef RENDER_HIGHLIGHT
	#ifdef HIGHLIGHT
		gl_FragColor.rgb *= 1.5;
	#endif
#endif
#ifdef UNPACK_DEPTH_COLOR
	gl_FragColor = vec4(vec3(1.0 - UnpackDepth32(texelColor)), 1.0);
#endif
#ifdef DESATURATE
	float luminance = 0.2126 * gl_FragColor.r + 0.7152 * gl_FragColor.g + 0.0722 * gl_FragColor.b * 0.0;
	gl_FragColor = vec4(vec3(luminance), gl_FragColor.a);
#endif
#if defined(TONE_MAPPING) && TONE_MAPPING > 0
	gl_FragColor.rgb = ToneMapping(gl_FragColor.rgb);
#endif
`;

var compute_lights_setup_vars = `
	IncidentLight directLight;

	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );

	GeometricContext geometry;
	geometry.position = vVertexPositionCameraSpace.xyz;
	geometry.normal = fragmentNormalCameraSpace;
	geometry.viewDir = normalize(-vVertexPositionCameraSpace.xyz);
	//TODO: check geometry.worldNormal
	geometry.worldNormal = normalize(vVertexNormalWorldSpace);
	geometry.worldNormal = normalize(fragmentNormalCameraSpace);

`;

var compute_vertex_log_depth = `
#ifdef USE_LOG_DEPTH
	vFragDepth = 1.0 + gl_Position.w;
#endif
`;

var compute_vertex_projection = `
#ifdef SKIP_PROJECTION
	gl_Position = vec4(aVertexPosition, 1.0);
#else
	vec4 vertexPositionCameraSpace = uViewMatrix * vertexPositionWorldSpace;//TODOv3: use projectionview matrix instead ?
	vec3 vertexNormalCameraSpace = uNormalMatrix * vertexNormalWorldSpace;//TODOv3: use projectionview matrix instead ?
	vec3 vertexTangentCameraSpace = uNormalMatrix * vertexTangentWorldSpace;//TODOv3: use projectionview matrix instead ?
	vec3 vertexBitangentCameraSpace = uNormalMatrix * vertexBitangentWorldSpace;//TODOv3: use projectionview matrix instead ?
	gl_Position = uProjectionMatrix * vertexPositionCameraSpace;

	vVertexPositionCameraSpace = vertexPositionCameraSpace;
	vVertexNormalCameraSpace = vertexNormalCameraSpace;
	vVertexTangentCameraSpace = vertexTangentCameraSpace;
	vVertexBitangentCameraSpace = vertexBitangentCameraSpace;
#endif
`;

var compute_vertex_shadow_mapping = `
#ifdef USE_SHADOW_MAPPING
	vec4 shadowWorldPosition;
	#if (NUM_POINT_LIGHT_SHADOWS > 0)
		for (int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++) {
			shadowWorldPosition = vertexPositionWorldSpace;
			vPointShadowCoord[i] = uPointShadowMatrix[i] * shadowWorldPosition;
		}
	#endif
	#if (NUM_SPOT_LIGHT_SHADOWS > 0)
		for (int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++) {
			shadowWorldPosition = vertexPositionWorldSpace;
			vSpotShadowCoord[i] = uSpotShadowMatrix[i] * shadowWorldPosition;
		}
	#endif
#endif
`;

var compute_vertex_skinning = `
#ifdef SKELETAL_MESH
	#ifdef HARDWARE_SKINNING
		mat4 skinMat = accumulateSkinMat();
		vec4 vertexPositionWorldSpace = skinMat * vertexPositionModelSpace;
		vec3 vertexNormalWorldSpace = vec3(skinMat * vertexNormalModelSpace).xyz;
		vec3 vertexTangentWorldSpace = vec3(skinMat * vertexTangentModelSpace).xyz;
	#else
		#define vertexPositionWorldSpace vertexPositionModelSpace
		#define vertexNormalWorldSpace vertexNormalModelSpace.xyz
		#define vertexTangentWorldSpace vertexTangentModelSpace.xyz
	#endif
#else
	vec4 vertexPositionWorldSpace = uModelMatrix * vertexPositionModelSpace;
	vec3 vertexNormalWorldSpace = vec3(uModelMatrix * vertexNormalModelSpace).xyz;
	vec3 vertexTangentWorldSpace = vec3(uModelMatrix * vertexTangentModelSpace).xyz;
#endif
vVertexPositionWorldSpace = vertexPositionWorldSpace;
vVertexNormalWorldSpace = vertexNormalWorldSpace;
#ifdef TESTING
	vVertexTangentWorldSpace = vertexTangentWorldSpace;
#endif

#ifdef USE_VERTEX_TANGENT
	vec3 vertexBitangentWorldSpace = cross( vertexNormalWorldSpace, vertexTangentWorldSpace) * aVertexTangent.w;
#else
	//TODO: compute it properly
	vec3 vertexBitangentWorldSpace = cross( vertexNormalWorldSpace, vertexTangentWorldSpace) * -1.0;
#endif
#ifdef TESTING
	vVertexBitangentWorldSpace = vertexBitangentWorldSpace;
#endif
`;

var compute_vertex_standard = `
#ifdef WRITE_DEPTH_TO_COLOR
	vPosition = gl_Position;
#endif
`;

var compute_vertex_uv = `
#ifdef USE_TEXTURE_TRANSFORM
	vTextureCoord.xy = (uTextureTransform * vec4(aTextureCoord, 1.0, 1.0)).st;
#else
	vTextureCoord.xy = aTextureCoord;
#endif
`;

var compute_vertex_uv2 = `
#ifdef USE_TEXTURE2_TRANSFORM
	vTexture2Coord.xy = (uTexture2Transform * vec4(aTextureCoord, 1.0, 1.0)).st;
#else
	vTexture2Coord.xy = aTextureCoord;
#endif
`;

var compute_vertex = `
vec4 vertexPositionModelSpace = vec4(aVertexPosition, 1.0);
#ifdef REVERSE_CULLING
	vec4 vertexNormalModelSpace = vec4(-aVertexNormal, 0.0);
#else
	vec4 vertexNormalModelSpace = vec4(aVertexNormal, 0.0);
#endif

#ifdef USE_VERTEX_TANGENT
	vec4 vertexTangentModelSpace = vec4(aVertexTangent.xyz, 0.0);
#else
	//TODO: compute it properly
	vec4 vertexTangentModelSpace = vec4(0.0, 1.0, 0.0, 0.0);
#endif

vVertexNormalModelSpace = vertexNormalModelSpace;
vVertexTangentModelSpace = vertexTangentModelSpace;
`;

Includes['compute_fragment_alpha_test'] = compute_fragment_alpha_test;
Includes['compute_fragment_ao_map'] = compute_fragment_ao_map;
Includes['compute_fragment_color_map'] = compute_fragment_color_map;
Includes['compute_fragment_depth'] = compute_fragment_depth;
Includes['compute_fragment_exponent_map'] = compute_fragment_exponent_map;
Includes['compute_fragment_lights'] = compute_fragment_lights;
Includes['compute_fragment_log_depth'] = compute_fragment_log_depth;
Includes['compute_fragment_normal'] = compute_fragment_normal;
Includes['compute_fragment_render_mode'] = compute_fragment_render_mode;
Includes['compute_fragment_self_illum_mask_map'] = compute_fragment_self_illum_mask_map;
Includes['compute_fragment_standard'] = compute_fragment_standard;
Includes['compute_lights_setup_vars'] = compute_lights_setup_vars;
Includes['compute_vertex_log_depth'] = compute_vertex_log_depth;
Includes['compute_vertex_projection'] = compute_vertex_projection;
Includes['compute_vertex_shadow_mapping'] = compute_vertex_shadow_mapping;
Includes['compute_vertex_skinning'] = compute_vertex_skinning;
Includes['compute_vertex_standard'] = compute_vertex_standard;
Includes['compute_vertex_uv'] = compute_vertex_uv;
Includes['compute_vertex_uv2'] = compute_vertex_uv2;
Includes['compute_vertex'] = compute_vertex;

var declare_camera_position = `
uniform vec3 uCameraPosition;
`;

var declare_fragment_alpha_test = `
#ifdef ALPHA_TEST
	uniform float uAlphaTestReference;
#endif
`;

var declare_fragment_ao_map = `
#ifdef USE_AO_MAP
	uniform sampler2D aoMap;
#endif
`;

var declare_fragment_exponent_map = `
#ifdef USE_EXPONENT_MAP
	uniform sampler2D exponentMap;
#endif
`;

var declare_fragment_light_warp = `
#ifndef SKIP_LIGHT_WARP
	#ifdef USE_LIGHT_WARP_MAP
		uniform sampler2D lightWarpMap;

		vec3 getLightWarp(const in float value) {
			return texture2D(lightWarpMap, vec2(value, 0.5) ).rgb;
		}
	#endif
#endif
`;

var declare_fragment_self_illum_mask_map = `
#ifdef USE_SELF_ILLUM_MASK_MAP
	uniform sampler2D selfIllumMaskMap;
#endif
`;

var declare_lights = `
#include luminance
#include declare_fragment_light_warp
#ifdef WRITE_DEPTH_TO_COLOR
	#ifdef IS_POINT_LIGHT
		uniform vec3 uLightPosition;
		uniform float uLightNear;
		uniform float uLightFar;
	#endif
#endif
#ifndef NUM_POINT_LIGHTS
	#define NUM_POINT_LIGHTS 0
#endif
#ifndef NUM_SPOT_LIGHTS
	#define NUM_SPOT_LIGHTS 0
#endif
#define NUM_HEMI_LIGHTS 0

uniform vec3 lightProbe[ 9 ];

	uniform vec3 uAmbientLight;
	struct GeometricContext {
		vec3 position;
		vec3 normal;
		vec3 worldNormal;
		vec3 viewDir;
	};

	struct PointLight {
		vec3 position;
		vec3 color;
		float range;
	};

	struct IncidentLight {//TODO: change structure name
		vec3 color;
		vec3 direction;
		bool visible;
	};



	struct ReflectedLight {
		vec3 directDiffuse;
		vec3 directSpecular;
		vec3 indirectDiffuse;
		vec3 indirectSpecular;
	};

#if NUM_POINT_LIGHTS > 0
	uniform PointLight uPointLights[NUM_POINT_LIGHTS];
#endif

	float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {

	#if defined ( PHYSICALLY_CORRECT_LIGHTS )

		// based upon Frostbite 3 Moving to Physically-based Rendering
		// page 32, equation 26: E[window1]
		// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
		// this is intended to be used on spot and point lights who are represented as luminous intensity
		// but who must be converted to luminous irradiance for surface lighting calculation
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );

		if( cutoffDistance > 0.0 ) {

			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );

		}

		return distanceFalloff;

	#else

		if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {

			return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );

		}

		return 1.0;

	#endif

	}

vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {

	// normal is assumed to have unit length

	float x = normal.x, y = normal.y, z = normal.z;

	// band 0
	vec3 result = shCoefficients[ 0 ] * 0.886227;

	// band 1
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;

	// band 2
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );

	return result;

}

vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {

	vec3 irradiance = shGetIrradianceAt( geometry.worldNormal, lightProbe );

	return irradiance;

}

vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {

	vec3 irradiance = ambientLightColor;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI;

	#endif

	return irradiance;

}

	void computePointLightIrradiance(const PointLight pointLight, const GeometricContext geometry, out IncidentLight directLight) {
		vec3 lightVector = pointLight.position - geometry.position;
		directLight.direction = normalize(lightVector);
		float lightDistance = length(lightVector);
		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.range, 1.0/*pointLight.decay*/);


/*

		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );

		float lightDistance = length( lVector );

		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );
		*/


	}

#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float range;
		float innerAngleCos;
		float outerAngleCos;
	};
	uniform SpotLight uSpotLights[NUM_SPOT_LIGHTS];

	void computeSpotLightIrradiance(const SpotLight spotLight, const GeometricContext geometry, out IncidentLight directLight) {
		vec3 lightVector = spotLight.position - geometry.position;
		directLight.direction = normalize(lightVector);
		float lightDistance = length(lightVector);
		float angleCos = dot( directLight.direction, spotLight.direction );

		if (angleCos > spotLight.outerAngleCos ) {
			float spotEffect = smoothstep( spotLight.outerAngleCos, spotLight.innerAngleCos, angleCos );
			directLight.color = spotLight.color;
			directLight.color *= spotEffect;
			directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.range, 1.0/*spotLight.decay*/);
			directLight.visible = true;
		} else {
			directLight.color = vec3(0.0);
			directLight.visible = false;
		}

/*

		float angleCos = dot( directLight.direction, spotLight.direction );

		if ( angleCos > spotLight.coneCos ) {

			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );

			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;

		} else {

			directLight.color = vec3( 0.0 );
			directLight.visible = false;

		}
*/
	}
#endif

struct BlinnPhongMaterial {

	vec3	diffuseColor;
	vec3	specularColor;
	float	specularShininess;
	float	specularStrength;

};
vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {

	// Original approximation by Christophe Schlick '94
	// float fresnel = pow( 1.0 - dotLH, 5.0 );

	// Optimized variant (presented by Epic at SIGGRAPH '13)
	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );

	return ( 1.0 - specularColor ) * fresnel + specularColor;

}

float G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {

	// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)
	return 0.25;

}

float D_BlinnPhong( const in float shininess, const in float dotNH ) {

	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH + EPSILON, shininess );

}
vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {

	return RECIPROCAL_PI * diffuseColor;

}vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {

	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );

	//float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );
	//float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );

	vec3 F = F_Schlick( specularColor, dotLH );

	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

	float D = D_BlinnPhong( shininess, dotNH );

	return F * ( G * D );

}
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

	#ifdef TOON

		vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;

	#else

		float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
		vec3 irradiance = dotNL * directLight.color;

	#endif

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI; // punctual light

	#endif

	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;

}

void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

}




#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
`;

var declare_log_depth = `
#ifdef USE_LOG_DEPTH
	uniform float uProjectionLogDepth;
#endif
`;

var declare_matrix_uniforms = `
uniform mat4 uModelMatrix;
uniform mat4 uViewMatrix;
uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat4 uViewProjectionMatrix;
uniform mat3 uNormalMatrix;
`;

var declare_shadow_mapping = `
#ifdef USE_SHADOW_MAPPING
	#if (NUM_SPOT_LIGHT_SHADOWS > 0)
		struct SpotLightShadow{
			bool enabled;
			vec2 mapSize;
		};
		uniform mat4 uSpotShadowMatrix[NUM_SPOT_LIGHT_SHADOWS];
		uniform sampler2D uSpotShadowMap[NUM_SPOT_LIGHT_SHADOWS];
		varying vec4 vSpotShadowCoord[NUM_SPOT_LIGHT_SHADOWS];
		uniform SpotLightShadow uSpotLightShadows[NUM_SPOT_LIGHT_SHADOWS];
	#endif

	#if (NUM_POINT_LIGHT_SHADOWS > 0)
		struct PointLightShadow{
			bool enabled;
			vec2 mapSize;
			float near;
			float far;
		};
		uniform mat4 uPointShadowMatrix[NUM_POINT_LIGHT_SHADOWS];
		uniform sampler2D uPointShadowMap[NUM_POINT_LIGHT_SHADOWS];
		varying vec4 vPointShadowCoord[NUM_POINT_LIGHT_SHADOWS];
		uniform PointLightShadow uPointLightShadows[NUM_POINT_LIGHT_SHADOWS];
	#endif

	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, UnpackDepth32( texture2D( depths, uv )) );
	}

	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;

		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;

		if (shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0 && shadowCoord.z <= 1.0) {
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z - 0.00001);
		}

		return shadow;
	}

	// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D
	// vector suitable for 2D texture mapping. This code uses the following layout for the
	// 2D texture:
	//
	// xzXZ
	//  y Y
	//
	// Y - Positive y direction
	// y - Negative y direction
	// X - Positive x direction
	// x - Negative x direction
	// Z - Positive z direction
	// z - Negative z direction
	//
	// Source and test bed:
	// https://gist.github.com/tschw/da10c43c467ce8afd0c4

	vec2 cubeToUV( vec3 v, float texelSizeY ) {

		// Number of texels to avoid at the edge of each square

		vec3 absV = abs( v );

		// Intersect unit cube

		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;

		// Apply scale to avoid seams

		// two texels less per square (one texel will do for NEAREST)
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );

		// Unwrap

		// space: -1 ... 1 range for each square
		//
		// #X##		dim    := ( 4 , 2 )
		//  # #		center := ( 1 , 1 )

		vec2 planar = v.xy;

		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;

		if ( absV.z >= almostOne ) {

			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;

		} else if ( absV.x >= almostOne ) {

			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;

		} else if ( absV.y >= almostOne ) {

			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;

		}

		// Transform to UV space

		// scale := 0.5 / dim
		// translate := ( center + 0.5 ) / dim
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );

	}

	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {

		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize/* * vec2( 4.0, 2.0 ) */);

		// for point lights, the uniform @vShadowCoord is re-purposed to hold
		// the vector from the light to the world-space position of the fragment.
		vec3 lightToPosition = shadowCoord.xyz;

		// dp = normalized distance from light to fragment position
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?
		dp += shadowBias;
		dp -= 0.001;

		// bd3D = base direction 3D
		vec3 bd3D = normalize( lightToPosition );

		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )

			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;

			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );

		#else // no percentage-closer filtering

			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp  + 0.00001);

		#endif

	}

#endif
`;

var declare_vertex_skinning = `
#ifdef HARDWARE_SKINNING
	#ifdef SKELETAL_MESH
		uniform sampler2D uBoneMatrix;

		mat4 getBoneMat(int boneId) {
			mat4 result = mat4(0.0);
			float texelPos = float(boneId) / float(MAX_HARDWARE_BONES);
			result[0] = texture2D(uBoneMatrix, vec2(0.00, texelPos));
			result[1] = texture2D(uBoneMatrix, vec2(0.25, texelPos));
			result[2] = texture2D(uBoneMatrix, vec2(0.50, texelPos));
			result[3] = texture2D(uBoneMatrix, vec2(0.75, texelPos));
			return result;
		}

		mat4 accumulateSkinMat() {
			mat4 result;
			result =		aBoneWeight.x * getBoneMat(int(aBoneIndices.x));
			result = result + aBoneWeight.y * getBoneMat(int(aBoneIndices.y));
			result = result + aBoneWeight.z * getBoneMat(int(aBoneIndices.z));
			return result;
		}
	#endif
#endif
`;

var declare_vertex_uv = `
#ifdef USE_TEXTURE_TRANSFORM
	uniform mat4 uTextureTransform;
#endif
`;

Includes['declare_camera_position'] = declare_camera_position;
Includes['declare_fragment_alpha_test'] = declare_fragment_alpha_test;
Includes['declare_fragment_ao_map'] = declare_fragment_ao_map;
Includes['declare_fragment_exponent_map'] = declare_fragment_exponent_map;
Includes['declare_fragment_light_warp'] = declare_fragment_light_warp;
Includes['declare_fragment_self_illum_mask_map'] = declare_fragment_self_illum_mask_map;
Includes['declare_lights'] = declare_lights;
Includes['declare_log_depth'] = declare_log_depth;
Includes['declare_matrix_uniforms'] = declare_matrix_uniforms;
Includes['declare_shadow_mapping'] = declare_shadow_mapping;
Includes['declare_vertex_skinning'] = declare_vertex_skinning;
Includes['declare_vertex_uv'] = declare_vertex_uv;

var common_defines = `
// conversion from glsl es1 to es3
#ifdef WEBGL2
	#define texture2D texture
	#define textureCube texture
#endif

// conversion from HLSL to glsl
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define lerp mix
#define saturate(x) clamp(x, 0.0, 1.0)
#define tex2D texture2D
#define texCUBE textureCube
#define fmod(x, y) x - y * trunc(x/y)

// Math
#define PI 3.141592653589793
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_TAU 0.15915494309189535
#define HALF_PI 1.5707963267948966
#define TWO_PI 6.283185307179586
#define TAU TWO_PI
#define EPSILON 0.000001

highp float rand(vec2 co) {
	const highp float a = 12.9898;
	const highp float b = 78.233;
	const highp float c = 43758.5453;
	highp float dt= dot(co.xy ,vec2(a,b));
	highp float sn= mod(dt,3.14);
	return fract(sin(sn) * c);
}
`;

var common_functions = `
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
`;

var common_uniforms = `
uniform vec4 uTime;
#define TIME uTime.x
#define FRAME uTime.y
uniform vec4 uResolution;
#ifdef PICKING_MODE
	uniform vec3 uPickingColor;
#endif
`;

var depth_packing = `
vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}

vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}

const float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)
const float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)

const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );

const float ShiftRight8 = 1. / 256.;

vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8; // tidy overflow
	return r * PackUpscale;
}

float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}

vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}

// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions

float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}

float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}

#define PackDepth32 packDepthToRGBA
#define UnpackDepth32 unpackRGBAToDepth
/*
vec4 PackDepth32(in float depth) {
	depth *= (256.0 * 256.0 * 256.0 - 1.0) / (256.0 * 256.0 * 256.0);
	vec4 encode = fract(depth * vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0));
	return vec4( encode.xyz - encode.yzw / 256.0, encode.w ) + 1.0 / 512.0;
}

float UnpackDepth32(in vec4 pack){
	float depth = dot( pack, 1.0 / vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0) );
	return depth * (256.0 * 256.0 * 256.0) / (256.0 * 256.0 * 256.0 - 1.0);
}*/
`;

var header_fragment = `
#ifdef WEBGL1
	#extension GL_EXT_frag_depth : enable
#endif
#include precision
#include common_defines
#include common_functions
#include common_uniforms
#include depth_packing

#ifdef WEBGL2
	#define varying in

	out vec4 fragColor;
	#define gl_FragColor fragColor
#endif

#ifdef WEBGL1
	#define gl_FragDepth gl_FragDepthEXT
#endif
#ifdef WEBGL2
	#define gl_FragDepthEXT gl_FragDepth
#endif
`;

var header_vertex = `
#include precision
#include common_defines
#include common_uniforms
#include depth_packing

#ifdef WEBGL2
	#define attribute in
	#define varying out
#endif
`;

var precision = `
#ifdef HIGH_PRECISION
	#ifdef GL_FRAGMENT_PRECISION_HIGH
		precision highp float;
		precision highp int;
	#else
		precision mediump float;
		precision mediump int;
	#endif
#endif

#ifdef MEDIUM_PRECISION
	precision mediump float;
	precision mediump int;
#endif

#ifdef LOW_PRECISION
	precision lowp float;
	precision lowp int;
#endif
`;

Includes['common_defines'] = common_defines;
Includes['common_functions'] = common_functions;
Includes['common_uniforms'] = common_uniforms;
Includes['depth_packing'] = depth_packing;
Includes['header_fragment'] = header_fragment;
Includes['header_vertex'] = header_vertex;
Includes['precision'] = precision;

var varying_standard = `
varying vec4 vVertexPositionModelSpace;
varying vec4 vVertexPositionWorldSpace;
varying vec4 vVertexPositionCameraSpace;


varying vec4 vVertexNormalModelSpace;
varying vec3 vVertexNormalWorldSpace;
varying vec3 vVertexNormalCameraSpace;

varying vec4 vVertexTangentModelSpace;
varying vec3 vVertexTangentWorldSpace;
varying vec3 vVertexTangentCameraSpace;

varying vec3 vVertexBitangentWorldSpace;
varying vec3 vVertexBitangentCameraSpace;

varying vec4 vTextureCoord;
varying vec4 vTexture2Coord;
#ifdef USE_VERTEX_COLOR
	varying vec4 vVertexColor;
#endif

#ifdef WRITE_DEPTH_TO_COLOR
	varying vec4 vPosition;
#endif
#ifdef USE_LOG_DEPTH
	varying float vFragDepth;
#endif
`;

Includes['varying_standard'] = varying_standard;

var declare_vertex_uv2 = `
#ifdef USE_TEXTURE2_TRANSFORM
	uniform mat4 uTexture2Transform;
#endif
`;

Includes['declare_vertex_uv2'] = declare_vertex_uv2;

var declare_attributes = `
attribute vec3 aVertexPosition;
attribute vec3 aVertexNormal;
#ifdef USE_VERTEX_TANGENT
	attribute vec4 aVertexTangent;//TODO: setup a define tangent is not used everywhere
#endif
#ifdef USE_VERTEX_COLOR
	attribute vec4 aVertexColor;
#endif
attribute vec2 aTextureCoord;
#ifdef USE_TEXTURE_COORD_2
	attribute vec2 aTextureCoord2;
#endif
#ifdef HARDWARE_SKINNING
	#ifdef SKELETAL_MESH
		attribute vec3 aBoneWeight;
		attribute vec3 aBoneIndices;
	#endif
#endif
`;

Includes['declare_attributes'] = declare_attributes;

var declare_fragment_color_map = `
#ifdef USE_COLOR_MAP
	uniform sampler2D colorMap;
#endif
#ifdef USE_COLOR_1_MAP
	uniform sampler2D color1Map;
#endif
`;

var declare_fragment_cube_map = `
#ifdef USE_CUBE_MAP
	uniform samplerCube cubeMap;
#endif
`;

var declare_fragment_detail_map = `
#ifdef USE_DETAIL_MAP
	uniform sampler2D detailMap;
#endif
`;

var declare_fragment_diffuse = `
#ifdef USE_MESH_COLOR
	uniform vec4 uColor;
#endif
`;

var declare_fragment_ibl = `
#ifdef USE_IRRADIANCE_TEXTURE
	uniform samplerCube irradianceTexture;
#endif
#ifdef USE_SPECULAR_TEXTURE
	uniform samplerCube specularTexture;
#endif
`;

var declare_fragment_mask_map = `
#ifdef USE_MASK_MAP
	uniform sampler2D maskMap;
#endif
#ifdef USE_MASK1_MAP
	uniform sampler2D mask1Map;
#endif
#ifdef USE_MASK2_MAP
	uniform sampler2D mask2Map;
#endif
`;

var declare_fragment_normal_map = `
#ifdef USE_NORMAL_MAP
	uniform sampler2D normalMap;
#endif
`;

var declare_fragment_phong_exponent_map = `
#ifdef USE_PHONG_EXPONENT_MAP
	uniform sampler2D phongExponentMap;
#endif
`;

var declare_fragment_specular_map = `
#ifdef USE_SPECULAR_MAP
	uniform sampler2D specularMap;
#endif
`;

var declare_fragment_standard = `
#include declare_fragment_tone_mapping
`;

var declare_fragment_tone_mapping = `

#ifndef TONE_MAPPING_EXPOSURE
	#define TONE_MAPPING_EXPOSURE 1.0
#endif
#ifdef TONE_MAPPING
#if TONE_MAPPING == 0
	vec3 ToneMapping( vec3 color ) {
		return color;
	}
#endif
#if TONE_MAPPING == 2 // Reinhard
	vec3 ToneMapping( vec3 color ) {
		color *= TONE_MAPPING_EXPOSURE;
		return saturate( color / ( vec3( 1.0 ) + color ) );

	}
#endif
#endif

`;

var declare_fragment_uniforms = `
uniform vec4 uColor;
`;

var declare_vertex_detail_uv = `
#ifdef USE_DETAIL_TEXTURE_TRANSFORM
	uniform mat4 uDetailTextureTransform;
#endif
`;

Includes['declare_fragment_color_map'] = declare_fragment_color_map;
Includes['declare_fragment_cube_map'] = declare_fragment_cube_map;
Includes['declare_fragment_detail_map'] = declare_fragment_detail_map;
Includes['declare_fragment_diffuse'] = declare_fragment_diffuse;
Includes['declare_fragment_ibl'] = declare_fragment_ibl;
Includes['declare_fragment_mask_map'] = declare_fragment_mask_map;
Includes['declare_fragment_normal_map'] = declare_fragment_normal_map;
Includes['declare_fragment_phong_exponent_map'] = declare_fragment_phong_exponent_map;
Includes['declare_fragment_specular_map'] = declare_fragment_specular_map;
Includes['declare_fragment_standard'] = declare_fragment_standard;
Includes['declare_fragment_tone_mapping'] = declare_fragment_tone_mapping;
Includes['declare_fragment_uniforms'] = declare_fragment_uniforms;
Includes['declare_vertex_detail_uv'] = declare_vertex_detail_uv;

var luminance = `
float luminance(vec3 color) {
	return dot(color, vec3(0.299, 0.587, 0.114));
}

float luminance(vec4 color) {
	return dot(color.rgb, vec3(0.299, 0.587, 0.114));
}
`;

var rotation_matrix = `
mat4 rotationMatrix(vec3 axis, float angle){
	axis = normalize(axis);
	float s = sin(angle);
	float c = cos(angle);
	float oc = 1.0 - c;

	return mat4(oc * axis.x * axis.x + c,			oc * axis.x * axis.y - axis.z * s,	oc * axis.z * axis.x + axis.y * s,	0.0,
				oc * axis.x * axis.y + axis.z * s,	oc * axis.y * axis.y + c,			oc * axis.y * axis.z - axis.x * s,	0.0,
				oc * axis.z * axis.x - axis.y * s,	oc * axis.y * axis.z + axis.x * s,	oc * axis.z * axis.z + c,			0.0,
				0.0,								0.0,								0.0,								1.0);
}
`;

Includes['luminance'] = luminance;
Includes['rotation_matrix'] = rotation_matrix;

var mat4_from_quat = `
#pragma once
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */

mat4 mat4FromQuat(vec4 q) {
	mat4 ret;
	float x = q.x;
	float y = q.y;
	float z = q.z;
	float w = q.w;

	float x2 = x + x;
	float y2 = y + y;
	float z2 = z + z;
	float xx = x * x2;
	float yx = y * x2;
	float yy = y * y2;
	float zx = z * x2;
	float zy = z * y2;
	float zz = z * z2;
	float wx = w * x2;
	float wy = w * y2;
	float wz = w * z2;

	ret[0][0] = 1. - yy - zz;
	ret[0][1] = yx + wz;
	ret[0][2] = zx - wy;
	ret[0][3] = 0.;
	ret[1][0] = yx - wz;
	ret[1][1] = 1. - xx - zz;
	ret[1][2] = zy + wx;
	ret[1][3] = 0.;
	ret[2][0] = zx + wy;
	ret[2][1] = zy - wx;
	ret[2][2] = 1. - xx - yy;
	ret[2][3] = 0.;
	ret[3][0] = 0.;
	ret[3][1] = 0.;
	ret[3][2] = 0.;
	ret[3][3] = 1.;

	return ret;
}
`;

var vec3_transform_quat = `
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
vec3 vec3_transformQuat (vec3 a, vec4 q) {
	vec3 ret;
	float qx = q.x;
	float qy = q.y;
	float qz = q.z;
	float qw = q.w;

	float x = a.x;
	float y = a.y;
	float z = a.z;

	float uvx = qy * z - qz * y;
	float uvy = qz * x - qx * z;
	float uvz = qx * y - qy * x;

	float uuvx = qy * uvz - qz * uvy;
	float uuvy = qz * uvx - qx * uvz;
	float uuvz = qx * uvy - qy * uvx;

	float w2 = qw * 2.0;
	uvx *= w2;
	uvy *= w2;
	uvz *= w2;

	uuvx *= 2.0;
	uuvy *= 2.0;
	uuvz *= 2.0;

	// return vec3.add(out, a, vec3.add(out, uv, uuv));

	ret.x = x + uvx + uuvx;
	ret.y = y + uvy + uuvy;
	ret.z = z + uvz + uuvz;

	return ret;
}
`;

Includes['mat4_from_quat'] = mat4_from_quat;
Includes['vec3_transform_quat'] = vec3_transform_quat;

var postprocessing_vertex = `
#include declare_attributes
#include declare_matrix_uniforms

#include varying_standard

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_projection
}
`;

Includes['postprocessing_vertex'] = postprocessing_vertex;

var sample_color_texture = `
#ifdef USE_COLOR_TEXTURE
	vec3 colorTexel = texture2D(uColorTexture, vTextureCoord.xy).rgb;
#else
	vec3 colorTexel = uColor.rgb;
#endif
`;

var sample_cube_uv_mapping = `
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0

	// These shader functions convert between the UV coordinates of a single face of
	// a cubemap, the 0-5 integer index of a cube face, and the direction vector for
	// sampling a textureCube (not generally normalized ).

	float getFace( vec3 direction ) {

		vec3 absDirection = abs( direction );

		float face = - 1.0;

		if ( absDirection.x > absDirection.z ) {

			if ( absDirection.x > absDirection.y )

				face = direction.x > 0.0 ? 0.0 : 3.0;

			else

				face = direction.y > 0.0 ? 1.0 : 4.0;

		} else {

			if ( absDirection.z > absDirection.y )

				face = direction.z > 0.0 ? 2.0 : 5.0;

			else

				face = direction.y > 0.0 ? 1.0 : 4.0;

		}

		return face;

	}

	// RH coordinate system; PMREM face-indexing convention
	vec2 getUV( vec3 direction, float face ) {

		vec2 uv;

		if ( face == 0.0 ) {

			uv = vec2( direction.z, direction.y ) / abs( direction.x ); // pos x

		} else if ( face == 1.0 ) {

			uv = vec2( - direction.x, - direction.z ) / abs( direction.y ); // pos y

		} else if ( face == 2.0 ) {

			uv = vec2( - direction.x, direction.y ) / abs( direction.z ); // pos z

		} else if ( face == 3.0 ) {

			uv = vec2( - direction.z, direction.y ) / abs( direction.x ); // neg x

		} else if ( face == 4.0 ) {

			uv = vec2( - direction.x, direction.z ) / abs( direction.y ); // neg y

		} else {

			uv = vec2( direction.x, direction.y ) / abs( direction.z ); // neg z

		}

		return 0.5 * ( uv + 1.0 );

	}

	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {

		float face = getFace( direction );

		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );

		mipInt = max( mipInt, cubeUV_minMipLevel );

		float faceSize = exp2( mipInt );

		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0; // #25071

		if ( face > 2.0 ) {

			uv.y += faceSize;

			face -= 3.0;

		}

		uv.x += face * faceSize;

		uv.x += filterInt * 3.0 * cubeUV_minTileSize;

		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );

		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;

		#ifdef texture2DGradEXT

			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb; // disable anisotropic filtering

		#else

			return texture2D( envMap, uv ).rgb;

		#endif

	}

	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0

	float roughnessToMip( float roughness ) {

		float mip = 0.0;

		if ( roughness >= cubeUV_r1 ) {

			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;

		} else if ( roughness >= cubeUV_r4 ) {

			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;

		} else if ( roughness >= cubeUV_r5 ) {

			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;

		} else if ( roughness >= cubeUV_r6 ) {

			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;

		} else {

			mip = - 2.0 * log2( 1.16 * roughness ); // 1.16 = 1.79^0.25
		}

		return mip;

	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		sampleDir = sampleDir.xzy * vec3(1.0, 1.0, -1.0);

		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );

		float mipF = fract( mip );

		float mipInt = floor( mip );

		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );

		if ( mipF == 0.0 ) {

			return vec4( color0, 1.0 );

		} else {

			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );

			return vec4( mix( color0, color1, mipF ), 1.0 );

		}

	}
`;

Includes['sample_color_texture'] = sample_color_texture;
Includes['sample_cube_uv_mapping'] = sample_cube_uv_mapping;

var varying_line = `
#include varying_standard
varying vec2 vUv;
#ifdef USE_DASH
	varying float vLineDistance;
#endif
`;

Includes['varying_line'] = varying_line;

var meshbasic_fs = `
#include declare_fragment_standard
#include declare_lights
#include declare_shadow_mapping

#include declare_fragment_diffuse
#include declare_fragment_color_map

#include varying_standard

void main(void) {
	#include compute_fragment_diffuse
	#include compute_fragment_color_map
#ifdef USE_COLOR_MAP
	diffuseColor *= texelColor;
#endif
	gl_FragColor = diffuseColor;

	#include compute_fragment_standard
}
`;

var meshbasic_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning

#include varying_standard

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_color
	#include compute_vertex_standard
}
`;

var meshphong_fs = `
#include declare_fragment_diffuse
#include declare_fragment_color_map
#include declare_fragment_alpha_test

#include declare_lights
#include declare_shadow_mapping
#include declare_log_depth

#include varying_standard

void main(void) {
	#include compute_fragment_diffuse
	#include compute_fragment_color_map
#ifdef USE_COLOR_MAP
	diffuseColor *= texelColor;
#endif
	#include compute_fragment_alpha_test
	#include compute_fragment_normal

/* TEST SHADING BEGIN*/
	#include compute_lights_setup_vars



	BlinnPhongMaterial material;
	material.diffuseColor = diffuseColor.rgb;//vec3(1.0);//diffuseColor.rgb;
	material.specularColor = vec3(1.0);//specular;
	material.specularShininess = 5.0;//shininess;
	material.specularStrength = 1.0;//specularStrength;

#include compute_fragment_lights

/* TEST SHADING END*/

#include compute_fragment_render_mode
/* TEST SHADING BEGIN*/
gl_FragColor.rgb = (reflectedLight.directSpecular + reflectedLight.directDiffuse + reflectedLight.indirectDiffuse);
gl_FragColor.a = diffuseColor.a;
/* TEST SHADING END*/


	#ifdef SKIP_LIGHTING
		gl_FragColor.rgb = diffuseColor.rgb;
	#else
		gl_FragColor.rgb = (reflectedLight.directSpecular + reflectedLight.directDiffuse + reflectedLight.indirectDiffuse);
	#endif
	gl_FragColor.a = diffuseColor.a;


	#include compute_fragment_standard
	#include compute_fragment_log_depth
}
`;

var meshphong_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning
#include declare_shadow_mapping
#include declare_log_depth

#include varying_standard

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_color
	#include compute_vertex_shadow_mapping
	#include compute_vertex_standard
	#include compute_vertex_log_depth
}
`;

Shaders['meshbasic.fs'] = meshbasic_fs;
Shaders['meshbasic.vs'] = meshbasic_vs;
Shaders['meshphong.fs'] = meshphong_fs;
Shaders['meshphong.vs'] = meshphong_vs;

var fullscreenquad_fs = `
uniform float opacity;
uniform sampler2D tDiffuse;

#include varying_standard

void main() {
	vec4 texel = texture2D(tDiffuse, vTextureCoord.xy);
	gl_FragColor = opacity * texel;
	gl_FragColor = vec4(vTextureCoord.xy, 0.0, 1.0);
	texel = texture2D(tDiffuse, vTextureCoord.xy);
	gl_FragColor = texel;
	#include compute_fragment_standard
}
`;

var fullscreenquad_vs = `
attribute vec3 aVertexPosition;
attribute vec2 aTextureCoord;

#include varying_standard

void main(void) {
	gl_Position = vec4(aVertexPosition.xy, 0.0, 1.0);
	vTextureCoord.xy = aVertexPosition.xy*0.5 + vec2(0.5);
}
`;

var grid_fs = `
#include declare_fragment_standard
#include declare_fragment_diffuse
#include declare_fragment_color_map

uniform float uSpacing;

#include varying_standard

void main(void) {
	#include compute_fragment_diffuse
	#include compute_fragment_color_map
#ifdef USE_COLOR_MAP
	diffuseColor *= texelColor;
#endif
	gl_FragColor = diffuseColor;

	#include compute_fragment_standard

	float halfSpacing = uSpacing * 0.5;
	float radSpacing = TWO_PI / uSpacing;

	vec4 xLines = saturate(mix(vec4(0.0), vec4(1.0), cos(vVertexPositionWorldSpace.y * radSpacing) * 100.0 - 99.0));
	vec4 yLines = saturate(mix(vec4(0.0), vec4(1.0), cos(vVertexPositionWorldSpace.x * radSpacing) * 100.0 - 99.0));


	if (abs(vVertexPositionWorldSpace.y) < halfSpacing) {
		xLines.gb = vec2(0.0);
	}
	if (abs(vVertexPositionWorldSpace.x) < halfSpacing) {
		yLines.rb = vec2(0.0);
	}

	gl_FragColor = xLines + yLines;
	gl_FragColor.rgb *= gl_FragColor.a;
}
`;

var grid_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning

#include varying_standard

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_color
}
`;

var line_fs = `
#include declare_fragment_standard
#include declare_fragment_diffuse
#include declare_lights

#ifdef USE_DASH
	uniform float dashSize;
	uniform float gapSize;
#endif

#include varying_line
void main() {
	#include compute_fragment_diffuse
	#ifdef USE_DASH
		if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps
		if ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard; // todo - FIX
	#endif

	if ( abs( vUv.y ) > 1.0 ) {
		float a = vUv.x;
		float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
		float len2 = a * a + b * b;
		if ( len2 > 1.0 ) discard;
	}
	gl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );
	#include compute_fragment_standard
}
`;

var line_vs = `
#include declare_attributes
#include declare_matrix_uniforms
		uniform float linewidth;
//		uniform vec2 resolution;

		attribute vec3 aSegmentStart;
		attribute vec3 aSegmentEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = uProjectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = uProjectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		#include varying_line

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( aVertexPosition.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( aVertexPosition.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;

			#endif

			float aspect = uResolution.x / uResolution.y;

			vUv = aTextureCoord;

			// camera space
			vec4 start = uModelViewMatrix * vec4( aSegmentStart, 1.0 );
			vec4 end = uModelViewMatrix * vec4( aSegmentEnd, 1.0 );

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( uProjectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = uProjectionMatrix * start;
			vec4 clipEnd = uProjectionMatrix * end;

			// ndc space
			vec2 ndcStart = clipStart.xy / clipStart.w;
			vec2 ndcEnd = clipEnd.xy / clipEnd.w;

			// direction
			vec2 dir = ndcEnd - ndcStart;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			// perpendicular to dir
			vec2 offset = vec2( dir.y, - dir.x );

			// undo aspect ratio adjustment
			dir.x /= aspect;
			offset.x /= aspect;

			// sign flip
			if ( aVertexPosition.x < 0.0 ) offset *= - 1.0;

			// endcaps
			if ( aVertexPosition.y < 0.0 ) {

				offset += - dir;

			} else if ( aVertexPosition.y > 1.0 ) {

				offset += dir;

			}

			// adjust for linewidth
			offset *= linewidth;

			// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
			offset /= uResolution.y;

			// select end
			vec4 clip = ( aVertexPosition.y < 0.5 ) ? clipStart : clipEnd;

			// back to clip space
			offset *= clip.w;

			clip.xy += offset;

			gl_Position = clip;

			vec4 mvPosition = ( aVertexPosition.y < 0.5 ) ? start : end; // this is an approximation


		}
`;

var shadertoy_fs = `
#define iTime TIME
#define iFrame int(FRAME)
#define iResolution vec3(uResolution)
#define iMouse vec4(0.0)
uniform sampler2D noiseMap;

#include shadertoy_code

#include varying_standard

void main(void) {
	mainImage(gl_FragColor, gl_FragCoord.xy);
	gl_FragColor.a = 1.;
	gl_FragDepth = 0.9999999;
	//#include compute_fragment_standard
}
`;

var shadertoy_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning

#include varying_standard

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
}
`;

var skybox_fs = `
#include declare_fragment_standard

#ifdef TEXTURE_MAPPING_CUBE_UV
	#include sample_cube_uv_mapping
	uniform sampler2D uCubeTexture;
#else
	uniform samplerCube uCubeTexture;
#endif

#include varying_standard

void main(void) {
	#include compute_fragment_diffuse
	#include compute_fragment_color_map
#ifdef USE_COLOR_MAP
	diffuseColor *= texelColor;
#endif
	gl_FragColor = diffuseColor;
	gl_FragColor = vec4(vTextureCoord.xy, 0., 1.);
	gl_FragColor.rgb = (normalize(vVertexPositionModelSpace.rgb));
	//gl_FragColor.rgb = texture2D(colorMap, vTextureCoord.xy);


#ifdef TEXTURE_MAPPING_CUBE_UV
	gl_FragColor = textureCubeUV(uCubeTexture, vVertexPositionModelSpace.xyz, 0.);
#else
	gl_FragColor = textureCube(uCubeTexture, vVertexPositionModelSpace.xyz);
#endif

	#include compute_fragment_standard
}
`;

var skybox_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning

#include varying_standard

void main(void) {
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_color

	vVertexPositionModelSpace = vertexPositionModelSpace;

	#include compute_vertex_standard
}
`;

Shaders['fullscreenquad.fs'] = fullscreenquad_fs;
Shaders['fullscreenquad.vs'] = fullscreenquad_vs;
Shaders['grid.fs'] = grid_fs;
Shaders['grid.vs'] = grid_vs;
Shaders['line.fs'] = line_fs;
Shaders['line.vs'] = line_vs;
Shaders['shadertoy.fs'] = shadertoy_fs;
Shaders['shadertoy.vs'] = shadertoy_vs;
Shaders['skybox.fs'] = skybox_fs;
Shaders['skybox.vs'] = skybox_vs;

var meshbasicpbr_fs = `
#include declare_fragment_standard
#include declare_lights
#include declare_shadow_mapping
#include declare_camera_position

#include declare_fragment_diffuse
#include declare_fragment_color_map
#include declare_fragment_uniforms
uniform float uMetalness;
uniform float uRoughness;
uniform sampler2D uColorTexture;
uniform sampler2D uNormalTexture;
uniform sampler2D uMetalnessTexture;
uniform sampler2D uRoughnessTexture;

#include declare_fragment_ibl
#include compute_pbr

#include varying_standard

void main(void) {
	#include compute_fragment_normal
	#include compute_fragment_normal_world_space
	#include compute_fragment_diffuse
	#include compute_fragment_color_map
#ifdef USE_COLOR_MAP
	diffuseColor *= texelColor;
#endif
	gl_FragColor = diffuseColor;

const int NumLights = 1;
/*PBRLight lights[NUM_PBR_LIGHTS] = PBRLight[](PBRLight(vec3(0, -1000, 0), vec3(1)));*/
#include sample_color_texture
vec3 albedo = pow(colorTexel, vec3(2.2));

const vec3 Fdielectric = vec3(0.04);
float metalness = 0.;
float roughness = 0.;
#ifdef USE_METALNESS_TEXTURE
	vec4 metalnessTexel = texture2D(uMetalnessTexture, vTextureCoord.xy);
	metalness = metalnessTexel.r;
#else
	metalness = uMetalness;
#endif
#ifdef USE_ROUGHNESS_TEXTURE
	vec4 roughnessTexel = texture2D(uRoughnessTexture, vTextureCoord.xy);
	roughness = roughnessTexel.r;
#else
	roughness = uRoughness;
#endif


	#ifdef USE_NORMAL_TEXTURE
		vec4 normalTexel = texture2D(uNormalTexture, vTextureCoord.xy);
		vec3 N = normalTexel.rgb * 2.0 - 1.0;
	#else
		vec3 N = vec3(0., 0., 1.0);
	#endif


	N = normalize(TBNMatrixWorldSpace * N);

vec3 F0 = mix(Fdielectric, albedo, metalness);
	#include compute_fragment_standard
	gl_FragColor.rgb = vec3(metalness * roughness);
#if NUM_PBR_LIGHTS > 0
	vec3 color = computePBR(uPbrLights, N, uCameraPosition, vVertexPositionWorldSpace.xyz, F0, metalness, roughness, albedo, 1.);
	color = color / (color + vec3(1.0));
	// gamma correct
	color = pow(color, vec3(1.0/2.2));
	gl_FragColor.rgb = color;
#endif
}
`;

var meshbasicpbr_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning

#include varying_standard

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_color
	#include compute_vertex_standard
}
`;

Shaders['meshbasicpbr.fs'] = meshbasicpbr_fs;
Shaders['meshbasicpbr.vs'] = meshbasicpbr_vs;

var copy_fs = `
#define USE_COLOR_MAP
#include declare_fragment_color_map

#include varying_standard

void main(void) {
	#include compute_fragment_color_map
	gl_FragColor = texelColor;
}
`;

var copy_vs = `
#include postprocessing_vertex
`;

var crosshatch_fs = `

#define USE_COLOR_MAP
#include declare_fragment_color_map

#include varying_standard

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
	vec2 uv = fragCoord.xy / uResolution.xy;

	float lum = length(texture(colorMap, uv).rgb);

	fragColor = vec4(1.0, 1.0, 1.0, 1.0);

	if (lum < 1.00) {
		if (mod(fragCoord.x + fragCoord.y, 10.0) == 0.0) {
			fragColor = vec4(0.0, 0.0, 0.0, 1.0);
		}
	}

	if (lum < 0.75) {
		if (mod(fragCoord.x - fragCoord.y, 10.0) == 0.0) {
			fragColor = vec4(0.0, 0.0, 0.0, 1.0);
		}
	}

	if (lum < 0.50) {
		if (mod(fragCoord.x + fragCoord.y - 5.0, 10.0) == 0.0) {
			fragColor = vec4(0.0, 0.0, 0.0, 1.0);
		}
	}

	if (lum < 0.3) {
		if (mod(fragCoord.x - fragCoord.y - 5.0, 10.0) == 0.0) {
			fragColor = vec4(0.0, 0.0, 0.0, 1.0);
		}
	}
}


void main(void) {
	mainImage(gl_FragColor, gl_FragCoord.xy);
}
`;

var crosshatch_vs = `
#include postprocessing_vertex
`;

var edgedetection_fs = `
#define USE_COLOR_MAP
#include declare_fragment_color_map

uniform vec2 uTexSize;
uniform vec3 uVisibleEdgeColor;
uniform vec3 uHiddenEdgeColor;

#include varying_standard

void main(void) {
	vec2 invSize = 1.0 / uTexSize;
	vec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);
	vec4 c1 = texture2D( colorMap, vTextureCoord.xy + uvOffset.xy);
	vec4 c2 = texture2D( colorMap, vTextureCoord.xy - uvOffset.xy);
	vec4 c3 = texture2D( colorMap, vTextureCoord.xy + uvOffset.yw);
	vec4 c4 = texture2D( colorMap, vTextureCoord.xy - uvOffset.yw);
	float diff1 = (c1.r - c2.r)*0.5;
	float diff2 = (c3.r - c4.r)*0.5;
	float d = length( vec2(diff1, diff2) );
	float a1 = min(c1.g, c2.g);
	float a2 = min(c3.g, c4.g);
	float visibilityFactor = min(a1, a2);
	vec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? uVisibleEdgeColor : uHiddenEdgeColor;
	gl_FragColor = vec4(edgeColor, 1.0) * vec4(d);

	//#include compute_fragment_standard
}
`;

var edgedetection_vs = `
#include declare_attributes
#include declare_matrix_uniforms

#include varying_standard

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_projection
}
`;

var grain_fs = `
#define USE_COLOR_MAP
#include declare_fragment_color_map

uniform float uGrainIntensity;

#include varying_standard

void main(void) {
	float grain = 1.0 - rand(vTextureCoord.xy) * uGrainIntensity;

	gl_FragColor = texture2D(colorMap, vTextureCoord.xy) * vec4(grain, grain, grain, 1.0);
}
`;

var grain_vs = `
#include postprocessing_vertex
`;

var oldmovie_fs = `
#define iTime TIME
#define iFrame int(FRAME)
#define iResolution vec2(uResolution)
#define iMouse vec3(0.0)
uniform sampler2D noiseMap;


#define USE_COLOR_MAP
#include declare_fragment_color_map

uniform float uGrainIntensity;

#include varying_standard

//
// Description : Array and textureless GLSL 2D simplex noise function.
//      Author : Ian McEwan, Ashima Arts.
//  Maintainer : stegu
//     Lastmod : 20110822 (ijm)
//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
//               Distributed under the MIT License. See LICENSE file.
//               https://github.com/ashima/webgl-noise
//               https://github.com/stegu/webgl-noise
//

vec3 mod289(vec3 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec2 mod289(vec2 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec3 permute(vec3 x) {
  return mod289(((x*34.0)+10.0)*x);
}

float snoise(vec2 v)
  {
  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                     -0.577350269189626,  // -1.0 + 2.0 * C.x
                      0.024390243902439); // 1.0 / 41.0
// First corner
  vec2 i  = floor(v + dot(v, C.yy) );
  vec2 x0 = v -   i + dot(i, C.xx);

// Other corners
  vec2 i1;
  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0
  //i1.y = 1.0 - i1.x;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  // x0 = x0 - 0.0 + 0.0 * C.xx ;
  // x1 = x0 - i1 + 1.0 * C.xx ;
  // x2 = x0 - 1.0 + 2.0 * C.xx ;
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;

// Permutations
  i = mod289(i); // Avoid truncation effects in permutation
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
		+ i.x + vec3(0.0, i1.x, 1.0 ));

  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
  m = m*m ;
  m = m*m ;

// Gradients: 41 points uniformly over a line, mapped onto a diamond.
// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)

  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;

// Normalise gradients implicitly by scaling m
// Approximation of: m *= inversesqrt( a0*a0 + h*h );
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );

// Compute final noise value at P
  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}


vec4 SCREEN(in vec4 src, in vec4 dst){
    return ( src + dst ) - ( src * dst );
}

vec3 Blur(sampler2D tex, vec2 uv, float blurSize, float directions, float quality){


    vec2 radius = blurSize/iResolution.xy;
    vec3 res = texture(tex, uv).rgb;
    for(float i=1.0/quality; i<=1.0; i+=1.0/quality)
    {
        for( float d=0.0; d<TWO_PI; d+=TWO_PI/directions)
        {
			res += texture( tex, uv+vec2(cos(d),sin(d))*radius*i).rgb;
        }
    }
    res /= (quality-1.) * directions;
    return res;
}
vec3 Blur(sampler2D tex, vec2 uv){
    return Blur(tex,uv, 4.,16.,4.);
}

vec2 ShakeUV(vec2 uv, float time){
    uv.x += 0.002 * sin(time*3.141) * sin(time*14.14);
    uv.y += 0.002 * sin(time*1.618) * sin(time*17.32);
    return uv;
}

float filmDirt(vec2 uv, float time){
    uv += time * sin(time) * 10.;
    float res = 1.0;

    float rnd = fract(sin(time+1.)*31415.);
    if(rnd>0.3){
        float dirt =
            texture(colorMap,uv*0.1).r *
            texture(colorMap,uv*0.01).r *
            texture(colorMap,uv*0.002).r *
            1.0;
        res = 1.0 - smoothstep(0.4,0.6, dirt);
    }
    return res;
}

float FpsTime(float time, float fps){
    time = mod(time, 60.0);
    time = float(int(time*fps)) / fps;
    return time;
}


void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec2 uv = fragCoord/iResolution.xy;
    vec2 mUV = iMouse.xy/iResolution.xy;

    mUV = vec2(0.5,0.7); /*fix mouse pos for thumbnail*/

    vec4 col;

    float time = FpsTime(iTime, 12.);
    fragColor = vec4(mod(uv.x+time*0.5, 0.1)*10.);
    //return; /* Debug FpsTime */

    vec2 suv = ShakeUV(uv, time);
    fragColor = vec4(mod(suv.xy,0.1)*10., 0., 1.0);
    //return; /* Debug ShakeUV */

    //float grain = mix(1.0, fract(sin(dot(suv.xy+time,vec2(12.9898,78.233))) * 43758.5453), 0.25); /* random */
    float grain = mix(1.0, snoise(suv.xy*1234.), 0.15); /* simplex noise */
    fragColor = vec4(vec3(grain), 1.0);
    //return; /* Debug grain */

    vec3 color = texture(colorMap, suv).rgb;
    color *= grain;

    float Size = mUV.x * 8.;
    float Directions = 16.0;
    float Quality = 3.0;
    vec3 blur = Blur(colorMap, suv, Size, Directions, Quality);
    blur *= grain;

    float Threshold = mUV.y;
    vec3 FilterRGB = normalize(vec3(1.5,1.2,1.0));
    float HighlightPower = 3.0;
    HighlightPower *= 1. + fract(sin(time)*3.1415) * 0.3;
    vec3 highlight = clamp(color -Threshold,0.0,1.0)/(1.0-Threshold);
    highlight = blur * Threshold * FilterRGB * HighlightPower;

    /* dirt */
    float dirt = filmDirt(uv, time);
    fragColor = vec4(vec3(dirt), 1.0);
    //return; /* Debug dirt */

    col = SCREEN(vec4(color,1.0), vec4(highlight,1.0));
    //col = vec4(highlight,1.0);
    //col = vec4(blur,1.0);
    col *= dirt;

    vec2 v = uv * (1.0 - uv.yx);
    float vig = v.x*v.y * 15.0;
    vig = pow(vig, 0.5);

    fragColor = col * vig;
    //fragColor = uv.x>0.5 ? colR : colL;
    fragColor.a = 1.0;
}

void main(void) {
	mainImage(gl_FragColor, gl_FragCoord.xy);
}
`;

var oldmovie_vs = `
#include postprocessing_vertex
`;

var palette_fs = `

#define USE_COLOR_MAP
#include declare_fragment_color_map

#include varying_standard

// short version of "random pixel sprites" by stb. https://shadertoy.com/view/3ttfzl ( 2371ch )
// Inspired by https://www.youtube.com/watch?v=8wOUe32Pt-E

// What power of 2 the pixel cell sizes are increased to
const int pixel_scale = 1;

// https://lospec.com/palette-list/oil-6
// Should be sorted in increasing order by perceived luminance for best results
// Can work with up to 256 distinct colors
/*const vec4[] palette = vec4[] (
vec4(32./255., 62./255., 62./255.,1.),
vec4(244./255., 114./255., 104./255., 1.),
vec4(245./255., 229./255., 193./255., 1.)
);*/

const vec4[] palette = vec4[] (
vec4(39./255., 39./255., 68./255., 1.),
vec4(73./255., 77./255., 126./255., 1.),
vec4(139./255., 109./255., 156./255.,1.),
vec4(198./255., 159./255., 165./255., 1.),
vec4(242./255., 211./255., 171./255., 1.),
vec4(251./255., 245./255., 239./255., 1.));

// Amount of colors in the palette
// Changing this is not recommended
const int colors = int(palette.length());

// How much the dither effect spreads. By default it is set to decrease as the amount of colors increases.
// Set to 0 to disable the dithering effect for flat color areas.
const float dither_spread = 1./float(colors);

// Precomputed threshold map for dithering
const mat4x4 threshold = mat4x4(0., 8., 2., 10.,
                                12., 4., 14., 6.,
                                3.,11.,1.,9.,
                                15.,7.,13., 5.);

// Chooses a color from the palette based on the current luminance
vec4 applyPalette(float lum)
{
    lum = floor(lum * float(colors));
    return palette[int(lum)];
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // https://luka712.github.io/2018/07/01/Pixelate-it-Shadertoy-Unity/
    float pixelSizeX = 1.0 / uResolution.x;
    float pixelSizeY = 1.0 / uResolution.y;
    float cellSizeX = pow(2., float(pixel_scale)) * pixelSizeX;
    float cellSizeY = pow(2., float(pixel_scale)) * pixelSizeY;

    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = fragCoord/uResolution.xy;

    // Convert pixel coordinates to cell coordinates
    float u = cellSizeX * floor(uv.x / cellSizeX);
    float v = cellSizeY * floor(uv.y / cellSizeY);

    // get pixel information from the cell coordinates
    vec4 col = texture(colorMap, vec2(u,v));

    // https://en.wikipedia.org/wiki/Ordered_dithering
    int x = int(u / cellSizeX) % 4;
    int y = int(v / cellSizeY) % 4;
    col.r = col.r + (dither_spread * ((threshold[x][y]/16.) -.5));
    col.g = col.g + (dither_spread * ((threshold[x][y]/16.) -.5));
    col.b = col.b + (dither_spread * ((threshold[x][y]/16.) -.5));
    col.r = floor(col.r * float(colors-1) + .5)/float(colors-1);
    col.g = floor(col.g * float(colors-1) + .5)/float(colors-1);
    col.b = floor(col.b * float(colors-1) + .5)/float(colors-1);

    // Calculate luminance
    float lum = (0.299*col.r + 0.587*col.g + 0.114*col.b);

    // Apply the new color palette
    col = applyPalette(lum);

    // Output to screen
    fragColor = vec4(col);
    if (col.r <= 0.2) {
        //fragColor.a = 0.0;
    }
}

void main(void) {
	mainImage(gl_FragColor, gl_FragCoord.xy);
}
`;

var palette_vs = `
#include postprocessing_vertex
`;

var pixelate_fs = `

#define USE_COLOR_MAP
#include declare_fragment_color_map

uniform float uHorizontalTiles;

#include varying_standard

#define lum(pix) dot( pix, vec4(.3,.59,.11,0) ) //luminance
#define T(x,y) texture( colorMap, uv2 + vec2(x,y) )

void computeSquarePixel(out vec4 fragColor, in vec2 fragCoord) {
	vec2 pixelWH = vec2(uHorizontalTiles / uResolution.xy);

	vec2 xy = floor(fragCoord.xy / uHorizontalTiles) * pixelWH + pixelWH / 2.0;

	vec2 uv = (fragCoord - 0.5 * uResolution.xy) / uResolution.y * uHorizontalTiles;

	float unit = 2.0 * uHorizontalTiles / uResolution.y;

	vec2 rep = vec2(1.0, 1.); // 1.73 ~ sqrt(3)
	vec2 hrep = 0.5 * rep;
	vec2 a = mod(uv, rep) - hrep;
	vec2 b = mod(uv - hrep, rep) - hrep;
	vec2 hexUv = b;//dot(a, a) < dot(b, b) ? a : b;
	vec2 cellId = uv - hexUv;

	vec2 sampleUv = cellId / uHorizontalTiles;
	sampleUv.x *= uResolution.y / uResolution.x;

	fragColor = texture2D(colorMap, sampleUv + 0.5);
}

void computeDiamondPixel(out vec4 fragColor, in vec2 fragCoord) {
	vec2 pixelWH = vec2(uHorizontalTiles / uResolution.xy);

	vec2 xy = floor(fragCoord.xy / uHorizontalTiles) * pixelWH + pixelWH / 2.0;

	vec2 uv = (fragCoord - 0.5 * uResolution.xy) / uResolution.y * uHorizontalTiles;

	float unit = 2.0 * uHorizontalTiles / uResolution.y;

	vec2 rep = vec2(1.0, 1.); // 1.73 ~ sqrt(3)
	vec2 hrep = 0.5 * rep;
	vec2 a = mod(uv, rep) - hrep;
	vec2 b = mod(uv - hrep, rep) - hrep;
	vec2 hexUv = dot(a, a) < dot(b, b) ? a : b;
	vec2 cellId = uv - hexUv;

	vec2 sampleUv = cellId / uHorizontalTiles;
	sampleUv.x *= uResolution.y / uResolution.x;

	fragColor = texture2D(colorMap, sampleUv + 0.5);
}

void computeRoundPixel1(out vec4 fragColor, in vec2 fragCoord) {
	vec2 div = vec2(uHorizontalTiles) * uResolution.xy / uResolution.y;


	vec2 uv = fragCoord/uResolution.xy;
	vec2 uv2 = floor(uv*div)/div;

	vec2 diff = (uv-uv2)*div;

	vec4 pix = texture(colorMap, uv2);

	if ( pow(diff.x - 0.5,2.0) + pow(diff.y - 0.5,2.0) > 0.25) {

		vec4 pmax;
		vec4 pmin;
		vec2 v2 = 1.0 / div;

		if (diff.x<0.5) { v2.x = -v2.x; }
		if (diff.y<0.5) { v2.y = -v2.y; }

		vec4 p1 = texture(colorMap, uv2 + vec2( 0.0, v2.y ));
		vec4 p2 = texture(colorMap, uv2 + vec2( v2.x, 0.0 ));
		vec4 p3 = texture(colorMap, uv2 + vec2( v2.x, v2.y ));

		if ( lum(p1) > lum(p2) ) {
			pmax = p1;
			pmin = p2;
		} else {
			pmax = p2;
			pmin = p1;
		}

		if ( lum(p3) < lum(pmin) ) {
			pmin = p3;
		}

		if ( lum(pix) > lum(pmax) ) {
			pix = pmax;
		} else if ( lum(pmin) > lum(pix) ) {
			pix = pmin;
		}

	}

	fragColor = pix;
}

void computeRoundPixel2(out vec4 fragColor, in vec2 fragCoord) {
	float pixelSize = uResolution.y / uHorizontalTiles;
	vec2 U = fragCoord / pixelSize;
	vec2 div = pixelSize / uResolution.xy;
	vec2 uv2 = floor(U)*div;
	vec2 diff = fract(U);

	//checkerboard pattern : half of the pixels are not changed
	if (fract( dot(floor(U),vec2(.5)) ) < .5)
	{ fragColor = T(0,0); return; }

	// neighbors
	vec4[4] pix = vec4[4](
		texture( colorMap, uv2 + vec2(0, div.y)),
		texture( colorMap, uv2 + vec2(div.x, 0)),
		texture( colorMap, uv2 + vec2(0, -div.y)),
		texture( colorMap, uv2 + vec2(-div.x, 0)));

	//where is the biggest contrast ?
	int comp = int ( abs( lum(pix[0]) - lum(pix[2]) )
	> abs( lum(pix[1]) - lum(pix[3]) ) );
	vec2 d = abs(diff-.5) - vec2(1-comp,comp); // offset = 0,1 or 1,0
	ivec2 v = ivec2( vec2(3.5,2.5) - diff*2. );

	fragColor = dot(d,d) < .5
	? pix[ v[comp] ]								 // 2 circles on the borders
	: mix( pix[comp+2], pix[comp] , diff[1-comp] ); // a gradient in between
}


float hexDist(in vec2 p) {
	p = abs(p);
	float edgeDist = dot(p, normalize(vec2(1.0, 1.73)));
	return max(edgeDist, p.x);
}

void computeHexagonPixel(out vec4 fragColor, in vec2 fragCoord) {
	vec2 uv = (fragCoord - 0.5 * uResolution.xy) / uResolution.y * uHorizontalTiles;
	float unit = 2.0 * uHorizontalTiles / uResolution.y;

	vec2 rep = vec2(1.0, 1.73); // 1.73 ~ sqrt(3)
	vec2 hrep = 0.5 * rep;
	vec2 a = mod(uv, rep) - hrep;
	vec2 b = mod(uv - hrep, rep) - hrep;
	vec2 hexUv = dot(a, a) < dot(b, b) ? a : b;
	vec2 cellId = uv - hexUv;

	vec2 sampleUv = cellId / uHorizontalTiles;
	sampleUv.x *= uResolution.y / uResolution.x;
	float brightness = dot(texture(colorMap, sampleUv + 0.5).rgb, vec3(1.0 / 3.0));
	fragColor = vec4(1.0);//vec4(smoothstep(unit, 0.0, hexDist(hexUv) - brightness * 0.5));
	fragColor.rgb *=texture(colorMap, sampleUv + 0.5).rgb;
}
vec2 hash2( vec2 p ) {
    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);
}
void computeVoronoiPixel(out vec4 fragColor, in vec2 fragCoord) {
	vec2 uv = fragCoord.xy / uResolution.xy;

    vec2 pixelating = uResolution.yx / uResolution.y / uHorizontalTiles;//mix(0.03, 0.005, pow(cos(0.0), 2.0));

    uv = (uv-0.5)/pixelating;

    vec2 n = floor(uv);
    vec2 f = fract(uv);

    //----------------------------------
    // regular voronoi from Inigo Quilez,
    // https://www.shadertoy.com/view/ldl3W8
    //----------------------------------
	vec2 mg, mr;

    // best distance
    float md = 8.0;
    // best delta vector
    vec2 mv;
    for(int j=-1;j<=1;j++)
    for(int i=-1;i<=1;i++) {
        vec2 g = vec2(float(i),float(j));
		vec2 o = hash2(n + g);
        #ifdef ANIMATE_VORONOI
        o = 0.5 + 0.5*sin(iTime + 6.2831*o);
        #endif
        vec2 r = g + o - f;
        float d = dot(r,r);
        if(d < md) {
            md = d;
            mv = r;
        }
    }

    uv += mv;

    uv = uv * pixelating+0.5;

	fragColor = texture(colorMap, uv);
}
void computeTrianglePixel(out vec4 fragColor, in vec2 fragCoord) {
	vec2 uv = fragCoord.xy / uResolution.xy;

	vec2 pixelating = uResolution.yx / uResolution.y / uHorizontalTiles;

	uv = (uv - 0.5) / pixelating;
	vec2 uvTriangleSpace = mat2(1.0, 1.0, 0.6, -0.6) * uv;
	uvTriangleSpace = fract(uvTriangleSpace);
	if(uvTriangleSpace.x > uvTriangleSpace.y) uvTriangleSpace.x -= 0.5;
	uv -= mat2(0.5, 0.833, 0.5, -0.833) * uvTriangleSpace + vec2(-0.25, 0.25);

	fragColor = texture(colorMap, clamp(uv * pixelating + 0.5, 0.01, 0.99));
}


#ifndef PIXEL_STYLE
	#define PIXEL_STYLE 0
#endif

void main(void) {

	#if (PIXEL_STYLE == 0)
		computeSquarePixel(gl_FragColor, gl_FragCoord.xy);
	#elif (PIXEL_STYLE == 1)
		computeDiamondPixel(gl_FragColor, gl_FragCoord.xy);
	#elif (PIXEL_STYLE == 2)
		computeRoundPixel1(gl_FragColor, gl_FragCoord.xy);
	#elif (PIXEL_STYLE == 3)
		computeRoundPixel2(gl_FragColor, gl_FragCoord.xy);
	#elif (PIXEL_STYLE == 4)
		computeHexagonPixel(gl_FragColor, gl_FragCoord.xy);
	#elif (PIXEL_STYLE == 5)
		computeVoronoiPixel(gl_FragColor, gl_FragCoord.xy);
	#elif (PIXEL_STYLE == 6)
		computeTrianglePixel(gl_FragColor, gl_FragCoord.xy);
	#endif
}
`;

var pixelate_vs = `
#include postprocessing_vertex
`;

var saturate_fs = `
#define USE_COLOR_MAP
#include declare_fragment_color_map

uniform float uSaturation;

#include varying_standard

void main(void) {
	#include compute_fragment_color_map
	float luminance = 0.2126 * texelColor.r + 0.7152 * texelColor.g + 0.0722 * texelColor.b;

	gl_FragColor = mix(vec4(luminance), texelColor, vec4(vec3(uSaturation), 1.0));
}
`;

var saturate_vs = `
#include postprocessing_vertex
`;

var sketch_fs = `
float dist = 6.0; // how far to sample from
int loops = 60; // how many times to sample, more = smoother

#define USE_COLOR_MAP
#include declare_fragment_color_map

uniform float uGrainIntensity;
const float PI2 = PI * 2.0;
const int mSize = 9;
const int kSize = (mSize-1)/2;
const float sigma = 3.0;
float kernel[mSize];

// Gaussian PDF
float normpdf(in float x, in float sigma)
{
	return 0.39894 * exp(-0.5 * x * x / (sigma * sigma)) / sigma;
}

//
vec3 colorDodge(in vec3 src, in vec3 dst)
{
    return step(0.0, dst) * mix(min(vec3(1.0), dst/ (1.0 - src)), vec3(1.0), step(1.0, src));
}

float greyScale(in vec3 col)
{
    return dot(col, vec3(0.3, 0.59, 0.11));
    //return dot(col, vec3(0.2126, 0.7152, 0.0722)); //sRGB
}

vec2 random(vec2 p){
	p = fract(p * (vec2(314.159, 314.265)));
    p += dot(p, p.yx + 17.17);
    return fract((p.xx + p.yx) * p.xy);
}

vec2 random2(vec2 p)
{
    return texture(colorMap, p / vec2(1024.0)).xy;
    //blue1 = texture(iChannel1, p / vec2(1024.0));
    //blue2 = texture(iChannel1, (p+vec2(137.0, 189.0)) / vec2(1024.0));
}



#include varying_standard

void main(void) {
	float grain = 1.0 - rand(vTextureCoord.xy) * uGrainIntensity;

	gl_FragColor = texture2D(colorMap, vTextureCoord.xy) * vec4(grain, grain, grain, 1.0);
    vec2 q = vTextureCoord.xy;
    vec3 col = texture(colorMap, q).rgb;

    vec2 r = random(q);
    r.x *= PI2;
    vec2 cr = vec2(sin(r.x),cos(r.x))*sqrt(r.y);

    vec3 blurred = texture(colorMap, q + cr * (vec2(mSize) / uResolution.xy) ).rgb;

    // comparison
    if (false) {
        blurred = vec3(0.0);
        float Z = 0.0;
        for (int j = 0; j <= kSize; ++j) {
            kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);
        }
        for (int j = 0; j < mSize; ++j) {
            Z += kernel[j];
        }

		// this can be done in two passes
        for (int i = -kSize; i <= kSize; ++i) {
            for (int j = -kSize; j <= kSize; ++j) {
                blurred += kernel[kSize+j]*kernel[kSize+i]*texture(colorMap, (gl_FragCoord.xy+vec2(float(i),float(j))) / uResolution.xy).rgb;
            }
    	}
   		blurred = blurred / Z / Z;

        // an interesting ink effect
        //r = random2(q);
        //vec2 cr = vec2(sin(r.x),cos(r.x))*sqrt(-2.0*r.y);
        //blurred = texture(iChannel0, q + cr * (vec2(mSize) / iResolution.xy) ).rgb;
    }

    vec3 inv = vec3(1.0) - blurred;
    // color dodge
    vec3 lighten = colorDodge(col, inv);
    // grey scale
    vec3 res = vec3(greyScale(lighten));

    // more contrast
    res = vec3(pow(res.x, 3.0));
    //res = clamp(res * 0.7 + 0.3 * res * res * 1.2, 0.0, 1.0);

    // edge effect
    //if (iMouse.z > 0.5) res *= 0.25 + 0.75 * pow( 16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.15 );
	gl_FragColor = vec4(res, 1.0);


}

`;

var sketch_vs = `
#include postprocessing_vertex
`;

Shaders['copy.fs'] = copy_fs;
Shaders['copy.vs'] = copy_vs;
Shaders['crosshatch.fs'] = crosshatch_fs;
Shaders['crosshatch.vs'] = crosshatch_vs;
Shaders['edgedetection.fs'] = edgedetection_fs;
Shaders['edgedetection.vs'] = edgedetection_vs;
Shaders['grain.fs'] = grain_fs;
Shaders['grain.vs'] = grain_vs;
Shaders['oldmovie.fs'] = oldmovie_fs;
Shaders['oldmovie.vs'] = oldmovie_vs;
Shaders['palette.fs'] = palette_fs;
Shaders['palette.vs'] = palette_vs;
Shaders['pixelate.fs'] = pixelate_fs;
Shaders['pixelate.vs'] = pixelate_vs;
Shaders['saturate.fs'] = saturate_fs;
Shaders['saturate.vs'] = saturate_vs;
Shaders['sketch.fs'] = sketch_fs;
Shaders['sketch.vs'] = sketch_vs;

const EDIT_MODE_SHADER = 0;
const EDIT_MODE_INCLUDE = 1;
class ShaderEditor extends HTMLElement {
    #initialized = false;
    #recompileDelay = 1000;
    #annotationsDelay = 500;
    #editMode = EDIT_MODE_SHADER;
    #shadowRoot;
    #shaderEditor;
    #htmlShaderNameSelect;
    #htmlShaderRenderMode;
    #recompileTimeout;
    #editorShaderName = '';
    #editorIncludeName = '';
    #shaderType = ShaderType.Vertex;
    initEditor(options = {}) {
        if (this.#initialized) {
            return;
        }
        this.#shadowRoot = this.attachShadow({ mode: 'closed' });
        I18n.observeElement(this.#shadowRoot);
        const aceScript = options.aceUrl ?? ACE_EDITOR_URI;
        this.#initialized = true;
        this.style.cssText = 'display: flex;flex-direction: column;height: 100%;width: 100%;';
        this.#htmlShaderNameSelect = createElement('select');
        this.#htmlShaderNameSelect.addEventListener('input', (event) => {
            const selectedOption = event.target.selectedOptions[0];
            if (selectedOption) {
                if (selectedOption.getAttribute('data-shader')) {
                    this.editorShaderName = event.target.value;
                }
                if (selectedOption.getAttribute('data-include')) {
                    this.editorIncludeName = event.target.value;
                }
            }
        });
        this.#htmlShaderRenderMode = createElement('input');
        this.#htmlShaderRenderMode.addEventListener('input', (event) => {
            const n = Number(event.target.value);
            if (Number.isNaN(n)) {
                Graphics$1.setIncludeCode('RENDER_MODE', '#undef RENDER_MODE');
            }
            else {
                Graphics$1.setIncludeCode('RENDER_MODE', '#define RENDER_MODE ' + n);
            }
        });
        const htmlCustomShaderButtons = createElement('div');
        if (options.displayCustomShaderButtons) {
            const htmlButtonSaveCustomShader = createElement('button', { i18n: '#save_custom_shader' });
            const htmlButtonLoadCustomShader = createElement('button', { i18n: '#load_custom_shader' });
            const htmlButtonRemoveCustomShader = createElement('button', { i18n: '#remove_custom_shader' });
            htmlCustomShaderButtons.append(htmlButtonSaveCustomShader, htmlButtonLoadCustomShader, htmlButtonRemoveCustomShader);
            this.#shadowRoot.append(htmlCustomShaderButtons);
            htmlButtonSaveCustomShader.addEventListener('click', () => this.#saveCustomShader());
            htmlButtonLoadCustomShader.addEventListener('click', () => this.#loadCustomShader());
            htmlButtonRemoveCustomShader.addEventListener('click', () => this.#removeCustomShader());
        }
        const c = createElement('div', { style: 'flex:1;' });
        {
            hide(this.#htmlShaderRenderMode);
        }
        this.#shadowRoot.append(this.#htmlShaderNameSelect, this.#htmlShaderRenderMode, htmlCustomShaderButtons, c);
        if (aceScript == '') {
            this.#initEditor2(c);
        }
        else {
            loadScripts([aceScript], () => this.#initEditor2(c)); //TODO: variable
        }
        ShaderEventTarget.addEventListener('shaderadded', event => this.#reloadGLSLList());
        ShaderEventTarget.addEventListener('includeadded', event => this.#reloadGLSLList());
    }
    #initEditor2(id) {
        this.#shaderEditor = globalThis.ace.edit(id);
        this.#shaderEditor.renderer.attachToShadowRoot();
        this.#shaderEditor.$blockScrolling = Infinity;
        this.#shaderEditor.setTheme('ace/theme/monokai');
        this.#shaderEditor.getSession().setMode('ace/mode/glsl');
        this.#shaderEditor.getSession().on('change', () => {
            clearTimeout(this.#recompileTimeout);
            this.#recompileTimeout = setTimeout(() => { this.recompile(); }, this.#recompileDelay); //TODO:
        });
        this.#shaderEditor.commands.addCommand({
            name: 'myCommand',
            bindKey: { win: 'Ctrl-Shift-C', mac: 'Command-M' },
            exec: () => {
                this.recompile();
            },
        });
        this.#reloadGLSLList();
    }
    #reloadGLSLList() {
        if (!this.#shaderEditor) {
            return;
        }
        this.#htmlShaderNameSelect.innerText = '';
        const shaderGroup = createElement('optgroup', { i18n: { label: '#shader_editor_shaders', }, parent: this.#htmlShaderNameSelect });
        const shaderList = [...ShaderManager.shaderList].sort();
        for (const shaderName of shaderList) {
            const option = createElement('option', {
                class: 'shader-editor-shader-list-shader',
                value: shaderName,
                innerHTML: shaderName,
                'data-shader': true,
                parent: shaderGroup
            });
            if (this.#editMode == EDIT_MODE_SHADER && this.editorShaderName == shaderName) {
                option.selected = true;
            }
        }
        const includeGroup = createElement('optgroup', { i18n: { label: '#shader_editor_includes', }, parent: this.#htmlShaderNameSelect });
        const includeList = [...getIncludeList()].sort();
        for (const includeName of includeList) {
            const option = createElement('option', {
                class: 'shader-editor-shader-list-include',
                value: includeName,
                innerHTML: includeName,
                'data-include': true,
                parent: includeGroup
            });
            if (this.#editMode == EDIT_MODE_INCLUDE && this.editorIncludeName == includeName) {
                option.selected = true;
            }
        }
        if (!this.editorShaderName && !this.editorIncludeName) {
            const selectedOption = this.#htmlShaderNameSelect.selectedOptions[0];
            if (selectedOption) {
                if (selectedOption.getAttribute('data-shader')) {
                    this.editorShaderName = selectedOption.value;
                }
            }
        }
    }
    get editorShaderName() {
        return this.#editorShaderName;
    }
    set editorShaderName(shaderName) {
        if (shaderName) {
            this.#editorShaderName = shaderName;
            const source = ShaderManager.getShaderSource(ShaderType.Vertex, this.#editorShaderName, true);
            if (source) {
                if (this.#shaderEditor) {
                    this.#shaderEditor.setValue(source.getSource());
                }
                this.#shaderType = source.getType();
                this.#editMode = EDIT_MODE_SHADER;
            }
        }
    }
    get editorIncludeName() {
        return this.#editorIncludeName;
    }
    set editorIncludeName(includeName) {
        if (includeName) {
            this.#editorIncludeName = includeName;
            const source = getIncludeSource(this.#editorIncludeName);
            if (source) {
                this.#shaderEditor.setValue(source);
                this.#editMode = EDIT_MODE_INCLUDE;
            }
        }
    }
    recompile() {
        clearTimeout(this.#recompileTimeout);
        const customSource = this.#shaderEditor.getValue();
        if (this.#editMode == EDIT_MODE_SHADER) {
            ShaderManager.setCustomSource(this.#shaderType, this.#editorShaderName, customSource);
        }
        else {
            setCustomIncludeSource(this.#editorIncludeName, customSource);
            ShaderManager.resetShadersSource();
            Graphics$1.invalidateShaders();
        }
        if (customSource == '') {
            if (this.#editMode == EDIT_MODE_SHADER) {
                this.editorShaderName = this.#editorShaderName;
            }
            else {
                this.editorIncludeName = this.#editorIncludeName;
            }
        }
        else {
            if (this.#editMode == EDIT_MODE_SHADER) {
                Graphics$1.invalidateShaders();
                setTimeout(() => this.setAnnotations(this.#editorShaderName), this.#annotationsDelay);
            }
            else {
                setTimeout(() => this.#shaderEditor.getSession().setAnnotations(ShaderManager.getIncludeAnnotations(this.#editorIncludeName)), this.#annotationsDelay);
            }
        }
    }
    setAnnotations(shaderName) {
        if (shaderName == this.#editorShaderName) {
            this.#shaderEditor.getSession().setAnnotations(ShaderManager.getCustomSourceAnnotations(shaderName));
        }
    }
    set recompileDelay(delay) {
        this.#recompileDelay = delay;
    }
    set annotationsDelay(delay) {
        this.#annotationsDelay = delay;
    }
    #saveCustomShader() {
        const type = this.#editMode == EDIT_MODE_SHADER ? 'shader' : 'include';
        const name = this.#editMode == EDIT_MODE_SHADER ? this.editorShaderName : this.editorIncludeName;
        this.dispatchEvent(new CustomEvent('save-custom-shader', { detail: { type: type, name: name, source: this.#shaderEditor.getValue() } }));
    }
    #loadCustomShader() {
        const type = this.#editMode == EDIT_MODE_SHADER ? 'shader' : 'include';
        const name = this.#editMode == EDIT_MODE_SHADER ? this.editorShaderName : this.editorIncludeName;
        const shaderType = this.#editMode == EDIT_MODE_SHADER ? this.#shaderType : null;
        this.dispatchEvent(new CustomEvent('load-custom-shader', { detail: { type: type, name: name, shaderType: shaderType } }));
    }
    #removeCustomShader() {
        const type = this.#editMode == EDIT_MODE_SHADER ? 'shader' : 'include';
        const name = this.#editMode == EDIT_MODE_SHADER ? this.editorShaderName : this.editorIncludeName;
        const shaderType = this.#editMode == EDIT_MODE_SHADER ? this.#shaderType : null;
        this.dispatchEvent(new CustomEvent('remove-custom-shader', { detail: { type: type, name: name, shaderType: shaderType } }));
    }
}
if (window.customElements) {
    customElements.define('shader-editor', ShaderEditor);
}
function loadScripts(array, callback) {
    const loader = function (src, handler) {
        const script = createElement('script');
        script.src = src;
        script.onload = () => {
            script.onload = null;
            handler();
        };
        const head = document.getElementsByTagName('head')[0];
        (head || document.body).appendChild(script);
    };
    (function run() {
        if (array.length != 0) {
            loader(array.shift(), run);
        }
        else {
            callback && callback();
        }
    })();
}

vec3.create(); //TODO: use IDENTITY_VEC3
quat.create();
const tempVec3$j = vec3.create();
const tempQuat$5 = quat.create();
const mat$2 = mat4.create();
class ControlPoint extends Entity {
    isControlPoint = true;
    #parentControlPoint;
    currentWorldPosition = vec3.create();
    prevWorldPosition = vec3.create();
    deltaWorldPosition = vec3.create();
    currentWorldQuaternion = quat.create();
    prevWorldQuaternion = quat.create();
    currentWorldTransformation = mat4.create();
    prevWorldTransformation = mat4.create();
    deltaWorldTransformation = mat4.create();
    //TODO: keep these vectors ?
    // Forward vector
    fVector = vec3.create();
    // Up vector
    uVector = vec3.create();
    // Right vector
    rVector = vec3.create();
    parentModel;
    lastComputed = -1;
    snapshot;
    model;
    getWorldTransformation(mat = mat4.create()) {
        this.getWorldQuaternion(tempQuat$5);
        this.getWorldPosition(tempVec3$j);
        return mat4.fromRotationTranslation(mat, tempQuat$5, tempVec3$j);
    }
    getWorldQuaternion(q = quat.create()) {
        if (this.#parentControlPoint) {
            this.#parentControlPoint.getWorldQuaternion(q);
            quat.mul(q, q, this._quaternion);
        }
        else {
            super.getWorldQuaternion(q);
        }
        return q;
    }
    parentChanged(parent) {
        const parentModel = this.getParentModel();
        this.forEach(entity => {
            if (entity.isControlPoint) {
                entity.parentModel = parentModel;
            }
        });
    }
    set parentControlPoint(parentControlPoint) {
        this.#parentControlPoint = parentControlPoint;
    }
    get parentControlPoint() {
        return this.#parentControlPoint;
    }
    step() {
        if (this.lastComputed < Graphics$1.currentTick) {
            this.lastComputed = Graphics$1.currentTick;
            vec3.copy(this.prevWorldPosition, this.currentWorldPosition);
            quat.copy(this.prevWorldQuaternion, this.currentWorldQuaternion);
            mat4.copy(this.prevWorldTransformation, this.currentWorldTransformation);
            this.#compute();
        }
    }
    resetDelta() {
        this.#compute();
        vec3.zero(this.deltaWorldPosition);
        mat4.identity(this.deltaWorldTransformation);
    }
    #compute() {
        super.getWorldPosition(this.currentWorldPosition);
        super.getWorldQuaternion(this.currentWorldQuaternion);
        mat4.fromRotationTranslation(this.currentWorldTransformation, this.currentWorldQuaternion, this.currentWorldPosition);
        // compute delta world position
        vec3.sub(this.deltaWorldPosition, this.currentWorldPosition, this.prevWorldPosition);
        // compute delta world transformation
        mat4.invert(mat$2, this.prevWorldTransformation);
        mat4.mul(this.deltaWorldTransformation, this.currentWorldTransformation, mat$2);
    }
    deltaPosFrom(other, out = vec3.create()) {
        return vec3.sub(out, other.currentWorldPosition, this.currentWorldPosition);
    }
    static async constructFromJSON(json) {
        return new ControlPoint();
    }
    static getEntityName() {
        return 'ControlPoint';
    }
}
registerEntity(ControlPoint);

let randomFloats;
const MAX_FLOATS = 4096;
function initRandomFloats() {
    randomFloats = new Array(MAX_FLOATS);
    for (let i = 0; i < MAX_FLOATS; i++) {
        randomFloats[i] = Math.random();
    }
}
function ParticleRandomFloat(id, offset) {
    if (!randomFloats) {
        initRandomFloats();
    }
    return randomFloats[(id + offset) % MAX_FLOATS];
}
function ParticleRandomVec3(vec, id, offset1, offset2, offset3) {
    if (!randomFloats) {
        initRandomFloats();
    }
    vec3.set(vec, randomFloats[(id + offset1) % MAX_FLOATS], randomFloats[(id + offset2) % MAX_FLOATS], randomFloats[(id + offset3) % MAX_FLOATS]);
    return vec;
}

var source_declare_particle = `
#pragma once

#include mat4_from_quat
#include rotation_matrix

#ifdef HARDWARE_PARTICLES
	uniform sampler2D uParticles;
	uniform float uMaxParticles;
	uniform float uVisibilityCameraDepthBias;//TODO: pack some uniforms
	uniform vec4 uOrientationControlPoint;

	#include source1_declare_particle_position
	#include vec3_transform_quat

	struct particle {
		vec3 center;
		vec4 color;
		float radius;
		float roll;
		float yaw;
		vec4 vecDelta;
		vec3 normal;
	};

	particle getParticle(int particleId) {
		particle result;
		vec4 renderScreenVelocityRotate;
		#ifdef WEBGL2
			result.center = texelFetch(uParticles, ivec2(0, particleId), 0).rgb;
			result.color = texelFetch(uParticles, ivec2(1, particleId), 0);
			vec4 rrya = texelFetch(uParticles, ivec2(2, particleId), 0);
			result.vecDelta = texelFetch(uParticles, ivec2(3, particleId), 0);
			result.normal = texelFetch(uParticles, ivec2(4, particleId), 0).rgb;
			renderScreenVelocityRotate = texelFetch(uParticles, ivec2(5, particleId), 0);
		#else
			float texelPos = float(particleId) / uMaxParticles;
			result.center = texture2D(uParticles, vec2(0.00, texelPos)).rgb;
			result.color = texture2D(uParticles, vec2(0.125, texelPos));
			vec4 rrya = texture2D(uParticles, vec2(0.25, texelPos));
			result.vecDelta = texture2D(uParticles, vec2(0.375, texelPos));
			result.normal = texture2D(uParticles, vec2(0.5, texelPos)).rgb;
			renderScreenVelocityRotate = texture2D(uParticles, vec2(0.625, texelPos));
		#endif

		result.color.a = clamp(result.color.a, 0., 1.);
		result.radius = rrya.r;

		if (renderScreenVelocityRotate.x == 0.0) {
			result.roll = rrya.b;
		} else {
			result.roll = atan(result.vecDelta.y, result.vecDelta.x) + renderScreenVelocityRotate.z - 1.57;
		}

		result.yaw = rrya.a;
		return result;
	}
#endif
`;

Includes['source_declare_particle'] = source_declare_particle;

/*
Copyright (c) 2011 Juan Mellado

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
/*
References:
- "LZMA SDK" by Igor Pavlov
    http://www.7-zip.org/sdk.html
- "The .lzma File Format" from xz documentation
    https://github.com/joachimmetz/xz/blob/master/doc/lzma-file-format.txt
*/
class OutWindow {
    #windowSize = 0;
    #buffer;
    #pos;
    #streamPos;
    #stream = null;
    create(windowSize) {
        if ((!this.#buffer) || (this.#windowSize !== windowSize)) {
            // using a typed array here gives a big boost on Firefox
            // not much change in chrome (but more memory efficient)
            this.#buffer = new Uint8Array(windowSize);
        }
        this.#windowSize = windowSize;
        this.#pos = 0;
        this.#streamPos = 0;
    }
    flush() {
        if (!this.#stream) {
            return;
        }
        const size = this.#pos - this.#streamPos;
        if (size !== 0) {
            if (this.#stream.writeBytes) {
                this.#stream.writeBytes(this.#buffer, size);
            }
            else {
                for (let i = 0; i < size; i++) {
                    this.#stream.writeByte(this.#buffer[i]);
                }
            }
            if (this.#pos >= this.#windowSize) {
                this.#pos = 0;
            }
            this.#streamPos = this.#pos;
        }
    }
    releaseStream() {
        this.flush();
        this.#stream = null;
    }
    setStream(stream) {
        this.releaseStream();
        this.#stream = stream;
    }
    init(solid) {
        if (!solid) {
            this.#streamPos = 0;
            this.#pos = 0;
        }
    }
    copyBlock(distance, len) {
        let pos = this.#pos - distance - 1;
        if (pos < 0) {
            pos += this.#windowSize;
        }
        while (len--) {
            if (pos >= this.#windowSize) {
                pos = 0;
            }
            this.#buffer[this.#pos++] = this.#buffer[pos++];
            if (this.#pos >= this.#windowSize) {
                this.flush();
            }
        }
    }
    putByte(b) {
        this.#buffer[this.#pos++] = b;
        if (this.#pos >= this.#windowSize) {
            this.flush();
        }
    }
    getByte(distance) {
        let pos = this.#pos - distance - 1;
        if (pos < 0) {
            pos += this.#windowSize;
        }
        return this.#buffer[pos];
    }
}
class RangeDecoder {
    #stream = null;
    #code = 0;
    #range = 0;
    setStream(stream) {
        this.#stream = stream;
    }
    releaseStream() {
        this.#stream = null;
    }
    init() {
        let i = 5;
        this.#code = 0;
        this.#range = -1;
        while (i--) {
            this.#code = (this.#code << 8) | this.#stream.readByte();
        }
    }
    decodeDirectBits(numTotalBits) {
        let result = 0, i = numTotalBits, t;
        while (i--) {
            this.#range >>>= 1;
            t = (this.#code - this.#range) >>> 31;
            this.#code -= this.#range & (t - 1);
            result = (result << 1) | (1 - t);
            if ((this.#range & 0xff000000) === 0) {
                this.#code = (this.#code << 8) | this.#stream.readByte();
                this.#range <<= 8;
            }
        }
        return result;
    }
    decodeBit(probs, index) {
        const prob = probs[index], newBound = (this.#range >>> 11) * prob;
        if ((this.#code ^ 0x80000000) < (newBound ^ 0x80000000)) {
            this.#range = newBound;
            probs[index] += (2048 - prob) >>> 5;
            if ((this.#range & 0xff000000) === 0) {
                this.#code = (this.#code << 8) | this.#stream.readByte();
                this.#range <<= 8;
            }
            return 0;
        }
        this.#range -= newBound;
        this.#code -= newBound;
        probs[index] -= prob >>> 5;
        if ((this.#range & 0xff000000) === 0) {
            this.#code = (this.#code << 8) | this.#stream.readByte();
            this.#range <<= 8;
        }
        return 1;
    }
}
class LZMA {
    static initBitModels(probs, len) {
        while (len--) {
            probs[len] = 1024;
        }
    }
    static reverseDecode2(models, startIndex, rangeDecoder, numBitLevels) {
        let m = 1, symbol = 0, i = 0, bit;
        for (; i < numBitLevels; ++i) {
            bit = rangeDecoder.decodeBit(models, startIndex + m);
            m = (m << 1) | bit;
            symbol |= bit << i;
        }
        return symbol;
    }
    static decompress(properties, inStream, outStream, outSize) {
        const decoder = new Decoder();
        if (!decoder.setDecoderProperties(properties)) {
            throw Error("Incorrect lzma stream properties");
        }
        if (!decoder.decodeBody(inStream, outStream, outSize)) {
            throw Error("Error in lzma data stream");
        }
        return outStream;
    }
}
class BitTreeDecoder {
    #models = [];
    #numBitLevels;
    constructor(numBitLevels) {
        this.#numBitLevels = numBitLevels;
    }
    init() {
        LZMA.initBitModels(this.#models, 1 << this.#numBitLevels);
    }
    decode(rangeDecoder) {
        let m = 1, i = this.#numBitLevels;
        while (i--) {
            m = (m << 1) | rangeDecoder.decodeBit(this.#models, m);
        }
        return m - (1 << this.#numBitLevels);
    }
    reverseDecode(rangeDecoder) {
        let m = 1, symbol = 0, i = 0, bit;
        for (; i < this.#numBitLevels; ++i) {
            bit = rangeDecoder.decodeBit(this.#models, m);
            m = (m << 1) | bit;
            symbol |= bit << i;
        }
        return symbol;
    }
}
class LenDecoder {
    #choice = [];
    #lowCoder = [];
    #midCoder = [];
    #highCoder = new BitTreeDecoder(8);
    #numPosStates = 0;
    create(numPosStates) {
        for (; this.#numPosStates < numPosStates; ++this.#numPosStates) {
            this.#lowCoder[this.#numPosStates] = new BitTreeDecoder(3);
            this.#midCoder[this.#numPosStates] = new BitTreeDecoder(3);
        }
    }
    init() {
        let i = this.#numPosStates;
        LZMA.initBitModels(this.#choice, 2);
        while (i--) {
            this.#lowCoder[i].init();
            this.#midCoder[i].init();
        }
        this.#highCoder.init();
    }
    decode(rangeDecoder, posState) {
        if (rangeDecoder.decodeBit(this.#choice, 0) === 0) {
            return this.#lowCoder[posState].decode(rangeDecoder);
        }
        if (rangeDecoder.decodeBit(this.#choice, 1) === 0) {
            return 8 + this.#midCoder[posState].decode(rangeDecoder);
        }
        return 16 + this.#highCoder.decode(rangeDecoder);
    }
}
class Decoder2 {
    #decoders = [];
    init() {
        LZMA.initBitModels(this.#decoders, 0x300);
    }
    decodeNormal(rangeDecoder) {
        let symbol = 1;
        do {
            symbol = (symbol << 1) | rangeDecoder.decodeBit(this.#decoders, symbol);
        } while (symbol < 0x100);
        return symbol & 0xff;
    }
    decodeWithMatchByte(rangeDecoder, matchByte) {
        let symbol = 1, matchBit, bit;
        do {
            matchBit = (matchByte >> 7) & 1;
            matchByte <<= 1;
            bit = rangeDecoder.decodeBit(this.#decoders, ((1 + matchBit) << 8) + symbol);
            symbol = (symbol << 1) | bit;
            if (matchBit !== bit) {
                while (symbol < 0x100) {
                    symbol = (symbol << 1) | rangeDecoder.decodeBit(this.#decoders, symbol);
                }
                break;
            }
        } while (symbol < 0x100);
        return symbol & 0xff;
    }
}
class LiteralDecoder {
    #coders;
    #numPrevBits = 0;
    #numPosBits = 0;
    #posMask = 0;
    create(numPosBits, numPrevBits) {
        let i;
        if (this.#coders
            && (this.#numPrevBits === numPrevBits)
            && (this.#numPosBits === numPosBits)) {
            return;
        }
        this.#numPosBits = numPosBits;
        this.#posMask = (1 << numPosBits) - 1;
        this.#numPrevBits = numPrevBits;
        this.#coders = [];
        i = 1 << (this.#numPrevBits + this.#numPosBits);
        while (i--) {
            this.#coders[i] = new Decoder2();
        }
    }
    init() {
        let i = 1 << (this.#numPrevBits + this.#numPosBits);
        while (i--) {
            this.#coders[i].init();
        }
    }
    getDecoder(pos, prevByte) {
        return this.#coders[((pos & this.#posMask) << this.#numPrevBits)
            + ((prevByte & 0xff) >>> (8 - this.#numPrevBits))];
    }
}
class Decoder {
    #outWindow = new OutWindow();
    #rangeDecoder = new RangeDecoder();
    #isMatchDecoders = [];
    #isRepDecoders = [];
    #isRepG0Decoders = [];
    #isRepG1Decoders = [];
    #isRepG2Decoders = [];
    #isRep0LongDecoders = [];
    #posSlotDecoder = [new BitTreeDecoder(6), new BitTreeDecoder(6), new BitTreeDecoder(6), new BitTreeDecoder(6)];
    #posDecoders = [];
    #posAlignDecoder = new BitTreeDecoder(4);
    #lenDecoder = new LenDecoder();
    #repLenDecoder = new LenDecoder();
    #literalDecoder = new LiteralDecoder();
    #dictionarySize = -1;
    #dictionarySizeCheck = -1;
    #posStateMask;
    setDictionarySize(dictionarySize) {
        if (dictionarySize < 0) {
            return false;
        }
        if (this.#dictionarySize !== dictionarySize) {
            this.#dictionarySize = dictionarySize;
            this.#dictionarySizeCheck = Math.max(this.#dictionarySize, 1);
            this.#outWindow.create(Math.max(this.#dictionarySizeCheck, 4096));
        }
        return true;
    }
    setLcLpPb(lc, lp, pb) {
        const numPosStates = 1 << pb;
        if (lc > 8 || lp > 4 || pb > 4) {
            return false;
        }
        this.#literalDecoder.create(lp, lc);
        this.#lenDecoder.create(numPosStates);
        this.#repLenDecoder.create(numPosStates);
        this.#posStateMask = numPosStates - 1;
        return true;
    }
    setProperties(props) {
        if (!this.setLcLpPb(props.lc, props.lp, props.pb)) {
            throw Error("Incorrect stream properties");
        }
        if (!this.setDictionarySize(props.dictionarySize)) {
            throw Error("Invalid dictionary size");
        }
    }
    decodeHeader(inStream) {
        let properties, lc, lp, pb, uncompressedSize, dictionarySize;
        if (inStream.size < 13) {
            return false;
        }
        // +------------+----+----+----+----+--+--+--+--+--+--+--+--+
        // | Properties |	Dictionary Size	|	 Uncompressed Size	 |
        // +------------+----+----+----+----+--+--+--+--+--+--+--+--+
        properties = inStream.readByte();
        lc = properties % 9;
        properties = ~~(properties / 9);
        lp = properties % 5;
        pb = ~~(properties / 5);
        dictionarySize = inStream.readByte();
        dictionarySize |= inStream.readByte() << 8;
        dictionarySize |= inStream.readByte() << 16;
        dictionarySize += inStream.readByte() * 16777216;
        uncompressedSize = inStream.readByte();
        uncompressedSize |= inStream.readByte() << 8;
        uncompressedSize |= inStream.readByte() << 16;
        uncompressedSize += inStream.readByte() * 16777216;
        inStream.readByte();
        inStream.readByte();
        inStream.readByte();
        inStream.readByte();
        return {
            // The number of high bits of the previous
            // byte to use as a context for literal encoding.
            lc: lc,
            // The number of low bits of the dictionary
            // position to include in literal_pos_state.
            lp: lp,
            // The number of low bits of the dictionary
            // position to include in pos_state.
            pb: pb,
            // Dictionary Size is stored as an unsigned 32-bit
            // little endian integer. Any 32-bit value is possible,
            // but for maximum portability, only sizes of 2^n and
            // 2^n + 2^(n-1) should be used.
            dictionarySize: dictionarySize,
            // Uncompressed Size is stored as unsigned 64-bit little
            // endian integer. A special value of 0xFFFF_FFFF_FFFF_FFFF
            // indicates that Uncompressed Size is unknown.
            uncompressedSize: uncompressedSize
        };
    }
    init() {
        let i = 4;
        this.#outWindow.init(false);
        LZMA.initBitModels(this.#isMatchDecoders, 192);
        LZMA.initBitModels(this.#isRep0LongDecoders, 192);
        LZMA.initBitModels(this.#isRepDecoders, 12);
        LZMA.initBitModels(this.#isRepG0Decoders, 12);
        LZMA.initBitModels(this.#isRepG1Decoders, 12);
        LZMA.initBitModels(this.#isRepG2Decoders, 12);
        LZMA.initBitModels(this.#posDecoders, 114);
        this.#literalDecoder.init();
        while (i--) {
            this.#posSlotDecoder[i].init();
        }
        this.#lenDecoder.init();
        this.#repLenDecoder.init();
        this.#posAlignDecoder.init();
        this.#rangeDecoder.init();
    }
    decodeBody(inStream, outStream, maxSize) {
        let state = 0, rep0 = 0, rep1 = 0, rep2 = 0, rep3 = 0, nowPos64 = 0, prevByte = 0, posState, decoder2, len, distance, posSlot, numDirectBits;
        this.#rangeDecoder.setStream(inStream);
        this.#outWindow.setStream(outStream);
        this.init();
        while (maxSize < 0 || nowPos64 < maxSize) {
            posState = nowPos64 & this.#posStateMask;
            if (this.#rangeDecoder.decodeBit(this.#isMatchDecoders, (state << 4) + posState) === 0) {
                decoder2 = this.#literalDecoder.getDecoder(nowPos64++, prevByte);
                if (state >= 7) {
                    prevByte = decoder2.decodeWithMatchByte(this.#rangeDecoder, this.#outWindow.getByte(rep0));
                }
                else {
                    prevByte = decoder2.decodeNormal(this.#rangeDecoder);
                }
                this.#outWindow.putByte(prevByte);
                state = state < 4 ? 0 : state - (state < 10 ? 3 : 6);
            }
            else {
                if (this.#rangeDecoder.decodeBit(this.#isRepDecoders, state) === 1) {
                    len = 0;
                    if (this.#rangeDecoder.decodeBit(this.#isRepG0Decoders, state) === 0) {
                        if (this.#rangeDecoder.decodeBit(this.#isRep0LongDecoders, (state << 4) + posState) === 0) {
                            state = state < 7 ? 9 : 11;
                            len = 1;
                        }
                    }
                    else {
                        if (this.#rangeDecoder.decodeBit(this.#isRepG1Decoders, state) === 0) {
                            distance = rep1;
                        }
                        else {
                            if (this.#rangeDecoder.decodeBit(this.#isRepG2Decoders, state) === 0) {
                                distance = rep2;
                            }
                            else {
                                distance = rep3;
                                rep3 = rep2;
                            }
                            rep2 = rep1;
                        }
                        rep1 = rep0;
                        rep0 = distance;
                    }
                    if (len === 0) {
                        len = 2 + this.#repLenDecoder.decode(this.#rangeDecoder, posState);
                        state = state < 7 ? 8 : 11;
                    }
                }
                else {
                    rep3 = rep2;
                    rep2 = rep1;
                    rep1 = rep0;
                    len = 2 + this.#lenDecoder.decode(this.#rangeDecoder, posState);
                    state = state < 7 ? 7 : 10;
                    posSlot = this.#posSlotDecoder[len <= 5 ? len - 2 : 3].decode(this.#rangeDecoder);
                    if (posSlot >= 4) {
                        numDirectBits = (posSlot >> 1) - 1;
                        rep0 = (2 | (posSlot & 1)) << numDirectBits;
                        if (posSlot < 14) {
                            rep0 += LZMA.reverseDecode2(this.#posDecoders, rep0 - posSlot - 1, this.#rangeDecoder, numDirectBits);
                        }
                        else {
                            rep0 += this.#rangeDecoder.decodeDirectBits(numDirectBits - 4) << 4;
                            rep0 += this.#posAlignDecoder.reverseDecode(this.#rangeDecoder);
                            if (rep0 < 0) {
                                if (rep0 === -1) {
                                    break;
                                }
                                return false;
                            }
                        }
                    }
                    else {
                        rep0 = posSlot;
                    }
                }
                if (rep0 >= nowPos64 || rep0 >= this.#dictionarySizeCheck) {
                    return false;
                }
                this.#outWindow.copyBlock(rep0, len);
                nowPos64 += len;
                prevByte = this.#outWindow.getByte(0);
            }
        }
        this.#outWindow.flush();
        this.#outWindow.releaseStream();
        this.#rangeDecoder.releaseStream();
        return true;
    }
    setDecoderProperties(properties) {
        let value, lc, lp, pb, dictionarySize;
        if (properties.size < 5) {
            return false;
        }
        value = properties.readByte();
        lc = value % 9;
        value = ~~(value / 9);
        lp = value % 5;
        pb = ~~(value / 5);
        if (!this.setLcLpPb(lc, lp, pb)) {
            return false;
        }
        dictionarySize = properties.readByte();
        dictionarySize |= properties.readByte() << 8;
        dictionarySize |= properties.readByte() << 16;
        dictionarySize += properties.readByte() * 16777216;
        return this.setDictionarySize(dictionarySize);
    }
}

function stringStrip(s) {
    return s.replace(/^[\s\0]+/, '').replace(/[\s\0]+$/, '');
}
function DecompressLZMA(properties, compressedDatas, uncompressedSize) {
    const inStream = {
        data: compressedDatas,
        offset: 0,
        size: compressedDatas.length,
        readByte: function () {
            return this.data[this.offset++];
        }
    };
    const propStream = {
        data: properties,
        offset: 0,
        size: properties.length,
        readByte: function () {
            return this.data[this.offset++];
        }
    };
    const outStream = {
        data: [],
        offset: 0,
        writeByte: function (value) {
            this.data[this.offset++] = value;
        }
    };
    if (LZMA.decompress(propStream, inStream, outStream, uncompressedSize)) {
        return new Uint8Array(outStream.data); //Uint8ToString(outStream.data);
    }
    return null;
}

const PROPERTY_ADDED = 'propertyadded';
const PROPERTY_CHANGED = 'propertychanged';
class TimelineObserver extends StaticEventTarget {
    /*
        parentChanged(child: Entity, oldParent: Entity | null, newParent: Entity | null) {
            this.dispatchEvent(new CustomEvent(PARENT_CHANGED, { detail: { child: child, oldParent: oldParent, newParent: newParent } }));
        }

        childAdded(parent: Entity, child: Entity) {
            this.dispatchEvent(new CustomEvent(CHILD_ADDED, { detail: { child: child, parent: parent } }));
        }

        childRemoved(parent: Entity, child: Entity) {
            this.dispatchEvent(new CustomEvent(CHILD_REMOVED, { detail: { child: child, parent: parent } }));
        }

        entityDeleted(entity: Entity) {
            this.dispatchEvent(new CustomEvent(ENTITY_DELETED, { detail: { entity: entity } }));
        }
    */
    static propertyAdded(element, propertyName, type, value) {
        this.dispatchEvent(new CustomEvent(PROPERTY_ADDED, { detail: { element: element, name: propertyName, type: type, value: value } }));
    }
    static propertyChanged(element, propertyName, oldValue, newValue) {
        this.dispatchEvent(new CustomEvent(PROPERTY_CHANGED, { detail: { element: element, name: propertyName, value: newValue, oldValue: oldValue } }));
    }
}

var TimelinePropertyType;
(function (TimelinePropertyType) {
    TimelinePropertyType[TimelinePropertyType["Unknown"] = 0] = "Unknown";
    TimelinePropertyType[TimelinePropertyType["Int"] = 1] = "Int";
    TimelinePropertyType[TimelinePropertyType["Float"] = 2] = "Float";
    TimelinePropertyType[TimelinePropertyType["Time"] = 3] = "Time";
    TimelinePropertyType[TimelinePropertyType["String"] = 4] = "String";
    TimelinePropertyType[TimelinePropertyType["Bool"] = 5] = "Bool";
    TimelinePropertyType[TimelinePropertyType["Color"] = 6] = "Color";
})(TimelinePropertyType || (TimelinePropertyType = {}));
class TimelineProperty {
    #name;
    #type;
    #value;
    constructor(name, type, value) {
        this.#name = name;
        this.#type = type;
        this.#value = value;
    }
    setValue(value) {
        this.#value = value;
    }
    getValue() {
        return this.#value;
    }
}

/*
export interface TimelineElement {
    name: string;
    setParent(element: TimelineElement): void;
    getParent(element: TimelineElement): TimelineElement | null;
}
*/
var TimelineElementType;
(function (TimelineElementType) {
    TimelineElementType[TimelineElementType["None"] = 0] = "None";
    TimelineElementType[TimelineElementType["Timeline"] = 1] = "Timeline";
    TimelineElementType[TimelineElementType["Group"] = 2] = "Group";
    TimelineElementType[TimelineElementType["Channel"] = 3] = "Channel";
    TimelineElementType[TimelineElementType["Clip"] = 4] = "Clip";
    TimelineElementType[TimelineElementType["Marker"] = 5] = "Marker";
})(TimelineElementType || (TimelineElementType = {}));
class TimelineElement {
    #parent;
    #properties = new Map();
    type = TimelineElementType.None;
    /*#name: string;
    startTime: number = 0;
    endTime: number = Infinity;*/
    constructor(name) {
        this.addProperty('name', TimelinePropertyType.String, name);
    }
    setName(name) {
        this.setPropertyValue('name', name);
    }
    getName() {
        return this.getPropertyValue('name');
    }
    addProperty(name, type, value) {
        const property = new TimelineProperty(name, type, value);
        this.#properties.set(name, property);
        return property;
    }
    setPropertyValue(name, value) {
        const property = this.#properties.get(name);
        if (property) {
            const oldValue = property.getValue();
            property.setValue(value);
            TimelineObserver.propertyChanged(this, name, oldValue, value);
        }
    }
    getPropertyValue(name) {
        return this.#properties.get(name)?.getValue();
    }
}

class TimelineGroup extends TimelineElement {
    type = TimelineElementType.Group;
    #childs = [];
    addChild(child) {
        this.#childs.push(child);
        return child;
    }
    getChilds() {
        return [...this.#childs];
    }
}

class Actor {
    name;
    channels = [];
    #choreography;
    active = false;
    constructor(choreography, name) {
        this.#choreography = choreography;
        this.name = name;
    }
    addChannel(channel) {
        this.channels.push(channel);
        channel.setActor(this);
    }
    getCharacter() {
        return this.#choreography.actors2[0]; //fixme: variable
    }
    setActive(active) {
        this.active = active;
    }
    toString(indent) {
        indent = indent || '';
        const subindent = indent + '\t';
        const arr = [indent + 'Actor ' + this.name];
        for (let i = 0; i < this.channels.length; ++i) {
            arr.push(this.channels[i].toString(subindent));
        }
        return arr.join('\n');
    }
    step(previousTime, currentTime) {
        //TODOv2
        for (let i = 0; i < this.channels.length; ++i) {
            this.channels[i].step(previousTime, currentTime);
        }
    }
    toTimelineElement() {
        const actor = new TimelineGroup(this.name);
        for (const channel of this.channels) {
            actor.addChild(channel.toTimelineElement());
        }
        return actor;
    }
}

class TimelineChannel extends TimelineElement {
    type = TimelineElementType.Channel;
    #clips = new Set;
    constructor(name = 'Channel') {
        super(name);
    }
    addClip(clip) {
        this.#clips.add(clip);
        return clip;
    }
    getClips() {
        return [...this.#clips];
    }
}

class Channel {
    active = false;
    events = [];
    name;
    actor;
    constructor(name) {
        this.name = name;
    }
    /**
     * Add an event
     * @param {Object ChoreographyEvent} event The event to add
     */
    addEvent(event) {
        this.events.push(event);
        event.setChannel(this);
    }
    /**
     * TODO
     */
    setActor(actor) {
        this.actor = actor;
    }
    /**
     * TODO
     */
    getActor() {
        return this.actor;
    }
    /**
     * Set active
     * @param {Bool} active active
     */
    setActive(active) {
        this.active = active;
    }
    /**
     * toString
     */
    toString(indent) {
        indent = indent ?? '';
        const subindent = indent + '\t';
        const arr = [indent + 'Channel ' + this.name];
        for (let i = 0; i < this.events.length; ++i) {
            arr.push(this.events[i].toString(subindent));
        }
        if (!this.active) {
            arr.push(indent + 'active 0');
        }
        return arr.join('\n');
    }
    /**
     * Step
     */
    step(previousTime, currentTime) {
        //TODOv2
        for (let i = 0; i < this.events.length; ++i) {
            this.events[i].step(previousTime, currentTime);
        }
    }
    toTimelineElement() {
        const channel = new TimelineChannel(this.name);
        for (const event of this.events) {
            channel.addClip(event.toTimelineElement());
        }
        return channel;
    }
}

class Timeline extends TimelineElement {
    type = TimelineElementType.Timeline;
    name = '';
    #root = new TimelineGroup('');
    constructor(name = 'Timeline') {
        super(name);
    }
    setParent(element) {
        return;
    }
    getRoot() {
        return this.#root;
    }
    addChild(child) {
        return this.#root.addChild(child);
    }
    getChilds() {
        return this.#root.getChilds();
    }
}

var ChoreographyEventType;
(function (ChoreographyEventType) {
    ChoreographyEventType["Stop"] = "stop";
})(ChoreographyEventType || (ChoreographyEventType = {}));
class Choreography extends MyEventTarget {
    #repository;
    actors2 = [];
    #events = [];
    #actors = [];
    previousTime = -1;
    currentTime = 0;
    animsSpeed = 1;
    shouldLoop = false;
    sceneLength = 0;
    //onStop: () => void;
    constructor(repository) {
        super();
        this.#repository = repository;
    }
    getRepository() {
        return this.#repository;
    }
    /**
     * Add an event
     * @param {Object ChoreographyEvent} event The event to add
     */
    addEvent(event) {
        this.#events.push(event);
    }
    /**
     * Add an actor
     * @param {Object ChoreographyActor} actor The actor to add
     */
    addActor(actor) {
        this.#actors.push(actor);
    }
    /**
     * toString
     */
    toString(indent = '') {
        const arr = [];
        for (let i = 0; i < this.#events.length; ++i) {
            arr.push(this.#events[i].toString(indent));
        }
        for (let i = 0; i < this.#actors.length; ++i) {
            arr.push(this.#actors[i].toString(indent));
        }
        return arr.join('\n');
    }
    /**
     * Step
     */
    step(delta) {
        if (this.animsSpeed > 0) {
            const currentTime = this.previousTime == -1 ? 0 : this.previousTime + delta * this.animsSpeed;
            if (this.previousTime != -0.5) {
                this.currentTime = currentTime;
            }
            for (let i = 0; i < this.#events.length; ++i) {
                this.#events[i].step(this.previousTime, this.currentTime);
            }
            for (let i = 0; i < this.#actors.length; ++i) {
                this.#actors[i].step(this.previousTime, this.currentTime);
            }
            if (this.shouldLoop) {
                this.shouldLoop = false;
                return true;
            }
            this.previousTime = this.currentTime;
            if (currentTime > this.sceneLength) {
                this.stop();
                return false;
            }
        }
        return true;
    }
    /**
     * Reset
     */
    reset() {
        this.previousTime = -1;
        this.currentTime = 0;
    }
    /**
     * Stop
     */
    stop() {
        this.dispatchEvent(new Event(ChoreographyEventType.Stop));
    }
    /**
     * Step
     */
    loop(startTime) {
        this.previousTime = startTime - EPSILON$2;
        this.currentTime = startTime;
        this.shouldLoop = true;
    }
    /**
     * Step
     */
    setActors(actors) {
        this.actors2 = actors;
    }
    toTimelineElement() {
        const timeline = new Timeline();
        const events = timeline.addChild(new TimelineGroup('Events'));
        timeline.addChild(new TimelineGroup('Actors'));
        for (const event of this.#events) {
            events.addChild(event.toTimelineElement());
        }
        for (const actor of this.#actors) {
            events.addChild(actor.toTimelineElement());
        }
        /*
        for (let i = 0; i < this.#actors.length; ++i) {
            arr.push(this.#actors[i].toString(indent));
        }
            */
        return timeline;
    }
}

class CurveData {
    #ramp = [];
    /**
     * Add a sample TODO
     * @param {Object ChoreographyEvent} event The event to add
     * @return {Object Choreography} The requested choreography or null
     */
    add(time, value, selected) {
        this.#ramp.push({ time: time, value: value, selected: selected });
    }
    getValue(time) {
        let previous = null;
        for (const current of this.#ramp) {
            if (time <= current.time) {
                if (previous) {
                    return RemapValClamped(time, previous.time, current.time, previous.value, current.value);
                }
                else {
                    return current.value;
                }
            }
            previous = current;
        }
        return null;
    }
    /**
     * toString
     */
    toString(indent) {
        if (!this.#ramp.length) {
            return '';
        }
        indent = indent ?? '';
        const subindent = indent + '\t';
        const arr = [indent + 'event_ramp'];
        for (let i = 0; i < this.#ramp.length; ++i) {
            const rampData = this.#ramp[i];
            arr.push(subindent + rampData.time + ' ' + rampData.value);
        }
        return arr.join('\n');
    }
}

class ExpressionSample {
    v = 0.0;
    t = 0.0;
    s = 0;
    c = 0;
    selected = false;
    setCurveType(curveType) {
        this.c = curveType;
    }
    /**
     * toString
     */
    toString(indent = '') {
        return indent + this.t + ' ' + this.v;
    }
}

class FlexAnimationTrack {
    event;
    flags = 0;
    samples = [[], []];
    controllerName = '';
    min = 0;
    max = 0;
    constructor(event) {
        this.event = event;
    }
    setFlexControllerName(controllerName) {
        this.controllerName = controllerName;
    }
    setFlags(flags) {
        this.flags = flags;
    }
    setMin(min) {
        this.min = min;
    }
    setMax(max) {
        this.max = max;
    }
    isTrackActive() {
        return (this.flags & (1 << 0)) ? true : false;
    }
    isComboType() {
        return (this.flags & (1 << 1)) ? true : false;
    }
    addSample(time, value, type) {
        const sample = new ExpressionSample();
        sample.t = time;
        sample.v = value;
        sample.selected = false;
        this.samples[type]?.push(sample);
        return sample;
    }
    toString(indent) {
        indent = indent ?? '';
        const subindent = indent + '\t';
        const arr = [indent + this.controllerName];
        for (let sampleType = 0; sampleType < 2; ++sampleType) {
            const samples = this.samples[sampleType];
            for (const sample of samples) {
                arr.push(subindent + sample.toString());
            }
        }
        return arr.join('\n');
    }
}

// TODO can this be merged with kv3element ?
class KvAttribute {
    name;
    value;
    constructor(name, value) {
        this.name = name.toLowerCase();
        this.value = value;
    }
}
class KvElement {
    // TODO: create map to store values
    addElement(name, value) {
        name = name.toLowerCase();
        let newName = name;
        let count = 1;
        while (this /*TODO: fix this*/[newName]) {
            newName = name + '#' + (++count);
        }
        this /*TODO: fix this*/[newName] = value;
    }
    toString(linePrefix) {
        linePrefix = linePrefix ?? '';
        const s = [linePrefix, '"' /*, this.type, '"\n'*/, linePrefix, '{\n'];
        for (const i in this) {
            s.push(this.toString(linePrefix + '\t'));
        }
        s.push(linePrefix);
        s.push('}\n');
        return s.join('');
    }
}
class KvReader {
    root = undefined;
    rootElements = {}; //TODO: create map
    rootId = 0;
    carSize;
    src;
    offset;
    inQuote = false;
    inComment = false;
    currentAttribute;
    currentElement;
    currentArray;
    //name!: never;
    currentValue;
    elementStack;
    attributeStack;
    valuesStack;
    keyStack;
    arrayStack;
    rootElement;
    rootName;
    currentKey;
    constructor(carSize = 1) {
        this.carSize = carSize;
    }
    readText(src) {
        if (!src) {
            return;
        }
        this.src = src;
        let start = src.indexOf('-->');
        if (start > 0) {
            start += 5; //-->/nx
        }
        else {
            start = 0;
        }
        this.offset = start;
        this.inQuote = false;
        this.inComment = false;
        this.currentAttribute = undefined;
        this.currentElement = undefined;
        this.currentArray = undefined;
        //this.name = undefined;
        this.currentValue = '';
        this.elementStack = [];
        this.attributeStack = [];
        this.valuesStack = [];
        this.keyStack = [];
        this.arrayStack = [];
        let end = false;
        do {
            end = this.parse();
        } while (!end);
        this.endElement();
    }
    getRootElement() {
        return this.rootElement;
    }
    getRootName() {
        return this.rootName;
    }
    readChar() {
        if (this.offset > this.src.length) {
            return -1;
        }
        const offset = this.offset;
        this.offset += this.carSize;
        return this.src.charAt(offset);
    }
    pickChar() {
        if (this.offset > this.src.length) {
            return -1;
        }
        return this.src.charAt(this.offset);
    }
    pushElement() {
        if (this.currentElement) {
            this.elementStack.push(this.currentElement);
        }
        if (!this.rootElement) ;
        this.currentElement = new KvElement( /*this.popValue()*/);
        this.currentKey = this.popValue();
        this.pushKey();
    }
    popElement() {
        const a = this.currentElement;
        this.currentElement = this.elementStack.pop();
        if (!this.currentElement) {
            //this.rootElements.push(a);
            let rootName = this.popKey();
            if (rootName == undefined) {
                rootName = 'undefined' + (this.rootId++);
            }
            this.rootElements[rootName] = a;
            if (!this.rootElement) {
                this.rootName = rootName;
                this.rootElement = a;
            }
        }
    }
    pushAttribute() {
        if (this.currentAttribute) {
            this.attributeStack.push(this.currentAttribute);
        }
        //this.currentAttribute = new KvElement();
    }
    popAttribute() {
        this.currentAttribute = this.attributeStack.pop();
    }
    pushValue() {
        this.valuesStack.push(this.currentValue);
        this.currentValue = '';
    }
    popValue() {
        if (this.valuesStack.length == 0) ;
        return this.valuesStack.pop();
    }
    pushKey() {
        this.keyStack.push(this.currentKey);
        this.currentKey = '';
    }
    popKey() {
        if (this.keyStack.length == 0) ;
        return this.keyStack.pop();
    }
    pushArray() {
        if (this.currentArray) {
            this.arrayStack.push(this.currentArray);
        }
        this.currentArray = undefined;
    }
    popArray() {
        this.currentArray = this.arrayStack.pop();
    }
    parse() {
        const car = this.readChar();
        if (car == -1)
            return true;
        if (this.inComment && (car != '\r' && car != '\n')) {
            return false;
        }
        this.inComment = false;
        if (this.inQuote && car != '"' && car != '\r' && car != '\n') {
            this.currentValue += car;
        }
        else {
            switch (car) {
                case '\\':
                    if (this.inQuote) {
                        const car2 = this.pickChar();
                        if (car2 == '\"') {
                            this.currentValue += car2;
                        }
                        else {
                            this.currentValue += car;
                        }
                    }
                    else {
                        this.currentValue += car;
                    }
                    break;
                case '/':
                    const car2 = this.pickChar();
                    if (car2 == '/') {
                        this.inComment = true;
                    }
                    else {
                        this.currentValue += car;
                    }
                    break;
                case ' ':
                case '\t':
                    if (this.currentValue != '') {
                        this.setValue();
                    }
                    if (this.valuesStack.length >= 2) {
                        this.newLine();
                        //if (!this.multipleValuesOnSameLine) {//TODOV2
                        this.inComment = true;
                        //}
                    }
                    break;
                case '\r':
                case '\n':
                    if (!this.inQuote && this.currentValue != '')
                        this.setValue();
                    this.newLine();
                    break;
                case '"':
                    if (this.inQuote)
                        this.setValue();
                    this.inQuote = !this.inQuote;
                    break;
                case '{':
                    if (this.currentValue != '') {
                        this.setValue();
                    }
                    this.startElement();
                    break;
                case '}':
                    this.endElement();
                    break;
                case '[':
                    this.startArray();
                    break;
                case ']':
                    this.endArray();
                    break;
                case ',':
                    this.comma();
                    //this.nextArrayValue()
                    break;
                default:
                    this.currentValue += car;
                    break;
            }
        }
        return false;
    }
    startElement() {
        this.pushElement();
        this.newLine();
        this.pushAttribute();
    }
    endElement() {
        if (this.currentElement) {
            const e = this.currentElement;
            this.popElement();
            if (this.currentElement) {
                const key = this.popKey();
                if (key !== undefined) {
                    this.currentElement.addElement(key, e);
                }
            }
        }
    }
    startArray() {
        this.pushArray();
        this.currentValue = [];
        this.currentArray = this.currentValue;
        this.pushValue();
        this.newLine();
        this.pushAttribute();
    }
    endArray() {
        this.popAttribute();
        //this.currentAttribute.value.push(this.currentElement);
        this.popArray();
    }
    nextArrayValue() {
        //TODO
    }
    setValue() {
        this.pushValue();
    }
    newLine() {
        if (this.valuesStack.length >= 2) {
            // order matters
            const value = this.popValue();
            const name = this.popValue();
            const newAttribute = new KvAttribute(name, value);
            if (this.currentElement) {
                this.currentElement.addElement(name, value);
            }
            else if (this.currentArray) {
                this.currentArray.push(newAttribute);
            }
            this.currentAttribute = newAttribute;
        }
    }
    comma() {
        if (this.valuesStack.length >= 1) {
            // order matters
            const value = this.popValue();
            const name = this.popValue();
            const newAttribute = new KvAttribute(name, value);
            if (this.currentArray) {
                this.currentArray.push(newAttribute);
            }
            else if (this.currentElement) ;
            this.currentAttribute = newAttribute;
        }
    }
}

class Sound {
    #repository;
    #wave;
    #channel;
    constructor(repository, wave, channel) {
        this.#repository = repository;
        this.#wave = wave;
        this.#channel = channel;
    }
    getRepository() {
        return this.#repository;
    }
    getWave() {
        if (Array.isArray(this.#wave)) {
            const index = Math.floor(Math.random() * this.#wave.length);
            return this.#wave[index];
        }
        else {
            return this.#wave;
        }
    }
    getChannel() {
        return this.#channel;
    }
}

class Source1SoundManager {
    static #mute = false;
    static #audioList = new Map();
    static #soundList = {};
    static #soundsPerRepository = new Map();
    static #soundListPerRepository = {};
    static #manifestsPerRepository = new Map();
    static #promisePerRepository = new Map();
    /**
     * Play a sound
     * @param {String} soundName soundName
     */
    static async playSound(repositoryName, soundName) {
        if (this.#mute) {
            return null;
        }
        const sound = await this.#getSound(repositoryName, soundName);
        //const sound = this.#soundList[soundName];
        if (sound) {
            let wave = sound.getWave();
            // Remove #, *, ( and ) from paths
            wave = wave.replace(/[\(\)\#\*]/g, '').toLowerCase();
            let audio = this.#audioList.get(wave);
            //audio = null;//removeme
            if (!audio) {
                const response = await Repositories.getFileAsBlob(sound.getRepository(), '/sound/' + wave);
                if (!response.error) {
                    audio = new Audio(URL.createObjectURL(response.blob) /*new URL('/sound/' + wave, repository.base).toString()*/);
                    this.#audioList.set(wave, audio);
                    audio.volume = 0.1;
                    //audio.play();
                    AudioMixer.playAudio('master', audio); //TODO: change master per actual channel
                }
                else {
                    return null;
                }
            }
            else {
                AudioMixer.playAudio('master', audio);
            }
            return audio;
        }
        return null;
    }
    static async #getSound(repositoryName, soundName) {
        await this.#fetchManifests(repositoryName);
        /*const repo = this.#soundsPerRepository[repositoryName];
        if (repo) {
            return repo[soundName];
        }*/
        return this.#soundsPerRepository.get(repositoryName)?.get(soundName) ?? null;
    }
    static async #fetchManifests(repositoryName) {
        if (this.#promisePerRepository.has(repositoryName)) {
            await this.#promisePerRepository.get(repositoryName);
        }
        if (!this.#soundsPerRepository.has(repositoryName)) {
            this.#soundsPerRepository.set(repositoryName, new Map());
        }
        let promiseResolve;
        this.#promisePerRepository.set(repositoryName, new Promise(resolve => promiseResolve = resolve));
        const manifests = this.#manifestsPerRepository.get(repositoryName);
        if (manifests) {
            this.#manifestsPerRepository.delete(repositoryName);
            for (const manifest of manifests) {
                await this.#fetchManifest(repositoryName, manifest);
            }
        }
        promiseResolve(true);
    }
    static async #fetchManifest(repositoryName, manifestPath) {
        const response = await Repositories.getFileAsText(repositoryName, manifestPath);
        if (!response.error) {
            this.#loadManifest(repositoryName, response.text);
        }
    }
    static #loadManifest(repositoryName, manifestTxt) {
        const sounds = this.#soundsPerRepository.get(repositoryName);
        const kv = new KvReader();
        kv.readText(manifestTxt);
        const list = kv.rootElements;
        const keyArray = Object.keys(list);
        for (let i = 0; i < keyArray.length; ++i) {
            const soundKey = keyArray[i];
            const sound = list[soundKey] /*TODO: improve type*/;
            let wave;
            if (sound.rndwave) {
                wave = [];
                Object.keys(sound.rndwave).forEach(function (element) {
                    wave.push(sound.rndwave[element]);
                });
            }
            else {
                wave = sound.wave;
            }
            //const wave = sound.rndwave ? sound.rndwave : sound.wave;
            const s = new Sound(repositoryName, wave, sound.channel);
            sounds?.set(soundKey, s);
        }
    }
    static loadManifest(repositoryName, fileName) {
        let manifests = this.#manifestsPerRepository.get(repositoryName);
        if (!manifests) {
            manifests = [];
            this.#manifestsPerRepository.set(repositoryName, manifests);
        }
        manifests.push(fileName);
    }
    static mute() {
        this.#mute = true;
    }
    static unmute() {
        this.#mute = false;
    }
}

class TimelineClip extends TimelineElement {
    type = TimelineElementType.Clip;
    constructor(name = 'Clip', startTime = 0, endTime = Infinity) {
        super(name);
        this.addProperty('start', TimelinePropertyType.Time, startTime);
        this.addProperty('end', TimelinePropertyType.Time, endTime);
    }
    setStartTime(start) {
        this.setPropertyValue('start', start);
    }
    getStartTime() {
        return this.getPropertyValue('start');
    }
    setEndTime(end) {
        this.setPropertyValue('end', end);
    }
    getEndTime() {
        return this.getPropertyValue('end');
    }
    getLength() {
        return this.getPropertyValue('end') - this.getPropertyValue('start');
    }
}

class ChoreographyEvent {
    #repository;
    type;
    name;
    startTime;
    endTime;
    param1;
    param2;
    param3;
    flags;
    distanceToTarget = 0;
    flexAnimTracks = {};
    #ramp;
    #ccType = -1; // TODO: create enum
    #ccToken = '';
    #choreography;
    #channel;
    m_nNumLoops = 0;
    constructor(choreography, repository, eventType, name, startTime, endTime, param1, param2, param3, flags, distanceToTarget) {
        this.#repository = repository;
        this.#choreography = choreography;
        this.type = eventType;
        this.name = name;
        this.startTime = startTime;
        this.endTime = endTime;
        this.param1 = param1;
        this.param2 = param2;
        this.param3 = param3;
        this.flags = flags;
        this.distanceToTarget = distanceToTarget;
    }
    getRepository() {
        return this.#repository;
    }
    /**
     * Get the startTime
     * @return {Number} startTime
     */
    getStartTime() {
        return this.startTime;
    }
    /**
     * Get the endTime
     * @return {Number} endTime
     */
    getEndTime() {
        return this.endTime;
    }
    /**
     * Get the type
     * @return {Number} The loaded file
     */
    getType() {
        return this.type;
    }
    /**
     * Set the ramp
     * @param {Object CurveData} ramp The ramp to set
     */
    setRamp(ramp) {
        this.#ramp = ramp;
    }
    /**
     * TODO
     */
    setCloseCaptionType(ccType) {
        this.#ccType = ccType;
    }
    /**
     * TODO
     */
    setCloseCaptionToken(token) {
        this.#ccToken = token;
    }
    /**
     * TODO
     */
    setChannel(channel) {
        this.#channel = channel;
    }
    //TODO
    AddRelativeTag() {
        console.error('TODO');
    }
    //TODO
    addRelativeTag() {
        console.error('TODO');
    }
    //TODO
    addTimingTag() {
        console.error('TODO');
    }
    //TODO
    addAbsoluteTag() {
        console.error('TODO');
    }
    /**
     * TODO
     */
    isResumeCondition() {
        return (this.flags & (1 << 0)) ? true : false;
    }
    /**
     * TODO
     */
    isLockBodyFacing() {
        return (this.flags & (1 << 1)) ? true : false;
    }
    /**
     * TODO
     */
    isFixedLength() {
        return (this.flags & (1 << 2)) ? true : false;
    }
    /**
     * TODO
     */
    isActive() {
        return (this.flags & (1 << 3)) ? true : false;
    }
    /**
     * TODO
     */
    getForceShortMovement() {
        return (this.flags & (1 << 4)) ? true : false;
    }
    /**
     * TODO
     */
    getPlayOverScript() {
        return (this.flags & (1 << 5)) ? true : false;
    }
    /**
     * TODO
     * Add a flex animation track
     */
    addTrack(controllerName) {
        const track = new FlexAnimationTrack(this);
        track.setFlexControllerName(controllerName);
        this.flexAnimTracks[controllerName] = track;
        return track;
    }
    /**
     * toString
     */
    toString(indent) {
        indent = indent ?? '';
        const subindent = indent + '\t';
        const arr = [];
        arr.push(indent + 'Event ' + EventType[this.type] + ' ' + this.name);
        arr.push(subindent + 'time ' + this.startTime + ' ' + this.endTime);
        if (this.param1) {
            arr.push(subindent + 'param1 ' + this.param1);
        }
        if (this.param2) {
            arr.push(subindent + 'param2 ' + this.param2);
        }
        if (this.param3) {
            arr.push(subindent + 'param3 ' + this.param3);
        }
        if (this.#ramp) {
            arr.push(this.#ramp.toString(subindent));
        }
        if (this.getType() == EventType.Flexanimation) {
            arr.push(subindent + 'flexanimations');
        }
        for (const i in this.flexAnimTracks) {
            arr.push(this.flexAnimTracks[i].toString(subindent + '\t'));
        }
        if (this.getType() == EventType.Speak) {
            arr.push(subindent + 'cctype ' + CloseCaptionType[this.#ccType]);
            arr.push(subindent + 'cctoken ' + this.#ccToken);
        }
        return arr.join('\n');
    }
    /**
     * Step
     */
    step(previousTime, currentTime) {
        const actor = this.getActor();
        if (actor) {
            actor.frame = currentTime;
        }
        //TODOv2
        if (previousTime < this.startTime && currentTime >= this.startTime) {
            //console.info(frame2, currentTime, this.type, this.param1, this.param2, this.param3);
            switch (this.type) {
                case EventType.Speak:
                    Source1SoundManager.playSound(this.#repository, this.param1);
                    break;
                case EventType.Sequence:
                    //mainCharacter.characterModel.playSequence(this.param1);//TODOv2
                    if (actor) {
                        actor.playSequence(this.param1); //TODOv2
                        //actor.frame = currentTime;
                        /*if (actor.characterModel) {
                            actor.playSequence(this.param1);//TODOv2
                        }
                        if (actor.sourceModel) {
                            actor.playSequence(this.param1);//TODOv2
                        }*/
                    }
                    //frame2 = currentTime;
                    break;
                case EventType.Loop:
                    //TODO: loop count
                    if (this.#choreography) {
                        this.#choreography.loop(this.param1 * 1.0);
                        //frame2 = this.param1 * 1.0;
                    }
                    break;
            }
            return;
        }
        if (previousTime < this.endTime && currentTime >= this.endTime) {
            //console.info(frame2, currentTime, this.type, this.param1, this.param2, this.param3);
            switch (this.type) {
                case EventType.Sequence:
                    const actor = this.getActor();
                    if (actor) {
                        if (actor) {
                            actor.playSequence('stand_secondary'); //TODOv2
                        }
                    }
                    //frame2 = currentTime;
                    break;
            }
        }
        if (currentTime >= this.startTime && currentTime <= this.endTime) {
            switch (this.type) {
                /*case EventType.Expression:
                    let actor = this.getActor();
                    if (actor) {
                        let flexParameters = {};
                        flexParameters[this.param2.toLowerCase()] = this.ramp.getValue(currentTime);
                        actor.setFlexes(flexParameters);
                    }
                    break;*/
            }
        }
    }
    /**
     * TODO
     */
    getActor() {
        const channel = this.#channel;
        if (channel) {
            const actor = channel.getActor();
            if (actor) {
                return actor.getCharacter();
            }
        }
    }
    toTimelineElement() {
        const clip = new TimelineClip(this.name, this.startTime, this.endTime);
        return clip;
    }
}
var EventType;
(function (EventType) {
    EventType[EventType["Unspecified"] = 0] = "Unspecified";
    EventType[EventType["Section"] = 1] = "Section";
    EventType[EventType["Expression"] = 2] = "Expression";
    EventType[EventType["LookAt"] = 3] = "LookAt";
    EventType[EventType["MoveTo"] = 4] = "MoveTo";
    EventType[EventType["Speak"] = 5] = "Speak";
    EventType[EventType["Gesture"] = 6] = "Gesture";
    EventType[EventType["Sequence"] = 7] = "Sequence";
    EventType[EventType["Face"] = 8] = "Face";
    EventType[EventType["FireTrigger"] = 9] = "FireTrigger";
    EventType[EventType["Flexanimation"] = 10] = "Flexanimation";
    EventType[EventType["SubScene"] = 11] = "SubScene";
    EventType[EventType["Loop"] = 12] = "Loop";
    EventType[EventType["Interrupt"] = 13] = "Interrupt";
    EventType[EventType["StopPoint"] = 14] = "StopPoint";
    EventType[EventType["PermitResponses"] = 15] = "PermitResponses";
    EventType[EventType["Generic"] = 16] = "Generic";
})(EventType || (EventType = {}));
//TODO: setup const
/*
Event.EventType = {
    UNSPECIFIED: 0,
    SECTION: 1,
    EXPRESSION: 2,
    LOOKAT: 3,
    MOVETO: 4,
    SPEAK: 5,
    GESTURE: 6,
    SEQUENCE: 7,
    FACE: 8,
    FIRETRIGGER: 9,
    FLEXANIMATION: 10,
    SUBSCENE: 11,
    LOOP: 12,
    INTERRUPT: 13,
    STOPPOINT: 14,
    PERMIT_RESPONSES: 15,
    GENERIC: 16
}
Event.EventTypeString = ['UNSPECIFIED', 'SECTION', 'EXPRESSION', 'LOOKAT', 'MOVETO', 'SPEAK', 'GESTURE', 'SEQUENCE', 'FACE', 'FIRETRIGGER', 'FLEXANIMATION', 'SUBSCENE', 'LOOP', 'INTERRUPT', 'STOPPOINT', 'PERMIT_RESPONSES', 'GENERIC']
*/
var TimeType;
(function (TimeType) {
    TimeType[TimeType["Default"] = 0] = "Default";
    TimeType[TimeType["Simulation"] = 1] = "Simulation";
    TimeType[TimeType["Display"] = 2] = "Display";
})(TimeType || (TimeType = {}));
/*
Event.TimeType = {
    DEFAULT: 0,
    SIMULATION: 1,
    DISPLAY: 2
}
Event.TimeTypeString = ['DEFAULT', 'SIMULATION', 'DISPLAY'];
*/
var CloseCaptionType;
(function (CloseCaptionType) {
    CloseCaptionType[CloseCaptionType["Master"] = 0] = "Master";
    CloseCaptionType[CloseCaptionType["Slave"] = 1] = "Slave";
    CloseCaptionType[CloseCaptionType["Disabled"] = 2] = "Disabled";
})(CloseCaptionType || (CloseCaptionType = {}));
/*
Event.CloseCaptionType = {
    CC_MASTER: 0,
    CC_SLAVE: 1,
    CC_DISABLED: 2
}
Event.CloseCaptionTypeString = ['CC_MASTER', 'CC_SLAVE', 'CC_DISABLED'];
*/

class Choreographies {
    // TODO: multiple repos
    #repository = '';
    choreographies = {}; //TODO: use map instead ?
    stringPool = {}; //TODO: use map instead ?
    #reader;
    fileId;
    fileVersion;
    scenesCount;
    stringsCount;
    scenesOffset;
    #sceneEntries = new Map();
    #initialized = false;
    async loadFile(repositoryName, fileName) {
        this.#repository = repositoryName;
        /*
        if (!repository) {
            console.error(`Unknown repository ${repositoryName} in Choreographies.loadFile`);
            return null;
        }
            */
        const respone = await Repositories.getFileAsArrayBuffer(repositoryName, fileName);
        if (respone.error) {
            return null;
        }
        /*
        p.then((arrayBuffer) => {
            if (arrayBuffer) {
                resolve(this.parse(repositoryName, fileName, arrayBuffer));
            } else {
                resolve(null);
            }
        });
        */
        //this.#reader = new RemoteBinaryReader(new URL(fileName, repository.base), undefined, CHOREOGRAPHIES_CHUNK_SIZE);
        this.#reader = new BinaryReader(respone.buffer, undefined, undefined, true);
        await this.#parseHeader();
    }
    async #parseHeader() {
        this.fileId = this.#reader.getUint32(0);
        this.fileVersion = this.#reader.getUint32();
        this.scenesCount = this.#reader.getUint32();
        this.stringsCount = this.#reader.getUint32();
        this.scenesOffset = this.#reader.getUint32();
    }
    async getChoreography(fileName) {
        const choreoCRC = crc32(fileName.replace(/\//g, '\\').toLowerCase());
        if (!this.#initialized) {
            await this.#parseSceneEntries();
            this.#initialized = true;
            if (!this.#initialized) {
                return null;
            }
        }
        if (this.choreographies[choreoCRC]) ;
        if (this.#sceneEntries.get(choreoCRC)) {
            const choreo = await this.#parseSceneData(this.#repository, choreoCRC);
            if (choreo) {
                this.choreographies[choreoCRC] = choreo;
                //console.info(choreo);
                return choreo;
            }
        }
        return null;
    }
    async #parseSceneEntries() {
        //await this.#reader.getLock();
        if (this.scenesOffset && this.scenesCount) {
            this.scenesCount * 16;
            // Ensure we have enough data
            //if (this.hasChunk(this.scenesOffset, size))
            {
                this.#sceneEntries.clear();
                this.#initialized = true;
                this.#reader.seek(this.scenesOffset);
                for (let i = 0; i < this.scenesCount; i++) {
                    const sceneCRC = this.#reader.getUint32();
                    const doo = this.#reader.getUint32();
                    const dl = this.#reader.getUint32();
                    const sso = this.#reader.getUint32();
                    const sceneEntry = { 'do': doo, 'dl': dl, 'sso': sso };
                    this.#sceneEntries.set(sceneCRC, sceneEntry);
                }
            }
        }
        //this.#reader.releaseLock();
    }
    async #parseSceneData(repository, sceneCRC) {
        //await this.#reader.getLock();
        let choreography = null;
        const sceneEntry = this.#sceneEntries.get(sceneCRC);
        if (sceneEntry) {
            //if (this.hasChunk(sceneEntry['do'], sceneEntry['dl']) && this.hasChunk(sceneEntry['sso'], 8))
            {
                //this.#reader.seek(sceneEntry['do']);
                //reader.skip(4);//LZMA
                const format = this.#reader.getString(4, sceneEntry['do']);
                let decompressedDatas;
                try {
                    if (format == 'LZMA') {
                        const HEADER_SIZE = 17; // 4 + 4 + 4 + 5
                        const uncompressedSize = this.#reader.getUint32();
                        const compressedSize = this.#reader.getUint32();
                        const properties = this.#reader.getBytes(5);
                        const compressedDatas = this.#reader.getBytes(sceneEntry['dl'] - HEADER_SIZE);
                        //decompressedDatas = _decompress(properties, compressedDatas, uncompressedSize);
                        decompressedDatas = DecompressLZMA(properties, compressedDatas, uncompressedSize);
                    }
                    else {
                        decompressedDatas = this.#reader.getString(sceneEntry['dl'], sceneEntry['do']);
                    }
                    if (decompressedDatas) {
                        choreography = await this.#loadChoreography(repository, decompressedDatas);
                    }
                }
                catch (e) {
                    //fixme: add error code
                    console.error(e);
                }
                if (choreography) {
                    //this.#reader.seek(sceneEntry['sso']);
                    choreography.sceneLength = (this.#reader.getUint32(sceneEntry['sso'])) * 0.001;
                }
            }
        }
        //this.#reader.releaseLock();
        return choreography;
    }
    async #loadChoreography(repository, fileContent) {
        const reader = new BinaryReader(fileContent, undefined, undefined, true);
        //saveFile(new File([new Blob([reader.buffer])], '#parseSceneData'));
        const choreography = new Choreography(repository);
        await reader.getInt32();
        await reader.getInt8();
        await reader.getInt32();
        await this.#loadChoreoEvents(reader, choreography);
        await this.#loadChoreoActors(reader, choreography);
        return choreography;
    }
    /**
    * load choreography events
    * @param {Object jDataView} reader File reader
    */
    async #loadChoreoEvents(reader, choreography) {
        const repository = choreography.getRepository();
        const eventCount = await reader.getUint8();
        for (let eventIndex = 0; eventIndex < eventCount; ++eventIndex) {
            choreography.addEvent(await this.#loadChoreoEvent(reader, repository, choreography));
        }
    }
    /**
    * load choreography actors
    * @param {Object jDataView} reader File reader
    */
    async #loadChoreoActors(reader, choreography) {
        const actorCount = await reader.getUint8();
        for (let actorIndex = 0; actorIndex < actorCount; ++actorIndex) {
            choreography.addActor(await this.#loadChoreoActor(reader, choreography.getRepository(), choreography));
        }
    }
    /**
    * load an actor
    * @param {Object jDataView} reader File reader
    */
    async #loadChoreoActor(reader, repository, choreography) {
        const actorName = await this.readString(reader);
        const actor = new Actor(choreography, actorName);
        const channelCount = await reader.getUint8();
        for (let channelIndex = 0; channelIndex < channelCount; ++channelIndex) {
            actor.addChannel(await this.#loadChoreoChannel(reader, repository, choreography));
        }
        actor.setActive(reader.getInt8() != 0);
        return actor;
    }
    /**
    * load an channel
    * @param {Object jDataView} reader File reader
    */
    async #loadChoreoChannel(reader, repository, choreography) {
        const channelName = await this.readString(reader);
        const channel = new Channel(channelName);
        const eventCount = await reader.getUint8();
        for (let eventIndex = 0; eventIndex < eventCount; ++eventIndex) {
            channel.addEvent(await this.#loadChoreoEvent(reader, repository, choreography));
        }
        channel.setActive(reader.getInt8() != 0);
        return channel;
    }
    /**
    * load an event
    * @param {Object jDataView} reader File reader
    */
    async #loadChoreoEvent(reader, repository, choreography) {
        const eventType = await reader.getInt8();
        const eventName = await this.readString(reader);
        const startTime = await reader.getFloat32();
        const endTime = await reader.getFloat32();
        const param1 = await this.readString(reader);
        const param2 = await this.readString(reader);
        const param3 = await this.readString(reader);
        const ramp = await this.#loadCurveData(reader);
        const flags = await reader.getUint8();
        const distToTarget = await reader.getFloat32();
        const event = new ChoreographyEvent(choreography, repository, eventType, eventName, startTime, endTime, param1, param2, param3, flags, distToTarget);
        event.setRamp(ramp);
        // Relative & timing tags
        for (let tagtype = 0; tagtype < 2; ++tagtype) {
            const numTags = await reader.getUint8();
            for (let j = 0; j < numTags; ++j) {
                await this.readString(reader);
                await reader.getUint8() / 255.0;
                if (tagtype == 0) {
                    event.addRelativeTag( /*tagName, percentage*/);
                }
                else {
                    event.addTimingTag( /*tagName, percentage, false*/);
                }
            }
        }
        // Absolute tags PLAYBACK / ORIGINAL
        for (let tagtype = 0; tagtype < 2; ++tagtype) {
            const numTags = await reader.getUint8();
            for (let j = 0; j < numTags; ++j) {
                await this.readString(reader);
                await reader.getUint16() / 4096.0;
                event.addAbsoluteTag( /*tagtype, tagName, percentage*/);
            }
        }
        if (event.getType() == EventType.Gesture) {
            await reader.getFloat32();
            console.error('TODO');
        }
        if (await reader.getInt8()) {
            await this.readString(reader);
            await this.readString(reader);
            console.error('TODO');
        }
        await this.#loadFlexAnimations(reader, event);
        if (event.getType() == EventType.Loop) {
            event.m_nNumLoops = await reader.getInt8();
        }
        if (event.getType() == EventType.Speak) {
            event.setCloseCaptionType(await reader.getInt8());
            event.setCloseCaptionToken(await this.readString(reader));
            await reader.getInt8();
            console.error('TODO');
        }
        return event;
    }
    /**
    * load flex animations
    * @param {Object jDataView} reader File reader
    */
    #loadFlexAnimations(reader, event) {
        const numTracks = reader.getUint8();
        for (let i = 0; i < numTracks; ++i) {
            console.error('TODO');
            // Controller name
            const track = event.addTrack(this.readString(reader));
            track.setFlags(reader.getUint8());
            track.setMin(reader.getFloat32());
            track.setMax(reader.getFloat32());
            const sampleTypeCount = track.isComboType() ? 2 : 1;
            for (let sampleType = 0; sampleType < sampleTypeCount; ++sampleType) { //TODO: improve condition
                const sampleCount = reader.getUint16();
                for (let j = 0; j < sampleCount; ++j) {
                    const sample = track.addSample(reader.getFloat32(), reader.getUint8() / 255.0, sampleType);
                    sample.setCurveType(reader.getUint16());
                    /*t = await reader.getFloat32();
                    v = await reader.getUint8() / 255.0;*/
                    //TODO: add sample
                    //					await reader.getUint16();
                }
            }
        }
    }
    /**
    * load curve data
    * @param {Object jDataView} reader File reader
    */
    #loadCurveData(reader) {
        const curveData = new CurveData();
        const count = reader.getUint8();
        /*if (count == 3) {
            //	TODO: there is an issue with choreo 'scenes/workshop/player/engineer/low/taunt_jackhammer_rodeo.vcd'
            count is stored as an unsigned char but actual count is 259
            count += 256;
        }*/
        for (let i = 0; i < count; ++i) {
            const t = reader.getFloat32();
            const v = reader.getUint8() / 255.0;
            curveData.add(t, v, false);
        }
        return curveData;
    }
    /**
    * Read string index, return the string
    * @return {String} The read string or null
    */
    readString(reader) {
        return this.getString(reader.getInt16());
    }
    /**
    * Get a string
    * @param {Number} stringIndex stringIndex
    * @return {String} The read string or error string
    */
    getString(stringIndex) {
        const s = this.stringPool[stringIndex];
        if (s === undefined) {
            const stringOffsetOffset = 20 + stringIndex * 4;
            const stringOffset = this.#reader.getUint32(stringOffsetOffset);
            return this.#reader.getNullString(stringOffset);
        }
        throw new Error(`String not found ${stringIndex}`);
    }
}
function makeCRCTable() {
    let c;
    const crcTable = [];
    for (let n = 0; n < 256; n++) {
        c = n;
        for (let k = 0; k < 8; k++) {
            c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
        }
        crcTable[n] = c;
    }
    return crcTable;
}
let CacheCrcTable;
function crc32(str) {
    const crcTable = CacheCrcTable ?? (CacheCrcTable = makeCRCTable());
    let crc = 0 ^ (-1);
    for (let i = 0; i < str.length; i++) {
        crc = (crc >>> 8) ^ crcTable[(crc ^ str.charCodeAt(i)) & 0xFF];
    }
    return (crc ^ (-1)) >>> 0;
}

class ChoreographiesManager {
    static #instance;
    #playbackSpeed = 1.0;
    #playing = true;
    #choreographies = new Set();
    #sceneImage;
    constructor() {
        if (ChoreographiesManager.#instance) {
            return ChoreographiesManager.#instance;
        }
        ChoreographiesManager.#instance = this;
    }
    async init(repositoryName, fileName) {
        if (!this.#sceneImage) {
            this.#sceneImage = new Choreographies();
            await this.#sceneImage.loadFile(repositoryName, fileName);
            GraphicsEvents.addEventListener(GraphicsEvent.Tick, (event) => {
                if (event.detail.delta) {
                    this.step(event.detail.delta);
                }
            });
        }
    }
    async playChoreography(choreoName, actors) {
        if (this.#sceneImage) {
            const choreography = await this.#sceneImage.getChoreography(choreoName);
            if (choreography) {
                //choreography.play();
                this.#choreographies.add(choreography);
                choreography.setActors(actors);
                //choreography.onStop = onStop;
                return choreography;
            }
            /* else {
                setTimeout(function() {playChoreo(choreoName, actors, onStop)}, 100);
            }*/
        }
        return null;
    }
    async getChoreography(choreoName) {
        if (this.#sceneImage) {
            return await this.#sceneImage.getChoreography(choreoName);
        }
        return null;
    }
    step(elapsed) {
        if (!this.#playing) {
            return;
        }
        elapsed = elapsed * this.#playbackSpeed;
        for (const choreography of this.#choreographies) {
            if (!choreography.step(elapsed)) {
                this.#choreographies.delete(choreography);
            }
        }
    }
    reset() {
        for (const choreography of this.#choreographies) {
            choreography.reset();
        }
    }
    stopAll() {
        for (const choreography of this.#choreographies) {
            choreography.stop();
            this.#choreographies.delete(choreography);
        }
    }
    play() {
        this.#playing = true;
    }
    pause() {
        this.#playing = false;
    }
    setPlaybackSpeed(playbackSpeed) {
        this.#playbackSpeed = playbackSpeed;
    }
    /**
     * @deprecated Please use `setPlaybackSpeed` instead.
     */
    set playbackSpeed(playbackSpeed) {
        this.setPlaybackSpeed(playbackSpeed);
    }
}

const COLLISION_GROUP_NONE = 0;
const COLLISION_GROUP_DEBRIS = 1;
//TODO: add other collision groups
/*
enum Collision_Group_t
{
    COLLISION_GROUP_NONE  = 0,
    COLLISION_GROUP_DEBRIS,			// Collides with nothing but world and static stuff
    COLLISION_GROUP_DEBRIS_TRIGGER, // Same as debris, but hits triggers
    COLLISION_GROUP_INTERACTIVE_DEBRIS,	// Collides with everything except other interactive debris or debris
    COLLISION_GROUP_INTERACTIVE,	// Collides with everything except interactive debris or debris
    COLLISION_GROUP_PLAYER,
    COLLISION_GROUP_BREAKABLE_GLASS,
    COLLISION_GROUP_VEHICLE,
    COLLISION_GROUP_PLAYER_MOVEMENT,  // For HL2, same as Collision_Group_Player, for
                                        // TF2, this filters out other players and CBaseObjects
    COLLISION_GROUP_NPC,			// Generic NPC group
    COLLISION_GROUP_IN_VEHICLE,		// for any entity inside a vehicle
    COLLISION_GROUP_WEAPON,			// for any weapons that need collision detection
    COLLISION_GROUP_VEHICLE_CLIP,	// vehicle clip brush to restrict vehicle movement
    COLLISION_GROUP_PROJECTILE,		// Projectiles!
    COLLISION_GROUP_DOOR_BLOCKER,	// Blocks entities not permitted to get near moving doors
    COLLISION_GROUP_PASSABLE_DOOR,	// Doors that the player shouldn't collide with
    COLLISION_GROUP_DISSOLVING,		// Things that are dissolving are in this group
    COLLISION_GROUP_PUSHAWAY,		// Nonsolid on client and server, pushaway in player code

    COLLISION_GROUP_NPC_ACTOR,		// Used so NPCs in scripts ignore the player.
    COLLISION_GROUP_NPC_SCRIPTED,	// USed for NPCs in scripts that should not collide with each other

    LAST_SHARED_COLLISION_GROUP
};
*/

/**
 * VTX Model
 */
class VTXBodyPart {
    models = [];
    numModels = 0;
}
class VTXModel {
    lods = [];
    numLODs = 0;
}
class VTXLod {
    meshes = [];
    numMeshes = 0;
    switchPoint = 0;
}
class VTXMesh {
    stripGroups = [];
    numStripGroups = 0;
}
/*
export class VTXStripGroup {
    stripGroups = [];
}
    */
class VTXStripGroupHeader {
    vertices = [];
    indexes = [];
    strips = [];
    numVerts = 0;
    numIndices = 0;
    numStrips = 0;
    flags = 0;
}
class MdlVertex {
    boneWeightIndex = [];
    boneID = [];
    numBones = 0;
    origMeshVertID = 0;
}
class MdlStripHeader {
    vertices = [];
    indexes = [];
    numIndices = 0;
    indexOffset = 0;
    numVerts = 0;
    vertOffset = 0;
    numBones = 0;
    flags = 0;
    numBoneStateChanges = 0;
    boneStateChangeOffset = 0;
}
class SourceVtx {
    bodyparts = [];
    version = 0;
    vertCacheSize = 0;
    maxBonesPerStrip = 0;
    maxBonesPerFace = 0;
    maxBonesPerVert = 0;
    checkSum = 0;
    numLODs = 0;
    materialReplacementListOffset = 0;
    numBodyParts = 0;
    bodyPartOffset = 0;
    getBodyparts() {
        return this.bodyparts;
    }
}

const BODYPART_HEADER_SIZE = 8; // Size in bytes of a BodyPartHeader_t
const MODEL_HEADER_SIZE = 8;
const LOD_HEADER_SIZE = 12;
const MESH_HEADER_SIZE = 9;
const STRIP_GROUP_HEADER_SIZE = 25;
const STRIP_HEADER_SIZE = 27;
class Source1VtxLoader extends SourceBinaryLoader {
    #mdlVersion;
    constructor(mdlVersion) {
        super();
        this.#mdlVersion = mdlVersion;
    }
    async load(repository, path) {
        return super.load(repository, path);
    }
    parse(repository, fileName, arrayBuffer) {
        const vtx = new SourceVtx();
        const reader = new BinaryReader(arrayBuffer);
        this.#parseHeader(reader, vtx);
        this.#parseBodyParts(reader, vtx);
        return vtx;
    }
    #parseHeader(reader, vtx) {
        reader.seek(0);
        vtx.version = reader.getInt32();
        vtx.vertCacheSize = reader.getInt32();
        vtx.maxBonesPerStrip = reader.getUint16();
        vtx.maxBonesPerFace = reader.getUint16();
        vtx.maxBonesPerVert = reader.getInt32();
        vtx.checkSum = reader.getInt32();
        vtx.numLODs = reader.getInt32();
        vtx.materialReplacementListOffset = reader.getInt32();
        vtx.numBodyParts = reader.getInt32();
        vtx.bodyPartOffset = reader.getInt32();
    }
    #parseBodyParts(reader, vtx) {
        const bodyparts = vtx.bodyparts;
        for (let i = 0; i < vtx.numBodyParts; ++i) {
            // seek the start of body part
            reader.seek(vtx.bodyPartOffset + i * BODYPART_HEADER_SIZE);
            const bodypart = this.#parseBodyPartHeader(reader, vtx);
            if (bodypart) {
                bodyparts.push(bodypart);
            }
        }
    }
    #parseBodyPartHeader(reader, vtx) {
        const bodypart = new VTXBodyPart();
        const baseOffset = reader.tell();
        bodypart.numModels = reader.getInt32();
        const modelOffset = reader.getInt32();
        for (let i = 0; i < bodypart.numModels; ++i) {
            reader.seek(baseOffset + modelOffset + i * MODEL_HEADER_SIZE);
            bodypart.models.push(this.#parseModelHeader(reader, vtx));
        }
        return bodypart;
    }
    #parseModelHeader(reader, vtx) {
        const model = new VTXModel();
        const baseOffset = reader.tell();
        model.numLODs = reader.getInt32();
        const lodOffset = reader.getInt32();
        for (let i = 0; i < model.numLODs; ++i) {
            reader.seek(baseOffset + lodOffset + i * LOD_HEADER_SIZE);
            model.lods.push(this.#parseLODHeader(reader, vtx));
        }
        return model;
    }
    #parseLODHeader(reader, vtx) {
        const lod = new VTXLod();
        const baseOffset = reader.tell();
        lod.numMeshes = reader.getInt32();
        const meshOffset = reader.getInt32();
        lod.switchPoint = reader.getFloat32();
        for (let i = 0; i < lod.numMeshes; ++i) {
            reader.seek(baseOffset + meshOffset + i * MESH_HEADER_SIZE);
            lod.meshes.push(this.#parseMeshHeader(reader, vtx));
        }
        return lod;
    }
    #parseMeshHeader(reader, vtx) {
        const mesh = new VTXMesh();
        const baseOffset = reader.tell();
        mesh.numStripGroups = reader.getInt32();
        const stripGroupHeaderOffset = reader.getInt32();
        const headerSize = STRIP_GROUP_HEADER_SIZE + Number(this.#mdlVersion >= 49) * 8;
        for (let i = 0; i < mesh.numStripGroups; ++i) {
            reader.seek(baseOffset + stripGroupHeaderOffset + i * headerSize);
            mesh.stripGroups.push(this.#parseStripGroupHeader(reader, vtx));
        }
        return mesh;
    }
    #parseStripGroupHeader(reader, vtx) {
        const stripGroup = new VTXStripGroupHeader();
        const baseOffset = reader.tell();
        stripGroup.numVerts = reader.getInt32();
        const vertOffset = reader.getInt32();
        stripGroup.numIndices = reader.getInt32();
        const indexOffset = reader.getInt32();
        stripGroup.numStrips = reader.getInt32();
        const stripOffset = reader.getInt32();
        stripGroup.flags = reader.getUint8();
        const vertexSize = vtx.maxBonesPerVert * 2 + 3;
        for (let i = 0; i < stripGroup.numVerts; ++i) {
            reader.seek(baseOffset + vertOffset + i * vertexSize);
            stripGroup.vertices.push(this.#parseVertex(reader, vtx));
        }
        for (let i = 0; i < stripGroup.numIndices; ++i) {
            reader.seek(baseOffset + indexOffset + i * 2);
            stripGroup.indexes.push(reader.getInt16());
        }
        for (let i = 0; i < stripGroup.numStrips; ++i) {
            reader.seek(baseOffset + stripOffset + i * STRIP_HEADER_SIZE);
            stripGroup.strips.push(this.#parseStripHeader(reader, vtx));
        }
        return stripGroup;
    }
    #parseStripHeader(reader, vtx) {
        const stripHeader = new MdlStripHeader();
        //const baseOffset = reader.tell();removeme
        stripHeader.numIndices = reader.getInt32();
        stripHeader.indexOffset = reader.getInt32();
        stripHeader.numVerts = reader.getInt32();
        stripHeader.vertOffset = reader.getInt32();
        stripHeader.numBones = reader.getInt16();
        stripHeader.flags = reader.getUint8();
        stripHeader.numBoneStateChanges = reader.getInt32();
        stripHeader.boneStateChangeOffset = reader.getInt32();
        return stripHeader;
    }
    #parseVertex(reader, vtx) {
        const vertex = new MdlVertex();
        for (let i = 0; i < vtx.maxBonesPerVert; ++i) {
            vertex.boneWeightIndex.push(reader.getUint8());
        }
        vertex.numBones = reader.getUint8();
        vertex.origMeshVertID = reader.getUint16();
        for (let i = 0; i < vtx.maxBonesPerVert; ++i) {
            vertex.boneID.push(reader.getInt8());
        }
        return vertex;
    }
}

const MAX_NUM_LODS = 8;

/**
 * VVD Model
 */
class SourceVvdFixup {
    lod = 0;
    sourceVertexID = 0;
    numVertexes = 0;
}
class SourceVvdBoneWeight {
    weight = [];
    bone = [];
    numbones = 0;
}
class SourceVvdVertex {
    m_BoneWeights = new SourceVvdBoneWeight();
    m_vecPosition = vec3.create();
    m_vecNormal = vec3.create();
    m_vecTexCoord = vec2.create();
    m_vecTangent = vec4.create();
}
class SourceVvd {
    vertices = [];
    numFixups = 0;
    fixups = [];
    modelFormatID = 0;
    formatVersionID = 0;
    checkSum = 0;
    numLODs = 0;
    numLODVertexes = [];
    fixupTableStart = 0;
    vertexDataStart = 0;
    tangentDataStart = 0;
    getVertices(lodLevel) {
        if (this.vertices) {
            if (this.numFixups == 0) {
                return this.vertices;
            }
            /*
                        if (!this.fixups) {
                            this.readFixups();
                        }
            */
            if (this.fixups) {
                const vertices1 = [];
                for (const fixup of this.fixups) {
                    if (fixup.lod < lodLevel) {
                        continue;
                    }
                    const last = fixup.sourceVertexID + fixup.numVertexes;
                    for (let vertexIndex = fixup.sourceVertexID; vertexIndex < last; ++vertexIndex) {
                        const a = this.vertices[vertexIndex];
                        if (a) {
                            vertices1.push(a);
                        }
                    }
                }
                return vertices1;
            }
        }
        return null;
    }
}

const VERTEX_SIZE = 48; // size in bytes of a vertex
const TANGENT_SIZE = 16; // size in bytes of a vertex
const FIXUP_STRUCT_SIZE = 12; // size in bytes of a vertex vertexFileFixup
const MAX_NUM_BONES_PER_VERT = 3;
class Source1VvdLoader extends SourceBinaryLoader {
    async load(repository, path) {
        return super.load(repository, path);
    }
    parse(repository, fileName, arrayBuffer) {
        const vvd = new SourceVvd();
        const reader = new BinaryReader(arrayBuffer);
        this.#parseHeader(reader, vvd);
        this.#parseVertices(reader, vvd);
        this.#parseFixups(reader, vvd);
        return vvd;
    }
    #parseHeader(reader, vvd) {
        reader.seek(0);
        vvd.modelFormatID = reader.getInt32();
        vvd.formatVersionID = reader.getInt32();
        vvd.checkSum = reader.getInt32();
        vvd.numLODs = reader.getInt32();
        for (let i = 0; i < MAX_NUM_LODS; ++i) {
            vvd.numLODVertexes.push(reader.getInt32());
        }
        vvd.numFixups = reader.getInt32();
        vvd.fixupTableStart = reader.getInt32();
        vvd.vertexDataStart = reader.getInt32();
        vvd.tangentDataStart = reader.getInt32();
    }
    #parseVertices(reader, vvd) {
        if (vvd.numLODVertexes.length) {
            if (vvd.numLODVertexes[0] === 0) { //TODO ????
                return;
            }
            for (let i = 0; i < vvd.numLODVertexes[0]; ++i) {
                // seek the start of body part
                reader.seek(vvd.vertexDataStart + i * VERTEX_SIZE);
                const vertex = this.#parseVertex(reader, vvd);
                reader.seek(vvd.tangentDataStart + i * TANGENT_SIZE);
                const m_vecTangent = reader.getVector4(); //vec4.fromValues(reader.getFloat32(), reader.getFloat32(), reader.getFloat32(), reader.getFloat32());
                // Avoid a nul vector
                if ((m_vecTangent[0] == 0.0) && (m_vecTangent[1] == 0.0) && (m_vecTangent[2] == 0.0)) {
                    m_vecTangent[0] = 1.0;
                }
                vertex.m_vecTangent = m_vecTangent;
            }
        }
    }
    #parseVertex(reader, vvd) {
        const vertex = new SourceVvdVertex();
        for (let i = 0; i < MAX_NUM_BONES_PER_VERT; ++i) {
            vertex.m_BoneWeights.weight[i] = reader.getFloat32();
        }
        for (let i = 0; i < MAX_NUM_BONES_PER_VERT; ++i) {
            vertex.m_BoneWeights.bone[i] = reader.getInt8();
        }
        vertex.m_BoneWeights.numbones = reader.getInt8();
        vertex.m_vecPosition = reader.getVector3();
        vertex.m_vecNormal = reader.getVector3();
        vertex.m_vecTexCoord = reader.getVector2();
        vvd.vertices.push(vertex);
        return vertex;
    }
    #parseFixups(reader, vvd) {
        if (vvd.numFixups === 0) {
            return;
        }
        for (let i = 0; i < vvd.numFixups; ++i) {
            // seek the start of body part
            reader.seek(vvd.fixupTableStart + i * FIXUP_STRUCT_SIZE);
            this.#parseFixup(reader, vvd);
        }
    }
    #parseFixup(reader, vvd) {
        const fixup = Object.create(null);
        fixup.lod = reader.getInt32();
        fixup.sourceVertexID = reader.getInt32();
        fixup.numVertexes = reader.getInt32();
        vvd.fixups.push(fixup);
    }
}

class Animation {
    #name;
    weight = 1;
    #frameCount = 0;
    #looping = false;
    //#sequence;
    #fps = 30;
    #frames = [];
    #bones = [];
    #bonesByName = new Map;
    constructor(name) {
        this.#name = name;
    }
    [Symbol.iterator] = () => {
        return this.#frames.entries();
    };
    addFrame(animationFrame) {
        this.#frames.push(animationFrame);
        ++this.#frameCount;
    }
    addBone(bone) {
        this.#bones[bone.id] = bone;
        this.#bonesByName.set(bone.name, bone);
    }
    get name() {
        return this.#name;
    }
    get frameCount() {
        return this.#frameCount;
    }
    set fps(fps) {
        this.#fps = fps;
    }
    get fps() {
        return this.#fps;
    }
    get bones() {
        return this.#bones;
    }
    getFrame(id) {
        id = Math.round(id) % Math.max(this.#frameCount, 1);
        return this.#frames[id];
    }
    setLooping(looping) {
        this.#looping = looping;
    }
    isLooping() {
        return this.#looping;
    }
    toSMD(header = SMD_HEADER) {
        const lines = [];
        lines.push(header);
        lines.push('version 1');
        // Start bones declaration
        lines.push('nodes');
        for (const bone of this.#bones) { // TODO: sort bones ?
            lines.push(`  ${bone.id} "${bone.name}" ${bone.getParentId()}`);
        }
        lines.push('end');
        // Start frames
        lines.push('skeleton');
        for (const frame of this.#frames) {
            lines.push(`  time ${frame.getFrameId()}`);
            const positions = frame.getData('position');
            const rotations = frame.getData('rotation');
            if (!positions || !rotations) {
                continue;
            }
            for (const bone of this.#bones) {
                const bonePos = positions.datas[bone.id] ?? vec3.create();
                const boneRot = quatToEuler(vec3.create(), rotations.datas[bone.id] ?? quat.create());
                if (!bonePos || !boneRot) {
                    continue;
                }
                lines.push(`  ${bone.id} ${bonePos[0].toFixed(5)} ${bonePos[1].toFixed(5)} ${bonePos[2].toFixed(5)} ${boneRot[0].toFixed(5)} ${boneRot[1].toFixed(5)} ${boneRot[2].toFixed(5)}`);
            }
        }
        lines.push('end');
        return lines.join('\n');
    }
}

class AnimationBone {
    #id;
    #parentId;
    #name;
    refPosition;
    refQuaternion;
    constructor(id, parentId, name, position, quaternion) {
        this.#id = id;
        this.#parentId = parentId;
        this.#name = name.toLowerCase();
        this.refPosition = vec3.clone(position);
        this.refQuaternion = quat.clone(quaternion);
    }
    get id() {
        return this.#id;
    }
    getParentId() {
        return this.#parentId;
    }
    get name() {
        return this.#name;
    }
}

var AnimationFrameDataType;
(function (AnimationFrameDataType) {
    AnimationFrameDataType[AnimationFrameDataType["Vec3"] = 0] = "Vec3";
    AnimationFrameDataType[AnimationFrameDataType["Quat"] = 1] = "Quat";
    AnimationFrameDataType[AnimationFrameDataType["Number"] = 2] = "Number";
    AnimationFrameDataType[AnimationFrameDataType["Boolean"] = 3] = "Boolean";
})(AnimationFrameDataType || (AnimationFrameDataType = {}));
class AnimationFrameData {
    type;
    datas = [];
    constructor(type, datas) {
        this.type = type;
        if (datas) {
            for (const data of datas) {
                switch (type) {
                    case AnimationFrameDataType.Vec3:
                        this.datas.push(vec3.clone(data));
                        break;
                    case AnimationFrameDataType.Quat:
                        this.datas.push(quat.clone(data));
                        break;
                    default:
                        this.datas.push(data);
                        break;
                }
            }
        }
    }
    pushData(data) {
        this.datas.push(data);
    }
}

class AnimationFrame {
    #frameId;
    #datas = new Map();
    constructor(frameId) {
        this.#frameId = frameId;
    }
    setDatas(name, type, datas) {
        this.#datas.set(name, new AnimationFrameData(type, datas));
    }
    pushData(name, data) {
        const frameDatas = this.#datas.get(name);
        frameDatas?.pushData(data);
    }
    getData(name) {
        return this.#datas.get(name);
    }
    getFrameId() {
        return this.#frameId;
    }
}

const BONE_USED_BY_ANYTHING = 0x0007FF00;
const BONE_ALWAYS_PROCEDURAL = 0x04;
const BONE_USED_BY_BONE_MERGE = 0x00040000;
const BONE_FIXED_ALIGNMENT = 0x00100000;
const tempMat4$2 = mat4.create();
vec3.create();
quat.create();
//TODOV4: cleanup unused code
class MdlBone {
    _poseToBone = mat4.create();
    _invPoseToBone = mat4.create();
    _initPoseToBone = mat4.create();
    _boneMat = mat4.create();
    _position = vec3.create();
    _quaternion = quat.create();
    _worldPos = vec3.create();
    _worldQuat = quat.create();
    _worldMat = mat4.create();
    _parent = null; /*TODO:remove ?*/
    dirty = true;
    lastComputed = 0;
    #skeleton; /*TODO:remove*/
    parentBone = -1;
    boneId = -1;
    name = '';
    lowcasename = '';
    bonecontroller = [];
    rot = vec3.create();
    posscale = vec3.create();
    rotscale = vec3.create();
    qAlignment = vec4.create();
    flags = 0;
    proctype = 0;
    procindex = 0;
    physicsbone = 0;
    surfacepropidx = 0;
    contents = 0;
    constructor(skeleton /*TODO:remove*/) {
        this.#skeleton = skeleton; /*TODO:remove*/
    }
    get skeleton() {
        return this.#skeleton;
    }
    set quaternion(quaternion) {
        quat.copy(this._quaternion, quaternion);
        this.dirty = true;
    }
    get quaternion() {
        return this._quaternion;
    }
    set position(position) {
        vec3.copy(this._position, position);
        this.dirty = true;
    }
    get position() {
        return this._position;
    }
    set parent(parent) {
        this._parent = parent;
        this.dirty = true;
    }
    get parent() {
        return this._parent;
    }
    set worldPos(worldPos) {
        vec3.copy(this._worldPos, worldPos);
        mat4.fromRotationTranslation(tempMat4$2, this._worldQuat, this._worldPos);
        mat4.multiply(this._boneMat, tempMat4$2, this._poseToBone);
    }
    set worldQuat(worldQuat) {
        quat.copy(this._worldQuat, worldQuat);
        mat4.fromRotationTranslation(tempMat4$2, this._worldQuat, this._worldPos);
        mat4.multiply(this._boneMat, tempMat4$2, this._poseToBone);
    }
    getWorldPos(offset, out = vec3.create()) {
        vec3.transformQuat(out, offset, this.worldQuat);
        vec3.add(out, this.worldPos, out);
        return out;
    }
    getRelativePos() {
        return vec3.clone(this.position);
    }
    set poseToBone(poseToBone) {
        mat4.copy(this._poseToBone, poseToBone);
        mat4.invert(this._invPoseToBone, poseToBone);
        this.dirty = true;
    }
    get poseToBone() {
        return this._poseToBone;
    }
    set initPoseToBone(initPoseToBone) {
        mat4.copy(this._initPoseToBone, initPoseToBone);
        this.dirty = true;
    }
    get initPoseToBone() {
        return this._initPoseToBone;
    }
    getWorldQuat() {
        return this.worldQuat;
    }
    /**
     * Is a procedural bone ?
     * @returns {bool} yes is procedural bone
     */
    isProcedural() {
        return (this.flags & BONE_ALWAYS_PROCEDURAL) == BONE_ALWAYS_PROCEDURAL;
    }
    /**
     * Use bone merge
     * @returns {bool} yes bone is available for bone merge to occur against it
     */
    useBoneMerge() {
        return (this.flags & BONE_USED_BY_BONE_MERGE) == BONE_USED_BY_BONE_MERGE; //TODO: test engine verion; TF2 seems not use this flag
    }
}

const STUDIO_ANIM_RAWPOS = 0x01; // Vector48
const STUDIO_ANIM_RAWROT = 0x02; // Quaternion48
const STUDIO_ANIM_ANIMPOS = 0x04; // mstudioanim_valueptr_t
const STUDIO_ANIM_ANIMROT = 0x08; // mstudioanim_valueptr_t
const STUDIO_ANIM_DELTA = 0x10;
const STUDIO_ANIM_RAWROT2 = 0x20; // Quaternion64
const tempMat4$1 = mat4.create();
quat.create();
const tempvec3 = vec3.create();
/**
 *	MdlStudioAnimValuePtr
 */
class MdlStudioAnimValuePtr {
    offset = [];
    base = 0;
    getAnimValue2(i) {
        return this.base + this.offset[i];
    }
}
class MdlStudioAnim {
    animValuePtrRot = new MdlStudioAnimValuePtr();
    animValuePtrPos = new MdlStudioAnimValuePtr();
    rawpos = vec3.create();
    rawrot = quat.create();
    rawrot2 = quat.create();
    flags = 0;
    bone = 0;
    nextOffset = 0;
    getRotValue() {
        return this.animValuePtrRot;
    }
    getPosValue() {
        return this.animValuePtrPos;
    }
    getQuaternion48() {
        return this.rawrot;
    }
    getQuaternion64() {
        return this.rawrot2;
    }
    /**
     * TODO
     */
    getRot(rot, mdl, bone, frame) {
        const fromEuler5 = function (out, q, i, j, k, h, parity, repeat, frame) {
            const M = tempMat4$1; //Dim M(,) As Double = {{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}
            let Nq;
            let s;
            let xs;
            let ys;
            let zs;
            let wx;
            let wy;
            let wz;
            let xx;
            let xy;
            let xz;
            let yy;
            let yz;
            let zz;
            Nq = q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3];
            if (Nq > 0) {
                s = 2.0 / Nq;
            }
            else {
                s = 0;
            }
            xs = q[0] * s;
            ys = q[1] * s;
            zs = q[2] * s;
            wx = q[3] * xs;
            wy = q[3] * ys;
            wz = q[3] * zs;
            xx = q[0] * xs;
            xy = q[0] * ys;
            xz = q[0] * zs;
            yy = q[1] * ys;
            yz = q[1] * zs;
            zz = q[2] * zs;
            M[0] = 1.0 - (yy + zz);
            M[1] = xy - wz;
            M[2] = xz + wy;
            M[4] = xy + wz;
            M[5] = 1.0 - (xx + zz);
            M[6] = yz - wx;
            M[8] = xz - wy;
            M[9] = yz + wx;
            M[10] = 1.0 - (xx + yy);
            M[14] = 1.0;
            return Eul_FromHMatrix(out, M, i, j, k, h, parity, repeat, frame);
        };
        const fromEuler4 = function (out, q) {
            fromEuler5(out, q, 0, 1, 2, 0, 'even', 'no', 'S');
            const temp = out[0];
            out[0] = out[2];
            out[2] = temp;
            return out;
        };
        var Eul_FromHMatrix = function (out, M, i, j, k, h, parity, repeat, frame) {
            const ea = tempvec3;
            if (repeat == 'yes') {
                const sy = Math.sqrt(M[i * 4 + j] * M[i * 4 + j] + M[i * 4 + k] * M[i * 4 + k]);
                if (sy > 16 * FLT_EPSILON) {
                    ea[0] = Math.atan2(M[i * 4 + j], M[i * 4 + k]);
                    ea[1] = Math.atan2(sy, M[i * 4 + i]);
                    ea[2] = Math.atan2(M[j * 4 + i], -M[k * 4 + i]);
                }
                else {
                    ea[0] = Math.atan2(-M[j * 4 + k], M[j * 4 + j]);
                    ea[1] = Math.atan2(sy, M[i * 4 + i]);
                    ea[2] = 0;
                }
            }
            else {
                const cy = Math.sqrt(M[i * 4 + i] * M[i * 4 + i] + M[j * 4 + i] * M[j * 4 + i]);
                if (cy > 16 * FLT_EPSILON) {
                    ea[0] = Math.atan2(M[k * 4 + j], M[k * 4 + k]);
                    ea[1] = Math.atan2(-M[k * 4 + i], cy);
                    ea[2] = Math.atan2(M[j * 4 + i], M[i * 4 + i]);
                }
                else {
                    ea[0] = Math.atan2(-M[j * 4 + k], M[j * 4 + j]);
                    ea[1] = Math.atan2(-M[k * 4 + i], cy);
                    ea[2] = 0;
                }
            }
            if (parity == 'odd') {
                ea[0] = -ea[0];
                ea[1] = -ea[1];
                ea[2] = -ea[2];
            }
            if (frame == 'R') {
                const t = ea[0];
                ea[0] = ea[2];
                ea[2] = t;
            }
            vec3.copy(out, ea);
            return out;
        };
        const flag = this.flags;
        let offset;
        if ((flag & STUDIO_ANIM_RAWROT) == STUDIO_ANIM_RAWROT) {
            //rot = vec3.add(rot, rot, this.rawrot);
            rot = fromEuler4(rot, this.rawrot2); //TODO: fix the from euler function
            return rot;
        }
        if ((flag & STUDIO_ANIM_RAWROT2) == STUDIO_ANIM_RAWROT2) {
            rot = fromEuler4(rot, this.rawrot2); //TODO: fix the from euler function
            return rot;
        }
        if ((flag & STUDIO_ANIM_ANIMROT) == STUDIO_ANIM_ANIMROT) {
            for (let i = 0; i < 3; ++i) {
                offset = this.animValuePtrRot.offset[i];
                if (offset) {
                    rot[i] = this.readValue(mdl, frame, this.animValuePtrRot.base + offset /*, bone.boneId, i*/) * bone.rotscale[i];
                }
            }
        }
        if ((flag & STUDIO_ANIM_DELTA) != STUDIO_ANIM_DELTA) {
            vec3.add(rot, rot, bone.rot);
        }
        return rot;
    }
    getPos(pos, mdl, bone, frame) {
        const flag = this.flags;
        let offset;
        pos[0] = 0;
        pos[1] = 0;
        pos[2] = 0;
        if ((flag & STUDIO_ANIM_RAWPOS) == STUDIO_ANIM_RAWPOS) {
            pos = vec3.add(pos, pos, this.rawpos);
            return pos;
        }
        else if ((flag & STUDIO_ANIM_ANIMPOS) != STUDIO_ANIM_ANIMPOS) {
            if ((flag & STUDIO_ANIM_DELTA) == STUDIO_ANIM_DELTA) {
                //vec3.add(pos, pos, bone.position);
                pos[0] = 0;
                pos[1] = 0;
                pos[2] = 0;
            }
            else {
                vec3.add(pos, pos, bone.position);
            }
            return pos;
        }
        if ((flag & STUDIO_ANIM_ANIMPOS) == STUDIO_ANIM_ANIMPOS) {
            for (let i = 0; i < 3; ++i) {
                offset = this.animValuePtrPos.offset[i];
                if (offset) {
                    pos[i] = this.readValue(mdl, frame, this.animValuePtrPos.base + offset /*, bone.boneId, i*/) * bone.posscale[i];
                }
            }
        }
        if ((flag & STUDIO_ANIM_DELTA) != STUDIO_ANIM_DELTA) {
            vec3.add(pos, pos, bone.position);
        }
        return pos;
    }
    readValue(mdl, frame, offset /*, boneid, memberid*/) {
        const reader = mdl.reader;
        reader.seek(offset);
        let valid = 0;
        let total = 0;
        let k = frame;
        let count = 0;
        do {
            count++;
            if (count > 1) {
                const nextOffset = reader.tell() + valid * 2;
                /*if (!mdl.hasChunk(nextOffset, 2)) {//TODOv3
                    return 0;
                }*/
                reader.seek(nextOffset);
            }
            k -= total;
            valid = reader.getInt8();
            total = reader.getInt8();
        } while ((total <= k) && count < 30); //TODO: change 30
        if (k >= valid) {
            k = valid - 1;
        }
        const nextOffset = reader.tell() + k * 2;
        reader.seek(nextOffset);
        return reader.getInt16();
    }
}

const STUDIO_AL_SPLINE = 0x0040;
const STUDIO_AL_XFADE = 0x0080;
const STUDIO_AL_NOBLEND = 0x0200;
const STUDIO_AL_LOCAL = 0x1000;
const STUDIO_AL_POSE = 0x4000;
class MdlStudioSeqDesc {
    paramindex = [];
    paramstart = [];
    paramend = [];
    blend = [];
    weightlist = [];
    groupsize = [0, 0];
    mdl;
    previousTime = -1;
    currentTime = -1;
    posekeyindex;
    autolayer = [];
    events = [];
    name;
    flags;
    activity;
    id;
    startOffset;
    actweight;
    numevents;
    eventindex;
    bbmin = vec3.create();
    bbmax = vec3.create();
    numblends;
    animindexindex;
    movementindex;
    paramparent;
    fadeintime;
    fadeouttime;
    localentrynode;
    localexitnode;
    nodeflags;
    entryphase;
    exitphase;
    lastframe;
    nextseq;
    pose;
    numikrules;
    numautolayers;
    autolayerindex;
    weightlistindex;
    numiklocks;
    iklockindex;
    keyvalueindex;
    keyvaluesize;
    cycleposeindex;
    activityName;
    keyvalueText;
    pBoneweight(boneIndex) {
        return this.weightlist[boneIndex];
    }
    //MdlStudioSeqDesc.prototype.weight = MdlStudioSeqDesc.prototype.pBoneweight;//TODOV2
    getBlend(x, y) {
        x = clamp$1(x, 0, this.groupsize[0] - 1);
        y = clamp$1(y, 0, this.groupsize[1] - 1);
        return this.blend[y]?.[x] ?? null;
    }
    poseKey(iParam, iAnim) {
        if (this.mdl && this.posekeyindex) {
            const mdl = this.mdl;
            const offset = this.posekeyindex + (iParam * this.groupsize[0] + iAnim) * 4;
            return mdl.reader.getFloat32(offset); //TODOv3
        }
        //float				*pPoseKey(int iParam, int iAnim) const { return (float *)(((byte *)this) + posekeyindex) + iParam * groupsize[0] + iAnim; }
        return 0;
    }
    getAutoLayer(autoLayerIndex) {
        return this.autolayer[autoLayerIndex] ?? null;
    }
    get length() {
        const anim = this.mdl.getAnimDescription(this.blend[0]?.[0]);
        if (!anim) {
            return 0;
        }
        return (anim.numframes - 1) / anim.fps;
    }
    play(dynamicProp) {
        const anim = this.mdl.getAnimDescription(this.blend[0]?.[0]);
        if (!anim) {
            return;
        }
        this.currentTime = (this.currentTime !== undefined) ? dynamicProp.frame * anim.fps / (anim.numframes - 1) : 0;
        this.currentTime = this.currentTime % 1;
        this.previousTime = (this.previousTime !== undefined) ? this.previousTime : -1;
        if (this.previousTime > this.currentTime) {
            this.previousTime = this.currentTime;
        }
        const previousTime = this.previousTime;
        const currentTime = this.currentTime;
        const seqEvents = this.events;
        for (let eventIndex = 0; eventIndex < seqEvents.length; ++eventIndex) {
            const event = seqEvents[eventIndex];
            if (event.cycle > previousTime && event.cycle <= currentTime) {
                this.processEvent(event, dynamicProp); //TODOv3
            }
        }
        this.previousTime = this.currentTime;
    }
    processEvent(event, dynamicProp) {
        let options;
        switch (true) {
            case event.event == 5004 || (event.event === 0 && event.name == 'AE_CL_PLAYSOUND'):
                Source1SoundManager.playSound(this.mdl?.repository, event.options);
                break;
            case (event.event === 0 && event.name == 'AE_CL_BODYGROUP_SET_VALUE'):
                options = event.options.split(' ');
                //dynamicProp.bodyGroups[options[0]] = options[1];
                if (options.length >= 2) {
                    dynamicProp.setBodyPartModel(options[0], Number(options[1]));
                }
                break;
            case (event.event === 0 && event.name == 'AE_WPN_HIDE'):
                //TODOV2
                //dynamicProp.setVisibility(false);
                //console.error('AE_WPN_HIDE' + dynamicProp.name);
                break;
            case (event.event === 0 && event.name == 'AE_WPN_UNHIDE'):
                //TODOV2
                //dynamicProp.setVisibility(true);
                //console.error('AE_WPN_UNHIDE' + dynamicProp.name);
                break;
            case (event.event === 0 && event.name == 'AE_CL_CREATE_PARTICLE_EFFECT'):
                options = event.options.split(' ');
                //TODOV2
                const f = async () => {
                    const sys = await Source1ParticleControler.createSystem(dynamicProp.sourceModel.repository, options[0]);
                    sys.autoKill = true;
                    sys.start();
                    //console.log(options[0], options[1], options[2]);
                    switch (options[1]) {
                        case 'follow_attachment':
                            dynamicProp.attachSystem(sys, options[2]);
                            break;
                        case 'start_at_attachment':
                            dynamicProp.attachSystem(sys, options[2]);
                            break;
                        case 'start_at_origin':
                            dynamicProp.attachSystem(sys, options[2]);
                            break;
                    }
                };
                if (options.length >= 1) {
                    f();
                }
                /*TODOv2
                        'start_at_origin',		// PATTACH_ABSORIGIN = 0,
                        'follow_origin',		// PATTACH_ABSORIGIN_FOLLOW,
                        'start_at_customorigin',// PATTACH_CUSTOMORIGIN,
                        'start_at_attachment',	// PATTACH_POINT,
                        'follow_attachment',	// PATTACH_POINT_FOLLOW,
                */
                break;
            case (event.event === 0 && event.name == 'AE_TAUNT_ADD_ATTRIBUTE'):
                //{ event AE_TAUNT_ADD_ATTRIBUTE 1 'taunt_attr_player_invis_percent 1 5.215' }
                options = event.options.split(' ');
                switch (options[0]) {
                    case 'taunt_attr_player_invis_percent':
                        dynamicProp.setVisible(false);
                        if (options.length >= 3) {
                            setTimeout(function () { dynamicProp.setVisible(); }, Number(options[2]) * 1000);
                        }
                        break;
                }
                break;
        }
        //'AE_CL_BODYGROUP_SET_VALUE'
    }
}
class MdlStudioAutoLayer {
    iSequence;
    iPose;
    flags;
    start;
    peak;
    tail;
    end;
}
class MdlStudioEvent {
    cycle;
    event;
    type;
    options;
    name;
}

//-----------------------------------------------------------------------------
// Purpose: returns array of animations and weightings for a sequence based on current pose parameters
//-----------------------------------------------------------------------------
//void Studio_SeqAnims(const CStudioHdr *pStudioHdr, mstudioseqdesc_t &seqdesc, int iSequence, const float poseParameters[], mstudioanimdesc_t *panim[4], float *weight)
function Studio_SeqAnims(pStudioHdr, seqdesc, iSequence, poseParameters, panim, weight) {
    /*if (!pStudioHdr || iSequence >= pStudioHdr.GetNumSeq())
    {
        weight[0] = weight[1] = weight[2] = weight[3] = 0.0;
        return;
    }*/
    const i0 = 0, i1 = 0;
    const s0 = 0, s1 = 0;
    //Studio_LocalPoseParameter(pStudioHdr, poseParameters, seqdesc, iSequence, 0, s0, i0);TODOV2
    //	Studio_LocalPoseParameter(pStudioHdr, poseParameters, seqdesc, iSequence, 1, s1, i1);
    //panim[0] = pStudioHdr.pAnimdesc(pStudioHdr.iRelativeAnim(iSequence, seqdesc.anim(i0	, i1)));
    panim[0] = pStudioHdr.getAnimDescription(seqdesc.getBlend(i0, i1));
    weight[0] = (1 - s0) * (1 - s1);
    //panim[1] = pStudioHdr.pAnimdesc(pStudioHdr.iRelativeAnim(iSequence, seqdesc.anim(i0+1, i1)));
    panim[1] = pStudioHdr.getAnimDescription(seqdesc.getBlend(i0 + 1, i1));
    weight[1] = (s0) * (1 - s1);
    //panim[2] = pStudioHdr.pAnimdesc(pStudioHdr.iRelativeAnim(iSequence, seqdesc.anim(i0	, i1+1)));
    panim[2] = pStudioHdr.getAnimDescription(seqdesc.getBlend(i0, i1 + 1));
    weight[2] = (1 - s0) * (s1);
    //panim[3] = pStudioHdr.pAnimdesc(pStudioHdr.iRelativeAnim(iSequence, seqdesc.anim(i0+1, i1+1)));
    panim[3] = pStudioHdr.getAnimDescription(seqdesc.getBlend(i0 + 1, i1 + 1));
    weight[3] = (s0) * (s1);
}
//-----------------------------------------------------------------------------
// Purpose: returns cycles per second of a sequence (cycles/second)
//-----------------------------------------------------------------------------
//float Studio_CPS(const CStudioHdr *pStudioHdr, mstudioseqdesc_t &seqdesc, int iSequence, const float poseParameters[])
function Studio_CPS(pStudioHdr, seqdesc, iSequence, poseParameters) {
    const panim = [null, null, null, null];
    const weight = [0, 0, 0, 0];
    Studio_SeqAnims(pStudioHdr, seqdesc, iSequence, poseParameters, panim, weight);
    let t = 0;
    for (let i = 0; i < 4; ++i) {
        const anim = panim[i];
        if (anim && weight[i] > 0 && anim.numframes > 1) {
            t += (anim.fps / (anim.numframes - 1)) * weight[i];
            //setAnimLength(anim.numframes);//TODOv3
        }
    }
    return t;
}
//-----------------------------------------------------------------------------
// Purpose: returns length (in seconds) of a sequence (seconds/cycle)
//-----------------------------------------------------------------------------
//float Studio_Duration(const CStudioHdr *pStudioHdr, int iSequence, const float poseParameters[])
function Studio_Duration(pStudioHdr, iSequence, poseParameters) {
    const seqdesc = pStudioHdr.getSequenceById(iSequence); //pStudioHdr.pSeqdesc(iSequence);
    if (!seqdesc) {
        return 0;
    }
    const cps = Studio_CPS(pStudioHdr, seqdesc, iSequence, poseParameters);
    if (cps == 0)
        return 0.0;
    return 1.0 / cps;
}
const SOURCE_MODEL_MAX_BONES$1 = 256;
//-----------------------------------------------------------------------------
// Purpose: calculate a pose for a single sequence
//-----------------------------------------------------------------------------
function InitPose(dynamicProp, pStudioHdr, pos, q, boneMask) {
    if (pStudioHdr.pLinearBones === undefined) {
        for (let i = 0, boneCount = pStudioHdr.getBoneCount(); i < boneCount; ++i) {
            {
                const pbone = pStudioHdr.getBone(i);
                pos[i] = pos[i] || vec3.create(); //removeme
                q[i] = q[i] || quat.create(); //removeme
                if (pbone) {
                    vec3.copy(pos[i], pbone.position);
                    quat.copy(q[i], pbone.quaternion);
                }
            }
        }
    }
}
//-----------------------------------------------------------------------------
// Purpose: calculate a pose for a single sequence
//			adds autolayers, runs local ik rukes
//-----------------------------------------------------------------------------
//function CalcPose(pStudioHdr, pIKContext, pos, q, sequence, cycle, poseParameters, boneMask, flWeight = 1.0, flTime = 0.0) {
function CalcPose(dynamicProp, pStudioHdr, pIKContext, pos, q, boneFlags, sequence, cycle, poseParameters, boneMask, flWeight, flTime) {
    cycle = cycle % 1; //TODOv2
    const seqdesc = pStudioHdr.getSequenceById(sequence);
    if (seqdesc) {
        //Assert(flWeight >= 0.0f && flWeight <= 1.0f);
        // This shouldn't be necessary, but the Assert should help us catch whoever is screwing this up
        flWeight = clamp$1(flWeight, 0.0, 1.0);
        // add any IK locks to prevent numautolayers from moving extremities
        //CIKContext seq_ik;TODOv2
        /*
        if (false && seqdesc.numiklocks) {//TODOV2
            seq_ik.Init(pStudioHdr, vec3_angle, vec3_origin, 0.0, 0, boneMask); // local space relative so absolute position doesn't mater
            seq_ik.AddSequenceLocks(seqdesc, pos, q);
        }
            */
        CalcPoseSingle(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, cycle, poseParameters, boneMask, flTime);
        AddSequenceLayers(dynamicProp, pStudioHdr, pIKContext, pos, q, boneFlags, seqdesc, sequence, cycle, poseParameters, boneMask, flWeight, flTime);
        /*
                if (false && seqdesc.numiklocks) {//TODOV2
                    seq_ik.SolveSequenceLocks(seqdesc, pos, q);
                }
                    */
    }
}
//-----------------------------------------------------------------------------
// Purpose: calculate a pose for a single sequence
//-----------------------------------------------------------------------------
//TODOv2: put somewhere else
const STUDIO_LOOPING$1 = 0x0001; // ending frame should be the same as the starting frame
const STUDIO_DELTA$1 = 0x0004; // this sequence 'adds' to the base sequences, not slerp blends
const STUDIO_POST = 0x0010; //
const STUDIO_ALLZEROS$1 = 0x0020; // this animation/sequence has no real animation data
//						0x0040
const STUDIO_CYCLEPOSE$1 = 0x0080; // cycle index is taken from a pose parameter index
const STUDIO_REALTIME$1 = 0x0100; // cycle index is taken from a real-time clock, not the animations cycle index
const STUDIO_LOCAL$1 = 0x0200; // sequence has a local context sequence
const STUDIO_WORLD = 0x4000; // sequence blends in worldspace
const CalcPoseSingle_pos2$1 = Array(SOURCE_MODEL_MAX_BONES$1);
const CalcPoseSingle_q2$1 = Array(SOURCE_MODEL_MAX_BONES$1);
const CalcPoseSingle_pos3$1 = Array(SOURCE_MODEL_MAX_BONES$1);
const CalcPoseSingle_q3$1 = Array(SOURCE_MODEL_MAX_BONES$1);
for (let i = 0; i < SOURCE_MODEL_MAX_BONES$1; i++) {
    CalcPoseSingle_pos2$1[i] = vec3.create();
    CalcPoseSingle_q2$1[i] = quat.create();
    CalcPoseSingle_pos3$1[i] = vec3.create();
    CalcPoseSingle_q3$1[i] = quat.create();
}
function CalcPoseSingle(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, cycle, poseParameters, boneMask, flTime) {
    let bResult = true;
    const pos2 = CalcPoseSingle_pos2$1; //[];//vec3.create();//TODOv2: optimize (see source)
    const q2 = CalcPoseSingle_q2$1; //[];//quat.create();//TODOv2: optimize (see source)
    const pos3 = CalcPoseSingle_pos3$1; //[];//vec3.create();//TODOv2: optimize (see source)
    const q3 = CalcPoseSingle_q3$1;
    for (let i = 0; i < SOURCE_MODEL_MAX_BONES$1; ++i) {
        vec3.zero(pos2[i]);
        quat.identity(q2[i]);
        vec3.zero(pos3[i]);
        quat.identity(q3[i]);
    }
    /*	if (sequence >= pStudioHdr->GetNumSeq())TODOv2
        {
            sequence = 0;
            seqdesc = pStudioHdr->pSeqdesc(sequence);
        }*/
    let i0 = 0, i1 = 0;
    let s0 = 0, s1 = 0;
    const r0 = Studio_LocalPoseParameter(pStudioHdr, poseParameters, seqdesc, sequence, 0 /*, s0, i0 */); //TODOv2
    const r1 = Studio_LocalPoseParameter(pStudioHdr, poseParameters, seqdesc, sequence, 1 /*, s1, i1 */);
    s0 = r0.s;
    i0 = r0.i;
    s1 = r1.s;
    i1 = r1.i;
    if (seqdesc.flags & STUDIO_REALTIME$1) {
        const cps = Studio_CPS(pStudioHdr, seqdesc, sequence, poseParameters);
        cycle = flTime * cps;
        cycle = cycle - Math.floor(cycle); //TODOv2: rounding issues
    }
    else if (seqdesc.flags & STUDIO_CYCLEPOSE$1) {
        {
            cycle = 0.0;
        }
    }
    else if (cycle < 0 || cycle >= 1) {
        if (seqdesc.flags & STUDIO_LOOPING$1) {
            cycle = cycle - Math.floor(cycle); //TODOv2: rounding issues
            if (cycle < 0) {
                cycle += 1;
            }
        }
        else {
            cycle = clamp$1(cycle, 0.0, 1.0);
        }
    }
    if (s0 < 0.001) {
        if (s1 < 0.001) {
            if (PoseIsAllZeros(pStudioHdr, sequence, seqdesc, i0, i1)) {
                bResult = false;
            }
            else {
                CalcAnimation(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0, i1), cycle, boneMask);
            }
        }
        else if (s1 > 0.999) {
            CalcAnimation(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0, i1 + 1), cycle, boneMask);
        }
        else {
            CalcAnimation(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0, i1), cycle, boneMask);
            CalcAnimation(dynamicProp, pStudioHdr, pos2, q2, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0, i1 + 1), cycle, boneMask);
            BlendBones(pStudioHdr, q, pos, seqdesc, sequence, q2, pos2, s1, boneMask);
        }
    }
    else if (s0 > 0.999) {
        if (s1 < 0.001) {
            if (PoseIsAllZeros(pStudioHdr, sequence, seqdesc, i0 + 1, i1)) {
                bResult = false;
            }
            else {
                CalcAnimation(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0 + 1, i1), cycle, boneMask);
            }
        }
        else if (s1 > 0.999) {
            CalcAnimation(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0 + 1, i1 + 1), cycle, boneMask);
        }
        else {
            CalcAnimation(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0 + 1, i1), cycle, boneMask);
            CalcAnimation(dynamicProp, pStudioHdr, pos2, q2, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0 + 1, i1 + 1), cycle, boneMask);
            BlendBones(pStudioHdr, q, pos, seqdesc, sequence, q2, pos2, s1, boneMask);
        }
    }
    else {
        if (s1 < 0.001) {
            if (PoseIsAllZeros(pStudioHdr, sequence, seqdesc, i0 + 1, i1)) {
                CalcAnimation(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0, i1), cycle, boneMask);
                ScaleBones(pStudioHdr, q, pos, sequence, 1.0 - s0, boneMask);
            }
            else if (PoseIsAllZeros(pStudioHdr, sequence, seqdesc, i0, i1)) {
                CalcAnimation(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0 + 1, i1), cycle, boneMask);
                ScaleBones(pStudioHdr, q, pos, sequence, s0, boneMask);
            }
            else {
                CalcAnimation(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0, i1), cycle, boneMask);
                CalcAnimation(dynamicProp, pStudioHdr, pos2, q2, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0 + 1, i1), cycle, boneMask);
                BlendBones(pStudioHdr, q, pos, seqdesc, sequence, q2, pos2, s0, boneMask);
            }
        }
        else if (s1 > 0.999) {
            CalcAnimation(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0, i1 + 1), cycle, boneMask);
            CalcAnimation(dynamicProp, pStudioHdr, pos2, q2, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0 + 1, i1 + 1), cycle, boneMask);
            BlendBones(pStudioHdr, q, pos, seqdesc, sequence, q2, pos2, s0, boneMask);
        }
        //else if (!anim_3wayblend.GetBool())
        else {
            const iAnimIndices = [0, 0, 0];
            const weight = [0, 0, 0];
            Calc3WayBlendIndices(i0, i1, s0, s1, seqdesc, iAnimIndices, weight);
            if (weight[1] < 0.001) {
                // on diagonal
                CalcAnimation(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, iAnimIndices[0], cycle, boneMask);
                CalcAnimation(dynamicProp, pStudioHdr, pos2, q2, boneFlags, seqdesc, sequence, iAnimIndices[2], cycle, boneMask);
                BlendBones(pStudioHdr, q, pos, seqdesc, sequence, q2, pos2, weight[2] / (weight[0] + weight[2]), boneMask);
            }
            else {
                CalcAnimation(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, iAnimIndices[0], cycle, boneMask);
                CalcAnimation(dynamicProp, pStudioHdr, pos2, q2, boneFlags, seqdesc, sequence, iAnimIndices[1], cycle, boneMask);
                BlendBones(pStudioHdr, q, pos, seqdesc, sequence, q2, pos2, weight[1] / (weight[0] + weight[1]), boneMask);
                CalcAnimation(dynamicProp, pStudioHdr, pos3, q3, boneFlags, seqdesc, sequence, iAnimIndices[2], cycle, boneMask);
                BlendBones(pStudioHdr, q, pos, seqdesc, sequence, q3, pos3, weight[2], boneMask);
            }
        }
    }
    //g_VectorPool.Free(pos2);
    //g_QaternionPool.Free(q2);
    //g_VectorPool.Free(pos3);
    //g_QaternionPool.Free(q3);
    return bResult;
}
//-----------------------------------------------------------------------------
// Purpose: Find and decode a sub-frame of animation
//-----------------------------------------------------------------------------
function CalcAnimation(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, animation, cycle, boneMask) {
    /*virtualmodel_t *pVModel = pStudioHdr->GetVirtualModel();TODOV2
    if (pVModel)
    {
        CalcVirtualAnimation(pVModel, pStudioHdr, pos, q, seqdesc, sequence, animation, cycle, boneMask);
        return;
    }*/
    const animdesc = pStudioHdr.getAnimDescription(animation);
    if (!animdesc) {
        return;
    }
    pStudioHdr.getBone(0);
    //const mstudiolinearbone_t *pLinearBones = pStudioHdr->pLinearBones();TODOV2
    let pLinearBones;
    const fFrame = cycle * (animdesc.numframes - 1);
    const iFrame = Math.floor(fFrame);
    const s = (fFrame - iFrame);
    //iFrame = 0;
    //console.log(pStudioHdr.getAnimFrame(animdesc, iFrame));
    pStudioHdr.getAnimFrame(dynamicProp, animdesc, iFrame);
    //console.log(iFrame);
    let iLocalFrame = iFrame;
    const panims = animdesc.pAnim(iLocalFrame /*, flStall*/);
    //animdesc.mdl.getAnimFrame(animdesc, 31);
    //const pweight = seqdesc.pBoneweight(0);
    // if the animation isn't available, look for the zero frame cache
    if (!panims) {
        for (let i = 0, boneCount = pStudioHdr.getBoneCount(); i < boneCount; ++i) {
            const pbone = pStudioHdr.getBone(i);
            const pweight = seqdesc.pBoneweight(i);
            if (pweight && pweight > 0 && (pStudioHdr.boneFlags(i) & boneMask)) {
                if (animdesc.flags & STUDIO_DELTA$1) {
                    q[i] = quat.create(); //TODOV2
                    pos[i] = vec3.create(); //TODOV2
                }
                else {
                    //q[i] = pbone.rot;TODOv2
                    //q[i] = q[i] || quat.create();
                    //pos[i] = pos[i] || vec3.create();
                    q[i] = quat.create();
                    pos[i] = vec3.create();
                    //quat.fromMat3(q[i], mat3.fromEuler(SourceEngineTempMat3, pbone.rot));
                    if (pbone && q[i] && pos[i]) {
                        quatFromEulerRad(q[i], pbone.rot[0], pbone.rot[1], pbone.rot[2]);
                        vec3.copy(pos[i], pbone.position);
                    }
                }
            }
        }
        //CalcZeroframeData(pStudioHdr, pStudioHdr->GetRenderHdr(), NULL, pStudioHdr->pBone(0), animdesc, fFrame, pos, q, boneMask, 1.0);
        pStudioHdr.getBone(0);
        return;
    }
    // BUGBUG: the sequence, the anim, and the model can have all different bone mappings.
    //for (i = 0; i < pStudioHdr->numbones(); i++, pbone++, pweight++)
    let panim = panims[0];
    for (let i = 0, boneCount = pStudioHdr.getBoneCount(), animIndex = 0; i < boneCount; ++i) {
        const pbone = pStudioHdr.getBone(i);
        const pweight = seqdesc.pBoneweight(i);
        //q[i] = q[i] || quat.create();//TODOV2
        //pos[i] = pos[i] || vec3.create();//TODOV2
        q[i] = quat.create();
        pos[i] = vec3.create();
        if (panim && panim.bone == i) {
            boneFlags[i] = panim.flags;
            //if (pweight > 0 && (pStudioHdr.boneFlags(i) & boneMask))
            if (pweight && pweight > 0) //TODOv2
             {
                if (animdesc.sectionframes != 0) {
                    iLocalFrame = iLocalFrame % animdesc.sectionframes;
                }
                if (pbone) {
                    CalcBoneQuaternion(pStudioHdr, iLocalFrame, s, pbone, pLinearBones, panim, q[i]);
                    CalcBonePosition(pStudioHdr, iLocalFrame, s, pbone, pLinearBones, panim, pos[i]);
                }
                //quat.copy(q[i], pbone.quaternion);
                //vec3.copy(pos[i], pbone.position);
            }
            //panim = panim->pNext();//TODOv2
            panim = panims[++animIndex];
            //} else if (pweight > 0 && (pStudioHdr.boneFlags(i) & boneMask)) {
        }
        else if (pweight && pweight > 0) {
            if (animdesc.flags & STUDIO_DELTA$1) {
                boneFlags[i] = STUDIO_ANIM_DELTA;
                q[i] = quat.create(); //TODOV2
                pos[i] = vec3.create(); //TODOV2
            }
            else {
                boneFlags[i] = 0;
                if (pbone && q[i] && pos[i]) {
                    quat.copy(q[i], pbone.quaternion);
                    vec3.copy(pos[i], pbone.position);
                }
            }
        }
        else {
            boneFlags[i] = STUDIO_ANIM_DELTA;
        }
    }
    // cross fade in previous zeroframe data
    /*
    if (flStall > 0.0) {
        CalcZeroframeData(pStudioHdr, pStudioHdr, null, pStudioHdr.getBone(0), animdesc, fFrame, pos, q, boneMask, flStall);
    }
    */
    //console.error(animdesc.numlocalhierarchy);
    /*
    if (false && animdesc.numlocalhierarchy) {//TODOv2
        const boneToWorld = mat4.create();//TODOv2
        let boneComputed;

        for (let i = 0; i < animdesc.numlocalhierarchy; ++i) {
            const pHierarchy = animdesc.pHierarchy(i);

            if (!pHierarchy) {
                break;
            }
            /*

            if (pStudioHdr.boneFlags(pHierarchy.iBone) & boneMask) {
                if (pStudioHdr.boneFlags(pHierarchy.iNewParent) & boneMask) {
                    CalcLocalHierarchyAnimation(pStudioHdr, boneToWorld, boneComputed, pos, q, pbone, pHierarchy, pHierarchy.iBone, pHierarchy.iNewParent, cycle, iFrame, s, boneMask);
                }
            }
                * /

        }

        //g_MatrixPool.Free(boneToWorld);TODOv2
    }
    */
}
//-----------------------------------------------------------------------------
// Purpose: return a sub frame rotation for a single bone
//-----------------------------------------------------------------------------
/*void CalcBoneQuaternion(int frame, float s,
                        const Quaternion &baseQuat, const RadianEuler &baseRot, const Vector &baseRotScale,
                        int iBaseFlags, const Quaternion &baseAlignment,
                        const mstudioanim_t *panim, Quaternion &q)*/
function _CalcBoneQuaternion(pStudioHdr, frame, s, baseQuat, baseRot, baseRotScale, iBaseFlags, baseAlignment, panim, q) {
    if (panim.flags & STUDIO_ANIM_RAWROT) {
        //q = panim.pQuat48();
        quat.copy(q, panim.rawrot); //TODOv2
        return;
    }
    if (panim.flags & STUDIO_ANIM_RAWROT2) {
        //q = panim.pQuat64();
        quat.copy(q, panim.rawrot2); //TODOv2
        q[0] = panim.rawrot2[2];
        q[1] = panim.rawrot2[1];
        q[2] = panim.rawrot2[0];
        q[3] = panim.rawrot2[3];
        return;
    }
    if (!(panim.flags & STUDIO_ANIM_ANIMROT)) {
        if (panim.flags & STUDIO_ANIM_DELTA) {
            quat.identity(q);
        }
        else {
            quat.copy(q, baseQuat); //TODOv2
        }
        return;
    }
    panim.animValuePtrRot;
    if (s > 0.001) {
        const angle1 = vec3.create(), angle2 = vec3.create(); // TODO: optimize
        const q1 = quat.create();
        const q2 = quat.create();
        for (let i = 0; i < 3; ++i) {
            const offset = panim.animValuePtrRot.offset[i];
            if (offset) {
                angle1[i] = panim.readValue(pStudioHdr, frame, panim.animValuePtrRot.base + offset /*, panim.bone, i*/) * baseRotScale[i];
                angle2[i] = angle1[i];
            }
        }
        if (!(panim.flags & STUDIO_ANIM_DELTA)) {
            angle1[0] = angle1[0] + baseRot[0];
            angle1[1] = angle1[1] + baseRot[1];
            angle1[2] = angle1[2] + baseRot[2];
            angle2[0] = angle2[0] + baseRot[0];
            angle2[1] = angle2[1] + baseRot[1];
            angle2[2] = angle2[2] + baseRot[2];
        }
        if (angle1[0] !== angle2[0] || angle1[1] !== angle2[1] || angle1[2] !== angle2[2]) {
            //_AngleQuaternion(angle1, q1);//TODOv2
            //_AngleQuaternion(angle2, q2);//TODOv2
            quatFromEulerRad(q1, angle1[0], angle1[1], angle1[2]);
            quatFromEulerRad(q2, angle2[0], angle2[1], angle2[2]);
            QuaternionBlend(q1, q2, s, q);
        }
        else {
            //_AngleQuaternion(angle1, q);//TODOv2
            //quat.fromMat3(q, mat3.fromEuler(SourceEngineTempMat3, angle1));
            quatFromEulerRad(q, angle1[0], angle1[1], angle1[2]);
        }
    }
    else {
        const angle = vec3.create();
        for (let i = 0; i < 3; ++i) {
            const offset = panim.animValuePtrRot.offset[i];
            if (offset) {
                angle[i] = panim.readValue(pStudioHdr, frame, panim.animValuePtrRot.base + offset /*, panim.bone, i*/) * baseRotScale[i];
            }
        }
        if (!(panim.flags & STUDIO_ANIM_DELTA)) {
            angle[0] = angle[0] + baseRot[0];
            angle[1] = angle[1] + baseRot[1];
            angle[2] = angle[2] + baseRot[2];
        }
        //_AngleQuaternion(angle, q);//TODOv2
        //quat.fromMat3(q, mat3.fromEuler(SourceEngineTempMat3, angle));
        quatFromEulerRad(q, angle[0], angle[1], angle[2]);
    }
    // align to unified bone
    if (!(panim.flags & STUDIO_ANIM_DELTA) && (iBaseFlags & BONE_FIXED_ALIGNMENT)) {
        QuaternionAlign(baseAlignment, q, q);
    }
}
function CalcBoneQuaternion(pStudioHdr, frame, s, pBone, pLinearBones, panim, q) {
    {
        _CalcBoneQuaternion(pStudioHdr, frame, s, pBone.quaternion, pBone.rot, pBone.rotscale, pBone.flags, pBone.qAlignment, panim, q);
        //_CalcBoneQuaternion(pStudioHdr, frame, s, pBone.quat, [0, 0, 0]/*pBone.rot*//*TODOV2*/, pBone.rotscale, pBone.flags, pBone.qAlignment, panim, q);
    }
}
function _CalcBonePosition(pStudioHdr, frame, s, basePos, baseBoneScale, panim, pos) {
    if (panim.flags & STUDIO_ANIM_RAWPOS) {
        vec3.copy(pos, panim.rawpos);
        return;
    }
    else if (!(panim.flags & STUDIO_ANIM_ANIMPOS)) {
        if (panim.flags & STUDIO_ANIM_DELTA) {
            vec3.zero(pos);
        }
        else {
            vec3.copy(pos, basePos);
        }
        return;
    }
    panim.animValuePtrPos;
    /*
        mstudioanim_valueptr_t *pPosV = panim.pPosV();
        int					j;
    */
    if (s > 0.001) {
        let v1, v2; // TODO: optimize
        for (let i = 0; i < 3; i++) {
            const offset = panim.animValuePtrPos.offset[i];
            if (offset) {
                //ExtractAnimValue(frame, pPosV->pAnimvalue(i), baseBoneScale[i], v1, v2);
                v1 = panim.readValue(pStudioHdr, frame, panim.animValuePtrPos.base + offset /*, panim.bone, i*/) * baseBoneScale[i];
                v2 = v1;
                pos[i] = v1 * (1.0 - s) + v2 * s;
            }
        }
    }
    else {
        for (let i = 0; i < 3; i++) {
            //ExtractAnimValue(frame, pPosV->pAnimvalue(i), baseBoneScale[i], pos[i]);
            const offset = panim.animValuePtrPos.offset[i];
            if (offset) {
                //ExtractAnimValue(frame, pPosV->pAnimvalue(i), baseBoneScale[i], v1, v2);
                pos[i] = panim.readValue(pStudioHdr, frame, panim.animValuePtrPos.base + offset /*, panim.bone, i*/) * baseBoneScale[i];
            }
        }
    }
    if (!(panim.flags & STUDIO_ANIM_DELTA)) {
        pos[0] = pos[0] + basePos[0];
        pos[1] = pos[1] + basePos[1];
        pos[2] = pos[2] + basePos[2];
    }
}
function CalcBonePosition(pStudioHdr, frame, s, pBone, pLinearBones, panim, pos) {
    if (pLinearBones) ;
    else {
        _CalcBonePosition(pStudioHdr, frame, s, pBone.position, pBone.posscale, panim, pos);
    }
}
//-----------------------------------------------------------------------------
// Do a piecewise addition of the quaternion elements. This actually makes little
// mathematical sense, but it's a cheap way to simulate a slerp.
//-----------------------------------------------------------------------------
//void QuaternionBlend(const Quaternion &p, const Quaternion &q, float t, Quaternion &qt)
function QuaternionBlend(p, q, t, qt) {
    // decide if one of the quaternions is backwards
    const q2 = quat.create(); //TODO: optimize
    QuaternionAlign(p, q, q2);
    QuaternionBlendNoAlign(p, q2, t, qt);
}
//void QuaternionBlendNoAlign(const Quaternion &p, const Quaternion &q, float t, Quaternion &qt)
function QuaternionBlendNoAlign(p, q, t, qt) {
    // 0.0 returns p, 1.0 return q.
    const sclp = 1.0 - t;
    const sclq = t;
    for (let i = 0; i < 4; ++i) {
        qt[i] = sclp * p[i] + sclq * q[i];
    }
    quat.normalize(qt, qt);
}
//-----------------------------------------------------------------------------
// make sure quaternions are within 180 degrees of one another, if not, reverse q
//-----------------------------------------------------------------------------
//void QuaternionAlign(const Quaternion &p, const Quaternion &q, Quaternion &qt)
function QuaternionAlign(p, q, qt) {
    // FIXME: can this be done with a quat dot product?
    // decide if one of the quaternions is backwards
    let a = 0;
    let b = 0;
    for (let i = 0; i < 4; ++i) {
        a += (p[i] - q[i]) * (p[i] - q[i]);
        b += (p[i] + q[i]) * (p[i] + q[i]);
    }
    if (a > b) {
        for (let i = 0; i < 4; ++i) {
            qt[i] = -q[i];
        }
    }
    else if (qt != q) {
        for (let i = 0; i < 4; ++i) {
            qt[i] = q[i];
        }
    }
}
function PoseIsAllZeros(pStudioHdr, sequence, seqdesc, i0, i1) {
    // remove 'zero' positional blends
    //const baseanim = pStudioHdr.iRelativeAnim(sequence, seqdesc.getBlend(i0 , i1));//TODOv2
    const baseanim = seqdesc.getBlend(i0, i1);
    const anim = pStudioHdr.getAnimDescription(baseanim);
    if (!anim) {
        return false;
    }
    return (anim.flags & STUDIO_ALLZEROS$1) != 0;
}
//-----------------------------------------------------------------------------
// Purpose: turn a 2x2 blend into a 3 way triangle blend
// Returns: returns the animination indices and barycentric coordinates of a triangle
//			the triangle is a right triangle, and the diagonal is between elements [0] and [2]
//-----------------------------------------------------------------------------
//void Calc3WayBlendIndices(int i0, int i1, float s0, float s1, const mstudioseqdesc_t &seqdesc, int *pAnimIndices, float *pWeight)
function Calc3WayBlendIndices(i0, i1, s0, s1, seqdesc, pAnimIndices, pWeight) {
    // Figure out which bi-section direction we are using to make triangles.
    const bEven = (((i0 + i1) & 0x1) == 0);
    let x1, y1;
    let x2, y2;
    let x3, y3;
    // diagonal is between elements 1 & 3
    // TL to BR
    if (bEven) {
        if (s0 > s1) {
            // B
            x1 = 0;
            y1 = 0;
            x2 = 1;
            y2 = 0;
            x3 = 1;
            y3 = 1;
            pWeight[0] = (1.0 - s0);
            pWeight[1] = s0 - s1;
        }
        else {
            // C
            x1 = 1;
            y1 = 1;
            x2 = 0;
            y2 = 1;
            x3 = 0;
            y3 = 0;
            pWeight[0] = s0;
            pWeight[1] = s1 - s0;
        }
    }
    // BL to TR
    else {
        const flTotal = s0 + s1;
        if (flTotal > 1.0) {
            // D
            x1 = 1;
            y1 = 0;
            x2 = 1;
            y2 = 1;
            x3 = 0;
            y3 = 1;
            pWeight[0] = (1.0 - s1);
            pWeight[1] = s0 - 1.0 + s1;
        }
        else {
            // A
            x1 = 0;
            y1 = 1;
            x2 = 0;
            y2 = 0;
            x3 = 1;
            y3 = 0;
            pWeight[0] = s1;
            pWeight[1] = 1.0 - s0 - s1;
        }
    }
    pAnimIndices[0] = seqdesc.getBlend(i0 + x1, i1 + y1) ?? 0;
    pAnimIndices[1] = seqdesc.getBlend(i0 + x2, i1 + y2) ?? 0;
    pAnimIndices[2] = seqdesc.getBlend(i0 + x3, i1 + y3) ?? 0;
    // clamp the diagonal
    if (pWeight[1] < 0.001)
        pWeight[1] = 0.0;
    pWeight[2] = 1.0 - pWeight[0] - pWeight[1];
    //Assert(pWeight[0] >= 0.0 && pWeight[0] <= 1.0);
    //Assert(pWeight[1] >= 0.0 && pWeight[1] <= 1.0);
    //Assert(pWeight[2] >= 0.0 && pWeight[2] <= 1.0);
}
//-----------------------------------------------------------------------------
// Purpose: calculate a pose for a single sequence //TODOv2
//			adds autolayers, runs local ik rukes
//-----------------------------------------------------------------------------
const AddSequenceLayers = function (dynamicProp, pStudioHdr, pIKContext, pos, q, boneFlags, seqdesc, sequence, cycle, poseParameters, boneMask, flWeight, flTime) {
    //return;
    for (let i = 0; i < seqdesc.numautolayers; ++i) {
        const pLayer = seqdesc.getAutoLayer(i);
        if (!pLayer) {
            continue;
        }
        if (pLayer.flags & STUDIO_AL_LOCAL) {
            continue;
        }
        let layerCycle = cycle;
        let layerWeight = flWeight;
        if (pLayer.start != pLayer.end) {
            let s = 1.0;
            let index;
            if (!(pLayer.flags & STUDIO_AL_POSE)) {
                index = cycle;
            }
            else {
                //TODOv2
                pLayer.iSequence; //int iSequence = pStudioHdr.iRelativeSeq(sequence, pLayer.iSequence);
                //const iPose = pStudioHdr.GetSharedPoseParameter(iSequence, pLayer.iPose);
                const iPose = pLayer.iPose;
                if (iPose != -1) {
                    //const Pose = pStudioHdr.pPoseParameter(iPose);
                    const Pose = pStudioHdr.getLocalPoseParameter(iPose);
                    if (Pose) {
                        index = (poseParameters.get(String(iPose)) ?? 1) * (Pose.end - Pose.start) + Pose.start;
                    }
                    else {
                        index = 0;
                    }
                }
                else {
                    index = 0;
                }
            }
            if (index < pLayer.start) {
                continue;
            }
            if (index >= pLayer.end) {
                continue;
            }
            if (index < pLayer.peak && pLayer.start != pLayer.peak) {
                s = (index - pLayer.start) / (pLayer.peak - pLayer.start);
            }
            else if (index > pLayer.tail && pLayer.end != pLayer.tail) {
                s = (pLayer.end - index) / (pLayer.end - pLayer.tail);
            }
            if (pLayer.flags & STUDIO_AL_SPLINE) {
                s = SimpleSpline(s);
            }
            if ((pLayer.flags & STUDIO_AL_XFADE) && (index > pLayer.tail)) {
                layerWeight = (s * flWeight) / (1 - flWeight + s * flWeight);
            }
            else if (pLayer.flags & STUDIO_AL_NOBLEND) {
                layerWeight = s;
            }
            else {
                layerWeight = flWeight * s;
            }
            if (!(pLayer.flags & STUDIO_AL_POSE)) {
                layerCycle = (cycle - pLayer.start) / (pLayer.end - pLayer.start);
            }
        }
        //const iSequence = pStudioHdr.iRelativeSeq(sequence, pLayer.iSequence);//TODOV2
        const iSequence = pLayer.iSequence; //pStudioHdr.getSequenceById(pLayer.iSequence);
        AccumulatePose(dynamicProp, pStudioHdr, pIKContext, pos, q, boneFlags, iSequence, layerCycle, poseParameters, boneMask, layerWeight, flTime);
    }
};
//-----------------------------------------------------------------------------
// Purpose: accumulate a pose for a single sequence on top of existing animation
//			adds autolayers, runs local ik rukes
//-----------------------------------------------------------------------------
const AccumulatePose_pos2$1 = Array(SOURCE_MODEL_MAX_BONES$1);
const AccumulatePose_q2$1 = Array(SOURCE_MODEL_MAX_BONES$1);
for (let i = 0; i < SOURCE_MODEL_MAX_BONES$1; i++) {
    AccumulatePose_pos2$1[i] = vec3.create();
    AccumulatePose_q2$1[i] = quat.create();
}
function AccumulatePose(dynamicProp, pStudioHdr, pIKContext, pos, q, boneFlags, sequence, cycle, poseParameters, boneMask, flWeight, flTime) {
    //const pos2 = [];
    //const q2 = [];
    const pos2 = AccumulatePose_pos2$1;
    const q2 = AccumulatePose_q2$1;
    // This shouldn't be necessary, but the Assert should help us catch whoever is screwing this up
    flWeight = clamp$1(flWeight, 0.0, 1.0);
    if (sequence < 0) {
        return;
    }
    const seqdesc = pStudioHdr.getSequenceById(sequence);
    if (!seqdesc) {
        return;
    }
    if (seqdesc.numiklocks) ;
    if (seqdesc.flags & STUDIO_LOCAL$1) {
        InitPose(dynamicProp, pStudioHdr, pos2, q2);
    }
    if (CalcPoseSingle(dynamicProp, pStudioHdr, pos2, q2, boneFlags, seqdesc, sequence, cycle, poseParameters, boneMask, flTime)) {
        // this weight is wrong, the IK rules won't composite at the correct intensity
        AddLocalLayers(dynamicProp, pStudioHdr, pIKContext, pos2, q2, boneFlags, seqdesc, sequence, cycle, poseParameters, boneMask, 1.0, flTime);
        SlerpBones(pStudioHdr, q, pos, seqdesc, sequence, q2, pos2, flWeight);
    }
    /*
    if (pIKContext) {
        // TODO: activate
        pIKContext.AddDependencies(seqdesc, sequence, cycle, poseParameters, flWeight);
    }
    */
    AddSequenceLayers(dynamicProp, pStudioHdr, pIKContext, pos, q, boneFlags, seqdesc, sequence, cycle, poseParameters, boneMask, flWeight, flTime);
    if (seqdesc.numiklocks) ;
}
//-----------------------------------------------------------------------------
// Purpose: calculate a pose for a single sequence
//			adds autolayers, runs local ik rukes
//-----------------------------------------------------------------------------
function AddLocalLayers(dynamicProp, pStudioHdr, pIKContext, pos, q, boneFlags, seqdesc, sequence, cycle, poseParameters, boneMask, flWeight, flTime) {
    if (!(seqdesc.flags & STUDIO_LOCAL$1)) {
        return;
    }
    for (let i = 0; i < seqdesc.numautolayers; ++i) {
        const pLayer = seqdesc.autolayer[i];
        if (!pLayer || !(pLayer.flags & STUDIO_AL_LOCAL)) {
            continue;
        }
        let layerCycle = cycle;
        let layerWeight = flWeight;
        if (pLayer.start != pLayer.end) {
            let s = 1.0;
            if (cycle < pLayer.start)
                continue;
            if (cycle >= pLayer.end)
                continue;
            if (cycle < pLayer.peak && pLayer.start != pLayer.peak) {
                s = (cycle - pLayer.start) / (pLayer.peak - pLayer.start);
            }
            else if (cycle > pLayer.tail && pLayer.end != pLayer.tail) {
                s = (pLayer.end - cycle) / (pLayer.end - pLayer.tail);
            }
            if (pLayer.flags & STUDIO_AL_SPLINE) {
                s = SimpleSpline(s);
            }
            if ((pLayer.flags & STUDIO_AL_XFADE) && (cycle > pLayer.tail)) {
                layerWeight = (s * flWeight) / (1 - flWeight + s * flWeight);
            }
            else if (pLayer.flags & STUDIO_AL_NOBLEND) {
                layerWeight = s;
            }
            else {
                layerWeight = flWeight * s;
            }
            layerCycle = (cycle - pLayer.start) / (pLayer.end - pLayer.start);
        }
        const iSequence = pLayer.iSequence; //pStudioHdr.iRelativeSeq(sequence, pLayer.iSequence);
        AccumulatePose(dynamicProp, pStudioHdr, pIKContext, pos, q, boneFlags, iSequence, layerCycle, poseParameters, boneMask, layerWeight, flTime);
    }
}
//-----------------------------------------------------------------------------
// Purpose: blend together q1,pos1 with q2,pos2.	Return result in q1,pos1.
//			0 returns q1, pos1.	1 returns q2, pos2
//-----------------------------------------------------------------------------
function SlerpBones(pStudioHdr, q1, pos1, seqdesc, sequence, q2, pos2, s, boneMask) {
    if (s <= 0.0) {
        return;
    }
    if (s > 1.0) {
        s = 1.0;
    }
    if (seqdesc.flags & STUDIO_WORLD) {
        //WorldSpaceSlerp(pStudioHdr, q1, pos1, seqdesc, sequence, q2, pos2, s, boneMask);
        return;
    }
    // Build weightlist for all bones
    const nBoneCount = pStudioHdr.getBoneCount();
    //const *pS2 = (float*)stackalloc(nBoneCount * sizeof(float));TODOv2
    const pS2 = [];
    for (let i = 0; i < nBoneCount; ++i) {
        q1[i] = q1[i] || q2[i] || quat.create(); //TODOV2
        pos1[i] = pos1[i] || pos2[i] || vec3.create();
        q2[i] = q2[i] || quat.create(); //TODOV2
        pos2[i] = pos2[i] || vec3.create();
        {
            pS2[i] = s * (seqdesc.pBoneweight(i) ?? 1); // blend in based on this bones weight
            continue;
        }
    }
    let s1, s2;
    if (seqdesc.flags & STUDIO_DELTA$1) {
        for (let i = 0; i < nBoneCount; ++i) {
            s2 = pS2[i];
            if (s2 <= 0.0) {
                continue;
            }
            if (!pos1[i] || !pos2[i] || !q1[i] || !q2[i]) {
                continue;
            }
            if (seqdesc.flags & STUDIO_POST) {
                QuaternionMA(q1[i], s2, q2[i], q1[i]);
                // FIXME: are these correct?
                pos1[i][0] = pos1[i][0] + pos2[i][0] * s2;
                pos1[i][1] = pos1[i][1] + pos2[i][1] * s2;
                pos1[i][2] = pos1[i][2] + pos2[i][2] * s2;
            }
            else {
                QuaternionSM(s2, q2[i], q1[i], q1[i]);
                // FIXME: are these correct?
                pos1[i][0] = pos1[i][0] + pos2[i][0] * s2;
                pos1[i][1] = pos1[i][1] + pos2[i][1] * s2;
                pos1[i][2] = pos1[i][2] + pos2[i][2] * s2;
            }
        }
        return;
    }
    const q3 = quat.create();
    for (let i = 0; i < nBoneCount; ++i) {
        s2 = pS2[i];
        if (s2 <= 0.0) {
            continue;
        }
        if (!q1[i] || !q2[i] || !pos1[i] || !pos2[i]) {
            continue;
        }
        s1 = 1.0 - s2;
        if (pStudioHdr.boneFlags(i) & BONE_FIXED_ALIGNMENT) {
            QuaternionSlerpNoAlign(q2[i], q1[i], s1, q3);
        }
        else {
            QuaternionSlerp(q2[i], q1[i], s1, q3);
        }
        q1[i][0] = q3[0];
        q1[i][1] = q3[1];
        q1[i][2] = q3[2];
        q1[i][3] = q3[3];
        pos1[i][0] = pos1[i][0] * s1 + pos2[i][0] * s2;
        pos1[i][1] = pos1[i][1] * s1 + pos2[i][1] * s2;
        pos1[i][2] = pos1[i][2] * s1 + pos2[i][2] * s2;
    }
}
//-----------------------------------------------------------------------------
// Purpose: qt = p * (s * q)
//-----------------------------------------------------------------------------
//void QuaternionMA(const Quaternion &p, float s, const Quaternion &q, Quaternion &qt)
function QuaternionMA(p, s, q, qt) {
    const p1 = quat.create();
    const q1 = quat.create();
    QuaternionScale(q, s, q1);
    quat.mul(p1, p, q1);
    quat.normalize(p1, p1);
    qt[0] = p1[0];
    qt[1] = p1[1];
    qt[2] = p1[2];
    qt[3] = p1[3];
}
//-----------------------------------------------------------------------------
// Purpose: qt = (s * p) * q
//-----------------------------------------------------------------------------
//void QuaternionSM(float s, const Quaternion &p, const Quaternion &q, Quaternion &qt)
function QuaternionSM(s, p, q, qt) {
    const p1 = quat.create();
    const q1 = quat.create();
    QuaternionScale(p, s, p1);
    quat.mul(q1, p1, q);
    quat.normalize(q1, q1); //QuaternionNormalize(q1);
    qt[0] = q1[0];
    qt[1] = q1[1];
    qt[2] = q1[2];
    qt[3] = q1[3];
}
//void QuaternionScale(const Quaternion &p, float t, Quaternion &q);
function QuaternionScale(p, t, q) {
    let r;
    // FIXME: nick, this isn't overly sensitive to accuracy, and it may be faster to
    // use the cos part (w) of the quaternion (sin(omega)*N,cos(omega)) to figure the new scale.
    let sinom = Math.sqrt(vec3.dot(p, p));
    sinom = Math.min(sinom, 1.0);
    const sinsom = Math.sin(Math.asin(sinom) * t);
    t = sinsom / (sinom + FLT_EPSILON);
    vec3.scale(q, p, t);
    // rescale rotation
    r = 1.0 - sinsom * sinsom;
    // Assert(r >= 0);
    if (r < 0.0) {
        r = 0.0;
    }
    r = Math.sqrt(r);
    // keep sign of rotation
    if (p[3] < 0) {
        q[3] = -r;
    }
    else {
        q[3] = r;
    }
    return;
}
//-----------------------------------------------------------------------------
// Purpose: Inter-animation blend.	Assumes both types are identical.
//			blend together q1,pos1 with q2,pos2.	Return result in q1,pos1.
//			0 returns q1, pos1.	1 returns q2, pos2
//-----------------------------------------------------------------------------
/*void BlendBones(
    const CStudioHdr *pStudioHdr,
    Quaternion q1[MAXSTUDIOBONES],
    Vector pos1[MAXSTUDIOBONES],
    mstudioseqdesc_t &seqdesc,
    int sequence,
    const Quaternion q2[MAXSTUDIOBONES],
    const Vector pos2[MAXSTUDIOBONES],
    float s,
    int boneMask)*/
function BlendBones(pStudioHdr, q1, pos1, seqdesc, sequence, q2, pos2, s, boneMask) {
    const q3 = quat.create();
    /*virtualmodel_t *pVModel = pStudioHdr.GetVirtualModel();TODO
    const virtualgroup_t *pSeqGroup = NULL;
    if (pVModel)
    {
        pSeqGroup = pVModel.pSeqGroup(sequence);
    }*/
    if (s <= 0) {
        //Assert(0); // shouldn't have been called
        return;
    }
    else if (s >= 1.0) {
        //Assert(0); // shouldn't have been called
        for (let i = 0, boneCount = pStudioHdr.getBoneCount(); i < boneCount; ++i) {
            let j;
            // skip unused bones
            if (!(pStudioHdr.boneFlags(i) & boneMask)) {
                continue;
            }
            /* TODO: activate
            if (pSeqGroup) {
                j = pSeqGroup.boneMap[i];
            }
            */
            else {
                j = i;
            }
            if (j >= 0 && (seqdesc.pBoneweight(j) ?? 0) > 0.0 && q2[i] && pos2[i]) {
                q1[i] = q2[i];
                pos1[i] = pos2[i];
            }
        }
        return;
    }
    const s2 = s;
    const s1 = 1.0 - s2;
    for (let i = 0, boneCount = pStudioHdr.getBoneCount(); i < boneCount; ++i) {
        let j;
        // skip unused bones
        q1[i] = q1[i] || quat.create();
        pos1[i] = pos1[i] || vec3.create();
        q2[i] = q2[i] || quat.create();
        pos2[i] = pos2[i] || vec3.create();
        if (!(pStudioHdr.boneFlags(i) & boneMask)) {
            continue;
        }
        /* TODO: activate
        if (pSeqGroup) {
            j = pSeqGroup.boneMap[i];
        }
        */
        else {
            j = i;
        }
        if (j >= 0 && (seqdesc.pBoneweight(j) ?? 0) > 0.0 && q2[i] && q1[i] && pos1[i] && pos2[i]) {
            if (pStudioHdr.boneFlags(i) & BONE_FIXED_ALIGNMENT) {
                QuaternionBlendNoAlign(q2[i], q1[i], s1, q3);
            }
            else {
                QuaternionBlend(q2[i], q1[i], s1, q3);
            }
            q1[i][0] = q3[0];
            q1[i][1] = q3[1];
            q1[i][2] = q3[2];
            q1[i][3] = q3[3];
            pos1[i][0] = pos1[i][0] * s1 + pos2[i][0] * s2;
            pos1[i][1] = pos1[i][1] * s1 + pos2[i][1] * s2;
            pos1[i][2] = pos1[i][2] * s1 + pos2[i][2] * s2;
        }
    }
}
//-----------------------------------------------------------------------------
// Quaternion sphereical linear interpolation
//-----------------------------------------------------------------------------
//void QuaternionSlerp(const Quaternion &p, const Quaternion &q, float t, Quaternion &qt)
function QuaternionSlerp(p, q, t, qt) {
    const q2 = quat.create();
    // 0.0 returns p, 1.0 return q.
    // decide if one of the quaternions is backwards
    QuaternionAlign(p, q, q2);
    QuaternionSlerpNoAlign(p, q2, t, qt);
}
//void QuaternionSlerpNoAlign(const Quaternion &p, const Quaternion &q, float t, Quaternion &qt)
function QuaternionSlerpNoAlign(p, q, t, qt) {
    //Assert(s_bMathlibInitialized);
    let omega, cosom, sinom, sclp, sclq;
    // 0.0 returns p, 1.0 return q.
    cosom = p[0] * q[0] + p[1] * q[1] + p[2] * q[2] + p[3] * q[3];
    if ((1.0 + cosom) > 0.000001) {
        if ((1.0 - cosom) > 0.000001) {
            omega = Math.acos(cosom);
            sinom = Math.sin(omega);
            sclp = Math.sin((1.0 - t) * omega) / sinom;
            sclq = Math.sin(t * omega) / sinom;
        }
        else {
            // TODO: add short circuit for cosom == 1.0?
            sclp = 1.0 - t;
            sclq = t;
        }
        for (let i = 0; i < 4; ++i) {
            qt[i] = sclp * p[i] + sclq * q[i];
        }
    }
    else {
        //Assert(&qt != &q);
        qt[0] = -q[1];
        qt[1] = q[0];
        qt[2] = -q[3];
        qt[3] = q[2];
        sclp = Math.sin((1.0 - t) * (0.5 * Math.PI));
        sclq = Math.sin(t * (0.5 * Math.PI));
        for (let i = 0; i < 3; i++) {
            qt[i] = sclp * p[i] + sclq * qt[i];
        }
    }
    //Assert(qt.IsValid());
}
//-----------------------------------------------------------------------------
// Purpose: resolve a global pose parameter to the specific setting for this sequence
//-----------------------------------------------------------------------------
//void Studio_LocalPoseParameter(const CStudioHdr *pStudioHdr, const float poseParameters[], mstudioseqdesc_t &seqdesc, int iSequence, int iLocalIndex, float &flSetting, int &index)
function Studio_LocalPoseParameter(pStudioHdr, poseParameters, seqdesc, iSequence, iLocalIndex /*, flSetting, index*/) {
    let flSetting = 0;
    let index = 0;
    //const iPose = pStudioHdr.GetSharedPoseParameter(iSequence, seqdesc.paramindex[iLocalIndex]);
    const iPose = seqdesc.paramindex[iLocalIndex] ?? -1;
    if (iPose == -1) {
        return { s: 0, i: 0 };
    }
    const Pose = pStudioHdr.getLocalPoseParameter(iPose);
    if (!Pose) {
        flSetting = 0;
        index = 0;
        return { s: flSetting, i: index };
    }
    //const flValue = poseParameters[iPose];
    let flValue = Pose.midpoint;
    const poseParameter = poseParameters.get(Pose.name);
    if (poseParameter !== undefined) {
        flValue = poseParameter;
    }
    if (Pose.loop) {
        const wrap = (Pose.start + Pose.end) / 2.0 + Pose.loop / 2.0;
        const shift = Pose.loop - wrap;
        flValue = flValue - Pose.loop * Math.floor((flValue + shift) / Pose.loop);
    }
    const paramStart = seqdesc.paramstart[iLocalIndex];
    const paramEnd = seqdesc.paramend[iLocalIndex];
    const groupSize = seqdesc.groupsize[iLocalIndex];
    if (paramStart === undefined || paramEnd === undefined || groupSize === undefined) {
        return { s: 0, i: 0 };
    }
    if (seqdesc.posekeyindex == 0) {
        const flLocalStart = (paramStart - Pose.start) / (Pose.end - Pose.start);
        const flLocalEnd = (paramEnd - Pose.start) / (Pose.end - Pose.start);
        // convert into local range
        flSetting = (flValue - flLocalStart) / (flLocalEnd - flLocalStart);
        // clamp.	This shouldn't ever need to happen if it's looping.
        if (flSetting < 0)
            flSetting = 0;
        if (flSetting > 1)
            flSetting = 1;
        index = 0;
        if (groupSize > 2) {
            // estimate index
            index = Math.round(flSetting * (groupSize - 1));
            if (index == groupSize - 1)
                index = groupSize - 2;
            flSetting = flSetting * (groupSize - 1) - index;
        }
    }
    else {
        flValue = flValue * (Pose.end - Pose.start) + Pose.start;
        index = 0;
        // FIXME: this needs to be 2D
        // FIXME: this shouldn't be a linear search
        while (1) {
            flSetting = (flValue - seqdesc.poseKey(iLocalIndex, index)) / (seqdesc.poseKey(iLocalIndex, index + 1) - seqdesc.poseKey(iLocalIndex, index));
            //flSetting = 0;//TODOV2
            /*
            if (index > 0 && flSetting < 0.0)
            {
                index--;
                continue;
            }
            else
            */
            if (index < groupSize - 2 && flSetting > 1.0) {
                index++;
                continue;
            }
            break;
        }
        // clamp.
        if (flSetting < 0.0)
            flSetting = 0.0;
        if (flSetting > 1.0)
            flSetting = 1.0;
    }
    return { s: flSetting, i: index };
}
function ScaleBones(pStudioHdr, //const CStudioHdr *pStudioHdr,
q1, //Quaternion q1[MAXSTUDIOBONES],
pos1, //Vector pos1[MAXSTUDIOBONES],
sequence, //int sequence,
s, //float s,
boneMask //int boneMask
) {
    let i, j = -1; //int			i, j;
    const seqdesc = pStudioHdr.getSequenceById(sequence); //mstudioseqdesc_t & seqdesc = ((CStudioHdr *)pStudioHdr) -> pSeqdesc(sequence);
    if (!seqdesc) {
        return;
    }
    /*
    virtualmodel_t * pVModel = pStudioHdr -> GetVirtualModel();
    const virtualgroup_t * pSeqGroup = NULL;
    if (pVModel) {
        pSeqGroup = pVModel -> pSeqGroup(sequence);
    }
        */
    const s2 = s;
    const s1 = 1.0 - s2;
    for (i = 0; i < pStudioHdr.getBoneCount(); i++) {
        if (!q1[i] || !pos1[i]) {
            continue;
        }
        // skip unused bones
        if (!(pStudioHdr.boneFlags(i) & boneMask)) {
            continue;
        }
        {
            j = i;
        }
        if (j >= 0 && (seqdesc.pBoneweight(j) ?? -1) > 0.0) {
            QuaternionIdentityBlend(q1[i], s1, q1[i]);
            //VectorScale(pos1[i], s2, pos1[i]);
            vec3.scale(pos1[i], pos1[i], s2);
        }
    }
}
//-----------------------------------------------------------------------------
// Purpose: translate animations done in a non-standard parent space
//-----------------------------------------------------------------------------
/*
function CalcLocalHierarchyAnimation(
    pStudioHdr,//const CStudioHdr * pStudioHdr,
    boneToWorld: mat4,//matrix3x4_t * boneToWorld,
    boneComputed,//CBoneBitList & boneComputed,
    pos,//Vector * pos,
    q,//Quaternion * q,
    //const mstudioanimdesc_t &animdesc,
    pbone,//const mstudiobone_t * pbone,
    pHierarchy,//mstudiolocalhierarchy_t * pHierarchy,
    iBone: number,//int iBone,
    iNewParent: number,//int iNewParent,
    cycle: number,//float cycle,
    iFrame: number,//int iFrame,
    flFraq: number,//float flFraq,
    boneMask: number,//int boneMask
): void {

    let localPos = vec3.create();//Vector localPos;
    let localQ = quat.create();//Quaternion localQ;

    // make fake root transform
    //static ALIGN16 matrix3x4_t rootXform ALIGN16_POST(1.0f, 0, 0, 0, 0, 1.0f, 0, 0, 0, 0, 1.0f, 0);
    let rootXform = mat4.create();

    // FIXME: missing check to see if seq has a weight for this bone
    //float weight = 1.0f;
    let weight = 1;

    // check to see if there's a ramp on the influence
    if (pHierarchy -> tail - pHierarchy -> peak < 1.0f  )
    {
        float index = cycle;

        if (pHierarchy -> end > 1.0f && index < pHierarchy -> start)
        index += 1.0f;

        if (index < pHierarchy -> start)
            return;
        if (index >= pHierarchy -> end)
            return;

        if (index < pHierarchy -> peak && pHierarchy -> start != pHierarchy -> peak) {
            weight = (index - pHierarchy -> start) / (pHierarchy -> peak - pHierarchy -> start);
        }
        else if (index > pHierarchy -> tail && pHierarchy -> end != pHierarchy -> tail) {
            weight = (pHierarchy -> end - index) / (pHierarchy -> end - pHierarchy -> tail);
        }

        weight = SimpleSpline(weight);
    }

    CalcDecompressedAnimation(pHierarchy -> pLocalAnim(), iFrame - pHierarchy -> iStart, flFraq, localPos, localQ);

    BuildBoneChain(pStudioHdr, rootXform, pos, q, iBone, boneToWorld, boneComputed);

    matrix3x4_t localXform;
    AngleMatrix(localQ, localPos, localXform);

    if (iNewParent != -1) {
        BuildBoneChain(pStudioHdr, rootXform, pos, q, iNewParent, boneToWorld, boneComputed);
        ConcatTransforms(boneToWorld[iNewParent], localXform, boneToWorld[iBone]);
    }
    else {
        boneToWorld[iBone] = localXform;
    }

    // back solve
    Vector p1;
    Quaternion q1;
    int n = pbone[iBone].parent;
    if (n == -1) {
        if (weight == 1.0f)
        {
            MatrixAngles(boneToWorld[iBone], q[iBone], pos[iBone]);
        }
        else
        {
            MatrixAngles(boneToWorld[iBone], q1, p1);
            QuaternionSlerp(q[iBone], q1, weight, q[iBone]);
            pos[iBone] = Lerp(weight, p1, pos[iBone]);
        }
    }
    else {
        matrix3x4_t worldToBone;
        MatrixInvert(boneToWorld[n], worldToBone);

        matrix3x4_t local;
        ConcatTransforms(worldToBone, boneToWorld[iBone], local);
        if (weight == 1.0f)
        {
            MatrixAngles(local, q[iBone], pos[iBone]);
        }
        else
        {
            MatrixAngles(local, q1, p1);
            QuaternionSlerp(q[iBone], q1, weight, q[iBone]);
            pos[iBone] = Lerp(weight, p1, pos[iBone]);
        }
    }
}
    */
//-----------------------------------------------------------------------------
// Purpose: blend together in world space q1,pos1 with q2,pos2.  Return result in q1,pos1.
//			0 returns q1, pos1.  1 returns q2, pos2
//-----------------------------------------------------------------------------
/*
function WorldSpaceSlerp(
    pStudioHdr,//const CStudioHdr *pStudioHdr,
    q1: Array<quat>,//Quaternion q1[MAXSTUDIOBONES],
    pos1: Array<vec3>,//Vector pos1[MAXSTUDIOBONES],
    seqdesc,//mstudioseqdesc_t &seqdesc,
    sequence: number,//int sequence,
    q2: Array<quat>,//const Quaternion q2[MAXSTUDIOBONES],
    pos2: Array<vec3>,//const Vector pos2[MAXSTUDIOBONES],
    s: number,//float s,
    boneMask: number//int boneMask
): void {
    int			i, j;
    float		s1; // weight of parent for q2, pos2
    float		s2; // weight for q2, pos2

    // make fake root transform
    matrix3x4_t rootXform;
    SetIdentityMatrix(rootXform);

    // matrices for q2, pos2
    matrix3x4_t * srcBoneToWorld = g_MatrixPool.Alloc();
    CBoneBitList srcBoneComputed;

    matrix3x4_t * destBoneToWorld = g_MatrixPool.Alloc();
    CBoneBitList destBoneComputed;

    matrix3x4_t * targetBoneToWorld = g_MatrixPool.Alloc();
    CBoneBitList targetBoneComputed;

    virtualmodel_t * pVModel = pStudioHdr -> GetVirtualModel();
    const virtualgroup_t * pSeqGroup = NULL;
    if (pVModel) {
        pSeqGroup = pVModel -> pSeqGroup(sequence);
    }

    mstudiobone_t * pbone = pStudioHdr -> pBone(0);

    for (i = 0; i < pStudioHdr -> numbones(); i++) {
        // skip unused bones
        if (!(pStudioHdr -> boneFlags(i) & boneMask)) {
            continue;
        }

        int n = pbone[i].parent;
        s1 = 0.0;
        if (pSeqGroup) {
            j = pSeqGroup -> boneMap[i];
            if (j >= 0) {
                s2 = s * seqdesc.weight(j);	// blend in based on this bones weight
                if (n != -1) {
                    s1 = s * seqdesc.weight(pSeqGroup -> boneMap[n]);
                }
            }
            else {
                s2 = 0.0;
            }
        }
        else {
            s2 = s * seqdesc.weight(i);	// blend in based on this bones weight
            if (n != -1) {
                s1 = s * seqdesc.weight(n);
            }
        }

        if (s1 == 1.0 && s2 == 1.0) {
            pos1[i] = pos2[i];
            q1[i] = q2[i];
        }
        else if (s2 > 0.0) {
            Quaternion srcQ, destQ;
            Vector srcPos, destPos;
            Quaternion targetQ;
            Vector targetPos;
            Vector tmp;

            BuildBoneChain(pStudioHdr, rootXform, pos1, q1, i, destBoneToWorld, destBoneComputed);
            BuildBoneChain(pStudioHdr, rootXform, pos2, q2, i, srcBoneToWorld, srcBoneComputed);

            MatrixAngles(destBoneToWorld[i], destQ, destPos);
            MatrixAngles(srcBoneToWorld[i], srcQ, srcPos);

            QuaternionSlerp(destQ, srcQ, s2, targetQ);
            AngleMatrix(targetQ, destPos, targetBoneToWorld[i]);

            // back solve
            if (n == -1) {
                MatrixAngles(targetBoneToWorld[i], q1[i], tmp);
            }
            else {
                matrix3x4_t worldToBone;
                MatrixInvert(targetBoneToWorld[n], worldToBone);

                matrix3x4_t local;
                ConcatTransforms(worldToBone, targetBoneToWorld[i], local);
                MatrixAngles(local, q1[i], tmp);

                // blend bone lengths (local space)
                pos1[i] = Lerp(s2, pos1[i], pos2[i]);
            }
        }
    }
    g_MatrixPool.Free(srcBoneToWorld);
    g_MatrixPool.Free(destBoneToWorld);
    g_MatrixPool.Free(targetBoneToWorld);
}
*/

//-----------------------------------------------------------------------------
// Purpose: returns array of animations and weightings for a sequence based on current pose parameters
//-----------------------------------------------------------------------------
//void Studio_SeqAnims(const CStudioHdr *pStudioHdr, mstudioseqdesc_t &seqdesc, int iSequence, const float poseParameters[], mstudioanimdesc_t *panim[4], float *weight)
function Studio_SeqAnims2(pStudioHdr, seqdesc, iSequence, poseParameters, panim, weight) {
    /*if (!pStudioHdr || iSequence >= pStudioHdr.GetNumSeq())
    {
        weight[0] = weight[1] = weight[2] = weight[3] = 0.0;
        return;
    }*/
    const i0 = 0, i1 = 0;
    const s0 = 0, s1 = 0;
    //Studio_LocalPoseParameter(pStudioHdr, poseParameters, seqdesc, iSequence, 0, s0, i0);TODOV2
    //	Studio_LocalPoseParameter(pStudioHdr, poseParameters, seqdesc, iSequence, 1, s1, i1);
    //panim[0] = pStudioHdr.pAnimdesc(pStudioHdr.iRelativeAnim(iSequence, seqdesc.anim(i0	, i1)));
    panim[0] = pStudioHdr.getAnimDescription(seqdesc.getBlend(i0, i1));
    weight[0] = (1 - s0) * (1 - s1);
    //panim[1] = pStudioHdr.pAnimdesc(pStudioHdr.iRelativeAnim(iSequence, seqdesc.anim(i0+1, i1)));
    panim[1] = pStudioHdr.getAnimDescription(seqdesc.getBlend(i0 + 1, i1));
    weight[1] = (s0) * (1 - s1);
    //panim[2] = pStudioHdr.pAnimdesc(pStudioHdr.iRelativeAnim(iSequence, seqdesc.anim(i0	, i1+1)));
    panim[2] = pStudioHdr.getAnimDescription(seqdesc.getBlend(i0, i1 + 1));
    weight[2] = (1 - s0) * (s1);
    //panim[3] = pStudioHdr.pAnimdesc(pStudioHdr.iRelativeAnim(iSequence, seqdesc.anim(i0+1, i1+1)));
    panim[3] = pStudioHdr.getAnimDescription(seqdesc.getBlend(i0 + 1, i1 + 1));
    weight[3] = (s0) * (s1);
}
//-----------------------------------------------------------------------------
// Purpose: returns cycles per second of a sequence (cycles/second)
//-----------------------------------------------------------------------------
//float Studio_CPS(const CStudioHdr *pStudioHdr, mstudioseqdesc_t &seqdesc, int iSequence, const float poseParameters[])
function Studio_CPS2(pStudioHdr, seqdesc, iSequence, poseParameters) {
    const panim = [null, null, null, null];
    const weight = [0, 0, 0, 0];
    Studio_SeqAnims2(pStudioHdr, seqdesc, iSequence, poseParameters, panim, weight);
    let t = 0;
    for (let i = 0; i < 4; ++i) {
        const anim = panim[i];
        if (anim && weight[i] > 0 && anim.numframes > 1) {
            t += (anim.fps / (anim.numframes - 1)) * weight[i];
            //setAnimLength(anim.numframes);//TODOv3
        }
    }
    return t;
}
function Studio_Frames2(pStudioHdr, seqdesc, iSequence, poseParameters) {
    const panim = [null, null, null, null];
    const weight = [0, 0, 0, 0];
    Studio_SeqAnims2(pStudioHdr, seqdesc, iSequence, poseParameters, panim, weight);
    let t = 0;
    for (let i = 0; i < 4; ++i) {
        if (panim[i] && weight[i] > 0) {
            t = Math.max(t, panim[i].numframes);
        }
    }
    return t;
}
function StudioFrames2(pStudioHdr, iSequence, poseParameters) {
    const seqdesc = pStudioHdr.getSequenceById(iSequence); //pStudioHdr.pSeqdesc(iSequence);
    if (!seqdesc) {
        return 0;
    }
    return Studio_Frames2(pStudioHdr, seqdesc, iSequence, poseParameters);
}
const SOURCE_MODEL_MAX_BONES = 256;
//-----------------------------------------------------------------------------
// Purpose: calculate a pose for a single sequence
//-----------------------------------------------------------------------------
function InitPose2(dynamicProp, pStudioHdr, pos, q, boneMask) {
    if (pStudioHdr.pLinearBones === undefined) {
        for (let i = 0, boneCount = pStudioHdr.getBoneCount(); i < boneCount; ++i) {
            {
                const pbone = pStudioHdr.getBone(i);
                pos[i] = pos[i] || vec3.create(); //removeme
                q[i] = q[i] || quat.create(); //removeme
                if (pbone) {
                    vec3.copy(pos[i], pbone.position);
                    quat.copy(q[i], pbone.quaternion);
                }
            }
        }
    }
}
//-----------------------------------------------------------------------------
// Purpose: calculate a pose for a single sequence
//			adds autolayers, runs local ik rukes
//-----------------------------------------------------------------------------
//function CalcPose(pStudioHdr, pIKContext, pos, q, sequence, cycle, poseParameters, boneMask, flWeight = 1.0, flTime = 0.0) {
function CalcPose2(dynamicProp, pStudioHdr, pIKContext, pos, q, boneFlags, sequence, cycle, poseParameters, boneMask, flWeight, flTime) {
    cycle = cycle % 1; //TODOv2
    const seqdesc = pStudioHdr.getSequenceById(sequence);
    if (seqdesc) {
        // add any IK locks to prevent numautolayers from moving extremities
        //CIKContext seq_ik;TODOv2
        /*
        if (false && seqdesc.numiklocks) {//TODOV2
            seq_ik.Init(pStudioHdr, vec3_angle, vec3_origin, 0.0, 0, boneMask); // local space relative so absolute position doesn't mater
            seq_ik.AddSequenceLocks(seqdesc, pos, q);
        }
            */
        CalcPoseSingle2(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, cycle, poseParameters, boneMask, flTime);
        AddSequenceLayers2(dynamicProp, pStudioHdr, pIKContext, pos, q, boneFlags, seqdesc, sequence, cycle, poseParameters);
        /*
                if (false && seqdesc.numiklocks) {//TODOV2
                    seq_ik.SolveSequenceLocks(seqdesc, pos, q);
                }
                    */
    }
}
//-----------------------------------------------------------------------------
// Purpose: calculate a pose for a single sequence
//-----------------------------------------------------------------------------
//TODOv2: put somewhere else
const STUDIO_LOOPING = 0x0001; // ending frame should be the same as the starting frame
const STUDIO_DELTA = 0x0004; // this sequence 'adds' to the base sequences, not slerp blends
const STUDIO_ALLZEROS = 0x0020; // this animation/sequence has no real animation data
//						0x0040
const STUDIO_CYCLEPOSE = 0x0080; // cycle index is taken from a pose parameter index
const STUDIO_REALTIME = 0x0100; // cycle index is taken from a real-time clock, not the animations cycle index
const STUDIO_LOCAL = 0x0200; // sequence has a local context sequence
const CalcPoseSingle_pos2 = Array(SOURCE_MODEL_MAX_BONES);
const CalcPoseSingle_q2 = Array(SOURCE_MODEL_MAX_BONES);
const CalcPoseSingle_pos3 = Array(SOURCE_MODEL_MAX_BONES);
const CalcPoseSingle_q3 = Array(SOURCE_MODEL_MAX_BONES);
for (let i = 0; i < SOURCE_MODEL_MAX_BONES; i++) {
    CalcPoseSingle_pos2[i] = vec3.create();
    CalcPoseSingle_q2[i] = quat.create();
    CalcPoseSingle_pos3[i] = vec3.create();
    CalcPoseSingle_q3[i] = quat.create();
}
function CalcPoseSingle2(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, cycle, poseParameters, boneMask, flTime) {
    let bResult = true;
    const pos2 = CalcPoseSingle_pos2; //[];//vec3.create();//TODOv2: optimize (see source)
    const q2 = CalcPoseSingle_q2; //[];//quat.create();//TODOv2: optimize (see source)
    const pos3 = CalcPoseSingle_pos3; //[];//vec3.create();//TODOv2: optimize (see source)
    const q3 = CalcPoseSingle_q3;
    for (let i = 0; i < SOURCE_MODEL_MAX_BONES; ++i) {
        vec3.zero(pos2[i]);
        quat.identity(q2[i]);
        vec3.zero(pos3[i]);
        quat.identity(q3[i]);
    }
    /*	if (sequence >= pStudioHdr->GetNumSeq())TODOv2
        {
            sequence = 0;
            seqdesc = pStudioHdr->pSeqdesc(sequence);
        }*/
    let i0 = 0, i1 = 0;
    let s0 = 0, s1 = 0;
    const r0 = Studio_LocalPoseParameter2(pStudioHdr, poseParameters, seqdesc, sequence, 0 /*, s0, i0 */); //TODOv2
    const r1 = Studio_LocalPoseParameter2(pStudioHdr, poseParameters, seqdesc, sequence, 1 /*, s1, i1 */);
    s0 = r0.s;
    i0 = r0.i;
    s1 = r1.s;
    i1 = r1.i;
    if (seqdesc.flags & STUDIO_REALTIME) {
        const cps = Studio_CPS2(pStudioHdr, seqdesc, sequence, poseParameters);
        cycle = flTime * cps;
        cycle = cycle - Math.floor(cycle); //TODOv2: rounding issues
    }
    else if (seqdesc.flags & STUDIO_CYCLEPOSE) {
        {
            cycle = 0.0;
        }
    }
    else if (cycle < 0 || cycle >= 1) {
        if (seqdesc.flags & STUDIO_LOOPING) {
            cycle = cycle - Math.floor(cycle); //TODOv2: rounding issues
            if (cycle < 0) {
                cycle += 1;
            }
        }
        else {
            cycle = clamp$1(cycle, 0.0, 1.0);
        }
    }
    if (s0 < 0.001) {
        if (s1 < 0.001) {
            if (PoseIsAllZeros2(pStudioHdr, sequence, seqdesc, i0, i1)) {
                bResult = false;
            }
            else {
                CalcAnimation2(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0, i1), cycle, boneMask);
            }
        }
        else if (s1 > 0.999) {
            CalcAnimation2(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0, i1 + 1), cycle, boneMask);
        }
        else {
            CalcAnimation2(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0, i1), cycle, boneMask);
            CalcAnimation2(dynamicProp, pStudioHdr, pos2, q2, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0, i1 + 1), cycle, boneMask);
            BlendBones2(pStudioHdr, q, pos, seqdesc, sequence, q2, pos2, s1, boneMask);
        }
    }
    else if (s0 > 0.999) {
        if (s1 < 0.001) {
            if (PoseIsAllZeros2(pStudioHdr, sequence, seqdesc, i0 + 1, i1)) {
                bResult = false;
            }
            else {
                CalcAnimation2(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0 + 1, i1), cycle, boneMask);
            }
        }
        else if (s1 > 0.999) {
            CalcAnimation2(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0 + 1, i1 + 1), cycle, boneMask);
        }
        else {
            CalcAnimation2(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0 + 1, i1), cycle, boneMask);
            CalcAnimation2(dynamicProp, pStudioHdr, pos2, q2, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0 + 1, i1 + 1), cycle, boneMask);
            BlendBones2(pStudioHdr, q, pos, seqdesc, sequence, q2, pos2, s1, boneMask);
        }
    }
    else {
        if (s1 < 0.001) {
            if (PoseIsAllZeros2(pStudioHdr, sequence, seqdesc, i0 + 1, i1)) {
                CalcAnimation2(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0, i1), cycle, boneMask);
                ScaleBones2(pStudioHdr, q, pos, sequence, 1.0 - s0, boneMask);
            }
            else if (PoseIsAllZeros2(pStudioHdr, sequence, seqdesc, i0, i1)) {
                CalcAnimation2(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0 + 1, i1), cycle, boneMask);
                ScaleBones2(pStudioHdr, q, pos, sequence, s0, boneMask);
            }
            else {
                CalcAnimation2(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0, i1), cycle, boneMask);
                CalcAnimation2(dynamicProp, pStudioHdr, pos2, q2, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0 + 1, i1), cycle, boneMask);
                BlendBones2(pStudioHdr, q, pos, seqdesc, sequence, q2, pos2, s0, boneMask);
            }
        }
        else if (s1 > 0.999) {
            CalcAnimation2(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0, i1 + 1), cycle, boneMask);
            CalcAnimation2(dynamicProp, pStudioHdr, pos2, q2, boneFlags, seqdesc, sequence, seqdesc.getBlend(i0 + 1, i1 + 1), cycle, boneMask);
            BlendBones2(pStudioHdr, q, pos, seqdesc, sequence, q2, pos2, s0, boneMask);
        }
        //else if (!anim_3wayblend.GetBool())
        else {
            const iAnimIndices = [0, 0, 0];
            const weight = [0, 0, 0];
            Calc3WayBlendIndices2(i0, i1, s0, s1, seqdesc, iAnimIndices, weight);
            if (weight[1] < 0.001) {
                // on diagonal
                CalcAnimation2(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, iAnimIndices[0], cycle, boneMask);
                CalcAnimation2(dynamicProp, pStudioHdr, pos2, q2, boneFlags, seqdesc, sequence, iAnimIndices[2], cycle, boneMask);
                BlendBones2(pStudioHdr, q, pos, seqdesc, sequence, q2, pos2, weight[2] / (weight[0] + weight[2]), boneMask);
            }
            else {
                CalcAnimation2(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, iAnimIndices[0], cycle, boneMask);
                CalcAnimation2(dynamicProp, pStudioHdr, pos2, q2, boneFlags, seqdesc, sequence, iAnimIndices[1], cycle, boneMask);
                BlendBones2(pStudioHdr, q, pos, seqdesc, sequence, q2, pos2, weight[1] / (weight[0] + weight[1]), boneMask);
                CalcAnimation2(dynamicProp, pStudioHdr, pos3, q3, boneFlags, seqdesc, sequence, iAnimIndices[2], cycle, boneMask);
                BlendBones2(pStudioHdr, q, pos, seqdesc, sequence, q3, pos3, weight[2], boneMask);
            }
        }
    }
    //g_VectorPool.Free(pos2);
    //g_QaternionPool.Free(q2);
    //g_VectorPool.Free(pos3);
    //g_QaternionPool.Free(q3);
    return bResult;
}
//-----------------------------------------------------------------------------
// Purpose: Find and decode a sub-frame of animation
//-----------------------------------------------------------------------------
function CalcAnimation2(dynamicProp, pStudioHdr, pos, q, boneFlags, seqdesc, sequence, animation, cycle, boneMask) {
    /*virtualmodel_t *pVModel = pStudioHdr->GetVirtualModel();TODOV2
    if (pVModel)
    {
        CalcVirtualAnimation(pVModel, pStudioHdr, pos, q, seqdesc, sequence, animation, cycle, boneMask);
        return;
    }*/
    const animdesc = pStudioHdr.getAnimDescription(animation);
    if (!animdesc) {
        return;
    }
    pStudioHdr.getBone(0);
    //const mstudiolinearbone_t *pLinearBones = pStudioHdr->pLinearBones();TODOV2
    let pLinearBones;
    const fFrame = cycle * (animdesc.numframes - 1);
    const iFrame = Math.floor(fFrame);
    const s = (fFrame - iFrame);
    //iFrame = 0;
    //console.log(pStudioHdr.getAnimFrame(animdesc, iFrame));
    pStudioHdr.getAnimFrame(dynamicProp, animdesc, iFrame);
    //console.log(iFrame);
    let iLocalFrame = iFrame;
    const panims = animdesc.pAnim(iLocalFrame /*, flStall*/);
    //animdesc.mdl.getAnimFrame(animdesc, 31);
    //const pweight = seqdesc.pBoneweight(0);
    // if the animation isn't available, look for the zero frame cache
    if (!panims) {
        for (let i = 0, boneCount = pStudioHdr.getBoneCount(); i < boneCount; ++i) {
            const pbone = pStudioHdr.getBone(i);
            const pweight = seqdesc.pBoneweight(i);
            if (pweight && pweight > 0 && (pStudioHdr.boneFlags(i) & boneMask)) {
                if (animdesc.flags & STUDIO_DELTA) {
                    q[i] = quat.create(); //TODOV2
                    pos[i] = vec3.create(); //TODOV2
                }
                else {
                    //q[i] = pbone.rot;TODOv2
                    //q[i] = q[i] || quat.create();
                    //pos[i] = pos[i] || vec3.create();
                    q[i] = quat.create();
                    pos[i] = vec3.create();
                    //quat.fromMat3(q[i], mat3.fromEuler(SourceEngineTempMat3, pbone.rot));
                    if (pbone && q[i] && pos[i]) {
                        quatFromEulerRad(q[i], pbone.rot[0], pbone.rot[1], pbone.rot[2]);
                        vec3.copy(pos[i], pbone.position);
                    }
                }
            }
        }
        //CalcZeroframeData(pStudioHdr, pStudioHdr->GetRenderHdr(), NULL, pStudioHdr->pBone(0), animdesc, fFrame, pos, q, boneMask, 1.0);
        pStudioHdr.getBone(0);
        return;
    }
    // BUGBUG: the sequence, the anim, and the model can have all different bone mappings.
    //for (i = 0; i < pStudioHdr->numbones(); i++, pbone++, pweight++)
    let panim = panims[0];
    for (let i = 0, boneCount = pStudioHdr.getBoneCount(), animIndex = 0; i < boneCount; ++i) {
        const pbone = pStudioHdr.getBone(i);
        const pweight = seqdesc.pBoneweight(i);
        q[i] = q[i] || quat.create(); //TODOV2
        pos[i] = pos[i] || vec3.create(); //TODOV2
        q[i] = quat.create();
        pos[i] = vec3.create();
        if (panim && panim.bone == i) {
            boneFlags[i] = panim.flags;
            //if (pweight > 0 && (pStudioHdr.boneFlags(i) & boneMask))
            if (pweight && pweight > 0) //TODOv2
             {
                if (animdesc.sectionframes != 0) {
                    iLocalFrame = iLocalFrame % animdesc.sectionframes;
                }
                if (pbone) {
                    CalcBoneQuaternion2(pStudioHdr, iLocalFrame, s, pbone, pLinearBones, panim, q[i]);
                    CalcBonePosition2(pStudioHdr, iLocalFrame, s, pbone, pLinearBones, panim, pos[i]);
                }
                //quat.copy(q[i], pbone.quaternion);
                //vec3.copy(pos[i], pbone.position);
            }
            //panim = panim->pNext();//TODOv2
            panim = panims[++animIndex];
            //} else if (pweight > 0 && (pStudioHdr.boneFlags(i) & boneMask)) {
        }
        else if (pweight && pweight > 0) {
            if (animdesc.flags & STUDIO_DELTA) {
                boneFlags[i] = STUDIO_ANIM_DELTA;
                q[i] = quat.create(); //TODOV2
                pos[i] = vec3.create(); //TODOV2
            }
            else {
                boneFlags[i] = 0;
                if (pbone && q[i] && pos[i]) {
                    quat.copy(q[i], pbone.quaternion);
                    vec3.copy(pos[i], pbone.position);
                }
            }
        }
        else {
            boneFlags[i] = STUDIO_ANIM_DELTA;
        }
    }
    // cross fade in previous zeroframe data
    /*
    if (flStall > 0.0) {
        CalcZeroframeData2(pStudioHdr, pStudioHdr, null, pStudioHdr.getBone(0), animdesc, fFrame, pos, q, boneMask, flStall);
    }
    */
    //console.error(animdesc.numlocalhierarchy);
    /*
    if (false && animdesc.numlocalhierarchy) {//TODOv2
        const boneToWorld = mat4.create();//TODOv2
        let boneComputed;

        for (let i = 0; i < animdesc.numlocalhierarchy; ++i) {
            const pHierarchy = animdesc.pHierarchy(i);

            if (!pHierarchy) {
                break;
            }
            /*

            if (pStudioHdr.boneFlags(pHierarchy.iBone) & boneMask) {
                if (pStudioHdr.boneFlags(pHierarchy.iNewParent) & boneMask) {
                    CalcLocalHierarchyAnimation(pStudioHdr, boneToWorld, boneComputed, pos, q, pbone, pHierarchy, pHierarchy.iBone, pHierarchy.iNewParent, cycle, iFrame, s, boneMask);
                }
            }
                * /

        }

        //g_MatrixPool.Free(boneToWorld);TODOv2
    }
    */
}
//-----------------------------------------------------------------------------
// Purpose: return a sub frame rotation for a single bone
//-----------------------------------------------------------------------------
/*void CalcBoneQuaternion(int frame, float s,
                        const Quaternion &baseQuat, const RadianEuler &baseRot, const Vector &baseRotScale,
                        int iBaseFlags, const Quaternion &baseAlignment,
                        const mstudioanim_t *panim, Quaternion &q)*/
function _CalcBoneQuaternion2(pStudioHdr, frame, s, baseQuat, baseRot, baseRotScale, iBaseFlags, baseAlignment, panim, q) {
    if (panim.flags & STUDIO_ANIM_RAWROT) {
        //q = panim.pQuat48();
        quat.copy(q, panim.rawrot); //TODOv2
        return;
    }
    if (panim.flags & STUDIO_ANIM_RAWROT2) {
        //q = panim.pQuat64();
        quat.copy(q, panim.rawrot2); //TODOv2
        q[0] = panim.rawrot2[2];
        q[1] = panim.rawrot2[1];
        q[2] = panim.rawrot2[0];
        q[3] = panim.rawrot2[3];
        return;
    }
    if (!(panim.flags & STUDIO_ANIM_ANIMROT)) {
        if (panim.flags & STUDIO_ANIM_DELTA) {
            quat.identity(q);
        }
        else {
            quat.copy(q, baseQuat); //TODOv2
        }
        return;
    }
    panim.animValuePtrRot;
    if (s > 0.001) {
        const angle1 = vec3.create(), angle2 = vec3.create(); // TODO: optimize
        const q1 = quat.create();
        const q2 = quat.create();
        for (let i = 0; i < 3; ++i) {
            const offset = panim.animValuePtrRot.offset[i];
            if (offset) {
                angle1[i] = panim.readValue(pStudioHdr, frame, panim.animValuePtrRot.base + offset /*, panim.bone, i*/) * baseRotScale[i];
                angle2[i] = angle1[i];
            }
        }
        if (!(panim.flags & STUDIO_ANIM_DELTA)) {
            angle1[0] = angle1[0] + baseRot[0];
            angle1[1] = angle1[1] + baseRot[1];
            angle1[2] = angle1[2] + baseRot[2];
            angle2[0] = angle2[0] + baseRot[0];
            angle2[1] = angle2[1] + baseRot[1];
            angle2[2] = angle2[2] + baseRot[2];
        }
        if (angle1[0] !== angle2[0] || angle1[1] !== angle2[1] || angle1[2] !== angle2[2]) {
            //_AngleQuaternion(angle1, q1);//TODOv2
            //_AngleQuaternion(angle2, q2);//TODOv2
            quatFromEulerRad(q1, angle1[0], angle1[1], angle1[2]);
            quatFromEulerRad(q2, angle2[0], angle2[1], angle2[2]);
            QuaternionBlend(q1, q2, s, q);
        }
        else {
            //_AngleQuaternion(angle1, q);//TODOv2
            //quat.fromMat3(q, mat3.fromEuler(SourceEngineTempMat3, angle1));
            quatFromEulerRad(q, angle1[0], angle1[1], angle1[2]);
        }
    }
    else {
        const angle = vec3.create();
        for (let i = 0; i < 3; ++i) {
            const offset = panim.animValuePtrRot.offset[i];
            if (offset) {
                angle[i] = panim.readValue(pStudioHdr, frame, panim.animValuePtrRot.base + offset /*, panim.bone, i*/) * baseRotScale[i];
            }
        }
        if (!(panim.flags & STUDIO_ANIM_DELTA)) {
            angle[0] = angle[0] + baseRot[0];
            angle[1] = angle[1] + baseRot[1];
            angle[2] = angle[2] + baseRot[2];
        }
        //_AngleQuaternion(angle, q);//TODOv2
        //quat.fromMat3(q, mat3.fromEuler(SourceEngineTempMat3, angle));
        quatFromEulerRad(q, angle[0], angle[1], angle[2]);
    }
    // align to unified bone
    if (!(panim.flags & STUDIO_ANIM_DELTA) && (iBaseFlags & BONE_FIXED_ALIGNMENT)) {
        QuaternionAlign(baseAlignment, q, q);
    }
}
function CalcBoneQuaternion2(pStudioHdr, frame, s, pBone, pLinearBones, panim, q) {
    {
        _CalcBoneQuaternion2(pStudioHdr, frame, s, pBone.quaternion, pBone.rot, pBone.rotscale, pBone.flags, pBone.qAlignment, panim, q);
        //_CalcBoneQuaternion(pStudioHdr, frame, s, pBone.quat, [0, 0, 0]/*pBone.rot*//*TODOV2*/, pBone.rotscale, pBone.flags, pBone.qAlignment, panim, q);
    }
}
function _CalcBonePosition2(pStudioHdr, frame, s, basePos, baseBoneScale, panim, pos) {
    if (panim.flags & STUDIO_ANIM_RAWPOS) {
        vec3.copy(pos, panim.rawpos);
        return;
    }
    else if (!(panim.flags & STUDIO_ANIM_ANIMPOS)) {
        if (panim.flags & STUDIO_ANIM_DELTA) {
            vec3.zero(pos);
        }
        else {
            vec3.copy(pos, basePos);
        }
        return;
    }
    panim.animValuePtrPos;
    /*
        mstudioanim_valueptr_t *pPosV = panim.pPosV();
        int					j;
    */
    if (s > 0.001) {
        let v1, v2; // TODO: optimize
        for (let i = 0; i < 3; i++) {
            const offset = panim.animValuePtrPos.offset[i];
            if (offset) {
                //ExtractAnimValue(frame, pPosV->pAnimvalue(i), baseBoneScale[i], v1, v2);
                v1 = panim.readValue(pStudioHdr, frame, panim.animValuePtrPos.base + offset /*, panim.bone, i*/) * baseBoneScale[i];
                v2 = v1;
                pos[i] = v1 * (1.0 - s) + v2 * s;
            }
        }
    }
    else {
        for (let i = 0; i < 3; i++) {
            //ExtractAnimValue(frame, pPosV->pAnimvalue(i), baseBoneScale[i], pos[i]);
            const offset = panim.animValuePtrPos.offset[i];
            if (offset) {
                //ExtractAnimValue(frame, pPosV->pAnimvalue(i), baseBoneScale[i], v1, v2);
                pos[i] = panim.readValue(pStudioHdr, frame, panim.animValuePtrPos.base + offset /*, panim.bone, i*/) * baseBoneScale[i];
            }
        }
    }
    if (!(panim.flags & STUDIO_ANIM_DELTA)) {
        pos[0] = pos[0] + basePos[0];
        pos[1] = pos[1] + basePos[1];
        pos[2] = pos[2] + basePos[2];
    }
}
function CalcBonePosition2(pStudioHdr, frame, s, pBone, pLinearBones, panim, pos) {
    if (pLinearBones) ;
    else {
        _CalcBonePosition2(pStudioHdr, frame, s, pBone.position, pBone.posscale, panim, pos);
    }
}
function PoseIsAllZeros2(pStudioHdr, sequence, seqdesc, i0, i1) {
    // remove 'zero' positional blends
    //const baseanim = pStudioHdr.iRelativeAnim(sequence, seqdesc.getBlend(i0 , i1));//TODOv2
    const baseanim = seqdesc.getBlend(i0, i1);
    const anim = pStudioHdr.getAnimDescription(baseanim);
    if (!anim) {
        return false;
    }
    return (anim.flags & STUDIO_ALLZEROS) != 0;
}
//-----------------------------------------------------------------------------
// Purpose: turn a 2x2 blend into a 3 way triangle blend
// Returns: returns the animination indices and barycentric coordinates of a triangle
//			the triangle is a right triangle, and the diagonal is between elements [0] and [2]
//-----------------------------------------------------------------------------
//void Calc3WayBlendIndices(int i0, int i1, float s0, float s1, const mstudioseqdesc_t &seqdesc, int *pAnimIndices, float *pWeight)
function Calc3WayBlendIndices2(i0, i1, s0, s1, seqdesc, pAnimIndices, pWeight) {
    // Figure out which bi-section direction we are using to make triangles.
    const bEven = (((i0 + i1) & 0x1) == 0);
    let x1, y1;
    let x2, y2;
    let x3, y3;
    // diagonal is between elements 1 & 3
    // TL to BR
    if (bEven) {
        if (s0 > s1) {
            // B
            x1 = 0;
            y1 = 0;
            x2 = 1;
            y2 = 0;
            x3 = 1;
            y3 = 1;
            pWeight[0] = (1.0 - s0);
            pWeight[1] = s0 - s1;
        }
        else {
            // C
            x1 = 1;
            y1 = 1;
            x2 = 0;
            y2 = 1;
            x3 = 0;
            y3 = 0;
            pWeight[0] = s0;
            pWeight[1] = s1 - s0;
        }
    }
    // BL to TR
    else {
        const flTotal = s0 + s1;
        if (flTotal > 1.0) {
            // D
            x1 = 1;
            y1 = 0;
            x2 = 1;
            y2 = 1;
            x3 = 0;
            y3 = 1;
            pWeight[0] = (1.0 - s1);
            pWeight[1] = s0 - 1.0 + s1;
        }
        else {
            // A
            x1 = 0;
            y1 = 1;
            x2 = 0;
            y2 = 0;
            x3 = 1;
            y3 = 0;
            pWeight[0] = s1;
            pWeight[1] = 1.0 - s0 - s1;
        }
    }
    pAnimIndices[0] = seqdesc.getBlend(i0 + x1, i1 + y1) ?? 0;
    pAnimIndices[1] = seqdesc.getBlend(i0 + x2, i1 + y2) ?? 0;
    pAnimIndices[2] = seqdesc.getBlend(i0 + x3, i1 + y3) ?? 0;
    // clamp the diagonal
    if (pWeight[1] < 0.001)
        pWeight[1] = 0.0;
    pWeight[2] = 1.0 - pWeight[0] - pWeight[1];
    //Assert(pWeight[0] >= 0.0 && pWeight[0] <= 1.0);
    //Assert(pWeight[1] >= 0.0 && pWeight[1] <= 1.0);
    //Assert(pWeight[2] >= 0.0 && pWeight[2] <= 1.0);
}
//-----------------------------------------------------------------------------
// Purpose: calculate a pose for a single sequence //TODOv2
//			adds autolayers, runs local ik rukes
//-----------------------------------------------------------------------------
const AddSequenceLayers2 = function (dynamicProp, pStudioHdr, pIKContext, pos, q, boneFlags, seqdesc, sequence, cycle, poseParameters, boneMask, flWeight, flTime) {
    //return;
    for (let i = 0; i < seqdesc.numautolayers; ++i) {
        const pLayer = seqdesc.getAutoLayer(i);
        if (!pLayer) {
            continue;
        }
        if (pLayer.flags & STUDIO_AL_LOCAL) {
            continue;
        }
        let layerCycle = cycle;
        if (pLayer.start != pLayer.end) {
            let index;
            if (!(pLayer.flags & STUDIO_AL_POSE)) {
                index = cycle;
            }
            else {
                //TODOv2
                pLayer.iSequence; //int iSequence = pStudioHdr.iRelativeSeq(sequence, pLayer.iSequence);
                //const iPose = pStudioHdr.GetSharedPoseParameter(iSequence, pLayer.iPose);
                const iPose = pLayer.iPose;
                if (iPose != -1) {
                    //const Pose = pStudioHdr.pPoseParameter(iPose);
                    const Pose = pStudioHdr.getLocalPoseParameter(iPose);
                    if (Pose) {
                        index = (poseParameters.get(String(iPose)) ?? 1) * (Pose.end - Pose.start) + Pose.start;
                    }
                    else {
                        index = 0;
                    }
                }
                else {
                    index = 0;
                }
            }
            if (index < pLayer.start) {
                continue;
            }
            if (index >= pLayer.end) {
                continue;
            }
            if (index < pLayer.peak && pLayer.start != pLayer.peak) {
                (index - pLayer.start) / (pLayer.peak - pLayer.start);
            }
            else if (index > pLayer.tail && pLayer.end != pLayer.tail) {
                (pLayer.end - index) / (pLayer.end - pLayer.tail);
            }
            if (pLayer.flags & STUDIO_AL_SPLINE) ;
            if ((pLayer.flags & STUDIO_AL_XFADE) && (index > pLayer.tail)) ;
            else if (pLayer.flags & STUDIO_AL_NOBLEND) ;
            else ;
            if (!(pLayer.flags & STUDIO_AL_POSE)) {
                layerCycle = (cycle - pLayer.start) / (pLayer.end - pLayer.start);
            }
        }
        //const iSequence = pStudioHdr.iRelativeSeq(sequence, pLayer.iSequence);//TODOV2
        const iSequence = pLayer.iSequence; //pStudioHdr.getSequenceById(pLayer.iSequence);
        AccumulatePose2(dynamicProp, pStudioHdr, pIKContext, pos, q, boneFlags, iSequence, layerCycle, poseParameters);
    }
};
//-----------------------------------------------------------------------------
// Purpose: accumulate a pose for a single sequence on top of existing animation
//			adds autolayers, runs local ik rukes
//-----------------------------------------------------------------------------
const AccumulatePose_pos2 = Array(SOURCE_MODEL_MAX_BONES);
const AccumulatePose_q2 = Array(SOURCE_MODEL_MAX_BONES);
for (let i = 0; i < SOURCE_MODEL_MAX_BONES; i++) {
    AccumulatePose_pos2[i] = vec3.create();
    AccumulatePose_q2[i] = quat.create();
}
function AccumulatePose2(dynamicProp, pStudioHdr, pIKContext, pos, q, boneFlags, sequence, cycle, poseParameters, boneMask, flWeight, flTime) {
    //const pos2 = [];
    //const q2 = [];
    const pos2 = AccumulatePose_pos2;
    const q2 = AccumulatePose_q2;
    if (sequence < 0) {
        return;
    }
    const seqdesc = pStudioHdr.getSequenceById(sequence);
    if (!seqdesc) {
        return;
    }
    if (seqdesc.numiklocks) ;
    if (seqdesc.flags & STUDIO_LOCAL) {
        InitPose2(dynamicProp, pStudioHdr, pos2, q2);
    }
    /*
    if (CalcPoseSingle(dynamicProp, pStudioHdr, pos2, q2, boneFlags, seqdesc, sequence, cycle, poseParameters, boneMask, flTime)) {
        // this weight is wrong, the IK rules won't composite at the correct intensity
        AddLocalLayers(dynamicProp, pStudioHdr, pIKContext, pos2, q2, boneFlags, seqdesc, sequence, cycle, poseParameters, boneMask, 1.0, flTime);
        SlerpBones(pStudioHdr, q, pos, seqdesc, sequence, q2, pos2, flWeight, boneMask);
    }
    */
    /*
    if (pIKContext) {
        // TODO: activate
        pIKContext.AddDependencies(seqdesc, sequence, cycle, poseParameters, flWeight);
    }
    */
    AddSequenceLayers2(dynamicProp, pStudioHdr, pIKContext, pos, q, boneFlags, seqdesc, sequence, cycle, poseParameters);
    if (seqdesc.numiklocks) ;
}
//-----------------------------------------------------------------------------
// Purpose: Inter-animation blend.	Assumes both types are identical.
//			blend together q1,pos1 with q2,pos2.	Return result in q1,pos1.
//			0 returns q1, pos1.	1 returns q2, pos2
//-----------------------------------------------------------------------------
/*void BlendBones(
    const CStudioHdr *pStudioHdr,
    Quaternion q1[MAXSTUDIOBONES],
    Vector pos1[MAXSTUDIOBONES],
    mstudioseqdesc_t &seqdesc,
    int sequence,
    const Quaternion q2[MAXSTUDIOBONES],
    const Vector pos2[MAXSTUDIOBONES],
    float s,
    int boneMask)*/
function BlendBones2(pStudioHdr, q1, pos1, seqdesc, sequence, q2, pos2, s, boneMask) {
    const q3 = quat.create();
    /*virtualmodel_t *pVModel = pStudioHdr.GetVirtualModel();TODO
    const virtualgroup_t *pSeqGroup = NULL;
    if (pVModel)
    {
        pSeqGroup = pVModel.pSeqGroup(sequence);
    }*/
    if (s <= 0) {
        //Assert(0); // shouldn't have been called
        return;
    }
    else if (s >= 1.0) {
        //Assert(0); // shouldn't have been called
        for (let i = 0, boneCount = pStudioHdr.getBoneCount(); i < boneCount; ++i) {
            let j;
            // skip unused bones
            if (!(pStudioHdr.boneFlags(i) & boneMask)) {
                continue;
            }
            /* TODO: activate
            if (pSeqGroup) {
                j = pSeqGroup.boneMap[i];
            }
            */
            else {
                j = i;
            }
            if (j >= 0 && (seqdesc.pBoneweight(j) ?? 0) > 0.0 && q2[i] && pos2[i]) {
                q1[i] = q2[i];
                pos1[i] = pos2[i];
            }
        }
        return;
    }
    const s2 = s;
    const s1 = 1.0 - s2;
    for (let i = 0, boneCount = pStudioHdr.getBoneCount(); i < boneCount; ++i) {
        let j;
        // skip unused bones
        q1[i] = q1[i] || quat.create();
        pos1[i] = pos1[i] || vec3.create();
        q2[i] = q2[i] || quat.create();
        pos2[i] = pos2[i] || vec3.create();
        if (!(pStudioHdr.boneFlags(i) & boneMask)) {
            continue;
        }
        /* TODO: activate
        if (pSeqGroup) {
            j = pSeqGroup.boneMap[i];
        }
        */
        else {
            j = i;
        }
        if (j >= 0 && (seqdesc.pBoneweight(j) ?? 0) > 0.0 && q2[i] && q1[i] && pos1[i] && pos2[i]) {
            if (pStudioHdr.boneFlags(i) & BONE_FIXED_ALIGNMENT) {
                QuaternionBlendNoAlign(q2[i], q1[i], s1, q3);
            }
            else {
                QuaternionBlend(q2[i], q1[i], s1, q3);
            }
            q1[i][0] = q3[0];
            q1[i][1] = q3[1];
            q1[i][2] = q3[2];
            q1[i][3] = q3[3];
            pos1[i][0] = pos1[i][0] * s1 + pos2[i][0] * s2;
            pos1[i][1] = pos1[i][1] * s1 + pos2[i][1] * s2;
            pos1[i][2] = pos1[i][2] * s1 + pos2[i][2] * s2;
        }
    }
}
//-----------------------------------------------------------------------------
// Purpose: resolve a global pose parameter to the specific setting for this sequence
//-----------------------------------------------------------------------------
//void Studio_LocalPoseParameter(const CStudioHdr *pStudioHdr, const float poseParameters[], mstudioseqdesc_t &seqdesc, int iSequence, int iLocalIndex, float &flSetting, int &index)
function Studio_LocalPoseParameter2(pStudioHdr, poseParameters, seqdesc, iSequence, iLocalIndex /*, flSetting, index*/) {
    let flSetting = 0;
    let index = 0;
    //const iPose = pStudioHdr.GetSharedPoseParameter(iSequence, seqdesc.paramindex[iLocalIndex]);
    const iPose = seqdesc.paramindex[iLocalIndex] ?? -1;
    if (iPose == -1) {
        return { s: 0, i: 0 };
    }
    const Pose = pStudioHdr.getLocalPoseParameter(iPose);
    if (!Pose) {
        return { s: 0, i: 0 };
    }
    //const flValue = poseParameters[iPose];
    let flValue = Pose.midpoint;
    const poseParameter = poseParameters.get(Pose.name);
    if (poseParameter !== undefined) {
        flValue = poseParameter;
    }
    if (Pose.loop) {
        const wrap = (Pose.start + Pose.end) / 2.0 + Pose.loop / 2.0;
        const shift = Pose.loop - wrap;
        flValue = flValue - Pose.loop * Math.floor((flValue + shift) / Pose.loop);
    }
    const paramStart = seqdesc.paramstart[iLocalIndex];
    const paramEnd = seqdesc.paramend[iLocalIndex];
    const groupSize = seqdesc.groupsize[iLocalIndex];
    if (paramStart === undefined || paramEnd === undefined || groupSize === undefined) {
        return { s: 0, i: 0 };
    }
    if (seqdesc.posekeyindex == 0) {
        const flLocalStart = (paramStart - Pose.start) / (Pose.end - Pose.start);
        const flLocalEnd = (paramEnd - Pose.start) / (Pose.end - Pose.start);
        // convert into local range
        flSetting = (flValue - flLocalStart) / (flLocalEnd - flLocalStart);
        // clamp.	This shouldn't ever need to happen if it's looping.
        if (flSetting < 0)
            flSetting = 0;
        if (flSetting > 1)
            flSetting = 1;
        index = 0;
        if (groupSize > 2) {
            // estimate index
            index = Math.round(flSetting * (groupSize - 1));
            if (index == groupSize - 1)
                index = groupSize - 2;
            flSetting = flSetting * (groupSize - 1) - index;
        }
    }
    else {
        flValue = flValue * (Pose.end - Pose.start) + Pose.start;
        index = 0;
        // FIXME: this needs to be 2D
        // FIXME: this shouldn't be a linear search
        while (1) {
            flSetting = (flValue - seqdesc.poseKey(iLocalIndex, index)) / (seqdesc.poseKey(iLocalIndex, index + 1) - seqdesc.poseKey(iLocalIndex, index));
            //flSetting = 0;//TODOV2
            /*
            if (index > 0 && flSetting < 0.0)
            {
                index--;
                continue;
            }
            else
            */
            if (index < groupSize - 2 && flSetting > 1.0) {
                index++;
                continue;
            }
            break;
        }
        // clamp.
        if (flSetting < 0.0)
            flSetting = 0.0;
        if (flSetting > 1.0)
            flSetting = 1.0;
    }
    return { s: flSetting, i: index };
}
function ScaleBones2(pStudioHdr, //const CStudioHdr *pStudioHdr,
q1, //Quaternion q1[MAXSTUDIOBONES],
pos1, //Vector pos1[MAXSTUDIOBONES],
sequence, //int sequence,
s, //float s,
boneMask //int boneMask
) {
    let i, j = -1; //int			i, j;
    const seqdesc = pStudioHdr.getSequenceById(sequence); //mstudioseqdesc_t & seqdesc = ((CStudioHdr *)pStudioHdr) -> pSeqdesc(sequence);
    if (!seqdesc) {
        return;
    }
    /*
    virtualmodel_t * pVModel = pStudioHdr -> GetVirtualModel();
    const virtualgroup_t * pSeqGroup = NULL;
    if (pVModel) {
        pSeqGroup = pVModel -> pSeqGroup(sequence);
    }
        */
    const s2 = s;
    const s1 = 1.0 - s2;
    for (i = 0; i < pStudioHdr.getBoneCount(); i++) {
        if (!q1[i] || !pos1[i]) {
            continue;
        }
        // skip unused bones
        if (!(pStudioHdr.boneFlags(i) & boneMask)) {
            continue;
        }
        {
            j = i;
        }
        if (j >= 0 && (seqdesc.pBoneweight(j) ?? -1) > 0.0) {
            QuaternionIdentityBlend(q1[i], s1, q1[i]);
            //VectorScale(pos1[i], s2, pos1[i]);
            vec3.scale(pos1[i], pos1[i], s2);
        }
    }
}
//-----------------------------------------------------------------------------
// Purpose: translate animations done in a non-standard parent space
//-----------------------------------------------------------------------------
/*
function CalcLocalHierarchyAnimation(
    pStudioHdr,//const CStudioHdr * pStudioHdr,
    boneToWorld: mat4,//matrix3x4_t * boneToWorld,
    boneComputed,//CBoneBitList & boneComputed,
    pos,//Vector * pos,
    q,//Quaternion * q,
    //const mstudioanimdesc_t &animdesc,
    pbone,//const mstudiobone_t * pbone,
    pHierarchy,//mstudiolocalhierarchy_t * pHierarchy,
    iBone: number,//int iBone,
    iNewParent: number,//int iNewParent,
    cycle: number,//float cycle,
    iFrame: number,//int iFrame,
    flFraq: number,//float flFraq,
    boneMask: number,//int boneMask
): void {

    let localPos = vec3.create();//Vector localPos;
    let localQ = quat.create();//Quaternion localQ;

    // make fake root transform
    //static ALIGN16 matrix3x4_t rootXform ALIGN16_POST(1.0f, 0, 0, 0, 0, 1.0f, 0, 0, 0, 0, 1.0f, 0);
    let rootXform = mat4.create();

    // FIXME: missing check to see if seq has a weight for this bone
    //float weight = 1.0f;
    let weight = 1;

    // check to see if there's a ramp on the influence
    if (pHierarchy -> tail - pHierarchy -> peak < 1.0f  )
    {
        float index = cycle;

        if (pHierarchy -> end > 1.0f && index < pHierarchy -> start)
        index += 1.0f;

        if (index < pHierarchy -> start)
            return;
        if (index >= pHierarchy -> end)
            return;

        if (index < pHierarchy -> peak && pHierarchy -> start != pHierarchy -> peak) {
            weight = (index - pHierarchy -> start) / (pHierarchy -> peak - pHierarchy -> start);
        }
        else if (index > pHierarchy -> tail && pHierarchy -> end != pHierarchy -> tail) {
            weight = (pHierarchy -> end - index) / (pHierarchy -> end - pHierarchy -> tail);
        }

        weight = SimpleSpline(weight);
    }

    CalcDecompressedAnimation(pHierarchy -> pLocalAnim(), iFrame - pHierarchy -> iStart, flFraq, localPos, localQ);

    BuildBoneChain(pStudioHdr, rootXform, pos, q, iBone, boneToWorld, boneComputed);

    matrix3x4_t localXform;
    AngleMatrix(localQ, localPos, localXform);

    if (iNewParent != -1) {
        BuildBoneChain(pStudioHdr, rootXform, pos, q, iNewParent, boneToWorld, boneComputed);
        ConcatTransforms(boneToWorld[iNewParent], localXform, boneToWorld[iBone]);
    }
    else {
        boneToWorld[iBone] = localXform;
    }

    // back solve
    Vector p1;
    Quaternion q1;
    int n = pbone[iBone].parent;
    if (n == -1) {
        if (weight == 1.0f)
        {
            MatrixAngles(boneToWorld[iBone], q[iBone], pos[iBone]);
        }
        else
        {
            MatrixAngles(boneToWorld[iBone], q1, p1);
            QuaternionSlerp(q[iBone], q1, weight, q[iBone]);
            pos[iBone] = Lerp(weight, p1, pos[iBone]);
        }
    }
    else {
        matrix3x4_t worldToBone;
        MatrixInvert(boneToWorld[n], worldToBone);

        matrix3x4_t local;
        ConcatTransforms(worldToBone, boneToWorld[iBone], local);
        if (weight == 1.0f)
        {
            MatrixAngles(local, q[iBone], pos[iBone]);
        }
        else
        {
            MatrixAngles(local, q1, p1);
            QuaternionSlerp(q[iBone], q1, weight, q[iBone]);
            pos[iBone] = Lerp(weight, p1, pos[iBone]);
        }
    }
}
    */
//-----------------------------------------------------------------------------
// Purpose: blend together in world space q1,pos1 with q2,pos2.  Return result in q1,pos1.
//			0 returns q1, pos1.  1 returns q2, pos2
//-----------------------------------------------------------------------------
/*
function WorldSpaceSlerp(
    pStudioHdr,//const CStudioHdr *pStudioHdr,
    q1: Array<quat>,//Quaternion q1[MAXSTUDIOBONES],
    pos1: Array<vec3>,//Vector pos1[MAXSTUDIOBONES],
    seqdesc,//mstudioseqdesc_t &seqdesc,
    sequence: number,//int sequence,
    q2: Array<quat>,//const Quaternion q2[MAXSTUDIOBONES],
    pos2: Array<vec3>,//const Vector pos2[MAXSTUDIOBONES],
    s: number,//float s,
    boneMask: number//int boneMask
): void {
    int			i, j;
    float		s1; // weight of parent for q2, pos2
    float		s2; // weight for q2, pos2

    // make fake root transform
    matrix3x4_t rootXform;
    SetIdentityMatrix(rootXform);

    // matrices for q2, pos2
    matrix3x4_t * srcBoneToWorld = g_MatrixPool.Alloc();
    CBoneBitList srcBoneComputed;

    matrix3x4_t * destBoneToWorld = g_MatrixPool.Alloc();
    CBoneBitList destBoneComputed;

    matrix3x4_t * targetBoneToWorld = g_MatrixPool.Alloc();
    CBoneBitList targetBoneComputed;

    virtualmodel_t * pVModel = pStudioHdr -> GetVirtualModel();
    const virtualgroup_t * pSeqGroup = NULL;
    if (pVModel) {
        pSeqGroup = pVModel -> pSeqGroup(sequence);
    }

    mstudiobone_t * pbone = pStudioHdr -> pBone(0);

    for (i = 0; i < pStudioHdr -> numbones(); i++) {
        // skip unused bones
        if (!(pStudioHdr -> boneFlags(i) & boneMask)) {
            continue;
        }

        int n = pbone[i].parent;
        s1 = 0.0;
        if (pSeqGroup) {
            j = pSeqGroup -> boneMap[i];
            if (j >= 0) {
                s2 = s * seqdesc.weight(j);	// blend in based on this bones weight
                if (n != -1) {
                    s1 = s * seqdesc.weight(pSeqGroup -> boneMap[n]);
                }
            }
            else {
                s2 = 0.0;
            }
        }
        else {
            s2 = s * seqdesc.weight(i);	// blend in based on this bones weight
            if (n != -1) {
                s1 = s * seqdesc.weight(n);
            }
        }

        if (s1 == 1.0 && s2 == 1.0) {
            pos1[i] = pos2[i];
            q1[i] = q2[i];
        }
        else if (s2 > 0.0) {
            Quaternion srcQ, destQ;
            Vector srcPos, destPos;
            Quaternion targetQ;
            Vector targetPos;
            Vector tmp;

            BuildBoneChain(pStudioHdr, rootXform, pos1, q1, i, destBoneToWorld, destBoneComputed);
            BuildBoneChain(pStudioHdr, rootXform, pos2, q2, i, srcBoneToWorld, srcBoneComputed);

            MatrixAngles(destBoneToWorld[i], destQ, destPos);
            MatrixAngles(srcBoneToWorld[i], srcQ, srcPos);

            QuaternionSlerp(destQ, srcQ, s2, targetQ);
            AngleMatrix(targetQ, destPos, targetBoneToWorld[i]);

            // back solve
            if (n == -1) {
                MatrixAngles(targetBoneToWorld[i], q1[i], tmp);
            }
            else {
                matrix3x4_t worldToBone;
                MatrixInvert(targetBoneToWorld[n], worldToBone);

                matrix3x4_t local;
                ConcatTransforms(worldToBone, targetBoneToWorld[i], local);
                MatrixAngles(local, q1[i], tmp);

                // blend bone lengths (local space)
                pos1[i] = Lerp(s2, pos1[i], pos2[i]);
            }
        }
    }
    g_MatrixPool.Free(srcBoneToWorld);
    g_MatrixPool.Free(destBoneToWorld);
    g_MatrixPool.Free(targetBoneToWorld);
}
*/

class AnimationDescription {
    #animation;
    #weight;
    #frame = 0;
    constructor(animation, weight) {
        this.#animation = animation;
        this.#weight = weight;
    }
    set weight(weight) {
        this.#weight = weight;
    }
    get weight() {
        return this.#weight;
    }
    set frame(frame) {
        this.#frame = Math.floor(frame % this.#animation.frameCount);
    }
    get frame() {
        return this.#frame;
    }
    get name() {
        return this.#animation.name;
    }
    get animation() {
        return this.#animation;
    }
}

class Animations {
    #animations = new Map();
    [Symbol.iterator] = () => {
        return this.#animations.entries();
    };
    clear() {
        this.#animations.clear();
    }
    set(id, animation) {
        this.#animations.set(id, animation);
        this.#computeWeights();
    }
    remove(id) {
        this.#animations.delete(id);
        this.#computeWeights();
    }
    /*
    get animations(): AnimationDescription[] {
        return this.#animations;
    }
    */
    get(id) {
        return this.#animations.get(id) ?? null;
    }
    setWeight(id, weight) {
        const animation = this.#animations.get(id);
        if (!animation) {
            return false;
        }
        animation.weight = weight;
        this.#computeWeights();
        return true;
    }
    #computeWeights() {
        // do nothing.
    }
}

class Hitbox {
    name;
    boundingBoxMin = vec3.create();
    boundingBoxMax = vec3.create();
    parent;
    constructor(name, boundingBoxMin, boundingBoxMax, parent) {
        this.name = name;
        vec3.copy(this.boundingBoxMin, boundingBoxMin);
        vec3.copy(this.boundingBoxMax, boundingBoxMax);
        this.parent = parent;
    }
}

function getRandomInt(max) {
    return Math.floor(Math.random() * max);
}

class SourceAnimation {
    position = vec3.create();
    boneRot = vec3.create(); //TODO: remove me ?
    quaternion = quat.create(); //TODOv2
    tempPos = vec3.create();
    tempRot = vec3.create();
    animate2(dynamicProp, poseParameters, position /*TODO: remove param*/, orientation /*TODO: remove param*/, sequences /*, bonesScale*/) {
        const model = dynamicProp.sourceModel;
        if (!model) {
            return;
        }
        const modelBones = model.getBones();
        if (!modelBones) {
            return;
        }
        dynamicProp.parent;
        const posRemoveMeTemp = [];
        const quatRemoveMeTemp = [];
        const seqlist = Object.keys(sequences);
        let posRemoveMe; // = [];//optimize
        let quatRemoveMe; // = [];//optimize
        if (seqlist.length) {
            let s;
            while (s = seqlist.shift()) {
                const s2 = sequences[s]?.s;
                if (s2) {
                    const sequenceMdl = s2.mdl;
                    const t = Studio_Duration(sequenceMdl, s2.id, poseParameters);
                    //InitPose(dynamicProp, sequenceMdl, posRemoveMeTemp, quatRemoveMeTemp, BONE_USED_BY_ANYTHING);
                    CalcPose(dynamicProp, sequenceMdl, undefined, posRemoveMeTemp, quatRemoveMeTemp, [], s2.id, dynamicProp.frame / t, poseParameters, BONE_USED_BY_ANYTHING, 1.0, dynamicProp.frame / t);
                    if (sequenceMdl != model.mdl && sequenceMdl.boneNames) {
                        posRemoveMe = [];
                        quatRemoveMe = [];
                        const modelBoneArray = model.mdl.getBones();
                        for (let boneIndex = 0, l = modelBoneArray.length; boneIndex < l; ++boneIndex) {
                            const boneName = modelBoneArray[boneIndex].lowcasename;
                            const seqBoneId = sequenceMdl.boneNames.get(boneName);
                            if (seqBoneId !== undefined) {
                                posRemoveMe[boneIndex] = posRemoveMeTemp[seqBoneId];
                                quatRemoveMe[boneIndex] = quatRemoveMeTemp[seqBoneId];
                            }
                        }
                    }
                    else {
                        posRemoveMe = posRemoveMeTemp;
                        quatRemoveMe = quatRemoveMeTemp;
                    }
                }
            }
        }
        posRemoveMe = posRemoveMe || [];
        quatRemoveMe = quatRemoveMe || [];
        //const currentFrame = null;
        const seqList = Object.keys(sequences);
        const bonesRemoveMe = Object.create(null);
        for (let i = 0; i < seqList.length * 0; ++i) {
            const sequenceName = seqList[i];
            const seqContext = sequences[sequenceName];
            if (seqContext) {
                const sequence = seqContext.s;
                if (sequence) {
                    const sequenceBones = sequence.mdl.getBones();
                    if (sequenceBones) {
                        const g1 = Math.floor(sequence.groupsize[0] / 2);
                        const g2 = Math.floor(sequence.groupsize[1] / 2);
                        //g1 = g1RemoveMe;
                        //g2 = g2RemoveMe;
                        //g1 = 2;
                        const animIndex = sequence.getBlend(g1, g2); //TODOV2
                        if (!animIndex) {
                            continue;
                        }
                        sequence.mdl.getAnimDescription(animIndex);
                    }
                }
            }
        }
        Object.keys(bonesRemoveMe).forEach(function (boneName) {
            vec3.scale(bonesRemoveMe[boneName].pos, bonesRemoveMe[boneName].pos, 1 / bonesRemoveMe[boneName].count);
            vec3.scale(bonesRemoveMe[boneName].rot, bonesRemoveMe[boneName].rot, 1 / bonesRemoveMe[boneName].count);
            //vec3.scale(bonesRemoveMe[boneName].quat, bonesRemoveMe[boneName].quat, 1 / bonesRemoveMe[boneName].count);
            quat.normalize(bonesRemoveMe[boneName].quat, bonesRemoveMe[boneName].quat);
        });
        for (let i = 0, l = modelBones.length; i < l; ++i) {
            //let pbone = modelBones[i];
            //quatRemoveMeTemp[i] = quat.copy(quat.create(), pbone.quaternion);//removeme
            //posRemoveMeTemp[i] = vec3.copy(vec3.create(), pbone.position);
            const boneIndex = i;
            const bone = modelBones[i];
            vec3.zero(this.boneRot);
            vec3.zero(this.position);
            quat.identity(this.quaternion);
            const bonesRemoveMeMe = bonesRemoveMe[bone.name];
            if (bonesRemoveMeMe !== undefined) ;
            else {
                vec3.copy(this.position, bone.position);
                //vec3.copy(this.boneRot, bone.rot);
                //quat.fromMat3(this.quaternion, mat3.fromEuler(SourceEngineTempMat3, bone.rot));
                quatFromEulerRad(this.quaternion, bone.rot[0], bone.rot[1], bone.rot[2]);
            }
            //const q = quat.fromMat3(quat.create(), mat3.fromEuler(SourceEngineTempMat3, this.boneRot));
            const posRemoveMeMe = posRemoveMe[bone.boneId];
            const quatRemoveMeMe = quatRemoveMe[bone.boneId];
            //bone.boneQuat = this.boneQuat;
            //bone.position = this.position;
            bone.parent;
            bone.lowcasename;
            //const parentMergedBone = bone.parentMergedBone;
            const dynamicPropBones = dynamicProp.skeleton?._bones; //dynamicProp.bones;
            if (!dynamicPropBones) {
                return;
            }
            const dynamicPropBone = dynamicPropBones[boneIndex];
            if (dynamicPropBone === undefined) {
                //dynamicPropBone = {worldPos:vec3.create(), worldQuat:quat.create()};//TODO: optimize
                //dynamicPropBones[boneNameLowerCase] = dynamicPropBone;
                return;
            }
            //vec3.copy(dynamicPropBone.worldPos, bone.worldPos);
            //quat.copy(dynamicPropBone.worldQuat, bone.worldQuat);
            //dynamicProp.bones[boneNameLowerCase] = dynamicPropBones;
            /*
            if (bonesScale !== undefined) {
                const boneScale = bonesScale[bone.name];
                if (boneScale) {
                    mat4.scale(bone.boneMat, bone.boneMat, [boneScale, boneScale, boneScale]);
                }
            }
            */
            let b = dynamicPropBones[boneIndex];
            if (b) {
                if (!b.locked) {
                    b.quaternion = quatRemoveMeMe ?? b._initialQuaternion;
                    b.position = posRemoveMeMe ?? b._initialPosition;
                }
            }
            else {
                throw 'fix me';
                /*
                b = new Bone(dynamicProp.skeleton);
                dynamicProp.skeleton._bones[boneIndex] = b;
                b.boneId = bone.boneId;
                b.name = bone.name;
                b.quaternion = bone.quaternion;
                b.position = bone.position;
                b.parentBone = bone.parentBone;
                b.parent = dynamicProp.skeleton._bones[b.parentBone];
                b.poseToBone = bone.poseToBone;
                b.initPoseToBone = bone.initPoseToBone;
                */
            }
        }
        return;
    }
}

class FlexController {
    #controllers = {}; //TODO: turn into map
    #controllers2 = {}; //TODO: turn into map
    #controllerIndex = 0;
    getController(name, min, max) {
        if (!this.#controllers[name]) {
            this.#controllers2[this.#controllerIndex] = 0;
            this.#controllers[name] = { i: this.#controllerIndex++, min: min, max: max };
            /*
            if (typeof AddController !== 'undefined') {
                AddController(name, min, max);
            }
                */
            this.setControllerValue(name, 0);
        }
        return this.#controllers[name].i;
    }
    getControllers() {
        return this.#controllers;
    }
    getControllerValue(name) {
        const index = this.#controllers[name]?.i;
        if (index !== undefined) {
            return this.#controllers2[index];
        }
        return 0;
    }
    getControllerRealValue(name) {
        const controller = this.#controllers[name];
        if (controller) {
            const index = controller.i;
            return RemapValClamped(this.#controllers2[index], 0.0, 1.0, controller.min, controller.max);
        }
        return 0;
    }
    setControllerValue(name, value) {
        const controller = this.#controllers[name];
        if (controller !== undefined) {
            value = RemapValClamped(value, controller.min, controller.max, 0.0, 1.0);
            this.#controllers2[controller.i] = value;
        }
    }
    setAllValues(value) {
        for (const i in this.#controllers) {
            this.setControllerValue(i, value);
        }
    }
    removeAllControllers() {
        this.#controllers = {};
        this.#controllers2 = {};
        this.#controllerIndex = 0;
    }
}

/**
 * MDL Model
 */
//TODOv3 remove parse* function
const STUDIO_FLEX_OP_CONST = 1;
const STUDIO_FLEX_OP_FETCH1 = 2;
const STUDIO_FLEX_OP_ADD = 4;
const STUDIO_FLEX_OP_SUB = 5;
const STUDIO_FLEX_OP_MUL = 6;
const STUDIO_FLEX_OP_DIV = 7;
const STUDIO_FLEX_OP_NEG = 8;
const STUDIO_FLEX_OP_MAX = 13;
const STUDIO_FLEX_OP_MIN = 14;
const STUDIO_FLEX_OP_DME_LOWER_EYELID = 20;
const STUDIO_FLEX_OP_DME_UPPER_EYELID = 21;
const MAX_STUDIO_FLEX_DESC = 1024;
const MAX_STUDIO_FLEX_CTRL = 96;
class MdlAttachment {
    name = '';
    lowcasename = '';
    mdl = null;
    flags = 0;
    localbone = 0;
    local = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
}
class MdlStudioAnimDesc {
    name = '';
    //animSections = [];
    mdl = null;
    startOffset = 0;
    fps = 0;
    flags = 0;
    numframes = 0;
    nummovements = 0;
    animblock = 0;
    animIndex = 0;
    numikrules = 0;
    animblockikruleOffset = 0;
    numlocalhierarchy = 0;
    localhierarchyOffset = 0;
    sectionOffset = 0;
    sectionframes = 0;
    zeroframespan = 0;
    zeroframecount = 0;
    zeroframeOffset = 0;
    frames = [];
    pAnim(frameIndex /*, flStall TODOv2*/) {
        if (this.mdl) {
            return this.mdl.loader._parseAnimSection(this.mdl.reader, this, frameIndex);
        }
        return null;
    }
    pZeroFrameData() {
        return null;
        /*
        short				zeroframespan;	// frames per span
            short				zeroframecount; // number of spans
            int					zeroframeindex;
            byte				*pZeroFrameData() const { if (zeroframeindex) return (((byte *)this) + zeroframeindex); else return NULL; };
            */
    }
}
class MdlStudioFlexRule {
    ops = [];
    flex;
}
class MdlStudioFlexOp {
    op = 0; //TODO: create op enum
    index = 0;
    value = 0;
}
class MdlStudioPoseParam {
    name = '';
    flags = 0;
    start = 0;
    end = 0;
    loop = 0;
    midpoint = 0;
}
class SourceMdl {
    repository;
    externalMdlsV2 = [];
    attachmentNames = new Map();
    flexController = new FlexController();
    skinReferences = [];
    textures = [];
    modelGroups = [];
    header;
    bodyParts = [];
    sequences = [];
    texturesDir = [];
    flexRules = [];
    flexControllers = [];
    boneCount = 0;
    bones = [];
    boneNames = new Map();
    numflexdesc = 0;
    attachments = [];
    animDesc = [];
    loader;
    reader;
    poseParameters = [];
    hitboxSets = [];
    boneOffset = 0;
    boneControllerCount = 0;
    boneControllerOffset = 0;
    hitboxCount = 0;
    hitboxOffset = 0;
    localAnimCount = 0;
    localAnimOffset = 0;
    localSeqCount = 0;
    localSeqOffset = 0;
    numFlexRules = 0;
    flexRulesIndex = 0;
    textureCount = 0;
    textureOffset = 0;
    textureDirCount = 0;
    textureDirOffset = 0;
    skinReferenceCount = 0;
    skinFamilyCount = 0;
    skinReferenceOffset = 0;
    bodyPartCount = 0;
    bodyPartOffset = 0;
    attachmentCount = 0;
    attachmentOffset = 0;
    localNodeCount = 0;
    localNodeIndex = 0;
    localNodeNameIndex = 0;
    flexDescIndex = 0;
    flexControllerCount = 0;
    flexControllerIndex = 0;
    ikChainCount = 0;
    ikChainIndex = 0;
    mouthsCount = 0;
    mouthsIndex = 0;
    localPoseParamCount = 0;
    localPoseParamOffset = 0;
    surfacePropIndex = 0;
    keyValueIndex = 0;
    keyValueCount = 0;
    ikLockCount = 0;
    ikLockIndex = 0;
    includeModelCount = 0;
    includeModelOffset = 0;
    animBlocksNameIndex = 0;
    boneTableByNameIndex = 0;
    vertexBase = 0;
    offsetBase = 0;
    flexControllerUICount = 0;
    flexControllerUIIndex = 0;
    studiohdr2index = 0;
    srcbonetransform_count = 0;
    srcbonetransform_index = 0;
    illumpositionattachmentindex = 0;
    flMaxEyeDeflection = 0;
    linearboneOffset = 0;
    pLinearBones;
    constructor(repository) {
        this.repository = repository;
    }
    getMaterialName(skinId, materialId /*, materialOverride = []*/) {
        if (skinId >= this.skinReferences.length) {
            skinId = 0; // default to 0
        }
        const skinRef = this.skinReferences[skinId];
        if (!skinRef) {
            return '';
        }
        if (materialId >= skinRef.length) {
            materialId = skinRef.length - 1;
        }
        let textureId = skinRef[materialId];
        if (textureId >= this.textures.length) {
            textureId = 0;
        }
        return /*materialOverride[textureId] ? materialOverride[textureId].name : */ this.textures[textureId]?.name ?? '';
    }
    getSkinList() {
        const skinReferences = this.skinReferences;
        const skinList = [];
        for (let skinIndex = 0; skinIndex < skinReferences.length; ++skinIndex) {
            skinList.push(skinIndex);
        }
        return skinList;
    }
    getBodyPart(bodyPartId) {
        return this.bodyParts[bodyPartId];
    }
    getBodyParts() {
        return this.bodyParts;
    }
    async getSequence(sequenceName) {
        const list = this.sequences;
        for (const seq of list) {
            if ((seq.name == sequenceName) && seq.flags != 0x800) { //TODOV2: const
                return seq;
            }
        }
        // Seek in external Mdl's
        const extCount = this.getExternalMdlCount();
        for (let extIndex = 0; extIndex < extCount; ++extIndex) {
            const mdl = await this.getExternalMdl(extIndex);
            if (mdl) {
                const seq = await mdl.getSequence(sequenceName);
                if (seq) {
                    return seq;
                }
            }
        }
        return null;
    }
    /*
    getModelGroup(modelGroupId: number): MdlStudioModelGroup {
        return this.modelGroups[modelGroupId];
    }
    */
    getModelGroups() {
        return this.modelGroups;
    }
    getExternalMdlCount() {
        return this.modelGroups.length;
    }
    async getExternalMdl(externalId) {
        if (this.externalMdlsV2[externalId] !== undefined) {
            return this.externalMdlsV2[externalId];
        }
        const modelGroup = this.modelGroups[externalId];
        if (modelGroup) {
            const p = new Promise(async (resolve) => {
                const mdlLoader = getLoader('Source1MdlLoader');
                const mdl = await (new mdlLoader().load(this.repository, modelGroup.name));
                if (mdl) {
                    //this.externalMdlsV2[externalId] = mdl;
                    resolve(mdl);
                }
                else {
                    resolve(null);
                }
            });
            this.externalMdlsV2[externalId] = p;
            return p;
        }
        return null;
    }
    getTextureDir() {
        return this.texturesDir;
    }
    getDimensions(out = vec3.create()) {
        if (this.header) {
            vec3.sub(out, this.header.hull_max, this.header.hull_min);
        }
        return out;
    }
    getBBoxMin(out = vec3.create()) {
        if (this.header) {
            vec3.copy(out, this.header.hull_min);
        }
        return out;
    }
    getBBoxMax(out = vec3.create()) {
        if (this.header) {
            vec3.copy(out, this.header.hull_max);
        }
        return out;
    }
    async getAnimList() {
        const animList = new Set;
        //animList = animList.concat(this.getSequences());
        for (const seq of this.getSequences()) {
            animList.add(seq);
        }
        const extCount = this.getExternalMdlCount();
        for (let extIndex = 0; extIndex < extCount; ++extIndex) {
            const mdl = await this.getExternalMdl(extIndex);
            if (mdl) {
                for (const seq of mdl.getSequences()) {
                    animList.add(seq);
                }
            }
        }
        return animList;
    }
    getFlexRules() {
        return this.flexRules;
    }
    getFlexControllers() {
        return this.flexControllers;
    }
    runFlexesRules(flexesWeight, g_flexdescweight) {
        //this.g_flexdescweight = this.g_flexdescweight || new Float32Array(MAX_STUDIO_FLEX_DESC);
        const src = new Float32Array(MAX_STUDIO_FLEX_CTRL * 4); //TODO: optimize
        const flexControllers = this.getFlexControllers();
        if (flexControllers) {
            for (const flexController of flexControllers) {
                const j = flexController.localToGlobal;
                // remap m_flexweights to full dynamic range, global flexcontroller indexes
                if (j >= 0 && j < MAX_STUDIO_FLEX_CTRL * 4) {
                    const flexWeight = flexesWeight[flexController.name] ?? this.flexController.getControllerValue(flexController.name);
                    src[j] = flexWeight * (flexController.max - flexController.min) + flexController.min;
                }
            }
            this.#runFlexesRules(src, g_flexdescweight);
        }
        //return g_flexdescweight;
    }
    #runFlexesRules(src, dest) {
        for (let i = 0; i < this.numflexdesc; ++i) {
            dest[i] = 0;
        }
        const flexRules = this.getFlexRules();
        if (flexRules) {
            for (const rule of flexRules) {
                const stack = new Float32Array(32);
                let k = 0;
                //				const rule = flexRules[i];
                const numops = rule.ops.length;
                for (let j = 0; j < numops; j++) {
                    const op = rule.ops[j];
                    let pCloseLidV;
                    let flCloseLidV;
                    let pCloseLid;
                    let flCloseLid;
                    let nEyeUpDownIndex;
                    let flEyeUpDown;
                    switch (op.op) {
                        case STUDIO_FLEX_OP_ADD:
                            stack[k - 2] = stack[k - 2] + stack[k - 1];
                            k--;
                            break;
                        case STUDIO_FLEX_OP_SUB:
                            stack[k - 2] = stack[k - 2] - stack[k - 1];
                            k--;
                            break;
                        case STUDIO_FLEX_OP_MUL:
                            stack[k - 2] = stack[k - 2] * stack[k - 1];
                            k--;
                            break;
                        case STUDIO_FLEX_OP_DIV:
                            if (stack[k - 1] > 0.0001) {
                                stack[k - 2] = stack[k - 2] / stack[k - 1];
                            }
                            else {
                                stack[k - 2] = 0;
                            }
                            k--;
                            break;
                        case STUDIO_FLEX_OP_NEG:
                            stack[k - 1] = -stack[k - 1];
                            break;
                        case STUDIO_FLEX_OP_MAX:
                            stack[k - 2] = Math.max(stack[k - 2], stack[k - 1]);
                            k--;
                            break;
                        case STUDIO_FLEX_OP_MIN:
                            stack[k - 2] = Math.min(stack[k - 2], stack[k - 1]);
                            k--;
                            break;
                        case STUDIO_FLEX_OP_CONST:
                            stack[k] = op.value;
                            k++;
                            break;
                        case STUDIO_FLEX_OP_FETCH1:
                            const m = this.flexControllers[op.index].localToGlobal;
                            stack[k] = src[m];
                            ++k;
                            break;
                        case STUDIO_FLEX_OP_DME_LOWER_EYELID:
                            pCloseLidV = this.flexControllers[op.index];
                            flCloseLidV = RemapValClamped(src[pCloseLidV.localToGlobal], pCloseLidV.min, pCloseLidV.max, 0.0, 1.0);
                            pCloseLid = this.flexControllers[stack[k - 1]];
                            flCloseLid = RemapValClamped(src[pCloseLid.localToGlobal], pCloseLid.min, pCloseLid.max, 0.0, 1.0);
                            nEyeUpDownIndex = stack[k - 3];
                            flEyeUpDown = 0.0;
                            if (nEyeUpDownIndex >= 0) {
                                const pEyeUpDown = this.flexControllers[stack[k - 3]];
                                flEyeUpDown = RemapValClamped(src[pEyeUpDown.localToGlobal], pEyeUpDown.min, pEyeUpDown.max, -1.0, 1.0);
                            }
                            if (flEyeUpDown > 0.0) {
                                stack[k - 3] = (1.0 - flEyeUpDown) * (1.0 - flCloseLidV) * flCloseLid;
                            }
                            else {
                                stack[k - 3] = (1.0 - flCloseLidV) * flCloseLid;
                            }
                            //console.error(stack [k - 3]);
                            k -= 2;
                            break;
                        case STUDIO_FLEX_OP_DME_UPPER_EYELID:
                            pCloseLidV = this.flexControllers[op.index];
                            flCloseLidV = RemapValClamped(src[pCloseLidV.localToGlobal], pCloseLidV.min, pCloseLidV.max, 0.0, 1.0);
                            pCloseLid = this.flexControllers[stack[k - 1]];
                            flCloseLid = RemapValClamped(src[pCloseLid.localToGlobal], pCloseLid.min, pCloseLid.max, 0.0, 1.0);
                            nEyeUpDownIndex = stack[k - 3];
                            flEyeUpDown = 0.0;
                            if (nEyeUpDownIndex >= 0) {
                                const pEyeUpDown = this.flexControllers[stack[k - 3]];
                                flEyeUpDown = RemapValClamped(src[pEyeUpDown.localToGlobal], pEyeUpDown.min, pEyeUpDown.max, -1.0, 1.0);
                            }
                            if (flEyeUpDown < 0.0) {
                                stack[k - 3] = (1.0 + flEyeUpDown) * flCloseLidV * flCloseLid;
                            }
                            else {
                                stack[k - 3] = flCloseLidV * flCloseLid;
                            }
                            //stack [k - 3] = Math.random();
                            k -= 2;
                            break;
                        //console.error('Unknown op ' + op.op)//TODOV2
                    }
                    //pops++;
                }
                dest[rule.flex] = stack[0];
            }
        }
        //console.log(stack);
    }
    addExternalMdl(mdlName) {
        //TODOV2: check name exists
        const modelgroup = new MdlStudioModelGroup();
        modelgroup.label = '';
        modelgroup.name = mdlName;
        this.modelGroups.push(modelgroup);
    }
    getBoneCount() {
        return this.boneCount;
    }
    getBones() {
        return this.bones;
    }
    getBone(boneIndex) {
        const bones = this.getBones();
        if (bones) {
            return bones[boneIndex];
        }
    }
    getBoneByName(boneName) {
        const bones = this.getBones();
        const boneIndex = this.boneNames.get(boneName);
        if (bones && boneIndex !== undefined) {
            return bones[boneIndex];
        }
    }
    getBoneId(boneName) {
        const boneIndex = this.boneNames.get(boneName);
        return boneIndex ?? -1;
    }
    getAttachments() {
        return this.attachments;
    }
    getAttachmentsNames(out) {
        return Array.from(this.getAttachments());
    }
    getAttachmentById(attachmentId) {
        const list = this.getAttachments();
        if (list) {
            return list[attachmentId];
        }
    }
    getAttachment(attachmentName) {
        attachmentName = attachmentName.toLowerCase();
        return this.attachmentNames.get(attachmentName);
    }
    getSequenceById(sequenceId) {
        return this.sequences[sequenceId];
    }
    /*
    getSequencesList() {
        let sequencesList = [];
        sequencesList = sequencesList.concat(this.getSequences());

        const list = this.externalMdlsV2;
        for (let i = 0; i < list.length; ++i) {
            let mdl = list[i];
            sequencesList = sequencesList.concat(mdl.getSequences());
        }
        return sequencesList;
    }

    getSequencesList2() {
        let sequencesList = [];
        sequencesList = sequencesList.concat(this.getSequences2());

        const list = this.externalMdlsV2;
        for (let i = 0; i < list.length; ++i) {
            let mdl = list[i];
            sequencesList = sequencesList.concat(mdl.getSequences2());
        }
        return sequencesList;
    }
    */
    getSequences() {
        const list = this.sequences;
        const animList = [];
        for (const seq of list) {
            animList.push(seq.name);
        }
        return animList;
    }
    getSequences2() {
        const list = this.sequences;
        const animList = [];
        for (const seq of list) {
            //if ((seq.activity != -1) && (seq.activityName != '')) {
            //if (seq.activityName != '') {
            //if (seq.name == 'run_melee') {
            if ((seq.activity == 0)) {
                animList.push(seq.name);
            }
        }
        return animList;
    }
    getAnimDescription(animIndex) {
        return this.animDesc[animIndex ?? -1] ?? null;
    }
    getAnimFrame(dynamicProp, animDesc, frameIndex) {
        //console.info(frameIndex);
        //const animDesc = this.getAnimDescription(animIndex);
        if (animDesc && this.getBones()) {
            const section = this.loader._parseAnimSection(this.reader, animDesc, frameIndex); //TODOv3
            //const section = animDesc.animSections[0];
            //animDesc.frames = [];
            const frame = dynamicProp.frameframe; // = dynamicProp.frameframe || Object.create(null);
            //frame.bones = Object.create(null);
            //for (let frameIndex=0; frameIndex < animDesc.numframes; ++frameIndex)
            {
                //frame = Object.create(null);
                //frame.bones = frame.bones || Object.create(null);
                //const sectionIndex = 0;
                let frameIndex2 = frameIndex;
                if (animDesc.sectionframes != 0) {
                    //sectionIndex = Math.floor(frameIndex / animDesc.sectionframes);
                    frameIndex2 = frameIndex % animDesc.sectionframes;
                }
                //frameIndex % animDesc.sectionframes;
                const blockList = section; //animDesc.animSections[sectionIndex];
                if (blockList) {
                    for (const block of blockList) {
                        const bone = this.bones[block.bone];
                        if (bone != undefined) {
                            //const fb1 = (this.frame && this.frame.bones) ? this.frame.bones[bone.name] || Object.create(null) : Object.create(null);
                            //const fb = Object.create(null);
                            let fb = frame.bones[bone.name];
                            if (fb === undefined) {
                                fb = Object.create(null);
                                frame.bones[bone.name] = fb;
                                fb.rot = vec3.create();
                                fb.pos = vec3.create();
                                fb.boneId = bone.boneId; //TODOv2
                            }
                            //frame.bones[bone.name] = fb;
                            //frame.bones[bone.boneId] = fb;
                            block.getRot(fb.rot, this, bone, frameIndex2);
                            block.getPos(fb.pos, this, bone, frameIndex2);
                            fb.valid = true;
                            //console.log(bone.name, fb.pos, fb.rot);
                        }
                    }
                    //animDesc.frames.push(frame);
                    //this.frame = frame;
                    return frame;
                }
            }
        }
        return null;
    }
    getLocalPoseParameter(poseIndex) {
        return this.poseParameters[poseIndex];
    }
    getPoseParameters() {
        return this.poseParameters;
    }
    /*
    getAllPoseParameters() {
        const poseList = Object.create(null);
        //poseList = poseList.concat(this.getPoseParameters());

        const list = this.externalMdlsV2.concat(this);
        for (let i = 0; i < list.length; ++i) {
            let mdl = list[i];
            let pp = mdl.getPoseParameters();
            if (!pp) {
                return null;
            }
            for (let j = 0; j < pp.length; j++) {
                poseList[pp[j].name] = 1;
            }
        }
        return poseList;
    }
    */
    boneFlags(boneIndex) {
        const bone = this.getBone(boneIndex);
        if (bone) {
            return bone.flags;
        }
        return 0;
    }
}
class MdlStudioModelGroup {
    name;
    label;
}
class MdlTexture {
    name;
    originalName;
}
class MdlBodyPart {
    name;
    base;
    models;
}

function cleanSource1MaterialName(name) {
    name = name.replace(/\\/g, '/').toLowerCase().replace(/\.vmt$/g, '').replace(/^materials\//g, '');
    name = name + '.vmt';
    //name = 'materials/' + name;
    return name;
}
class Source1MaterialManager {
    static #fileListPerRepository = new Map(); // TODO: use a Map2
    static #materialList = new Map2();
    static #materialList2 = new Set();
    static #materialListPerRepository = {};
    static fallbackRepository = '';
    static async getMaterial(repository, path, searchPaths) {
        // TODO: improve this function code
        path = cleanSource1MaterialName(path);
        if (searchPaths) {
            const promises = [];
            for (const searchPath of searchPaths) {
                promises.push(this.#getMaterial(repository, 'materials/' + searchPath + path));
            }
            const promise = new Promise(resolve => {
                Promise.allSettled(promises).then(async (promises) => {
                    for (const promise of promises) {
                        const value = promise.value;
                        if (value) {
                            resolve(value);
                            return;
                        }
                    }
                    //resolve(this.#getMaterial(repository, 'materials/' + path));
                    const material = await this.#getMaterial(repository, 'materials/' + path);
                    if (material) {
                        resolve(material);
                    }
                    if (this.fallbackRepository && this.fallbackRepository != repository) {
                        resolve(this.getMaterial(this.fallbackRepository, path, searchPaths));
                    }
                    resolve(null);
                });
            });
            return promise;
        }
        else {
            const material = await this.#getMaterial(repository, 'materials/' + path);
            if (material) {
                return material;
            }
            if (this.fallbackRepository && this.fallbackRepository != repository) {
                return this.getMaterial(this.fallbackRepository, path, searchPaths);
            }
            return null;
        }
    }
    static #getMaterial(repository, path) {
        const material = this.#materialList.get(repository, path);
        if (material instanceof Promise) {
            const promise = new Promise(resolve => {
                material.then((material) => {
                    if (!material) {
                        resolve(material);
                        return;
                    }
                    const newMaterial = material.clone();
                    newMaterial.init();
                    this.#materialList2.add(newMaterial);
                    resolve(newMaterial);
                });
            });
            return promise;
        }
        if (material !== undefined) {
            if (!material) {
                return new Promise(resolve => {
                    resolve(material);
                });
            }
            return new Promise(resolve => {
                const newMaterial = material.clone();
                newMaterial.init();
                this.#materialList2.add(newMaterial);
                resolve(newMaterial);
            });
        }
        else {
            const promise = new Promise(resolve => {
                const vmtLoader = getLoader('Source1VmtLoader');
                vmtLoader.load(repository, path).then((material) => {
                    if (!material) {
                        resolve(material);
                        return;
                    }
                    this.#materialList.set(repository, path, material);
                    const newMaterial = material.clone();
                    newMaterial.init();
                    this.#materialList2.add(newMaterial);
                    resolve(newMaterial);
                }).catch((value) => resolve(value));
            });
            this.#materialList.set(repository, path, promise);
            return promise;
        }
    }
    /*
    static async copyMaterial(repository:string, sourcePath:string, destPath:string, searchPaths?: string[]) {
        const material: Source1Material = await this.getMaterial(repository, sourcePath, searchPaths);
        this.#materialList.set(destPath, material.clone());
        material.init();
    }
    */
    static addRepository(repository) {
        this.#fileListPerRepository.set(repository, null);
    }
    static async getMaterialList() {
        const repoList = [];
        for (let [repositoryName, repository] of this.#fileListPerRepository) {
            console.error(repositoryName, repository);
            if (repository == null) {
                repository = new Promise(async (resolve) => {
                    try {
                        const manifestUrl = repositoryName + 'materials_manifest.json'; //todo variable
                        const response = await customFetch(manifestUrl);
                        resolve(await response.json());
                    }
                    catch (e) {
                        resolve({ files: [] });
                    }
                });
                this.#fileListPerRepository.set(repositoryName, repository);
            }
            repoList.push({ name: repositoryName, files: [await repository] });
        }
        return { files: repoList };
    }
}

var _a$1;
const defaultMaterial = new MeshBasicMaterial();
class Source1ModelInstance extends Entity {
    isSource1ModelInstance = true;
    #poseParameters = new Map();
    #flexParameters = {};
    #flexesWeight = new Float32Array(MAX_STUDIO_FLEX_DESC);
    #materialOverride = null;
    #animations = new Animations();
    #skeleton = null;
    #skin = 0;
    #attachments = {};
    #materialsUsed = new Set();
    animable = true;
    hasAnimations = true;
    sourceModel;
    bodyParts = {}; //TODO: create map
    sequences = {};
    #meshes = new Set();
    frame = 0;
    anim = new SourceAnimation(); //TODO: removeme
    animationSpeed = 1.0;
    isDynamic;
    #sheen;
    #tint = null;
    static useNewAnimSystem = false;
    useNewAnimSystem = false;
    #animationList = [];
    #bodyGroups = new Map();
    frameframe = { bones: {} };
    static #animSpeed = 1.0;
    static {
        defaultMaterial.addUser(_a$1);
    }
    constructor(params) {
        super(params);
        this.sourceModel = params.sourceModel;
        this.name = this.sourceModel.name;
        if (params.isDynamic) {
            this.#createSkeleton();
        }
        this.isDynamic = params.isDynamic;
        if (!params.preventInit) {
            this.#init();
        }
        if (params.isDynamic) {
            this.#initSkeleton();
            this.#initAttachments();
        }
        this.#updateMaterials();
    }
    get skeleton() {
        return this.#skeleton;
    }
    set skeleton(skeleton) {
        this.#skeleton = skeleton;
    }
    #createSkeleton() {
        this.#skeleton = new Skeleton({ name: `Skeleton ${this.name}` });
        return super.addChild(this.#skeleton);
    }
    addChild(child) {
        const ret = super.addChild(child);
        child.skeleton?.setParentSkeleton(this.#skeleton ?? null);
        return ret;
    }
    removeChild(child) {
        super.removeChild(child);
        child.skeleton?.setParentSkeleton(null);
    }
    set skin(skin) {
        this.setSkin(skin);
    }
    get skin() {
        return String(this.#skin);
    }
    async setSkin(skin) {
        this.#skin = Number(skin);
        await this.#updateMaterials();
    }
    set sheen(sheen) {
        this.#sheen = sheen;
        //SHADER_PARAM( SHEENMAPMASKSCALEX, SHADER_PARAM_TYPE_FLOAT, '1', 'X Scale the size of the map mask to the size of the target' )
        //SHADER_PARAM( SHEENMAPMASKSCALEY, SHADER_PARAM_TYPE_FLOAT, '1', 'Y Scale the size of the map mask to the size of the target' )
        //SHADER_PARAM( SHEENMAPMASKOFFSETX, SHADER_PARAM_TYPE_FLOAT, '0', 'X Offset of the mask relative to model space coords of target' )
        //SHADER_PARAM( SHEENMAPMASKOFFSETY, SHADER_PARAM_TYPE_FLOAT, '0', 'Y Offset of the mask relative to model space coords of target' )
        //SHADER_PARAM( SHEENMAPMASKDIRECTION, SHADER_PARAM_TYPE_INTEGER, '0', 'The direction the sheen should move (length direction of weapon) XYZ, 0,1,2' )
        const dimensions = this.sourceModel.mdl.getDimensions(vec3.create());
        const dimensionsMin = this.sourceModel.mdl.getBBoxMin(vec3.create());
        const dimMax = Math.max(dimensions[0], dimensions[1], dimensions[2]);
        const direction = 0;
        let scaleX = 1;
        let scaleY = 1;
        let offsetX = 0;
        let offsetY = 0;
        for (let i = 0; i < 3; ++i) {
            if (dimMax == dimensions[i]) {
                //let direction = i;
                scaleX = dimMax;
                offsetX = dimensionsMin[i];
            }
        }
        this.materialsParams['SheenTintColor'] = vec3.fromValues(sheen[0], sheen[1], sheen[2]);
        this.materialsParams['SheenMaskScaleX'] = scaleX;
        this.materialsParams['SheenMaskScaleY'] = scaleX; //TODOv3: set y scale
        this.materialsParams['SheenMaskOffsetX'] = offsetX;
        this.materialsParams['SheenMaskOffsetY'] = offsetX; //TODOv3: set y offset
        this.materialsParams['SheenMaskDirection'] = direction;
        const min = vec3.create();
        const max = vec3.create();
        this.getBoundsModelSpace(min, max);
        //console.error(min, max);
        scaleX = max[0] - min[0];
        offsetX = min[0];
        scaleY = max[2] - min[2];
        offsetY = min[2];
        let sheenDir = 0;
        if (max[1] - min[1] > scaleX) {
            scaleX = max[1] - min[1];
            offsetX = min[1];
            scaleY = max[0] - min[0];
            offsetY = min[0];
            sheenDir = 2;
        }
        if (max[2] - min[2] > scaleX) {
            scaleX = max[2] - min[2];
            offsetX = min[2];
            scaleY = max[1] - min[1];
            offsetY = min[1];
            sheenDir = 1;
        }
        this.materialsParams['SheenMaskScaleX'] = scaleX;
        this.materialsParams['SheenMaskScaleY'] = scaleY; //TODOv3: set y scale
        this.materialsParams['SheenMaskOffsetX'] = offsetX;
        this.materialsParams['SheenMaskOffsetY'] = offsetY; //TODOv3: set y offset
        this.materialsParams['SheenMaskDirection'] = sheenDir;
    }
    set tint(tint) {
        this.#tint = tint ? vec4.clone(tint) : null;
        this.materialsParams['ItemTintColor'] = tint;
    }
    getTint(out) {
        if (this.#tint) {
            out = vec4.copy(out ?? vec4.create(), this.#tint);
            return out;
        }
    }
    setPoseParameter(paramName, paramValue) {
        this.#poseParameters.set(paramName, paramValue);
    }
    playAnimation(name) {
        this.playSequence(name);
    }
    async setAnimation(id, name, weight) {
        //TODO: merge with addAnimation
        this.#animationList[id] = { name: name, weight: weight };
        this.#animations.clear();
        for (const [index, anim] of this.#animationList.entries()) {
            if (anim) {
                await this.addAnimation(index, anim.name, anim.weight);
            }
        }
    }
    playSequence(sequenceName) {
        sequenceName = sequenceName.toLowerCase();
        const existingSequence = this.sequences[sequenceName];
        this.sequences = Object.create(null); //TODOv2
        this.sequences[sequenceName] = existingSequence ?? {};
        /*{
            startTime : -1
        }*/
        this.frame = 0;
    }
    async addAnimation(id, animationName, weight = 1) {
        //TODO: merge with setAnimation
        animationName = animationName.toLowerCase();
        if (!this.#animations.setWeight(id, weight)) {
            //let animation = new Animation(animationName);
            //this.#fillAnimation(animation);
            this.#animations.set(id, new AnimationDescription(await this.sourceModel.getAnimation(animationName, this), weight));
        }
    }
    update(scene, camera, delta) {
        if (this.#skeleton && this.isPlaying()) {
            this.#playSequences(delta * _a$1.#animSpeed * this.animationSpeed);
            this.#skeleton.setBonesMatrix();
        }
        for (const mesh of this.#meshes) {
            if (mesh.skeleton) {
                mesh.skeleton.setBonesMatrix();
            }
        }
    }
    #playSequences(delta) {
        if (_a$1.useNewAnimSystem || this.useNewAnimSystem) {
            this.frame += delta;
            this.#animate();
            return;
        }
        this.frame += delta;
        const now = new Date().getTime();
        const seqList = Object.keys(this.sequences);
        if (seqList.length === 0) {
            return;
        }
        for (const sequenceName of seqList) {
            const seqContext = this.sequences[sequenceName];
            let sequence;
            if (seqContext) {
                sequence = seqContext.s;
                if (!sequence) {
                    this.sourceModel.mdl.getSequence(sequenceName).then((sequence) => {
                        if (sequence) {
                            seqContext.s = sequence;
                            seqContext.startTime = now;
                            if (sequence.autolayer) {
                                const autoLayerList = sequence.autolayer;
                                for (let autoLayerIndex = 0; autoLayerIndex < autoLayerList.length; ++autoLayerIndex) {
                                    autoLayerList[autoLayerIndex];
                                    //if (autoLayer && (autoLayer.start !== 0 || autoLayer.end !== 0)) {
                                    //if (autoLayer && (autoLayer.start !== autoLayer.end)) {//TODOV2
                                    //if (autoLayer) {//TODOV2
                                    /*
                                    if (false && autoLayer && (autoLayer.start === autoLayer.end)) {//TODOV2
                                        const autoLayerSequence = sequence.mdl.getSequenceById(autoLayer.iSequence);
                                        if (autoLayerSequence) {
                                            const autoLayerSequenceName = autoLayerSequence.name;
                                            this.sequences[autoLayerSequenceName] = { s: autoLayerSequence, startTime: now }
                                        }
                                    }
                                    */
                                }
                            }
                        }
                    });
                }
            }
            if (sequence) {
                sequence.play(this); //TODOv2: play autolayer ?
            }
        }
        this.anim.animate2(this, this.#poseParameters, this.position, this.quaternion, this.sequences);
    }
    #animate() {
        const skeleton = this.#skeleton;
        if (!skeleton) {
            return;
        }
        for (const bone of skeleton._bones) {
            vec3.zero(bone.tempPosition);
            quat.identity(bone.tempQuaternion);
        }
        vec3.create(); //TODO:optimize
        quat.create();
        for (const [_, animationDescription] of this.#animations) {
            if (!animationDescription) {
                continue;
            }
            //console.info(animation);
            const animation = animationDescription.animation;
            if (!animation) {
                continue;
            }
            /*
            if (!animation.once) {
                animation.once = true;
                const frame = animation.getFrame(10);
                const rotationData = frame.getData('rotation');

                var arr = []
                for (const data of rotationData.datas as Array<quat>) {
                    let s = '';
                    for (let i = 0; i < 4; i++) {
                        s += data[i].toFixed(2) + ' ';
                    }
                    arr.push(s);
                }
                console.info(arr);

            }
    */
            for (const bone of animation.bones) {
                const skeletonBone = skeleton.getBoneById(bone.id);
                if (!skeletonBone) {
                    continue;
                }
                //skeletonBone.poseToBone = bone.refPos;
                const frame = animation.getFrame(this.frame * 30);
                if (frame) {
                    const flagData = frame.getData('flags');
                    if (!flagData) {
                        continue;
                    }
                    const flag = flagData.datas[bone.id];
                    if (flag === undefined) {
                        vec3.copy(skeletonBone.tempPosition, bone.refPosition);
                        quat.copy(skeletonBone.tempQuaternion, bone.refQuaternion);
                        continue;
                    }
                    const positionData = frame.getData('position');
                    if (positionData && positionData.datas[bone.id]) {
                        if (flag & STUDIO_ANIM_DELTA) {
                            vec3.add(skeletonBone.tempPosition, skeletonBone.tempPosition, positionData.datas[bone.id]);
                        }
                        else {
                            vec3.copy(skeletonBone.tempPosition, positionData.datas[bone.id]);
                        }
                    }
                    const rotationData = frame.getData('rotation');
                    if (rotationData && rotationData.datas[bone.id]) {
                        if (flag & STUDIO_ANIM_DELTA) {
                            quat.mul(skeletonBone.tempQuaternion, skeletonBone.tempQuaternion, rotationData.datas[bone.id]);
                        }
                        else {
                            quat.copy(skeletonBone.tempQuaternion, rotationData.datas[bone.id]);
                        }
                    }
                }
            }
            /*
            let b = dynamicPropBones[boneIndex];
            if (b) {
                if (!b.locked) {
                    b.quaternion = quatRemoveMeMe ?? b._initialQuaternion;
                    b.position = posRemoveMeMe ?? b._initialPosition;
                }
            } else {
                b = new MdlBone(dynamicProp.skeleton);
                dynamicProp.skeleton._bones[boneIndex] = b;
                b.boneId = bone.boneId;
                b.name = bone.name;
                b.quaternion = bone.quaternion;
                b.position = bone.position;
                b.parentBone = bone.parentBone;
                b.parent = dynamicProp.skeleton._bones[b.parentBone];
                b.poseToBone = bone.poseToBone;
                b.initPoseToBone = bone.initPoseToBone;
            }*/
        }
        for (const bone of skeleton._bones) {
            if (!bone.locked) {
                bone.position = bone.tempPosition;
                bone.quaternion = bone.tempQuaternion;
            }
        }
    }
    async setMaterialOverride(materialOverride) {
        this.#materialOverride = materialOverride;
        await this.#updateMaterials();
    }
    async #updateMaterials() {
        for (const mesh of this.#meshes) {
            let material;
            let materialName;
            materialName = this.sourceModel.mdl.getMaterialName(this.#skin, mesh.properties.getNumber('materialId') ?? 0);
            material = await Source1MaterialManager.getMaterial(this.sourceModel.repository, materialName, this.sourceModel.mdl.getTextureDir());
            if (this.#materialOverride) {
                material = this.#materialOverride;
            }
            if (material) {
                this.#materialsUsed.add(material);
                material.addUser(this);
                mesh.setMaterial(material);
                mesh.properties.setString('materialName', materialName);
                material.properties.set('materialType', mesh.properties.getNumber('materialType')); //TODOv3 : setup a better material param
                material.properties.set('materialParam', mesh.properties.getNumber('materialParam')); //TODOv3 : setup a better material param
                material.properties.set('eyeballArray', mesh.properties.getArray('eyeballArray')); //TODOv3 : setup a better material param
                material.properties.set('skeleton', mesh.skeleton); //TODOv3 : setup a better material param
            }
        }
    }
    async getSkins() {
        const skinReferences = this.sourceModel.mdl.skinReferences;
        const skins = new Set();
        for (const skin of skinReferences.keys()) {
            skins.add(String(skin));
        }
        return skins;
    }
    async getMaterialsName(skin) {
        this.sourceModel.mdl.skinReferences;
        const materials = new Set();
        for (const mesh of this.#meshes) {
            let material;
            let materialName;
            materialName = this.sourceModel.mdl.getMaterialName(Number(skin), mesh.properties.getNumber('materialId') ?? 0);
            material = await Source1MaterialManager.getMaterial(this.sourceModel.repository, materialName, this.sourceModel.mdl.getTextureDir());
            if (material) {
                materials.add(material.path);
            }
        }
        return [this.sourceModel.repository, materials];
    }
    #init() {
        const sourceModel = this.sourceModel;
        for (const [bodyPartName, bodyPart] of sourceModel.bodyParts) {
            //let newBodyPart = [];
            //let defaul = undefined;//TODOv3: change variable name;
            const group = new Entity({ name: bodyPartName });
            this.addChild(group);
            group.serializable = false;
            for (const [modelId, model] of bodyPart.entries()) {
                //const model = bodyPart[modelId];
                if (model) {
                    const group2 = new Entity();
                    group2.properties.setNumber('modelId', modelId);
                    group2.name = `${bodyPartName} ${modelId}`;
                    if (Number(modelId) != 0) {
                        group2.setVisible(false);
                    }
                    group.addChild(group2);
                    for (const modelMesh of model) {
                        const geometry = modelMesh.geometry;
                        let mesh;
                        if (this.#skeleton) {
                            mesh = new SkeletalMesh({ geometry: geometry.clone(), material: defaultMaterial, skeleton: this.#skeleton });
                        }
                        else {
                            mesh = new Mesh({ geometry: geometry, material: defaultMaterial });
                        }
                        mesh.name = geometry.properties.getString('name') ?? '';
                        mesh.properties.setObject('sourceModelMesh', modelMesh.mesh);
                        if (geometry.hasAttribute('aVertexTangent')) {
                            mesh.setDefine('USE_VERTEX_TANGENT');
                        }
                        //mesh.visible = defaul;
                        mesh.properties.copy(geometry.properties, ['materialId', 'materialType', 'materialParam', 'eyeballArray',]);
                        mesh.materialsParams = this.materialsParams;
                        //this.addChild(mesh);
                        this.#meshes.add(mesh);
                        group2.addChild(mesh);
                    }
                    //newBodyPart.push(newModel);
                }
                //defaul = false;
            }
            //this.bodyParts[bodyPartName] = newBodyPart;
            this.bodyParts[bodyPartName] = group;
        }
    }
    #initSkeleton() {
        const bones = this.sourceModel.getBones();
        if (bones) {
            for (const bone of bones) {
                const skeletonBone = this.#skeleton.addBone(bone.boneId, bone.name);
                quat.copy(skeletonBone._initialQuaternion, bone.quaternion);
                vec3.copy(skeletonBone._initialPosition, bone.position);
                const parentBoneId = bone.parentBone;
                skeletonBone.poseToBone = bone.poseToBone;
                if (parentBoneId >= 0) {
                    const parentBone = this.#skeleton._bones[parentBoneId];
                    parentBone?.addChild(skeletonBone);
                    //skeletonBone.parent = this.#skeleton._bones[parentBone];
                    if (!skeletonBone.parent) {
                        console.error('parent not found : ' + bone.name);
                    }
                }
                else {
                    this.#skeleton.addChild(skeletonBone);
                }
            }
        }
    }
    #initAttachments() {
        const attachments = this.sourceModel.getAttachments();
        const localMat3 = mat3.create(); //todo: optimize
        if (attachments) {
            for (const attachment of attachments) {
                const attachmentBone = new Bone({ name: attachment.name });
                localMat3[0] = attachment.local[0];
                localMat3[3] = attachment.local[1];
                localMat3[6] = attachment.local[2];
                localMat3[1] = attachment.local[4];
                localMat3[4] = attachment.local[5];
                localMat3[7] = attachment.local[6];
                localMat3[2] = attachment.local[8];
                localMat3[5] = attachment.local[9];
                localMat3[8] = attachment.local[10];
                vec3.set(attachmentBone._position, attachment.local[3], attachment.local[7], attachment.local[11]);
                quat.fromMat3(attachmentBone._quaternion, localMat3);
                const bone = this.#skeleton.getBoneById(attachment.localbone);
                bone?.addChild(attachmentBone);
                this.#attachments[attachment.lowcasename] = attachmentBone;
            }
        }
    }
    getBoneById(boneId) {
        return this.#skeleton?.getBoneById(boneId);
    }
    /*
    setBodyGroup(bodyPartName, bodyPartModelId) {
        let bodyPart = this.bodyParts[bodyPartName];
        if (bodyPart) {
            for (let index = 0, l = bodyPart.length; index < l; index++) {
                let meshes = bodyPart[index];
                let visible = false;
                if (index === bodyPartModelId) {
                    visible = true;
                }
                for (let mesh of meshes) {
                    mesh.visible = visible;
                }
            }
        }
    }
    */
    renderBodyParts(render) {
        for (const bodyPartName in this.bodyParts) {
            this.renderBodyPart(bodyPartName, render);
            /*let bodyPart = this.bodyParts[bodyPartName];
            if (bodyPart) {
                for (let model of bodyPart) {
                    for (let model of bodyPart) {
                        model.visible = render ? undefined : false;
                    }
                }
            }*/
        }
    }
    renderBodyPart(bodyPartName, render) {
        const bodyPart = this.bodyParts[bodyPartName];
        if (bodyPart) {
            bodyPart.setVisible(render ? undefined : false);
            /*for (let model of bodyPart) {
                for (let mesh of model) {
                    mesh.visible = render ? undefined : false;
                }
            }*/
        }
    }
    resetBodyPartModels() {
        for (const bodyPartName in this.bodyParts) {
            this.setBodyPartModel(bodyPartName, 0);
        }
    }
    setBodyPartIdModel(bodyPartId, modelId) {
        const bodypart = this.sourceModel.getBodyPart(bodyPartId);
        if (bodypart) {
            this.setBodyPartModel(bodypart.name, modelId);
        }
    }
    setBodyPartModel(bodyPartName, modelId) {
        const bodyPart = this.bodyParts[bodyPartName];
        if (bodyPart) {
            //let id = 0;
            for (const bodyPartModel of bodyPart.children) {
                //let bodyPartModel = bodyPart.children.get(id);
                bodyPartModel.setVisible((bodyPartModel.properties.getNumber('modelId') == modelId) ? undefined : false);
                //++id;
            }
        }
        //this.sourceModel.setBodyPartModel(bodyPartName, modelId);
        //this.bodyGroups[bodyPartName] = this.bodyGroups[bodyPartName] || {render : true, modelId : 0};
        //this.bodyGroups[bodyPartName].modelId = modelId;
        this.#bodyGroups.set(bodyPartName, Number(modelId));
    }
    getBodyGroups() {
        return new Map(this.#bodyGroups);
    }
    toString() {
        return 'Source1ModelInstance ' + super.toString();
    }
    attachSystem(system, attachmentName = '', cpIndex = 0, offset) {
        this.addChild(system);
        const attachment = this.getAttachment(attachmentName);
        if (attachment) {
            const controlPoint = system.getControlPoint(cpIndex);
            attachment.addChild(controlPoint);
        }
        else {
            this.#attachSystemToBone(system, attachmentName);
        }
        if (offset) {
            system.getControlPoint(0).setPosition(offset);
        }
    }
    #attachSystemToBone(system, boneName) {
        if (!this.#skeleton) {
            return;
        }
        this.addChild(system);
        const controlPoint = system.getControlPoint(0);
        const bone = this.#skeleton.getBoneByName(boneName);
        if (bone) {
            bone.addChild(controlPoint);
        }
        else {
            this.addChild(controlPoint);
        }
    }
    getAttachment(attachmentName) {
        return this.#attachments[attachmentName.toLowerCase()];
    }
    getBoneByName(boneName) {
        if (!this.#skeleton) {
            return;
        }
        return this.#skeleton.getBoneByName(boneName);
    }
    set material(material) {
        for (const bodyPartName in this.bodyParts) {
            const bodyPart = this.bodyParts[bodyPartName];
            const meshes = bodyPart.getChildList('Mesh');
            for (const mesh of meshes) {
                mesh.setMaterial(material);
            }
        }
        const subModels = this.getChildList('Source1ModelInstance');
        for (const subModel of subModels) {
            if (subModel !== this) {
                subModel.material = material;
            }
        }
    }
    buildContextMenu() {
        //console.error();
        const skins = this.sourceModel.mdl.getSkinList();
        const skinMenu = [];
        for (const skin of skins) {
            const item = Object.create(null);
            item.name = skin;
            item.f = () => this.skin = String(skin);
            skinMenu.push(item);
        }
        return Object.assign(super.buildContextMenu(), {
            Source1ModelInstance_1: null,
            skin: { i18n: '#skin', submenu: skinMenu },
            tint: { i18n: '#tint', f: async (entity) => new Interaction().getColor(0, 0, undefined, (tint) => { entity.tint = tint; }, (tint = entity.tint) => { entity.tint = tint; }) },
            reset_tint: { i18n: '#reset_tint', f: (entity) => entity.tint = null, disabled: this.#tint === undefined },
            animation: { i18n: '#animation', f: async (entity) => { const animation = await new Interaction().getString(0, 0, await entity.sourceModel.mdl.getAnimList()); if (animation) {
                    entity.playSequence(animation);
                } } },
            overrideallmaterials: { i18n: '#overrideallmaterials', f: async (entity) => { const material = await new Interaction().getString(0, 0, Object.keys(Material.materialList)); if (material) {
                    entity.material = new Material.materialList[material];
                } } },
            Source1ModelInstance_2: null,
            animate: { i18n: '#animate', selected: this.animationSpeed != 0.0, f: () => this.animationSpeed == 0 ? this.animationSpeed = 1 : this.animationSpeed = 0 },
            frame: { i18n: '#frame', f: () => { const frame = prompt('Frame', String(this.frame)); if (frame) {
                    this.animationSpeed = 0;
                    this.frame = Number(frame);
                } } },
            Source1ModelInstance_3: null,
            copy_filename: { i18n: '#copy_filename', f: () => navigator.clipboard.writeText(this?.sourceModel?.fileName) },
        });
    }
    getParentModel() {
        return this;
    }
    getRandomPointOnModel(vec, initialVec, bones) {
        const hitboxes = this.getHitboxes();
        const hitbox = hitboxes[getRandomInt(hitboxes.length)];
        const bone = hitbox.parent;
        if (bone) {
            bones.push([bone, 1]);
            vec3RandomBox(vec, hitbox.boundingBoxMin, hitbox.boundingBoxMax);
            //vec3.transformMat4(vec, vec, bone.boneMat);
            vec3.copy(initialVec, vec);
            vec3.transformMat4(vec, vec, mat4.fromRotationTranslationScale(mat4.create(), bone.worldQuat, bone.worldPos, bone.worldScale));
        }
        return vec;
    }
    setPosition(position) {
        super.setPosition(position);
        if (this.#skeleton) {
            this.#skeleton.dirty();
        }
    }
    set quaternion(quaternion) {
        super.quaternion = quaternion;
        if (this.#skeleton) {
            this.#skeleton.dirty();
        }
    }
    get quaternion() {
        return quat.clone(this._quaternion);
    }
    static set animSpeed(speed) {
        this.#animSpeed = speed;
    }
    setFlexes(flexes = {}) {
        this.#flexParameters = flexes;
        this.#refreshFlexes();
    }
    resetFlexParameters() {
        this.#flexParameters = {};
        this.#refreshFlexes();
    }
    #refreshFlexes() {
        this.sourceModel.mdl.runFlexesRules(this.#flexParameters, this.#flexesWeight);
        for (const mesh of this.#meshes) {
            if (mesh && mesh.geometry) {
                const attribute = mesh.geometry.getAttribute('aVertexPosition');
                const newAttribute = attribute.clone();
                mesh.geometry.setAttribute('aVertexPosition', newAttribute);
                const sourceModelMesh = mesh.properties.getObject('sourceModelMesh');
                this.#updateArray(newAttribute._array, sourceModelMesh.flexes, sourceModelMesh.vertexoffset);
            }
        }
    }
    #updateArray(vertexPositionArray, flexes, vertexoffset) {
        const flexesWeight = this.#flexesWeight;
        if (flexes && flexes.length) {
            for (const flex of flexes) {
                //const g_flexdescweight = this.mdl.g_flexdescweight;
                const w1 = flexesWeight[flex.flexdesc] ?? 0;
                let w3 = w1;
                if (flex.flexpair) {
                    w3 = flexesWeight[flex.flexpair] ?? 0;
                }
                if (w1) {
                    const vertAnims = flex.vertAnims;
                    //let good = 0;
                    //let bad = 0;
                    for (const vertAnim of vertAnims) {
                        const b = vertAnim.side / 255.0;
                        //console.error(b);
                        const w = w1 * (1.0 - b) + b * w3;
                        const flDelta = vertAnim.flDelta;
                        vertAnim.flNDelta;
                        //const vertexIndex = vertAnim.index * 3;
                        //const vertexIndexArray = this.verticesPositionToto[vertAnim.index];
                        const vertexIndex = (vertexoffset + vertAnim.index) * 3;
                        vertexPositionArray[vertexIndex + 0] += flDelta[0] * w;
                        vertexPositionArray[vertexIndex + 1] += flDelta[1] * w;
                        vertexPositionArray[vertexIndex + 2] += flDelta[2] * w;
                        //vertexPositionArray[vertexIndex + 0] += 0;
                        //vertexPositionArray[vertexIndex + 1] += 0;
                        //vertexPositionArray[vertexIndex + 2] += 0;
                        /*
                        if (vertexIndexArray) {
                            for (let vertexIndexArrayIndex = 0; vertexIndexArrayIndex < vertexIndexArray.length; ++vertexIndexArrayIndex) {
                                let vertexIndex = vertexIndexArray[vertexIndexArrayIndex];
                                vertexPositionArray[vertexIndex + 0] += flDelta[0] * w;
                                vertexPositionArray[vertexIndex + 1] += flDelta[1] * w;
                                vertexPositionArray[vertexIndex + 2] += flDelta[2] * w;

                                /*normalArray[vertexIndex + 0] += flNDelta[0] * w;
                                normalArray[vertexIndex + 1] += flNDelta[1] * w;
                                normalArray[vertexIndex + 2] += flNDelta[2] * w;* /
                                ++good;
                            }
                        } else {
                            ++bad;
                        }*/
                    }
                }
            }
        }
    }
    async playDefaultAnim() {
        const animList = await this.sourceModel.mdl.getAnimList();
        if (animList && animList.size > 0) {
            this.playSequence(animList.keys().next().value);
        }
    }
    getHitboxes() {
        const mdlHitboxSets = this.sourceModel.mdl.hitboxSets;
        const hitboxes = [];
        if (mdlHitboxSets) {
            for (const mdlHitboxSet of mdlHitboxSets) {
                const mdlHitboxes = mdlHitboxSet.hitboxes;
                for (const mdlHitbox of mdlHitboxes) {
                    const bone = this.getBoneById(mdlHitbox.boneId);
                    if (bone) {
                        hitboxes.push(new Hitbox(mdlHitbox.name, mdlHitbox.bbmin, mdlHitbox.bbmax, bone));
                    }
                }
            }
        }
        return hitboxes;
    }
    replaceMaterial(material, recursive = true) {
        super.replaceMaterial(material, recursive);
        for (const mesh of this.#meshes) {
            mesh.material = material;
        }
    }
    resetMaterial(recursive = true) {
        super.resetMaterial(recursive);
        this.#updateMaterials();
    }
    getAnimations() {
        return this.sourceModel.mdl.getAnimList();
    }
    toJSON() {
        const json = super.toJSON();
        json.skin = this.skin;
        json.repository = this.sourceModel.repository;
        json.filename = this.sourceModel.fileName;
        json.dynamic = this.isDynamic;
        if (this.#skeleton) {
            json.skeletonid = this.#skeleton.id;
        }
        return json;
    }
    static async constructFromJSON(json, entities, loadedPromise) {
        const entity = await Source1ModelManager.createInstance(json.repository, json.filename, false /*dynamic*/, true);
        if (!entity) {
            return null;
        }
        loadedPromise.then(() => {
            if (json.dynamic) {
                if (json.skeletonid) {
                    entity.skeleton = entities.get(json.skeletonid);
                }
                if (!entity.skeleton) {
                    entity.#createSkeleton();
                    entity.#initSkeleton();
                    entity.#initAttachments();
                }
                entity.isDynamic = true;
            }
            entity.#init();
            entity.#updateMaterials();
            if (entity._parent) {
                entity._parent.addChild(entity);
            }
        });
        return entity;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.skin = json.skin ?? '0';
        //TODO
    }
    dispose() {
        super.dispose();
        this.#skeleton?.dispose();
        for (const material of this.#materialsUsed) {
            material.removeUser(this);
        }
        for (const mesh of this.#meshes) {
            mesh.dispose();
        }
    }
    static getEntityName() {
        return 'Source1Model';
    }
    is(s) {
        if (s == 'Source1ModelInstance') {
            return true;
        }
        else {
            return super.is(s);
        }
    }
}
_a$1 = Source1ModelInstance;
registerEntity(Source1ModelInstance);

class SourceModel {
    repository;
    fileName;
    name;
    mdl; //TODO: set private ?
    vvd;
    vtx;
    requiredLod = 0;
    drawBodyPart = {};
    currentSkin = 0;
    currentSheen = null;
    animLayers = [];
    materialRepository = null;
    dirty = true;
    bodyParts = new Map();
    constructor(repository, fileName, mdl, vvd, vtx) {
        this.repository = repository;
        this.fileName = fileName;
        this.name = FileNameFromPath(fileName);
        this.mdl = mdl;
        this.vvd = vvd;
        this.vtx = vtx;
        //this.visible = true;
        this.requiredLod = 0;
        //this.bodyParts = [];
        //this.origin = vec3.create();
        //this.orientation = vec3.create();
        //this.geometries = new Set();
    }
    addGeometry(mesh, geometry, bodyPartName, bodyPartModelId) {
        const modelMesh = new SourceModelMesh(mesh, geometry);
        if (bodyPartName !== undefined) {
            let bodyPart = this.bodyParts.get(bodyPartName);
            if (bodyPart === undefined) {
                bodyPart = [];
                this.bodyParts.set(bodyPartName, bodyPart);
            }
            if (bodyPartModelId !== undefined) {
                let meshes = bodyPart[bodyPartModelId];
                if (meshes === undefined) {
                    meshes = [];
                    bodyPart[bodyPartModelId] = meshes;
                }
                meshes.push(modelMesh);
            }
        }
        //this.geometries.add(geometry);
    }
    createInstance(isDynamic, preventInit) {
        return new Source1ModelInstance({ sourceModel: this, isDynamic: isDynamic, preventInit: preventInit });
    }
    getBodyNumber(bodygroups) {
        let bodyPartCount = 1;
        let bodyPartNumber = 0;
        for (const bodyPart of this.mdl.bodyParts) {
            if (bodyPart && bodyPart.models && (bodyPart.models.length > 1)) {
                const bodyPartModel = bodygroups.get(bodyPart.name);
                bodyPartNumber += (bodyPartModel ?? 0) * bodyPartCount;
                bodyPartCount *= (bodyPart.models.length);
            }
        }
        return bodyPartNumber;
    }
    getBones() {
        if (this.mdl) {
            return this.mdl.getBones();
        }
        return null;
    }
    getAttachments() {
        if (this.mdl) {
            return this.mdl.getAttachments();
        }
        return null;
    }
    getBone(boneIndex) {
        if (this.mdl) {
            return this.mdl.getBone(boneIndex);
        }
    }
    getAttachmentById(attachmentIndex) {
        if (this.mdl) {
            return this.mdl.getAttachmentById(attachmentIndex);
        }
    }
    getBoneByName(boneName) {
        if (this.mdl) {
            return this.mdl.getBoneByName(boneName);
        }
    }
    getAttachment(attachmentName) {
        if (this.mdl) {
            return this.mdl.getAttachment(attachmentName);
        }
    }
    getBodyPart(bodyPartId) {
        if (this.mdl) {
            return this.mdl.getBodyPart(bodyPartId);
        }
    }
    getBodyParts() {
        if (this.mdl) {
            return this.mdl.getBodyParts();
        }
    }
    async getAnimation(animationName, entity) {
        const animation = new Animation(animationName);
        const seq = await this.mdl.getSequence(animationName);
        const bones = this.mdl.getBones();
        for (const mdlBone of bones) {
            animation.addBone(new AnimationBone(mdlBone.boneId, mdlBone.parentBone, mdlBone.name, mdlBone.position, mdlBone.quaternion));
        }
        if (seq) {
            //const t = Studio_Duration(seq.mdl, seq.id, []);
            const frameCount = StudioFrames2(seq.mdl, seq.id, new Map());
            const posRemoveMeTemp = [];
            const quatRemoveMeTemp = [];
            const boneFlags = [];
            //const poseParameters = {};
            for (const [boneId, bone] of animation.bones.entries()) {
                //posRemoveMeTemp.push(vec3.clone(bone.refPosition));
                //quatRemoveMeTemp.push(quat.clone(bone.refQuaternion));
                //posRemoveMeTemp.push(vec3.create());
                //quatRemoveMeTemp.push(quat.create());
            }
            for (let frame = 0; frame < frameCount; frame++) {
                const animationFrame = new AnimationFrame(frame);
                const cycle = frameCount > 1 ? frame / (frameCount - 1) : 0;
                CalcPose2(entity, seq.mdl, undefined, posRemoveMeTemp, quatRemoveMeTemp, boneFlags, seq.id, cycle /*entity.frame / t*/, new Map(), BONE_USED_BY_ANYTHING, 1.0, cycle /*dynamicProp.frame / t*/);
                //console.info(posRemoveMeTemp, quatRemoveMeTemp);
                animationFrame.setDatas('position', AnimationFrameDataType.Vec3, posRemoveMeTemp);
                animationFrame.setDatas('rotation', AnimationFrameDataType.Quat, quatRemoveMeTemp);
                animationFrame.setDatas('flags', AnimationFrameDataType.Number, boneFlags);
                animation.addFrame(animationFrame);
            }
        }
        return animation;
    }
}
class SourceModelMesh {
    mesh;
    geometry;
    constructor(mesh, geometry) {
        this.mesh = mesh;
        this.geometry = geometry;
    }
}

class ModelLoader {
    load(repositoryName, fileName) {
        const promise = new Promise(async (resolve) => {
            fileName = fileName.toLowerCase().replace(/\.mdl$/, '');
            // First load mdl. We need the mdl version to load the vtx
            const mdlLoader = getLoader('Source1MdlLoader');
            const mdl = await new mdlLoader().load(repositoryName, fileName + '.mdl');
            if (!mdl) {
                resolve(null);
                return;
            }
            const vvdPromise = new Source1VvdLoader().load(repositoryName, fileName + '.vvd');
            const vtxPromise = new Source1VtxLoader(mdl.header.formatVersionID).load(repositoryName, fileName + '.dx90.vtx');
            Promise.all([vvdPromise, vtxPromise]).then(([vvd, vtx]) => {
                if (vvd && vtx) {
                    this.#fileLoaded(resolve, repositoryName, fileName, mdl, vvd, vtx);
                }
            });
        });
        return promise;
    }
    #fileLoaded(resolve, repositoryName, fileName, mdl, vvd, vtx) {
        const requiredLod = 0;
        const vertices = [];
        const normals = [];
        const tangents = [];
        const uvs = [];
        const boneWeights = [];
        const boneIds = [];
        const vertexArray = vvd.getVertices(requiredLod); //vertices;
        const bodyparts = vtx.getBodyparts(); //vertices;
        if (!vertexArray || !bodyparts) {
            resolve(null);
            return;
        }
        const newSourceModel = new SourceModel(repositoryName, fileName, mdl, vvd, vtx);
        for (const i of vertexArray) {
            vertices.push(...i.m_vecPosition);
            normals.push(...i.m_vecNormal);
            tangents.push(...i.m_vecTangent);
            uvs.push(...i.m_vecTexCoord);
            boneWeights.push(...i.m_BoneWeights.weight);
            boneIds.push(...i.m_BoneWeights.bone);
        }
        const vertexPosition = new Float32BufferAttribute(vertices, 3);
        const vertexNormal = new Float32BufferAttribute(normals, 3);
        const vertexTangent = new Float32BufferAttribute(tangents, 4);
        const textureCoord = new Float32BufferAttribute(uvs, 2);
        const vertexWeights = new Float32BufferAttribute(boneWeights, 3);
        const vertexBones = new Float32BufferAttribute(boneIds, 3);
        //let material = new MeshBasicMaterial({map: 'texture'});//removeme
        //console.info('Vertex array :')
        //console.info(vertexArray);
        let stripgroup = null;
        let cumulateVertexOffset = 0;
        let modelsname = '';
        // Iterate body parts
        for (let bodypartIndex = 0; bodypartIndex < bodyparts.length; ++bodypartIndex) {
            const bodyPart = /*bodyparts[bodypartIndex];//*/ mdl.getBodyPart(bodypartIndex);
            if (bodyPart) {
                const vtxBodyPart = bodyparts[bodypartIndex];
                if (!vtxBodyPart) {
                    continue;
                }
                // iterate models
                for (let modelIndex = 0; modelIndex < vtxBodyPart.models.length; ++modelIndex) {
                    const modelTest = bodyPart.models[modelIndex];
                    if (!modelTest) {
                        continue;
                    }
                    const model = vtxBodyPart.models[modelIndex];
                    if (!model) {
                        continue;
                    }
                    modelsname += modelTest.name + ', '; //TODOV2
                    const lod = model.lods[requiredLod];
                    if (!lod) {
                        continue;
                    }
                    // iterate meshes
                    for (let meshIndex = 0; meshIndex < lod.meshes.length; ++meshIndex) {
                        const mesh = lod.meshes[meshIndex];
                        if (!mesh) {
                            continue;
                        }
                        const msh = modelTest.meshArray[meshIndex]; //new SourceModel.MeshTest();
                        if (!msh) {
                            continue;
                        }
                        if (!msh.initialized) {
                            //msh.setMaterialId(msh.material);
                            const vertexOffset = cumulateVertexOffset + msh.vertexoffset; //TODO
                            const indices = [];
                            for (let stripgroupIndex = 0; stripgroupIndex < mesh.stripGroups.length; ++stripgroupIndex) {
                                stripgroup = mesh.stripGroups[stripgroupIndex];
                                if (!stripgroup) {
                                    continue;
                                }
                                const indexArray = stripgroup.indexes;
                                const stripVertexArray = stripgroup.vertices;
                                //if (this.drawBodyPart[bodyPartName])
                                for (const j of indexArray) {
                                    const sva = stripVertexArray[j];
                                    if (!sva)
                                        break;
                                    const i = sva.origMeshVertID + vertexOffset; //TODO: rename variable i
                                    indices.push(i);
                                }
                            } // stripgroup
                            // reverse triangles from CW to CCW
                            for (let i = 0, l = indices.length; i < l; i += 3) { //TODOv3: optimize
                                const a = indices[i + 1];
                                indices[i + 1] = indices[i + 2];
                                indices[i + 2] = a;
                            }
                            const geometry = new BufferGeometry();
                            geometry.setIndex(new Uint32BufferAttribute(indices, 1));
                            geometry.setAttribute('aVertexPosition', vertexPosition);
                            geometry.setAttribute('aVertexNormal', vertexNormal);
                            geometry.setAttribute('aVertexTangent', vertexTangent);
                            geometry.setAttribute('aTextureCoord', textureCoord);
                            geometry.setAttribute('aBoneWeight', vertexWeights);
                            geometry.setAttribute('aBoneIndices', vertexBones);
                            geometry.properties.set('materialId', new Property(PropertyType.Number, msh.material));
                            geometry.properties.set('materialType', new Property(PropertyType.Number, msh.materialtype)); //TODOv3 : setup a better material param
                            geometry.properties.set('materialParam', new Property(PropertyType.Number, msh.materialparam)); //TODOv3 : setup a better material param
                            geometry.properties.set('eyeballArray', new Property(PropertyType.Array, msh.model.eyeballArray)); //TODOv3 : setup a better material param
                            geometry.count = indices.length;
                            geometry.properties.set('name', new Property(PropertyType.String, modelTest.name));
                            newSourceModel.addGeometry(msh, geometry, bodyPart.name, modelIndex);
                        }
                    } // mesh
                    cumulateVertexOffset += modelTest.numvertices;
                } // model
            }
        } // body
        resolve(newSourceModel);
    }
}
registerLoader('ModelLoader', ModelLoader);

class Source1VmtLoaderClass {
    #materials = new Map();
    #extraMaterials = new Map(); //TODO: this is used for maps create a map repo instead
    async load(repository, path) {
        const response = await Repositories.getFileAsText(repository, path);
        if (!response.error) {
            return this.parse(repository, path, response.text);
        }
        else {
            const fileContent = this.#extraMaterials.get(path);
            if (fileContent) {
                return this.parse(repository, path, fileContent);
            }
        }
        return null;
    }
    async parse(repository, path, content) {
        path = path.replace(/(\/)+/g, '/').replace(/(\\)+/g, '/').toLowerCase();
        const kv = new KvReader();
        kv.readText(content);
        const vmt = kv.getRootElement();
        if (!vmt) {
            return null;
        }
        const shaderName = kv.getRootName().toLowerCase();
        let material = null;
        if (shaderName === 'patch') {
            //TODO: check patch
            const include = vmt /*TODO: fix that*/['include'];
            const insert = vmt /*TODO: fix that*/['insert'];
            const material = await Source1MaterialManager.getMaterial(repository, include);
            if (material) {
                for (const insertIndex in insert) {
                    material.variables.set(insertIndex, insert[insertIndex]);
                    throw 'material.parameters[insertIndex] = insert[insertIndex];';
                }
            }
            //materialList[fileNameRemoveMe] = material;removeme
            return (material);
            //promise.then(patchResolve);
        }
        else {
            const materialClass = this.#materials.get(shaderName);
            if (materialClass) {
                material = new materialClass(repository, path, vmt);
            }
            else {
                console.error('Unknown material : ' + shaderName);
            }
        }
        return material;
    }
    setMaterial(/*TODO: add repository param*/ fileName, fileContent) {
        this.#extraMaterials.set(fileName, fileContent);
    }
    registerMaterial(materialName, materialClass) {
        this.#materials.set(materialName.toLowerCase(), materialClass);
    }
}
const Source1VmtLoader = new Source1VmtLoaderClass();
registerLoader('Source1VmtLoader', Source1VmtLoader);

/**
 * Map entities
 */
class MapEntities {
    static #entities = new Map();
    static registerEntity(className, entityClass) {
        this.#entities.set(className, entityClass);
    }
    static createEntity(map, className) {
        const entityClass = this.#entities.get(className);
        if (!entityClass) {
            return null;
        }
        const entity = new entityClass({ className: className, map: map });
        return entity;
    }
}

function ParseVector(out, str) {
    const regex = / *(-?\d*(\.\d*)?) *(-?\d*(\.\d*)?) *(-?\d*(\.\d*)?) */i;
    const result = regex.exec(str);
    if (result && result.length >= 6) {
        return vec3.set(out, Number.parseFloat(result[1]), Number.parseFloat(result[3]), Number.parseFloat(result[5]));
    }
    return null;
}
function ParseVector2(out, str) {
    const regex = / *(-?\d*(\.\d*)?) *(-?\d*(\.\d*)?) *(-?\d*(\.\d*)?) */i;
    const result = regex.exec(str);
    if (result && result.length >= 6) {
        return vec3.set(out, Number.parseFloat(result[1]), Number.parseFloat(result[3]), Number.parseFloat(result[5]));
    }
    return null;
}
function parseLightColorIntensity(value, light, intensityMultiplier = 1) {
    const colorValue = vec3.create();
    const arrayValue = value.split(' ');
    colorValue[0] = Math.pow(Number(arrayValue[0]) / 255.0, 2.2);
    colorValue[1] = Math.pow(Number(arrayValue[1]) / 255.0, 2.2);
    colorValue[2] = Math.pow(Number(arrayValue[2]) / 255.0, 2.2);
    light.color = colorValue;
    light.intensity = Number(arrayValue[3]) / 255.0 * intensityMultiplier;
}
function AngleQuaternion(angles, outQuat) {
    const sy = Math.sin(angles[1] * 0.5);
    const cy = Math.cos(angles[1] * 0.5);
    const sp = Math.sin(angles[0] * 0.5);
    const cp = Math.cos(angles[0] * 0.5);
    const sr = Math.sin(angles[2] * 0.5);
    const cr = Math.cos(angles[2] * 0.5);
    /*SinCos(DEG2RAD(angles[1]) * 0.5f, &sy, &cy);
    SinCos(DEG2RAD(angles[0]) * 0.5f, &sp, &cp);
    SinCos(DEG2RAD(angles[2]) * 0.5f, &sr, &cr);*/
    // NJS: for some reason VC6 wasn't recognizing the common subexpressions:
    const srXcp = sr * cp, crXsp = cr * sp;
    outQuat[0] = srXcp * cy - crXsp * sy; // X
    outQuat[1] = crXsp * cy + srXcp * sy; // Y
    const crXcp = cr * cp, srXsp = sr * sp;
    outQuat[2] = crXcp * sy - srXsp * cy; // Z
    outQuat[3] = crXcp * cy + srXsp * sy; // W (real component)
    return outQuat;
}
//angles[PITCH, YAW, ROLL]
function AngleVectors(angles, forward) {
    const sy = Math.sin(angles[1]);
    const cy = Math.cos(angles[1]);
    const sp = Math.sin(angles[0]);
    const cp = Math.cos(angles[0]);
    forward[0] = cp * cy;
    forward[1] = cp * sy;
    forward[2] = -sp;
}
function ParseAngles(out, str) {
    const angles = ParseVector(out, str);
    if (angles) {
        return vec3.scale(angles, angles, Math.PI / 180);
    }
    return null;
}
function ParseAngles2(out, str) {
    if (ParseVector2(out, str)) {
        return vec3.scale(out, out, Math.PI / 180);
    }
    return null;
}
/**
 * Map entity
 */
class MapEntity extends Entity {
    static incrementalId = 0;
    classname;
    outputs = [];
    m_vecVelocity = vec3.create();
    m_flMoveDoneTime = -1;
    m_flLocalTime = 0;
    f = 0;
    keys = new Map();
    targetName = '';
    parentName;
    map;
    #parentEntity = null;
    constructor(params) {
        super(params);
        this.name = params.className;
        this.map = params.map;
        this.classname = params.className;
        this.id = String(++MapEntity.incrementalId);
        //this.children = Object.create(null);
    }
    setKeyValues(kvElement) {
        if (kvElement) {
            if (kvElement /*TODO: fix that*/.spawnflags) {
                this.f = Number(kvElement /*TODO: fix that*/.spawnflags);
            }
            const entityParams = Object.keys(kvElement);
            for (const key of entityParams) {
                this.setKeyValue(key, kvElement /*TODO: fix that*/[key]);
            }
        }
    }
    setKeyValue(key, value) {
        if (key) {
            this.keys.set(key, value);
            if (key.indexOf('on') == 0) {
                this.addOutput(key.replace(/#\d+$/, ''), value);
            }
            switch (key) {
                case 'targetname':
                    this.targetName = value;
                    break;
                case 'origin':
                    ParseVector(this._position, value);
                    break;
                case 'angles':
                    const angles = ParseAngles(vec3.create() /*TODO: optimize*/, value);
                    if (angles) {
                        AngleQuaternion(angles, this._quaternion);
                    }
                    break;
                case 'parentname':
                    this.parentName = value;
                    break;
            }
        }
    }
    getValue(key) {
        return this.keys.get(key);
    }
    addOutput(outputName, outputValue /*TODO: improve type*/) {
        const output = new MapEntityConnection(outputName);
        this.map.addConnection(output);
        this.outputs.push(output);
        output.fromString(outputValue);
        //console.log(output.outputName, output.getTargetName(), output.getTargetInput(), output.getTargetParameter(), output.getDelay(), output.getFireOnlyOnce());
    }
    setInput(input, parameters /*TODO: improve type*/) {
    }
    getFlag(position) {
        return (this.f >> position) & 1;
    }
    move(delta) {
        this.setPosition(vec3.add(vec3.create(), this._position, delta)); //todo remove me
    }
    /*set position(o) {
        if (o) {
            let oo = this._position;
            if ((o[0] != oo[0]) || (o[1] != oo[1]) || (o[2] != oo[2])) {
                this._position = o;
                let delta = vec3.sub(vec3.create(), this._position, o);
                for (let i in this.children) {
                    let child = this.children[i];
                    child.move(delta, /*initiator || * /this);
                }
            }
        }
    }*/
    /*
    get position() {
        return super.position;
    }
        */
    getAbsOrigin() {
        return vec3.create();
    }
    getLocalOrigin() {
        return this._position;
    }
    getLocalVelocity() {
        return this.m_vecVelocity;
    }
    update(scene, camera, delta) {
        this.m_flLocalTime += delta;
        if (this.parentName) {
            throw 'uncomment next line';
            /*const parent = this.map.getEntityByTargetName(this.parentName);
            if (parent) {
                this.setParent(parent);
                delete this.parentName;
            }
            */
        }
        this.position = vec3.scaleAndAdd(vec3.create(), this.getLocalOrigin(), this.getLocalVelocity(), delta); //TODO removeme : optimize
    }
    setParent(parent) {
        //void CBaseEntity::SetParent(CBaseEntity *pParentEntity, int iAttachment)
        const oldParent = this.parent;
        this.#parentEntity = parent;
        if (parent == this) {
            this.parent = null;
        }
        if (oldParent) {
            oldParent.removeChild(this);
        }
        if (this.parent) {
            this.parent.addChild(this);
        }
    }
    /*addChild(child) {
        if (child) {
            this.children[child.id] = child;
        }
    }

    removeChild(child) {
        if (child) {
            delete this.children[child.id];
        }
    }*/
    setLocalVelocity(vecVelocity) {
        vec3.copy(this.m_vecVelocity, vecVelocity);
    }
    setMoveDoneTime(delay) {
        if (delay >= 0) {
            this.m_flMoveDoneTime = this.getLocalTime() + delay;
        }
        else {
            this.m_flMoveDoneTime = -1;
        }
    }
    getLocalTime() {
        return this.m_flLocalTime;
    }
    fireOutput(outputName) {
        for (const output of this.outputs) {
            if (outputName == output.outputName) {
                //result.push(connection);
                output.fire(this.map);
            }
        }
    }
    toString() {
        return this.classname;
    }
}
MapEntity.incrementalId = 0;
/**
 * Entity connection
 */
class MapEntityConnection {
    //'OnMapSpawn' 'tonemap_global,SetAutoExposureMax,.8,0,-1'
    name;
    parameters = null;
    constructor(name) {
        this.name = name;
        this.parameters = null;
    }
    fromString(stringDatas) {
        const parameters = stringDatas.split(',');
        if (parameters && parameters.length == 5) {
            this.parameters = parameters;
        }
    }
    get outputName() {
        return this.name;
    }
    getTargetName() {
        const parameters = this.parameters;
        if (parameters) {
            return parameters[0];
        }
    }
    getTargetInput() {
        const parameters = this.parameters;
        if (parameters) {
            return parameters[1];
        }
    }
    getTargetParameter() {
        const parameters = this.parameters;
        if (parameters) {
            return parameters[2];
        }
    }
    getDelay() {
        const parameters = this.parameters;
        if (parameters) {
            return parameters[3];
        }
    }
    getFireOnlyOnce() {
        const parameters = this.parameters;
        if (parameters) {
            return parameters[4];
        }
    }
    fire(map) {
        const parameters = this.parameters;
        if (parameters) {
            throw 'uncomment next line';
            //map.setTargetsInput(parameters[0], parameters[1], parameters[2]);
        }
    }
}

/**
 * BSP lump
 * @param {Number} type The lump type
 */
class SEBaseBspLump {
    map;
    initialized = false;
    mapOffset;
    mapLength;
    lumpOffset;
    lumpLen;
    lumpDataPromise = null;
    //reader;
    #lzmaReader;
    //mapLen;
    lumpVersion = 0;
    lumpData = null;
    lumpType = 0;
    constructor(map, reader, offset, length) {
        this.map = map;
        //this.reader = reader;//TODOv3 remove reader
        this.mapOffset = offset;
        this.mapLength = length;
        this.lumpOffset = offset;
        this.lumpLen = length;
    }
    init() {
        throw 'remove me';
        /*
        if (this.reader.getString(4, this.lumpOffset) == 'LZMA') {
            const uncompressedSize = this.reader.getUint32();
            const compressedSize = this.reader.getUint32();
            const properties = this.reader.getBytes(5);
            const compressedDatas = this.reader.getBytes(this.lumpLen - 17);

            this.lzmaReader = new jDataView(SourceEngine.Choreographies._decompress(properties, compressedDatas, uncompressedSize), undefined, undefined, true);

            this.lumpOffset = 0;
            this.lumpLen = uncompressedSize;
        } else {
            //lumpData.str = this.reader.getString(lump.getLumpLen(), startOffset);
        }
        this.initialized = true;
        */
    }
    /**
     * Set lump offset
     * @param {Number} newLumpOffset The lump offset
     */
    /*setLumpOffset(newLumpOffset) {
        this.lumpOffset = newLumpOffset;
    }*/
    /**
     * Get lump offset
     * @return {Number} The lump offset
     */
    getLumpOffset() {
        return this.lumpOffset;
    }
    getMapOffset() {
        return this.mapOffset;
    }
    /**
     * Set lump len
     * @param {Number} newLumpLen The lump len
     */
    /*setLumpLen(newLumpLen) {
        this.lumpLen = newLumpLen;
    }*/
    /**
     * Get lump len
     * @return {Number} The lump len
     */
    getLumpLen() {
        return this.lumpLen;
    }
    /*
    getMapLen() {
        return this.mapLen;
    }
    */
    /**
     * Set lump Version
     * @param {Number} newLumpVersion The lump Version
     */
    setLumpVersion(newLumpVersion) {
        this.lumpVersion = newLumpVersion;
    }
    /**
     * Get lump Version
     * @return {Number} The lump Version
     */
    getLumpVersion() {
        return this.lumpVersion;
    }
    /**
     * Set lump Data
     * @param {Object} newLumpData The lump data
     */
    setLumpData(newLumpData) {
        this.lumpData = newLumpData;
    }
    /**
     * Get lump data
     * @return {Object} The lump data
     */
    getLumpData() {
        const datas = this.lumpData;
        if (!datas) {
            this.initDatas();
        }
        return this.lumpData;
    }
    /*
    getReader() {
        if (!this.initialized) {
            this.init();
        }
        if (this.#lzmaReader) {
            this.#lzmaReader.seek(0);
            return this.#lzmaReader;
        } else {
            this.reader.seek(this.lumpOffset);
            return this.reader;
        }
    }
    */
    initDatas() {
    }
}
/**
 * BSP lump
 * @param {Number} type The lump type
 */
class SourceBSPLump extends SEBaseBspLump {
    constructor(map, type, reader, offset, length) {
        super(map, reader, offset, length);
        this.lumpType = type;
    }
}
const LUMP_ENTITIES = 0;
const LUMP_PLANES = 1;
const LUMP_TEXDATA = 2;
const LUMP_VERTEXES = 3;
const LUMP_VISIBILITY = 4;
const LUMP_NODES = 5;
const LUMP_TEXINFO = 6;
const LUMP_FACES = 7;
const LUMP_LIGHTING = 8;
const LUMP_LEAFS = 10;
const LUMP_EDGES = 12;
const LUMP_SURFEDGES = 13;
const LUMP_MODELS = 14;
const LUMP_LEAFFACES = 16;
const LUMP_LEAFBRUSHES = 17;
const LUMP_BRUSHES = 18;
const LUMP_BRUSHSIDES = 19;
const LUMP_DISPINFO = 26;
const LUMP_ORIGINALFACES = 27;
const LUMP_DISP_VERTS = 33; // CDispVerts
//		 For each lightmap sample
//				 byte for index
//				 if 255; then index = next byte + 255
//				 3 bytes for barycentric coordinates
// The game lump is a method of adding game-specific lumps
// FIXME: Eventually; all lumps could use the game lump system
const LUMP_GAME_LUMP = 35;
// A pak file can be embedded in a .bsp now; and the file system will search the pak
//	file first for any referenced names; before deferring to the game directory
//	file system/pak files and finally the base directory file system/pak files.
const LUMP_PAKFILE = 40;
const LUMP_TEXDATA_STRING_DATA = 43;
const LUMP_TEXDATA_STRING_TABLE = 44;
const LUMP_OVERLAYS = 45;
const LUMP_DISP_TRIS = 48;
// optional lumps for HDR
const LUMP_LIGHTING_HDR = 53;
const LUMP_FACES_HDR = 58; // HDR maps may have different face data.
class SourceBSPLumpPlane {
    normal;
    dist;
    type;
    constructor(normal, dist, type) {
        this.normal = vec3.clone(normal); // normal vector
        this.dist = dist; // distance from origin
        this.type = type; // plane axis identifier
    }
}
class SourceBSPLumpEdge {
    // f: first index s: second index
    f = 0; // better than store as an array of 2 ?
    s = 0;
}
class SourceBSPLumpFace {
    initialized = false;
    planenum = 0;
    side = 0;
    onNode = 0;
    firstedge = 0;
    numedges = 0;
    texinfo = 0;
    dispinfo = 0;
    surfaceFogVolumeID = 0;
    styles = [];
    lightofs = 0;
    area = 0;
    lightmapTextureMinsInLuxels = [];
    lightmapTextureSizeInLuxels = [];
    origFace = 0;
    numPrims = 0;
    firstPrimID = 0;
    smoothingGroups = 0;
}
/*
unsigned short	planenum;		// the plane number
byte		side;			// faces opposite to the node's plane direction
byte		onNode;			// 1 of on node, 0 if in leaf
int		firstedge;		// index into surfedges
short		numedges;		// number of surfedges
short		texinfo;		// texture info
short		dispinfo;		// displacement info
short		surfaceFogVolumeID;	// ?
byte		styles[4];		// switchable lighting info
int		lightofs;		// offset into lightmap lump
float		area;			// face area in units^2
int		LightmapTextureMinsInLuxels[2];	// texture lighting info
int		LightmapTextureSizeInLuxels[2];	// texture lighting info
int		origFace;		// original face this was split from
unsigned short	numPrims;		// primitives
unsigned short	firstPrimID;
unsigned int	smoothingGroups;	// lightmap smoothing group
*/
class SourceBSPLumpTexData {
    reflectivity = vec3.create(); // RGB reflectivity
    nameStringTableID = 0; // index into TexdataStringTable
    width = 0;
    height = 0; // source image
    view_width = 0;
    view_height = 0;
}
/*
const SourceBSPLumpGameLump = function() {
    this.id = null;		// gamelump ID
    this.flags = null;		// flags
    this.version = null;	// gamelump version
    this.fileofs = null;	// offset to this gamelump
    this.filelen = null;	// length
}*/
/**
 * BSP lump
 * @param {Number} type The lump type
 */
class SourceBSPLumpGameLump extends SEBaseBspLump {
    id = '';
    flags = 0;
    version = 0;
}
class SourceBSPLumpPropStaticDirectory {
    name = [];
    leaf = [];
    props = [];
}
class SourceBSPLumpPropDetailDirectory {
    name = [];
    leaf = [];
    props = [];
}
class SourceBSPLumpPropStatic {
    position = vec3.create();
    angles = vec3.create();
    propType = 0;
    firstLeaf = 0;
    leafCount = 0;
    solid = 0;
    flags = 0;
    skin = 0;
    fadeMinDist = 0;
    fadeMaxDist = 0;
    lightingOrigin = vec3.create();
    forcedFadeScale = 0;
    minDXLevel = 0;
    maxDXLevel = 0;
    minCPULevel = 0;
    maxCPULevel = 0;
    minGPULevel = 0;
    maxGPULevel = 0;
    diffuseModulation = 0;
    disableX360 = 0;
}
class SourceBSPLumpTexInfo {
    textureVecs = [vec4.create(), vec4.create()]; // [s/t][xyz offset]
    lightmapVecs = [vec4.create(), vec4.create()]; // [s/t][xyz offset] - length is in units of texels/area
    flags = 0; // miptex flags	overrides
    texdata = 0;
}
class SourceBSPLumpDispInfo {
    startPosition = vec3.create();
    dispVertStart = 0;
    dispTriStart = 0;
    power = 0;
    minTess = 0;
    smoothingAngle = 0;
    contents = 0;
    mapFace = 0;
    lightmapAlphaStart = 0;
    lightmapSamplePositionStart = 0;
    allowedVerts = [];
}
class SourceBSPLumpDispNeighbor {
    subNeighbors = [];
}
class SourceBSPLumpDispSubNeighbor {
    iNeighbor = 0;
    orientation = 0;
    span = 0;
    neighSpan = 0;
}
/*TODO
const SourceBSPLumpDispSubNeighbor
{
};*/
class SourceBSPLumpDispVertex {
    vec = vec3.create();
    dist = 0;
    alpha = 0;
}
class SourceBSPLumpColorRGBExp32 {
    color = vec4.create();
}
class SourceBSPLumpBrush {
    firstside = 0;
    numsides = 0;
    contents = 0;
}
class SourceBSPLumpBrushSide {
    planenum = 0;
    texinfo = 0;
    dispinfo = 0;
    bevel = 0;
}
class SourceBSPLumpModel {
    //readonly mins = vec3.create();
    //readonly maxs = vec3.create();
    position = vec3.create();
    headnode = 0;
    firstface = 0;
    numfaces = 0;
}
/*const SourceBSPLumpLeaf = function() {
/*

    DECLARE_BYTESWAP_DATADESC();
    int				contents;			// OR of all brushes (not needed?)

    short			cluster;

    BEGIN_BITFIELD(bf);
    short			area:9;
    short			flags:7;			// Per leaf flags.
    END_BITFIELD();

    short			mins[3];			// for frustum culling
    short			maxs[3];

    unsigned short	firstleafface;
    unsigned short	numleaffaces;

    unsigned short	firstleafbrush;
    unsigned short	numleafbrushes;
    * /
    this.contents = null;
    this.cluster = null;
    this.areaflags = null;
    this.mins = null;
    this.maxs = null;
    this.firstleafface = null;
    this.numleaffaces = null;
    this.firstleafbrush = null;
    this.numleafbrushes = null;
    this.leafWaterDataID = null;
}*/
class SourceBSPLumpLeaf {
    contents = 0;
    cluster = -1;
    areaflags = 0;
    mins = vec3.create();
    maxs = vec3.create();
    firstleafface = 0;
    numleaffaces = 0;
    firstleafbrush = 0;
    numleafbrushes = 0;
    leafWaterDataID = 0;
    contains(position) {
        const mins = this.mins;
        const maxs = this.maxs;
        if (mins[0] <= position[0]
            && mins[1] <= position[1]
            && mins[2] <= position[2]
            && maxs[0] >= position[0]
            && maxs[1] >= position[1]
            && maxs[2] >= position[2]) {
            return true;
        }
        return false;
    }
}
/*const SourceBSPLumpNode = function() {
/*
int			planenum;
int			children[2];	// negative numbers are -(leafs+1), not nodes
short		mins[3];		// for frustom culling
short		maxs[3];
unsigned short	firstface;
unsigned short	numfaces;	// counting both sides
short			area;		// If all leaves below this node are in the same area, then
                            // this is the area index. If not, this is -1.
    * /
    this.planenum = null;
    this.children = null;
    this.mins = null;
    this.maxs = null;
    this.firstface = null;
    this.numfaces = null;
    this.area = null;
}*/
class SourceBSPLumpNode {
    planenum = 0;
    children = [0, 0];
    mins = vec3.create();
    maxs = vec3.create();
    firstface = -1;
    numfaces = -1;
    area = 0;
    contains(position) {
        const mins = this.mins;
        const maxs = this.maxs;
        if (mins[0] <= position[0]
            && mins[1] <= position[1]
            && mins[2] <= position[2]
            && maxs[0] >= position[0]
            && maxs[1] >= position[1]
            && maxs[2] >= position[2]) {
            return true;
        }
        return false;
    }
}
const OVERLAY_BSP_FACE_COUNT = 64;
class SourceBSPLumpOverlay {
    id = 0;
    texInfo = 0;
    FaceCountAndRenderOrder = 0;
    faces = new Int32Array(OVERLAY_BSP_FACE_COUNT);
    u = [0, 0];
    v = [0, 0];
    uvPoint0 = vec3.create();
    uvPoint1 = vec3.create();
    uvPoint2 = vec3.create();
    uvPoint3 = vec3.create();
    origin = vec3.create();
    basisNormal = vec3.create();
}
class SourceBSPLumpEntity {
    str = '';
    kv;
}

/**
 * BSP Tree
 */
class Source1BspTree {
    #map;
    visibilityClusters = undefined;
    clustersCount = 0;
    countRemoveMe = 0;
    #leavesRemoveme = [];
    constructor(map) {
        this.#map = map;
    }
    /*
    set clusters(clusters) {
        if (clusters) {
            this.visibilityClusters = clusters.clusterVis;
            this.clustersCount = clusters.clusterCount;

            this.countRemoveMe++;
            if (this.countRemoveMe > 5000) {
                this.countRemoveMe = 0;
                console.error('Fix me');
            }
        }
    }
    */
    getLeafId(pos) {
        //TODO: optimize
        const map = this.#map;
        const lumpModels = map.getLumpData(LUMP_MODELS);
        const lumpPlanes = map.getLumpData(LUMP_PLANES);
        const lumpNodes = map.getLumpData(LUMP_NODES);
        const lumpLeafs = map.getLumpData(LUMP_LEAFS);
        const lumpLeafFaces = map.getLumpData(LUMP_LEAFFACES);
        const lumpVisibility = map.getLumpData(LUMP_VISIBILITY);
        if (lumpModels && lumpPlanes && lumpNodes && lumpLeafs && lumpLeafFaces && lumpVisibility && lumpModels.length > 0) {
            const model = lumpModels[0];
            let index = model.headnode;
            let node = null;
            let plane = null;
            vec3.create();
            let dist = 0;
            while (index >= 0) {
                node = lumpNodes[index];
                if (!node) {
                    break;
                }
                plane = lumpPlanes[node.planenum];
                if (!plane) {
                    break;
                }
                //normal[0] = plane.normal.x; normal[1] = plane.normal.y; normal[2] = plane.normal.z; // TODO: Not this.
                //dist = vec3.dot(normal, pos) - plane.dist;
                dist = vec3.dot(plane.normal, pos) - plane.dist;
                if (dist >= 0) {
                    index = node.children[0];
                }
                else {
                    index = node.children[1];
                }
            }
            return -(index + 1);
        }
        else {
            return undefined;
        }
    }
    isLeafVisible(fromLeafId, toLeafId) {
        if (fromLeafId == toLeafId) {
            return true;
        } // Leaves are always visible from themselves
        const lumpLeafs = this.#map.getLumpData(LUMP_LEAFS);
        if (lumpLeafs && this.visibilityClusters) {
            const fromLeaf = lumpLeafs[fromLeafId];
            const toLeaf = lumpLeafs[toLeafId];
            if (!fromLeaf || !toLeaf) {
                return false;
            }
            if (fromLeaf.cluster == -1 || toLeaf.cluster != -1) {
                return false;
            }
            return this.visibilityClusters[(fromLeaf.cluster * this.clustersCount) + toLeaf.cluster];
        }
        return false;
    }
    isVisLeaf(leafId) {
        const lumpLeafs = this.#map.getLumpData(LUMP_LEAFS);
        if (lumpLeafs) {
            const lumpLeaf = lumpLeafs[leafId];
            if (lumpLeaf) {
                return lumpLeaf.cluster != -1;
            }
        }
        return true;
    }
    addPropToLeaf(leafId, propId) {
        const leaf = this.#leavesRemoveme[leafId] || [];
        this.#leavesRemoveme[leafId] = leaf;
        leaf.push(propId);
    }
}

/**
 * Light Map
 */
let lightMapNodeId = 0;
/**
 * TODO
 */
class SELightMapNode {
    x;
    y;
    width;
    height;
    content = null;
    filled = false;
    id = ++lightMapNodeId;
    sub1;
    sub2;
    constructor(x, y, width, height) {
        this.y = y;
        this.x = x;
        this.height = height;
        this.width = width;
    }
    setContent(content) {
        if (this.sub1) {
            return false;
        }
        this.content = content;
    }
    split(x, y) {
        if (this.content)
            return false;
        if (this.filled)
            return false;
        if (y >= this.height)
            return false;
        if (x >= this.width)
            return false;
        if (y != 0 && x != 0)
            return false;
        if (y == 0) { /* splitting vertically */
            this.sub1 = new SELightMapNode(this.x, this.y, x, this.height);
            this.sub2 = new SELightMapNode(this.x + x, this.y, this.width - x, this.height);
        }
        else { /* splitting horizontally */
            this.sub1 = new SELightMapNode(this.x, this.y, this.width, y);
            this.sub2 = new SELightMapNode(this.x, this.y + y, this.width, this.height - y);
        }
    }
    allocate(width, height) {
        if (this.filled)
            return null;
        if (this.content)
            return null;
        if (height == 0)
            return null;
        if (width == 0)
            return null;
        if (height > this.height)
            return null;
        if (width > this.width)
            return null;
        let node;
        if (this.sub1) {
            node = this.sub1.allocate(width, height);
            if (node) {
                this.checkFull();
                return node;
            }
        }
        if (this.sub2) {
            node = this.sub2.allocate(width, height);
            if (node) {
                this.checkFull();
                return node;
            }
        }
        if (height == this.height && width == this.width) {
            this.filled = true;
            return this;
        }
        if ((height / this.height) > (width / this.width)) {
            this.split(width, 0);
        }
        else {
            this.split(0, height);
        }
        if (this.sub1) {
            node = this.sub1.allocate(width, height);
            if (node) {
                this.checkFull();
                return node;
            }
        }
        if (this.sub2) {
            node = this.sub2.allocate(width, height);
            this.checkFull();
            if (node) {
                this.checkFull();
                return node;
            }
        }
        return null;
    }
    toString() {
        return this.id;
    }
    checkFull() {
        if (this.sub1?.filled && this.sub2?.filled) {
            this.filled = true;
        }
    }
    getAllocatedSize() {
        let total = 0;
        if (this.sub1) {
            total += this.sub1?.getAllocatedSize() ?? 0;
            total += this.sub2?.getAllocatedSize() ?? 0;
            return total;
        }
        if (this.filled) {
            return this.height * this.width;
        }
        return 0;
    }
}

const DISPLACEMENT_DELTA = 1.0; // max distance from start position
const LIGTH_MAP_TEXTURE_SIZE = 1024;
class SourceBSP extends World {
    repository;
    bspFileVersion = 0;
    lumps = [];
    mapRevision = 0;
    loaded = false;
    bufferInitialized = false;
    staticGeometry = {};
    skyBoxStaticGeometry = {};
    skyboxGeometry = {};
    overlayVerticesByTexture = {};
    mainLightMap = new SELightMapNode(0, 0, LIGTH_MAP_TEXTURE_SIZE, LIGTH_MAP_TEXTURE_SIZE);
    lightMapTexture = null;
    skyCamera = null;
    skyName = null;
    entities = [];
    #connections = [];
    mapSpawn = true;
    lastLeaf = undefined;
    bspTree;
    frameCount = 0;
    mustParseHeader = true;
    funcBrushesRemoveMe = [];
    partialLoading = false;
    eventTarget = new EventTarget(); //TODOv3
    staticProps = new Group({ name: 'Static props' });
    dynamicProps = new Group({ name: 'Dynamic props' });
    mapFaces = new Group({ name: 'World geometry' });
    #characterSpawn;
    #geometries = {}; //TODO: turn into map
    //loader;
    constructor(params /*TODO: fix type*/) {
        super(params);
        this.repository = params.repository;
        //this.staticProps = [];
        this.bspTree = new Source1BspTree(this);
        //this.loadFile(root, fileName);
        //BspMap.defaultMaterial = BspMap.defaultMaterial ||	SourceEngine.Materials.MaterialManager._loadMaterial('', SourceEngine.Settings.Materials.defaultLightMappedMaterial).then(function(material){BspMap.defaultMaterial = material;});TODOv3
        this.addChild(this.staticProps);
        this.addChild(this.dynamicProps);
        this.addChild(this.mapFaces);
    }
    initMap() {
        this.#initGeometry();
        this.#createEntities();
        this.#createStaticProps();
    }
    #createEntities() {
        const lumpEntities = this.getLumpData(LUMP_ENTITIES);
        if (lumpEntities) {
            this.#createDynamicEntities(lumpEntities.kv);
            /*new Promise((resolve) => {
                this.createDynamicEntities(entities.kv);
                this.eventTarget.dispatchEvent(new CustomEvent('entitiescreated'));//TODOv3
                resolve();
            });*/
        }
    }
    #createStaticProps() {
        const gameLump = this.getLumpData(LUMP_GAME_LUMP);
        const staticLump = gameLump?.get('prps');
        const propsStatic = staticLump?.getLumpData();
        if (propsStatic) {
            //const propsStatic = lumpGameDatas.prps.lumpData;
            const propNames = propsStatic.name;
            const props = propsStatic.props;
            const tempQuaternion = quat.create();
            for (const prop of props) {
                const propName = propNames[prop.propType];
                if (!propName) {
                    continue;
                }
                Source1ModelManager.createInstance(this.repository, propName, true).then((model) => {
                    if (model) {
                        this.staticProps.addChild(model);
                        model.position = prop.position;
                        model.quaternion = AngleQuaternion(prop.angles, tempQuaternion);
                        model.skin = String(prop.skin);
                    }
                });
            }
        }
    }
    #createDynamicEntities(kv) {
        const list = Object.keys(kv.rootElements);
        for (const name of list) {
            const entity = kv.rootElements[name];
            if (entity.classname) {
                const e = MapEntities.createEntity(this, entity.classname);
                if (e) {
                    e.setKeyValues(entity);
                    this.#addEntity(e);
                }
                else {
                    console.error('Unknown classname : %s', entity.classname);
                }
                if (entity.classname == 'sky_camera') {
                    this.skyCamera = e;
                    //this.renderBuffer = false;
                }
                if (entity.classname == 'worldspawn' && entity.skyname) {
                    //console.log(entity.skyname);
                    this.skyName = entity.skyname;
                }
                if (entity.classname == 'info_player_teamspawn') {
                    if (!this.#characterSpawn) {
                        this.#characterSpawn = vec3.scale(vec3.create(), entity.origin.split(' '), 1);
                    }
                }
            }
        }
    }
    addLump(lump) {
        this.lumps.push(lump);
    }
    getLumpData(lumpType) {
        const lump = this.lumps[lumpType];
        if (lump) {
            return lump.getLumpData();
        }
        return null;
    }
    #initFaceGeometry(face, position) {
        if (face.initialized) { //TODOv3
            return;
        }
        face.initialized = true;
        this.getLumpData(LUMP_FACES);
        const lumpTexInfo = this.getLumpData(LUMP_TEXINFO);
        const lumpTexData = this.getLumpData(LUMP_TEXDATA);
        const lumpTexDataStringData = this.getLumpData(LUMP_TEXDATA_STRING_DATA);
        const lumpSurfEdges = this.getLumpData(LUMP_SURFEDGES);
        const lumpEdges = this.getLumpData(LUMP_EDGES);
        const lumpVertices = this.getLumpData(LUMP_VERTEXES);
        if (!lumpEdges || !lumpVertices || !lumpTexInfo || !lumpTexData || !lumpTexDataStringData || !lumpSurfEdges) {
            return;
        }
        const texInfo = lumpTexInfo[face.texinfo];
        if (!texInfo) {
            return;
        }
        const texData = lumpTexData[texInfo.texdata];
        if (!texData) {
            return;
        }
        const texName = lumpTexDataStringData[texData.nameStringTableID];
        if (!texName) {
            return;
        }
        //console.log(face);
        let buffer = this.#geometries[texName];
        if (!buffer) {
            buffer = {
                lastIndice: 0,
                vertices: [], indices: [], coords: [], alphas: [],
                triangleArray: [], alphaArray: [], textureCoord: [], lightMaps: [], textureVecs: texInfo.textureVecs, height: texData.height, width: texData.width
            }; //TODOv3
            this.#geometries[texName] = buffer;
        }
        const textureVecsU = texInfo.textureVecs[0];
        const textureVecsV = texInfo.textureVecs[1];
        const firstEdge = face.firstedge;
        const lastEdge = firstEdge + face.numedges;
        const firstIndice = buffer.lastIndice;
        for (let surfEdgeIndex = firstEdge; surfEdgeIndex < lastEdge; ++surfEdgeIndex) {
            const surfedge = lumpSurfEdges[surfEdgeIndex];
            if (!surfedge) {
                continue;
            }
            //			const surfedge = lumpSurfEdges[surfEdgeIndex];
            const edge = lumpEdges[Math.abs(surfedge)]; //TODOv3 ? why abs
            if (edge === undefined) {
                continue;
            }
            let vertice1, vertice2;
            if (surfedge <= 0) {
                vertice1 = lumpVertices[edge.f];
                vertice2 = lumpVertices[edge.s];
            }
            else {
                vertice2 = lumpVertices[edge.f];
                vertice1 = lumpVertices[edge.s];
            }
            if (vertice1 && vertice2) {
                if (position) {
                    buffer.vertices.push(vertice1[0] + position[0]); //TODOv3: optimize
                    buffer.vertices.push(vertice1[1] + position[1]);
                    buffer.vertices.push(vertice1[2] + position[2]);
                    buffer.vertices.push(vertice2[0] + position[0]);
                    buffer.vertices.push(vertice2[1] + position[1]);
                    buffer.vertices.push(vertice2[2] + position[2]);
                }
                else {
                    buffer.vertices.push(vertice1[0]); //TODOv3: optimize
                    buffer.vertices.push(vertice1[1]);
                    buffer.vertices.push(vertice1[2]);
                    buffer.vertices.push(vertice2[0]);
                    buffer.vertices.push(vertice2[1]);
                    buffer.vertices.push(vertice2[2]);
                }
                buffer.coords.push((vertice1[0] * textureVecsU[0] + vertice1[1] * textureVecsU[1] + vertice1[2] * textureVecsU[2] + textureVecsU[3]) / texData.width);
                buffer.coords.push((vertice1[0] * textureVecsV[0] + vertice1[1] * textureVecsV[1] + vertice1[2] * textureVecsV[2] + textureVecsV[3]) / texData.height);
                buffer.coords.push((vertice2[0] * textureVecsU[0] + vertice2[1] * textureVecsU[1] + vertice2[2] * textureVecsU[2] + textureVecsU[3]) / texData.width);
                buffer.coords.push((vertice2[0] * textureVecsV[0] + vertice2[1] * textureVecsV[1] + vertice2[2] * textureVecsV[2] + textureVecsV[3]) / texData.height);
                buffer.indices.push(firstIndice); //TODOv3: optimize
                buffer.indices.push(buffer.lastIndice++); //TODOv3: optimize
                buffer.indices.push(buffer.lastIndice++); //TODOv3: optimize
            }
        }
    }
    #initDispGeometry(dispInfo, face) {
        if (face.initialized) { //TODOv3
            return;
        }
        face.initialized = true;
        this.getLumpData(LUMP_FACES);
        const lumpTexInfo = this.getLumpData(LUMP_TEXINFO);
        const lumpTexData = this.getLumpData(LUMP_TEXDATA);
        const lumpTexDataStringData = this.getLumpData(LUMP_TEXDATA_STRING_DATA);
        const lumpSurfEdges = this.getLumpData(LUMP_SURFEDGES);
        const lumpEdges = this.getLumpData(LUMP_EDGES);
        const lumpVertices = this.getLumpData(LUMP_VERTEXES);
        const lumpDispVerts = this.getLumpData(LUMP_DISP_VERTS);
        if (!lumpTexInfo || !lumpTexData || !lumpTexDataStringData || !lumpSurfEdges || !lumpEdges || !lumpVertices || !lumpDispVerts) {
            return;
        }
        const texInfo = lumpTexInfo[face.texinfo];
        if (!texInfo) {
            return;
        }
        const texData = lumpTexData[texInfo.texdata];
        if (!texData) {
            return;
        }
        const texName = lumpTexDataStringData[texData.nameStringTableID];
        if (!texName) {
            return;
        }
        //console.log(face);
        let buffer = this.#geometries[texName];
        if (!buffer) {
            buffer = {
                lastIndice: 0,
                vertices: [], indices: [], coords: [], alphas: [],
                triangleArray: [], alphaArray: [], textureCoord: [], lightMaps: [], textureVecs: texInfo.textureVecs, height: texData.height, width: texData.width
            }; //TODOv3
            this.#geometries[texName] = buffer;
        }
        const textureVecsU = texInfo.textureVecs[0];
        const textureVecsV = texInfo.textureVecs[1];
        const firstEdge = face.firstedge;
        const lastEdge = firstEdge + face.numedges;
        const origVertices = [];
        for (let surfEdgeIndex = firstEdge; surfEdgeIndex < lastEdge; ++surfEdgeIndex) {
            const surfedge = lumpSurfEdges[surfEdgeIndex];
            if (surfedge === undefined) {
                continue;
            }
            const edge = lumpEdges[Math.abs(surfedge)]; //TODOv3 ? why abs
            if (edge === undefined) {
                continue;
            }
            let vertice1;
            if (surfedge <= 0) {
                vertice1 = lumpVertices[edge.f];
                lumpVertices[edge.s];
            }
            else {
                lumpVertices[edge.f];
                vertice1 = lumpVertices[edge.s];
            }
            if (vertice1) {
                origVertices.push(vertice1);
            }
        }
        for (let testremoveme = 0; testremoveme < 4; testremoveme++) {
            const vvremoveme = origVertices[0];
            if (!vvremoveme) {
                continue;
            }
            if (Math.abs(vvremoveme[0] - dispInfo.startPosition[0]) < DISPLACEMENT_DELTA
                && Math.abs(vvremoveme[1] - dispInfo.startPosition[1]) < DISPLACEMENT_DELTA
                && Math.abs(vvremoveme[2] - dispInfo.startPosition[2]) < DISPLACEMENT_DELTA) {
                break;
            }
            origVertices.push(origVertices.shift());
        }
        if (origVertices.length < 4) {
            return;
        }
        let subdiv = Math.pow(2, dispInfo.power);
        const verticesPerSide = subdiv + 1;
        const tesselateVertices = []; // vec4 is used for position + alpha
        /* create tesslate array */
        for (let i = 0; i < verticesPerSide; ++i) {
            const row = [];
            tesselateVertices.push(row);
            for (let j = 0; j < verticesPerSide; ++j) {
                row[j] = vec4.create();
            }
        }
        vec3.copy(tesselateVertices[0][0], origVertices[0]);
        vec3.copy(tesselateVertices[0][verticesPerSide - 1], origVertices[3]);
        vec3.copy(tesselateVertices[verticesPerSide - 1][verticesPerSide - 1], origVertices[2]);
        vec3.copy(tesselateVertices[verticesPerSide - 1][0], origVertices[1]);
        for (let level = 0; level < dispInfo.power; ++level) {
            const squares = Math.pow(2, level);
            //const levelVerts2 = Math.pow(2, level) + 1;
            const subdiv2 = subdiv / 2;
            for (let i = 0; i < squares; ++i) {
                for (let j = 0; j < squares; ++j) {
                    const iMin = subdiv * i;
                    const iMax = iMin + subdiv;
                    const jMin = subdiv * j;
                    const jMax = jMin + subdiv;
                    const v1 = tesselateVertices[iMin][jMin];
                    const v2 = tesselateVertices[iMax][jMin];
                    const v3 = tesselateVertices[iMin][jMax];
                    const v4 = tesselateVertices[iMax][jMax];
                    const iMid = iMin + subdiv2;
                    const jMid = jMin + subdiv2;
                    if (v1 && v2 && v3 && v4) {
                        Vec3Middle(tesselateVertices[iMid][jMin], v1, v2);
                        Vec3Middle(tesselateVertices[iMid][jMax], v3, v4);
                        const s3 = Vec3Middle(tesselateVertices[iMin][jMid], v1, v3);
                        const s4 = Vec3Middle(tesselateVertices[iMax][jMid], v2, v4);
                        Vec3Middle(tesselateVertices[iMid][jMid], s3, s4);
                    }
                }
            }
            subdiv = subdiv2;
        }
        /* displace vertices */
        let vertexIndex = dispInfo.dispVertStart;
        for (let i = 0; i < verticesPerSide; ++i) {
            for (let j = 0; j < verticesPerSide; ++j) {
                const dispVert = lumpDispVerts[vertexIndex];
                if (dispVert) {
                    const v = tesselateVertices[i][j];
                    if (dispVert.dist > 0) {
                        vec3.scaleAndAdd(v, v, dispVert.vec, dispVert.dist);
                    }
                    v[3] = dispVert.alpha;
                }
                ++vertexIndex;
            }
        }
        subdiv = Math.pow(2, dispInfo.power);
        for (let i = 0; i < subdiv; ++i) {
            for (let j = 0; j < subdiv; ++j) {
                const firstIndice = buffer.lastIndice;
                const v1 = tesselateVertices[i][j];
                const v2 = tesselateVertices[i + 1][j];
                const v3 = tesselateVertices[i + 1][j + 1];
                const v4 = tesselateVertices[i][j + 1];
                if (v1 && v2 && v3 && v4) {
                    buffer.vertices.push(v1[0], v1[1], v1[2]); //TODOv3: optimize
                    buffer.vertices.push(v2[0], v2[1], v2[2]); //TODOv3: optimize
                    buffer.vertices.push(v3[0], v3[1], v3[2]); //TODOv3: optimize
                    buffer.vertices.push(v4[0], v4[1], v4[2]); //TODOv3: optimize
                    buffer.alphas.push(v1[3] / 255.0, v2[3] / 255.0, v3[3] / 255.0, v4[3] / 255.0);
                    buffer.coords.push((v1[0] * textureVecsU[0] + v1[1] * textureVecsU[1] + v1[2] * textureVecsU[2] + textureVecsU[3]) / texData.width);
                    buffer.coords.push((v1[0] * textureVecsV[0] + v1[1] * textureVecsV[1] + v1[2] * textureVecsV[2] + textureVecsV[3]) / texData.height);
                    buffer.coords.push((v2[0] * textureVecsU[0] + v2[1] * textureVecsU[1] + v2[2] * textureVecsU[2] + textureVecsU[3]) / texData.width);
                    buffer.coords.push((v2[0] * textureVecsV[0] + v2[1] * textureVecsV[1] + v2[2] * textureVecsV[2] + textureVecsV[3]) / texData.height);
                    buffer.coords.push((v3[0] * textureVecsU[0] + v3[1] * textureVecsU[1] + v3[2] * textureVecsU[2] + textureVecsU[3]) / texData.width);
                    buffer.coords.push((v3[0] * textureVecsV[0] + v3[1] * textureVecsV[1] + v3[2] * textureVecsV[2] + textureVecsV[3]) / texData.height);
                    buffer.coords.push((v4[0] * textureVecsU[0] + v4[1] * textureVecsU[1] + v4[2] * textureVecsU[2] + textureVecsU[3]) / texData.width);
                    buffer.coords.push((v4[0] * textureVecsV[0] + v4[1] * textureVecsV[1] + v4[2] * textureVecsV[2] + textureVecsV[3]) / texData.height);
                    { //TODOv3
                        buffer.indices.push(firstIndice); //TODOv3: optimize
                        buffer.indices.push(firstIndice + 2);
                        buffer.indices.push(firstIndice + 1);
                        buffer.indices.push(firstIndice + 3);
                        buffer.indices.push(firstIndice + 2);
                        buffer.indices.push(firstIndice);
                    }
                    buffer.lastIndice += 4;
                }
            }
        }
    }
    #initGeometry() {
        this.#geometries = {};
        const lumpFaces = this.getLumpData(LUMP_FACES);
        const lumpLeafs = this.getLumpData(LUMP_LEAFS);
        const lumpLeafFaces = this.getLumpData(LUMP_LEAFFACES);
        //const lumpNodes = this.getLumpData(LUMP_NODES);
        const lumpTexLighting = this.getLumpData(LUMP_LIGHTING);
        const lumpTexInfo = this.getLumpData(LUMP_TEXINFO);
        const lumpTexData = this.getLumpData(LUMP_TEXDATA);
        const lumpTexDataStringData = this.getLumpData(LUMP_TEXDATA_STRING_DATA);
        const lumpSurfEdges = this.getLumpData(LUMP_SURFEDGES);
        const lumpEdges = this.getLumpData(LUMP_EDGES);
        const lumpVertices = this.getLumpData(LUMP_VERTEXES);
        const lumpModels = this.getLumpData(LUMP_MODELS);
        const lumpDispInfos = this.getLumpData(LUMP_DISPINFO);
        if (lumpFaces && lumpLeafs && lumpLeafFaces && /*lumpNodes && */ lumpTexLighting && lumpTexInfo && lumpTexData && lumpTexDataStringData && lumpSurfEdges && lumpEdges && lumpVertices) {
            if (lumpModels) {
                for (const funcBrushesRemove of this.funcBrushesRemoveMe) {
                    //const funcBrushesRemove = this.funcBrushesRemoveMe[i];
                    const modelIndex = funcBrushesRemove.model;
                    const model = lumpModels[modelIndex];
                    if (model) {
                        const firstFace = model.firstface;
                        const lastFace = firstFace + model.numfaces;
                        for (let j = firstFace; j < lastFace; ++j) {
                            const face = lumpFaces[j];
                            //this.renderLeafFace(renderContext, face, funcBrushesRemove.position, 0/*leafId TODO*/);
                            if (face) {
                                this.#initFaceGeometry(face, funcBrushesRemove.origin);
                            }
                        }
                    }
                }
            }
            /* Init displacement buffer */
            if (lumpDispInfos) {
                for (const dispInfo of lumpDispInfos) {
                    const face = lumpFaces[dispInfo.mapFace];
                    if (face) {
                        this.#initDispGeometry(dispInfo, face);
                    }
                }
            }
            for (let leafIndex = 0, l = lumpLeafs.length; leafIndex < l; ++leafIndex) {
                const leaf = lumpLeafs[leafIndex];
                if (!leaf) {
                    continue;
                }
                const firstFace = leaf.firstleafface;
                const lastFace = leaf.firstleafface + leaf.numleaffaces;
                for (let faceIndex = firstFace; faceIndex < lastFace; ++faceIndex) {
                    const face = lumpFaces[lumpLeafFaces[faceIndex]];
                    if (face) {
                        this.#initFaceGeometry(face);
                    }
                }
            }
        }
        for (const textureName in this.#geometries) {
            const geometry = this.#geometries[textureName];
            if (!geometry) {
                continue;
            }
            if (textureName.toLowerCase().substring(0, 5) == 'tools') { //TODOV3
                continue;
                /*
                if (
                //((lumpTexInfo.flags & 4) == 4) // SURF_SKY
                /*|| * /((lumpTexInfo.flags & 40) == 40) // SURF_TRIGGER
                    || ((lumpTexInfo.flags & 200) == 200) // SURF_SKIP
                    //((lumpTexInfo.flags & 400) == 400) // SURF_NOLIGHT
                    //|| true
                ) {
                    continue;
                }
                */
                //continue;
            }
            const bufferGeometry = new BufferGeometry();
            const vertexPosition = new Float32BufferAttribute(geometry.vertices, 3);
            const vertexAlpha = new Float32BufferAttribute(geometry.alphas, 1);
            const textureCoord = new Float32BufferAttribute(geometry.coords, 2);
            bufferGeometry.setIndex(new Uint16BufferAttribute(geometry.indices, 1));
            bufferGeometry.setAttribute('aVertexPosition', vertexPosition);
            bufferGeometry.setAttribute('aVertexAlpha', vertexAlpha);
            bufferGeometry.setAttribute('aTextureCoord', textureCoord);
            bufferGeometry.count = geometry.indices.length;
            const staticMesh = new Mesh({ geometry: bufferGeometry });
            staticMesh.name = textureName;
            Source1MaterialManager.getMaterial(this.repository, textureName).then((material) => {
                if (material) {
                    staticMesh.setMaterial(material);
                }
            });
            this.mapFaces.addChild(staticMesh);
        }
    }
    #addEntity(entity) {
        if (entity) {
            this.entities.push(entity);
        }
    }
    addConnection(connection) {
        if (connection) {
            this.#connections.push(connection);
        }
    }
    getOBBSize(modelIndex) {
        const lumpModels = this.getLumpData(LUMP_MODELS);
        const lumpFaces = this.getLumpData(LUMP_FACES);
        const lumpSurfEdges = this.getLumpData(LUMP_SURFEDGES);
        const lumpEdges = this.getLumpData(LUMP_EDGES);
        const lumpVertices = this.getLumpData(LUMP_VERTEXES);
        if (!lumpModels || !lumpFaces || !lumpSurfEdges || !lumpEdges || !lumpVertices) {
            return null;
        }
        const model = lumpModels[modelIndex];
        if (!model) {
            return null;
        }
        if (model.numfaces == 0) {
            return vec3.create();
        }
        function compare(v) {
            for (let i = 0; i < 3; i++) {
                if (v[i] < min[i]) {
                    min[i] = v[i];
                }
                if (v[i] > max[i]) {
                    max[i] = v[i];
                }
            }
        }
        const min = vec3.fromValues(Infinity, Infinity, Infinity);
        const max = vec3.fromValues(-Infinity, -Infinity, -Infinity);
        const firstFace = model.firstface;
        const lastFace = firstFace + model.numfaces;
        for (let j = firstFace; j < lastFace; j++) {
            const face = lumpFaces[j];
            if (face) {
                const firstEdge = face.firstedge;
                const lastEdge = firstEdge + face.numedges;
                for (let surfEdgeIndex = firstEdge; surfEdgeIndex < lastEdge; surfEdgeIndex++) {
                    const surfedge = lumpSurfEdges[surfEdgeIndex];
                    if (surfedge === undefined) {
                        continue;
                    }
                    const edge = lumpEdges[Math.abs(surfedge)];
                    if (edge === undefined) {
                        continue;
                    }
                    const vertice1 = lumpVertices[edge.f];
                    const vertice2 = lumpVertices[edge.s];
                    if (!vertice1 || !vertice2) {
                        continue;
                    }
                    compare(vertice1);
                    compare(vertice2);
                }
            }
        }
        return vec3.sub(vec3.create(), max, min);
    }
    static getEntityName() {
        return 'BSP Map';
    }
}

const BSP_HEADER_LUMPS_COUNT = 64;
function initLZMALump(reader, lump) {
    if (reader.getString(4, lump.lumpOffset) === 'LZMA') {
        const uncompressedSize = reader.getUint32();
        const compressedSize = reader.getUint32();
        const properties = reader.getBytes(5);
        const compressedDatas = reader.getBytes(compressedSize); // 4 + 4 + 4 + 5
        const result = DecompressLZMA(properties, compressedDatas, uncompressedSize);
        if (result) {
            reader = new BinaryReader(result);
        }
        lump.lumpOffset = 0;
        lump.lumpLen = uncompressedSize;
    }
    return reader;
}
class Source1BspLoader extends SourceBinaryLoader {
    parse(repository, fileName, arrayBuffer) {
        const bsp = new SourceBSP({ repository: repository, name: fileName });
        //bsp.loader = this;
        const reader = new BinaryReader(arrayBuffer);
        this.#parseHeader(reader, bsp);
        this.#parseLumps(reader, bsp);
        return bsp;
    }
    #parseHeader(reader, bsp) {
        reader.seek(4); //skip first 4 char TODO: check == 'VBSP' ?
        bsp.bspFileVersion = reader.getInt32();
        this.#parseLumpDirectory(reader, bsp);
        bsp.mapRevision = reader.getInt32();
    }
    #parseLumpDirectory(reader, bsp) {
        const startOffset = reader.tell();
        for (let lumpIndex = 0; lumpIndex < BSP_HEADER_LUMPS_COUNT; ++lumpIndex) {
            reader.seek(startOffset + lumpIndex * 16);
            const lumpOffset = reader.getInt32();
            const lumpLen = reader.getInt32();
            const lump = new SourceBSPLump(bsp, lumpIndex, reader, lumpOffset, lumpLen); //lump type is the index in lump directory
            //lump.setLumpOffset(reader.getInt32());
            //lump.setLumpLen(reader.getInt32());
            lump.setLumpVersion(reader.getInt32());
            //reader.getInt32() // TODO: replace by lump fourCC
            //lump.init();
            bsp.addLump(lump);
        }
    }
    #parseLumps(reader, bsp) {
        for (const lump of bsp.lumps) {
            this.#parseLump(reader, lump, bsp); //TODOv3: lzma
            //console.error(lump);
        }
    }
    #parseLump(reader, lump, bsp) {
        if (lump.lumpLen === 0) {
            lump.lumpData = Object.create(null);
        }
        else {
            /*if (reader.getString(4, lump.lumpOffset) === 'LZMA') {
                const uncompressedSize = reader.getUint32();
                const compressedSize = reader.getUint32();
                const properties = reader.getBytes(5);
                const compressedDatas = reader.getBytes(lump.lumpLen - 17);// 4 + 4 + 4 + 5

                reader = new BinaryReader(DecompressLZMA(properties, compressedDatas, uncompressedSize));

                lump.lumpOffset = 0;
                lump.lumpLen = uncompressedSize;
            }*/
            reader = initLZMALump(reader, lump);
            switch (lump.lumpType) {
                case LUMP_ENTITIES:
                    this.#parseLumpEntities(reader, lump);
                    break;
                case LUMP_PLANES:
                    this.#parseLumpPlanes(reader, lump);
                    break;
                case LUMP_VERTEXES:
                    this.#parseLumpVertices(reader, lump);
                    break;
                case LUMP_VISIBILITY:
                    this.#parseLumpVisibility(reader, lump);
                    break;
                case LUMP_EDGES:
                    this.#parseLumpEdges(reader, lump);
                    break;
                case LUMP_SURFEDGES:
                    this.#parseLumpSurfEdges(reader, lump);
                    break;
                case LUMP_FACES:
                case LUMP_ORIGINALFACES: //TODO: remove if useless
                case LUMP_FACES_HDR:
                    this.#parseLumpFaces(reader, lump);
                    break;
                case LUMP_TEXDATA:
                    this.#parseLumpTexdata(reader, lump);
                    break;
                case LUMP_TEXDATA_STRING_DATA:
                    this.#parseLumpTexdataStringData(reader, lump);
                    break;
                case LUMP_TEXDATA_STRING_TABLE:
                    this.#parseLumpTexdataStringTable(reader, lump);
                    break;
                case LUMP_GAME_LUMP:
                    this.#parseLumpGameDirectory(reader, lump, bsp);
                    break;
                case LUMP_TEXINFO:
                    this.#parseLumpTexInfo(reader, lump);
                    break;
                case LUMP_DISPINFO:
                    this.#parseLumpDispInfo(reader, lump);
                    break;
                case LUMP_DISP_VERTS:
                    this.#parseLumpDispVerts(reader, lump);
                    break;
                case LUMP_DISP_TRIS:
                    //this._parseLumpDispTris(reader, lump);//TODOv3
                    break;
                case LUMP_LIGHTING:
                case LUMP_LIGHTING_HDR:
                    this.#parseLumpLighting(reader, lump);
                    break;
                case LUMP_BRUSHES:
                    this.#parseLumpBrushes(reader, lump);
                    break;
                case LUMP_BRUSHSIDES:
                    this.#parseLumpBrushSides(reader, lump);
                    break;
                case LUMP_MODELS:
                    this.#parseLumpModels(reader, lump);
                    break;
                case LUMP_LEAFS:
                    this.#parseLumpLeafs(reader, lump);
                    break;
                case LUMP_LEAFFACES:
                    this.#parseLumpLeafFaces(reader, lump);
                    break;
                case LUMP_LEAFBRUSHES:
                    this.#parseLumpLeafbrushes(reader, lump);
                    break;
                case LUMP_NODES:
                    this.#parseLumpNodes(reader, lump);
                    break;
                case LUMP_PAKFILE:
                    this.#parseLumpPakFile(reader, lump);
                    break;
                case LUMP_OVERLAYS:
                    this.#parseLumpOverlays(reader, lump);
                    break;
            }
        }
    }
    #parseLumpEntities(reader, lump) {
        const lumpData = new SourceBSPLumpEntity();
        lumpData.str = reader.getString(lump.getLumpLen(), lump.lumpOffset);
        const kv = new KvReader();
        kv.readText(lumpData.str);
        lumpData.kv = kv;
        lump.setLumpData(lumpData);
    }
    #parseLumpPlanes(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_PLANE = 20;
        const planesCount = lump.getLumpLen() / BYTES_PER_PLANE;
        const lumpData = [];
        for (let planeIndex = 0; planeIndex < planesCount; planeIndex++) {
            const plane = new SourceBSPLumpPlane(reader.getVector3() /*TODO: optimize*/, reader.getFloat32(), reader.getInt32());
            lumpData.push(plane);
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpTexdata(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_TEXDATA = 32;
        const texdataCount = lump.getLumpLen() / BYTES_PER_TEXDATA;
        const lumpData = [];
        for (let texdataIndex = 0; texdataIndex < texdataCount; ++texdataIndex) {
            const texdata = new SourceBSPLumpTexData();
            reader.getVector3(undefined, undefined, texdata.reflectivity);
            texdata.nameStringTableID = reader.getInt32();
            texdata.width = reader.getInt32();
            texdata.height = reader.getInt32();
            texdata.view_width = reader.getInt32();
            texdata.view_height = reader.getInt32();
            lumpData.push(texdata);
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpVertices(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_VERTEX = 12;
        const verticesCount = lump.getLumpLen() / BYTES_PER_VERTEX;
        const lumpData = [];
        for (let vertexIndex = 0; vertexIndex < verticesCount; ++vertexIndex) {
            lumpData.push(reader.getVector3());
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpVisibility(reader, lump) {
        reader.seek(lump.lumpOffset);
        const offset = reader.tell();
        const clusterCount = reader.getInt32();
        const visOffsets = [];
        for (let clusterIndex = 0; clusterIndex < clusterCount; clusterIndex++) {
            visOffsets.push([reader.getInt32(), reader.getInt32()]);
        }
        const numBytes = Math.ceil(clusterCount / 8);
        const clusterVis = new Uint8Array(clusterCount * clusterCount);
        for (let i = 0; i < clusterCount; ++i) {
            const rleVis = new Uint8Array(reader.buffer, offset + visOffsets[i][0], numBytes); //TODOv3 ???
            const clusterOfs = i * clusterCount;
            let v = 0;
            // Unpack the RLE visibility bitfield
            // See code at: http://www.flipcode.com/archives/Quake_2_BSP_File_Format.shtml
            for (let c = 0; c < clusterCount; v++) {
                if (rleVis[v] === 0) {
                    v++;
                    c += 8 * rleVis[v] /*TODO: actually check*/;
                }
                else {
                    for (let bit = 1; bit < 256; bit *= 2, c++) {
                        if (rleVis[v] /*TODO: actually check*/ & bit) {
                            clusterVis[clusterOfs + c] = 1;
                        }
                    }
                }
            }
        }
        const lumpData = { clusterCount: clusterCount, clusterVis: clusterVis };
        lump.setLumpData(lumpData);
    }
    #parseLumpNodes(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_NODE = 32;
        const nodeCount = lump.getLumpLen() / BYTES_PER_NODE;
        const lumpData = [];
        for (let nodeIndex = 0; nodeIndex < nodeCount; ++nodeIndex) {
            const node = new SourceBSPLumpNode();
            node.planenum = reader.getInt32();
            node.children[0] = reader.getInt32();
            node.children[1] = reader.getInt32();
            vec3.set(node.mins, reader.getInt16(), reader.getInt16(), reader.getInt16());
            vec3.set(node.maxs, reader.getInt16(), reader.getInt16(), reader.getInt16());
            node.firstface = reader.getUint16();
            node.numfaces = reader.getUint16();
            node.area = reader.getInt16();
            reader.getInt16();
            //console.log(node);
            lumpData.push(node);
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpTexInfo(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_TEXINFO = 72;
        const texInfoCount = lump.getLumpLen() / BYTES_PER_TEXINFO;
        const lumpData = [];
        for (let texinfoIndex = 0; texinfoIndex < texInfoCount; ++texinfoIndex) {
            const texinfo = new SourceBSPLumpTexInfo();
            reader.getVector4(undefined, undefined, texinfo.textureVecs[0]);
            reader.getVector4(undefined, undefined, texinfo.textureVecs[1]);
            reader.getVector4(undefined, undefined, texinfo.lightmapVecs[0]);
            reader.getVector4(undefined, undefined, texinfo.lightmapVecs[1]);
            texinfo.flags = reader.getInt32();
            texinfo.texdata = reader.getInt32();
            lumpData.push(texinfo);
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpFaces(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_FACE = 56;
        const faceCount = lump.getLumpLen() / BYTES_PER_FACE;
        const lumpData = [];
        for (let faceIndex = 0; faceIndex < faceCount; ++faceIndex) {
            const face = new SourceBSPLumpFace();
            face.planenum = reader.getInt16();
            face.side = reader.getInt8();
            face.onNode = reader.getInt8();
            face.firstedge = reader.getInt32();
            face.numedges = reader.getInt16();
            face.texinfo = reader.getInt16();
            face.dispinfo = reader.getInt16();
            face.surfaceFogVolumeID = reader.getInt16();
            for (let styleIndex = 0; styleIndex < 4; ++styleIndex) {
                const style = reader.getUint8();
                face.styles.push(style);
                /*
                if (style != 255) {
                    face.styleCount = styleIndex + 1;
                }
                */
            }
            face.lightofs = reader.getInt32() / 4;
            face.area = reader.getFloat32();
            face.lightmapTextureMinsInLuxels.push(reader.getInt32(), reader.getInt32());
            face.lightmapTextureSizeInLuxels.push(reader.getInt32(), reader.getInt32());
            //face.LightmapTextureSizeInLuxels = (face.LightmapTextureSizeInLuxels[0] + 1) * (face.LightmapTextureSizeInLuxels[1] + 1);
            face.origFace = reader.getInt32();
            face.numPrims = reader.getUint16();
            face.firstPrimID = reader.getUint16();
            face.smoothingGroups = reader.getInt32();
            lumpData.push(face);
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpLighting(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_LIGHTING = 4;
        const lightingCount = lump.getLumpLen() / BYTES_PER_LIGHTING;
        const lumpData = [];
        for (let lightingIndex = 0; lightingIndex < lightingCount; ++lightingIndex) {
            const lighting = new SourceBSPLumpColorRGBExp32();
            vec4.set(lighting.color, reader.getUint8(), reader.getUint8(), reader.getUint8(), reader.getUint8());
            lumpData.push(lighting);
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpLeafs(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_LEAF = 32;
        const brushSidesCount = lump.getLumpLen() / BYTES_PER_LEAF;
        const lumpData = [];
        for (let brushSideIndex = 0; brushSideIndex < brushSidesCount; ++brushSideIndex) {
            const brushSide = new SourceBSPLumpLeaf();
            brushSide.contents = reader.getInt32();
            brushSide.cluster = reader.getInt16();
            brushSide.areaflags = reader.getInt16();
            vec3.set(brushSide.mins, reader.getInt16(), reader.getInt16(), reader.getInt16());
            vec3.set(brushSide.maxs, reader.getInt16(), reader.getInt16(), reader.getInt16());
            brushSide.firstleafface = reader.getUint16();
            brushSide.numleaffaces = reader.getUint16();
            brushSide.firstleafbrush = reader.getUint16();
            brushSide.numleafbrushes = reader.getUint16();
            brushSide.leafWaterDataID = reader.getInt16();
            reader.getInt16();
            lumpData.push(brushSide);
        }
        for (const leaf of lumpData) {
            //const leaf = lumpData[brushSideIndex];
            if (leaf.numleaffaces) ;
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpEdges(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_EDGE = 4;
        const edgesCount = lump.getLumpLen() / BYTES_PER_EDGE;
        const lumpData = [];
        for (let edgeIndex = 0; edgeIndex < edgesCount; ++edgeIndex) {
            const edge = new SourceBSPLumpEdge();
            edge.f = reader.getUint16();
            edge.s = reader.getUint16();
            lumpData.push(edge);
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpSurfEdges(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_SURFEDGE = 4;
        const surfedgesCount = lump.getLumpLen() / BYTES_PER_SURFEDGE;
        const lumpData = [];
        for (let surfedgeIndex = 0; surfedgeIndex < surfedgesCount; ++surfedgeIndex) {
            lumpData.push(reader.getInt32());
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpModels(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_MODEL = 48;
        const brushSidesCount = lump.getLumpLen() / BYTES_PER_MODEL;
        const lumpData = [];
        for (let brushSideIndex = 0; brushSideIndex < brushSidesCount; ++brushSideIndex) {
            const brushSide = new SourceBSPLumpModel();
            //brushSide.planenum = reader.getUint16();
            //brushSide.texinfo = reader.getInt16();
            //brushSide.dispinfo = reader.getInt16();
            reader.skip(24);
            reader.getVector3(undefined, undefined, brushSide.position);
            brushSide.headnode = reader.getInt32();
            brushSide.firstface = reader.getInt32();
            brushSide.numfaces = reader.getInt32();
            lumpData.push(brushSide);
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpLeafFaces(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_LEAFFACE = 2;
        const brushSidesCount = lump.getLumpLen() / BYTES_PER_LEAFFACE;
        const lumpData = [];
        for (let brushSideIndex = 0; brushSideIndex < brushSidesCount; ++brushSideIndex) {
            lumpData.push(reader.getUint16());
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpLeafbrushes(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_LEAFBRUSH = 2;
        const brushSidesCount = lump.getLumpLen() / BYTES_PER_LEAFBRUSH;
        const lumpData = [];
        for (let brushSideIndex = 0; brushSideIndex < brushSidesCount; ++brushSideIndex) {
            lumpData.push(reader.getUint16());
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpBrushes(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_BRUSH = 12;
        const brushesCount = lump.getLumpLen() / BYTES_PER_BRUSH;
        const lumpData = [];
        for (let brushIndex = 0; brushIndex < brushesCount; ++brushIndex) {
            const brush = new SourceBSPLumpBrush();
            brush.firstside = reader.getInt32();
            brush.numsides = reader.getInt32();
            brush.contents = reader.getInt32();
            lumpData.push(brush);
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpBrushSides(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_BRUSH_SIDE = 8;
        const brushSidesCount = lump.getLumpLen() / BYTES_PER_BRUSH_SIDE;
        const lumpData = [];
        for (let brushSideIndex = 0; brushSideIndex < brushSidesCount; ++brushSideIndex) {
            const brushSide = new SourceBSPLumpBrushSide();
            brushSide.planenum = reader.getUint16();
            brushSide.texinfo = reader.getInt16();
            brushSide.dispinfo = reader.getInt16();
            brushSide.bevel = reader.getInt16();
            lumpData.push(brushSide);
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpGameDirectory(reader, lump, bsp) {
        reader.seek(lump.lumpOffset);
        const gameCount = reader.getInt32();
        const lumpData = new Map(); //Object.create(null);
        for (let gameIndex = 0; gameIndex < gameCount; ++gameIndex) {
            const gamelump = new SourceBSPLumpGameLump(bsp, reader, 0, 0);
            gamelump.id = reader.getString(4); //Four CC
            gamelump.flags = reader.getUint16();
            gamelump.version = reader.getUint16();
            gamelump.lumpOffset = reader.getInt32();
            gamelump.lumpLen = reader.getInt32();
            lumpData.set(gamelump.id, gamelump);
        }
        for (const [_, lump] of lumpData) {
            //const lump = lumpData[gameIndex];
            const lumpReader = initLZMALump(reader, lump);
            this.#parseLumpGame(lumpReader, lump);
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpGame(reader, lump) {
        reader.seek(lump.lumpOffset);
        switch (lump.id) {
            case 'prps':
                this.#parseLumpGamePropStatic(reader, lump);
                break;
        }
    }
    #parseLumpGamePropStatic(reader, lump) {
        reader.seek(lump.lumpOffset);
        const STATIC_PROP_NAME_LENGTH = 128;
        const staticDir = new SourceBSPLumpPropStaticDirectory();
        //lump.map.map.staticDirRemoveMe = staticDir;//TODOv3 removeme
        const lumpVersion = lump.version;
        const nameCount = reader.getInt32();
        for (let nameIndex = 0; nameIndex < nameCount; ++nameIndex) {
            const name = stringStrip(reader.getString(STATIC_PROP_NAME_LENGTH));
            staticDir.name.push(name);
        }
        const leafCount = reader.getInt32();
        for (let leafIndex = 0; leafIndex < leafCount; ++leafIndex) {
            staticDir.leaf.push(reader.getUint16());
        }
        const propCount = reader.getInt32();
        // This is bullshit, but the structure size is not sturdy
        const propsStartOffset = reader.tell();
        const propsTotalLength = lump.getLumpLen() - (propsStartOffset - lump.getLumpOffset());
        const byteSizePerProp = Math.floor(propsTotalLength / propCount); // Should be int anyway
        for (let propIndex = 0; propIndex < propCount; ++propIndex) {
            reader.seek(propsStartOffset + propIndex * byteSizePerProp);
            const prop = new SourceBSPLumpPropStatic();
            reader.getVector3(undefined, undefined, prop.position);
            const angles = reader.getVector3(); //TODO: memory
            prop.propType = reader.getUint16();
            if (angles[0] != 0) ;
            prop.angles[0] = DEG_TO_RAD * angles[0];
            prop.angles[1] = DEG_TO_RAD * angles[1];
            prop.angles[2] = DEG_TO_RAD * angles[2];
            prop.firstLeaf = reader.getUint16();
            prop.leafCount = reader.getUint16();
            prop.solid = reader.getUint8();
            prop.flags = reader.getUint8();
            prop.skin = reader.getInt32();
            prop.fadeMinDist = reader.getFloat32();
            prop.fadeMaxDist = reader.getFloat32();
            reader.getVector3(undefined, undefined, prop.lightingOrigin);
            if (lumpVersion >= 5) {
                prop.forcedFadeScale = reader.getFloat32();
            }
            if (lumpVersion == 6 || lumpVersion == 7) {
                prop.minDXLevel = reader.getUint16();
                prop.maxDXLevel = reader.getUint16();
            }
            //TODO
            if (lumpVersion >= 7) {
                reader.skip(4);
            }
            if (lumpVersion >= 8) {
                reader.skip(4);
            }
            if (lumpVersion >= 9) {
                reader.skip(4);
            }
            staticDir.props.push(prop);
        }
        quat.create();
        lump.lumpData = staticDir;
    }
    #parseLumpPakFile(reader, lump) {
        reader.seek(lump.lumpOffset);
        const startOffset = lump.lumpOffset;
        let offset = reader.byteLength - 22; //sizeof ZIP_EndOfCentralDirRecord
        for (let sO = offset; (offset >= 0) && (offset <= sO); --offset) {
            reader.seek(offset);
            if (reader.getUint32() == 101010256) { //PK56
                break;
            }
        }
        if (offset <= 0) {
            lump.setLumpData(Object.create(null));
            return;
        }
        reader.seek(offset);
        reader.skip(4); //signature
        reader.skip(2); //numberOfThisDisk
        reader.skip(2); //numberOfTheDiskWithStartOfCentralDirectory
        reader.skip(2); //nCentralDirectoryEntries_ThisDisk
        const nCentralDirectoryEntries_Total = reader.getUint16();
        reader.getUint32();
        const startOfCentralDirOffset = reader.getUint32();
        const lumpData = new Map();
        reader.seek(startOffset + startOfCentralDirOffset);
        for (let i = 0; i < nCentralDirectoryEntries_Total; ++i) {
            reader.skip(4); //signature
            reader.skip(2); //versionMadeBy
            reader.skip(2); //versionNeededToExtract
            reader.skip(2); //flags
            const compressionMethod = reader.getUint16();
            reader.skip(2); //lastModifiedTime
            reader.skip(2); //lastModifiedDate
            reader.skip(4); //crc32
            const compressedSize = reader.getUint32();
            const uncompressedSize = reader.getUint32();
            const fileNameLength = reader.getUint16();
            const extraFieldLength = reader.getUint16();
            const fileCommentLength = reader.getUint16();
            reader.getUint16();
            reader.getUint16();
            reader.getUint32();
            const relativeOffsetOfLocalHeader = reader.getUint32();
            const fileName = reader.getString(fileNameLength);
            const filepos = startOffset + relativeOffsetOfLocalHeader + fileNameLength + extraFieldLength + 30; //sizeof ZIP_LocalFileHeader
            reader.skip(extraFieldLength + fileCommentLength);
            const file = { cs: compressedSize, fp: filepos, cm: compressionMethod, us: uncompressedSize };
            lumpData.set(fileName, file);
        }
        for (const [fileName, file] of lumpData) {
            if (fileName.match(/^materials\/.*\.vmt$/)) {
                const fileContent = this.#getFileData(reader, file);
                if (fileContent) {
                    Source1VmtLoader.setMaterial(fileName, fileContent);
                }
            }
        }
        lump.setLumpData(lumpData);
    }
    #getFileData(reader, file) {
        if (file) {
            if (file.cm == 14) { //LZMA
                const lzmaProperties = reader.getBytes(5, file.fp + 4);
                const compressedDatas = reader.getBytes(file.cs, file.fp + 9);
                const uncompressedDatas = DecompressLZMA(lzmaProperties, compressedDatas, file.us);
                if (uncompressedDatas) {
                    const lzmaReader = new BinaryReader(uncompressedDatas);
                    return lzmaReader.getString(file.us);
                }
            }
            return reader.getString(file.cs, file.fp);
        }
    }
    #parseLumpTexdataStringData(reader, lump) {
        reader.seek(lump.lumpOffset);
        const startOffset = lump.getLumpOffset();
        const endOffset = startOffset + lump.getLumpLen();
        const lumpData = [];
        while (reader.tell() < endOffset) {
            lumpData.push(reader.getNullString());
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpTexdataStringTable(reader, lump) {
        reader.seek(lump.lumpOffset);
        const texdataCount = lump.getLumpLen() / 4; /* size of int */
        const lumpData = [];
        for (let texdataIndex = 0; texdataIndex < texdataCount; ++texdataIndex) {
            lumpData.push(reader.getInt32());
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpOverlays(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_OVERLAY = 352;
        const overlayCount = lump.getLumpLen() / BYTES_PER_OVERLAY;
        const lumpData = [];
        for (let overlayIndex = 0; overlayIndex < overlayCount; ++overlayIndex) {
            const overlay = new SourceBSPLumpOverlay();
            overlay.id = reader.getInt32();
            overlay.texInfo = reader.getInt16();
            overlay.FaceCountAndRenderOrder = reader.getUint16();
            //overlay.faces = new Int32Array(OVERLAY_BSP_FACE_COUNT);
            for (let i = 0; i < OVERLAY_BSP_FACE_COUNT; ++i) {
                overlay.faces[i] = reader.getInt32();
            }
            overlay.u[0] = reader.getFloat32();
            overlay.u[1] = reader.getFloat32();
            overlay.v[0] = reader.getFloat32();
            overlay.v[1] = reader.getFloat32();
            vec3.set(overlay.uvPoint0, reader.getFloat32(), reader.getFloat32(), reader.getFloat32());
            vec3.set(overlay.uvPoint1, reader.getFloat32(), reader.getFloat32(), reader.getFloat32());
            vec3.set(overlay.uvPoint2, reader.getFloat32(), reader.getFloat32(), reader.getFloat32());
            vec3.set(overlay.uvPoint3, reader.getFloat32(), reader.getFloat32(), reader.getFloat32());
            vec3.set(overlay.origin, reader.getFloat32(), reader.getFloat32(), reader.getFloat32());
            vec3.set(overlay.basisNormal, reader.getFloat32(), reader.getFloat32(), reader.getFloat32());
            vec3.normalize(overlay.basisNormal, overlay.basisNormal);
            lumpData.push(overlay);
        }
        lump.setLumpData(lumpData);
    }
    #parseLumpDispInfo(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_DISPINFO = 176;
        const dispInfoCount = lump.getLumpLen() / BYTES_PER_DISPINFO;
        const lumpData = [];
        for (let dispinfoIndex = 0; dispinfoIndex < dispInfoCount; ++dispinfoIndex) {
            const dispinfo = new SourceBSPLumpDispInfo();
            reader.getVector3(undefined, undefined, dispinfo.startPosition);
            dispinfo.dispVertStart = reader.getInt32();
            dispinfo.dispTriStart = reader.getInt32();
            dispinfo.power = reader.getInt32();
            dispinfo.minTess = reader.getInt32();
            dispinfo.smoothingAngle = reader.getFloat32();
            dispinfo.contents = reader.getInt32();
            dispinfo.mapFace = reader.getUint16();
            dispinfo.lightmapAlphaStart = reader.getInt32();
            dispinfo.lightmapSamplePositionStart = reader.getInt32();
            reader.getUint16(); // Spare bytes
            this.#parseEdgeNeighbors(reader);
            reader.skip(40); //skip CornerNeighbors
            //dispinfo.allowedVerts = [];
            for (let i = 0; i < 10; ++i) { //TODO : variable
                dispinfo.allowedVerts.push(reader.getInt32());
            }
            lumpData.push(dispinfo);
        }
        lump.setLumpData(lumpData);
    }
    #parseEdgeNeighbors(reader) {
        for (let edgeIndex = 0; edgeIndex < 4; ++edgeIndex) {
            const neighbor = new SourceBSPLumpDispNeighbor();
            for (let neighborIndex = 0; neighborIndex < 2; ++neighborIndex) {
                const subneighbor = new SourceBSPLumpDispSubNeighbor();
                neighbor.subNeighbors.push(subneighbor);
                subneighbor.iNeighbor = reader.getUint16();
                subneighbor.orientation = reader.getUint8();
                subneighbor.span = reader.getUint8();
                subneighbor.neighSpan = reader.getUint8();
                reader.skip(1); // read spare byte;
            }
        }
    }
    #parseLumpDispVerts(reader, lump) {
        reader.seek(lump.lumpOffset);
        const BYTES_PER_DISPVERT = 20;
        const dispVertCount = lump.getLumpLen() / BYTES_PER_DISPVERT;
        const lumpData = [];
        for (let dispvertIndex = 0; dispvertIndex < dispVertCount; ++dispvertIndex) {
            const dispvert = new SourceBSPLumpDispVertex();
            reader.getVector3(undefined, undefined, dispvert.vec);
            dispvert.dist = reader.getFloat32();
            dispvert.alpha = reader.getFloat32();
            lumpData.push(dispvert);
        }
        lump.setLumpData(lumpData);
    }
}

const BODYPART_STRUCT_SIZE = 16;
const MODEL_VERTEX_DATA_STRUCT_SIZE = 8; // Size in bytes of mstudio_modelvertexdata_t
const MODEL_STRUCT_SIZE = 140 + MODEL_VERTEX_DATA_STRUCT_SIZE; // Size in bytes of mstudio_modelvertexdata_t
const MESH_VERTEX_DATA_STRUCT_SIZE = 4 + 4 * MAX_NUM_LODS; // Size in bytes of mstudio_meshvertexdata_t
const MESH_STRUCT_SIZE = 80 + MESH_VERTEX_DATA_STRUCT_SIZE;
const EYEBALL_STRUCT_SIZE = 172; // Size in bytes of mstudioeyeball_t
const STUDIO_VERT_ANIM_NORMAL = 0;
const STUDIO_VERT_ANIM_NORMAL_STRUCT_SIZE = 16; // Size in bytes of mstudiovertanim_t
const TEXTURE_STRUCT_SIZE = 64;
const STUDIO_MODEL_GROUP_STRUCT_SIZE = 8;
const STUDIO_ANIM_DESC_STRUCT_SIZE = 25 * 4; // Size in bytes of mstudioanimdesc_t
const STUDIO_SEQUENCE_DESC_STRUCT_SIZE = 53 * 4; // Size in bytes of mstudioseqdesc_t
const STUDIO_EVENT_STRUCT_SIZE = 80; // Size in bytes of mstudioevent_t
const STUDIO_AUTO_LAYER_STRUCT_SIZE = 24; // Size in bytes of mstudioautolayer_t
const BONE_STRUCT_SIZE = 216;
const STUDIO_POSE_PARAMETER_STRUCT_SIZE = 20; // Size in bytes of mstudioposeparamdesc_t
const ATTACHMENT_STRUCT_SIZE = 92;
const STUDIO_FLEX_RULE_STRUCT_SIZE = 12;
const STUDIO_FLEX_OP_STRUCT_SIZE = 8;
const STUDIO_FLEX_CONTROLLER_STRUCT_SIZE = 20; // Size in bytes of mstudioflexcontroller_t
const STUDIO_FLEX_STRUCT_SIZE = 60; // Size in bytes of mstudioflex_t
const STUDIO_HITBOX_SET_STRUCT_SIZE = 12; // Size in bytes of mstudiohitboxset_t
const STUDIO_HITBOX_STRUCT_SIZE = 68; // Size in bytes of mstudiobbox_t
class ModelTest /*TODO: rename class*/ {
    render = true; //removeme
    name = '';
    type = 0;
    boundingradius = 0;
    meshArray = [];
    vertexArray = [];
    eyeballArray = [];
    numvertices = 0;
    vertexindex = 0;
    tangentsindex = 0;
    numattachments = 0;
    attachmentindex = 0;
    numeyeballs = 0;
    eyeballindex = 0;
}
class MeshTest /*TODO: rename class*/ {
    render = true; //removeme
    model;
    material = 0;
    modelindex = 0;
    numvertices = 0;
    vertexoffset = 0;
    numflexes = 0;
    flexindex = 0;
    materialtype = 0;
    materialparam = 0;
    meshid = 0;
    center = vec3.create();
    flexes = [];
    initialized = false;
    constructor(model) {
        this.model = model;
    }
}
class MdlStudioFlex {
    flexdesc = 0;
    target0 = 0;
    target1 = 0;
    target2 = 0;
    target3 = 0;
    numverts = 0;
    vertindex = 0;
    flexpair = 0;
    vertanimtype = 0;
    vertAnims = [];
}
class MdlStudioVertAnim {
    index = 0;
    speed = 0;
    side = 0;
    flDelta = [];
    flNDelta = [];
}
class MdlEyeball {
    name = '';
    bone = -1;
    org = vec3.create();
    zoffset = 0;
    radius = 0;
    up = vec3.create();
    forward = vec3.create();
    texture = 0;
    irisScale = 0;
    upperflexdesc = [];
    lowerflexdesc = [];
    uppertarget = vec3.create();
    lowertarget = vec3.create();
    upperlidflexdesc = 0;
    lowerlidflexdesc = 0;
    m_bNonFACS = 0;
}
class MdlStudioFlexController {
    localToGlobal = 0;
    min = 0;
    max = 0;
    type = '';
    name = '';
}
class MdlStudioHitboxSet {
    name = '';
    hitboxes = [];
}
class MdlStudioHitbox {
    name = '';
    bbmin = vec3.create();
    bbmax = vec3.create();
    boneId = -1;
    groupId = -1;
}
const invQuaternion64 = (1 / 1048576.5);
function readQuaternion64(reader, q = quat.create()) {
    const b = reader.getBytes(8);
    const x = ((b[7] & 0x7F) << 14) | (b[6] << 6) | ((b[5] & 0xFC) >> 2);
    const y = ((b[5] & 0x03) << 19) | (b[4] << 11) | (b[3] << 3) | ((b[2] & 0xE0) >> 5);
    const z = ((b[2] & 0x1F) << 16) | (b[1] << 8) | b[0];
    const neg = (b[7] & 0x80) >> 7;
    const tmpx = (x - 1048576) * invQuaternion64;
    const tmpy = (y - 1048576) * invQuaternion64;
    const tmpz = (z - 1048576) * invQuaternion64;
    let tmpw = Math.sqrt(1 - tmpx * tmpx - tmpy * tmpy - tmpz * tmpz);
    if (neg) {
        tmpw = -tmpw;
    }
    return quat.set(q, tmpx, tmpy, tmpz, tmpw);
}
const invQuaternion48xy = (1 / 32768.0);
const invQuaternion48z = (1 / 16384.0);
function readQuaternion48(reader, q = quat.create()) {
    const x = reader.getUint16();
    const y = reader.getUint16();
    const tmp = reader.getUint16();
    const z = tmp & 0x7FFF;
    const neg = tmp & 0x8000;
    const tmpx = (x - 32768) * invQuaternion48xy;
    const tmpy = (y - 32768) * invQuaternion48xy;
    const tmpz = (z - 16384) * invQuaternion48z;
    let tmpw = Math.sqrt(1 - tmpx * tmpx - tmpy * tmpy - tmpz * tmpz);
    if (neg) {
        tmpw = -tmpw;
    }
    return quat.set(q, tmpx, tmpy, tmpz, tmpw);
}
class Source1MdlLoader extends SourceBinaryLoader {
    #parseAnimSectionOnce = false;
    async load(repository, path) {
        return super.load(repository, path);
    }
    parse(repository, fileName, arrayBuffer) {
        const mdl = new SourceMdl(repository);
        const reader = new BinaryReader(arrayBuffer);
        mdl.reader = reader; //TODOv3//removeme
        mdl.loader = this; //TODOv3//removeme
        this.#parseHeader(reader, mdl);
        this.#parseBodyParts(reader, mdl);
        this.#parseSkinReferences(reader, mdl);
        this.#parseTextures(reader, mdl);
        this.#parseTextureDirs(reader, mdl);
        this.#parseModelGroups(reader, mdl);
        this.#parseAnimDescriptions(reader, mdl);
        this.#parseSequences(reader, mdl);
        this.#parseBones(reader, mdl);
        parsePoseParameters(reader, mdl);
        this.#parseAttachments(reader, mdl);
        this.#parseFlexRules(reader, mdl);
        this.#parseFlexControllers(reader, mdl);
        parseHitBoxSets(reader, mdl);
        return mdl;
    }
    #parseHeader(reader, mdl) {
        mdl.header = {};
        const header = mdl.header;
        reader.seek(0);
        header.modelFormatID = reader.getInt32();
        header.formatVersionID = reader.getInt32();
        header.checkSum = reader.getInt32();
        header.modelName = stringStrip(reader.getString(64));
        header.dataLength = reader.getInt32();
        header.eyeposition = reader.getVector3();
        header.illumposition = reader.getVector3();
        header.hull_min = reader.getVector3();
        header.hull_max = reader.getVector3();
        header.view_bbmin = reader.getVector3();
        header.view_bbmax = reader.getVector3();
        header.flags = reader.getInt32();
        mdl.boneCount = reader.getInt32();
        mdl.boneOffset = reader.getInt32();
        mdl.boneControllerCount = reader.getInt32();
        mdl.boneControllerOffset = reader.getInt32();
        mdl.hitboxCount = reader.getInt32();
        mdl.hitboxOffset = reader.getInt32();
        mdl.localAnimCount = reader.getInt32();
        mdl.localAnimOffset = reader.getInt32();
        mdl.localSeqCount = reader.getInt32();
        mdl.localSeqOffset = reader.getInt32();
        header.activitylistversion = reader.getInt32();
        header.eventsindexed = reader.getInt32();
        mdl.textureCount = reader.getInt32();
        mdl.textureOffset = reader.getInt32();
        mdl.textureDirCount = reader.getInt32();
        mdl.textureDirOffset = reader.getInt32();
        mdl.skinReferenceCount = reader.getInt32();
        mdl.skinFamilyCount = reader.getInt32();
        mdl.skinReferenceOffset = reader.getInt32();
        mdl.bodyPartCount = reader.getInt32();
        mdl.bodyPartOffset = reader.getInt32();
        mdl.attachmentCount = reader.getInt32();
        mdl.attachmentOffset = reader.getInt32();
        mdl.localNodeCount = reader.getInt32();
        mdl.localNodeIndex = reader.getInt32();
        mdl.localNodeNameIndex = reader.getInt32();
        header.numFlexDesc = reader.getInt32();
        mdl.flexDescIndex = reader.getInt32();
        mdl.flexControllerCount = reader.getInt32();
        mdl.flexControllerIndex = reader.getInt32();
        mdl.numFlexRules = reader.getInt32();
        mdl.flexRulesIndex = reader.getInt32();
        mdl.ikChainCount = reader.getInt32();
        mdl.ikChainIndex = reader.getInt32();
        mdl.mouthsCount = reader.getInt32();
        mdl.mouthsIndex = reader.getInt32();
        mdl.localPoseParamCount = reader.getInt32();
        mdl.localPoseParamOffset = reader.getInt32();
        mdl.surfacePropIndex = reader.getInt32();
        mdl.keyValueIndex = reader.getInt32();
        mdl.keyValueCount = reader.getInt32();
        mdl.ikLockCount = reader.getInt32();
        mdl.ikLockIndex = reader.getInt32();
        header.mass = reader.getFloat32();
        header.contents = reader.getInt32();
        mdl.includeModelCount = reader.getInt32();
        mdl.includeModelOffset = reader.getInt32();
        header.virtualModel = reader.getInt32();
        mdl.animBlocksNameIndex = reader.getInt32();
        header.animBlocksCount = reader.getInt32();
        header.animBlocksIndex = reader.getInt32();
        header.animBlockModel = reader.getInt32();
        mdl.boneTableByNameIndex = reader.getInt32();
        mdl.vertexBase = reader.getInt32();
        mdl.offsetBase = reader.getInt32();
        header.directionaldotproduct = reader.getInt8();
        header.rootLod = reader.getInt8();
        header.numAllowedRootLods = reader.getInt8();
        reader.getInt8();
        reader.getInt32();
        mdl.flexControllerUICount = reader.getInt32();
        mdl.flexControllerUIIndex = reader.getInt32();
        reader.getInt32();
        reader.getInt32();
        mdl.studiohdr2index = reader.getInt32();
        reader.getInt32();
        if (mdl.studiohdr2index != 0) {
            //if (this.hasChunk(this.studiohdr2index, 5 * 4)) {
            // seek the start of header2
            reader.seek(mdl.studiohdr2index);
            mdl.srcbonetransform_count = reader.getInt32();
            mdl.srcbonetransform_index = reader.getInt32();
            mdl.illumpositionattachmentindex = reader.getInt32();
            mdl.flMaxEyeDeflection = reader.getFloat32();
            mdl.linearboneOffset = reader.getInt32();
        }
    }
    #parseBodyParts(reader, mdl) {
        const bodyParts = mdl.bodyParts;
        for (let i = 0; i < mdl.bodyPartCount; ++i) {
            const bodyPart = this.#parseBodyPart(reader, mdl, mdl.bodyPartOffset + i * BODYPART_STRUCT_SIZE);
            bodyParts.push(bodyPart);
        }
    }
    #parseBodyPart(reader, mdl, startOffset) {
        const nameOffset = reader.getInt32(startOffset) + startOffset;
        // Ensure we have enough data for the name
        const bodyPart = new MdlBodyPart();
        const nummodels = reader.getInt32();
        bodyPart.base = reader.getInt32();
        const modelOffset = reader.getInt32();
        bodyPart.models = [];
        for (let i = 0; i < nummodels; ++i) {
            const model = this.#parseModel(reader, mdl, startOffset + modelOffset + i * MODEL_STRUCT_SIZE);
            bodyPart.models.push(model);
            //reader.seek(baseOffset + bodypart.modelindex + i*MODEL_STRUCT_SIZE);
            //bodyPart.models.push(this.readModel());
        }
        bodyPart.name = reader.getNullString(nameOffset);
        return bodyPart;
    }
    #parseModel(reader, mdl, startOffset) {
        // Ensure we have enough data for the name
        const model = new ModelTest();
        model.name = stringStrip(reader.getString(64, startOffset));
        model.type = reader.getInt32();
        model.boundingradius = reader.getFloat32();
        const nummeshes = reader.getInt32();
        const meshOffset = reader.getInt32();
        model.numvertices = reader.getInt32();
        model.vertexindex = reader.getInt32();
        model.tangentsindex = reader.getInt32();
        model.numattachments = reader.getInt32();
        model.attachmentindex = reader.getInt32();
        model.numeyeballs = reader.getInt32();
        model.eyeballindex = reader.getInt32();
        //this.readModelVertexData();//TODO
        reader.skip(4 * 8);
        for (let i = 0; i < nummeshes; ++i) {
            const mesh = this.#parseMesh(reader, mdl, startOffset + meshOffset + i * MESH_STRUCT_SIZE, model);
            model.meshArray.push(mesh);
            //mesh.model = model;
        }
        for (let i = 0; i < model.numeyeballs; ++i) {
            const eyeBall = this.#parseEyeBall(reader, startOffset + model.eyeballindex + i * EYEBALL_STRUCT_SIZE);
            model.eyeballArray.push(eyeBall);
        }
        return model;
    }
    #parseMesh(reader, mdl, startOffset, model) {
        // Ensure we have enough data
        //const mesh = new MdlMesh();TODO
        const mesh = new MeshTest(model); //TODO
        mesh.material = reader.getInt32(startOffset);
        mesh.modelindex = reader.getInt32();
        mesh.numvertices = reader.getInt32();
        mesh.vertexoffset = reader.getInt32();
        mesh.numflexes = reader.getInt32();
        mesh.flexindex = reader.getInt32() + startOffset; //TODO: add array
        mesh.materialtype = reader.getInt32();
        mesh.materialparam = reader.getInt32();
        mesh.meshid = reader.getInt32();
        reader.getVector3(undefined, undefined, mesh.center);
        //mesh.vertexData = this.readMeshVertexData();
        reader.skip(4 + MAX_NUM_LODS * 4);
        //mesh.flexes = [];
        reader.skip(4 * 8);
        //TODO: read flexes
        this.#parseFlexes(reader, mdl, mesh.flexindex, mesh.numflexes, mesh.flexes);
        return mesh;
    }
    #parseFlexes(reader, mdl, startOffset, count, flexes) {
        for (let i = 0; i < count; ++i) {
            flexes.push(this.#parseFlex(reader, startOffset + i * STUDIO_FLEX_STRUCT_SIZE));
        }
    }
    #parseFlex(reader, startOffset) {
        reader.seek(startOffset);
        const flex = new MdlStudioFlex();
        flex.flexdesc = reader.getInt32();
        flex.target0 = reader.getFloat32();
        flex.target1 = reader.getFloat32();
        flex.target2 = reader.getFloat32();
        flex.target3 = reader.getFloat32();
        flex.numverts = reader.getInt32();
        flex.vertindex = reader.getInt32();
        flex.flexpair = reader.getInt32();
        flex.vertanimtype = reader.getInt8();
        const vertOffset = startOffset + flex.vertindex;
        if (flex.vertanimtype == STUDIO_VERT_ANIM_NORMAL) {
            //const size = flex.numverts * STUDIO_VERT_ANIM_NORMAL_STRUCT_SIZE;
            for (let i = 0; i < flex.numverts; ++i) {
                //reader.seek(vertOffset + i*STUDIO_VERT_ANIM_NORMAL_STRUCT_SIZE);
                const vertAnim = this.#parseVertAnim(reader, vertOffset + i * STUDIO_VERT_ANIM_NORMAL_STRUCT_SIZE);
                flex.vertAnims.push(vertAnim);
            }
        }
        return flex;
    }
    #parseVertAnim(reader, startOffset) {
        reader.seek(startOffset);
        const vert = new MdlStudioVertAnim();
        vert.index = reader.getUint16();
        vert.speed = reader.getUint8();
        vert.side = reader.getUint8();
        vert.flDelta[0] = reader.getFloat16();
        vert.flDelta[1] = reader.getFloat16();
        vert.flDelta[2] = reader.getFloat16();
        vert.flNDelta[0] = reader.getFloat16();
        vert.flNDelta[1] = reader.getFloat16();
        vert.flNDelta[2] = reader.getFloat16();
        return vert;
    }
    #parseEyeBall(reader, startOffset) {
        const eyeball = new MdlEyeball();
        const nameOffset = startOffset + reader.getInt32(startOffset);
        eyeball.bone = reader.getInt32();
        reader.getVector3(undefined, undefined, eyeball.org);
        eyeball.zoffset = reader.getFloat32();
        eyeball.radius = reader.getFloat32();
        reader.getVector3(undefined, undefined, eyeball.up);
        reader.getVector3(undefined, undefined, eyeball.forward);
        eyeball.texture = reader.getInt32();
        reader.skip(4); //unused
        eyeball.irisScale = reader.getFloat32();
        reader.skip(4); //unused
        eyeball.upperflexdesc.push(reader.getInt32(), reader.getInt32(), reader.getInt32());
        eyeball.lowerflexdesc.push(reader.getInt32(), reader.getInt32(), reader.getInt32());
        reader.getVector3(undefined, undefined, eyeball.uppertarget);
        reader.getVector3(undefined, undefined, eyeball.lowertarget);
        eyeball.upperlidflexdesc = reader.getInt32();
        eyeball.lowerlidflexdesc = reader.getInt32();
        reader.skip(4 * 4); //unused
        eyeball.m_bNonFACS = reader.getInt8();
        reader.skip(3 * 1 + 7 * 4); //unused
        eyeball.name = reader.getNullString(nameOffset);
        //console.error(eyeball);
        return eyeball;
    }
    #parseSkinReferences(reader, mdl) {
        const skinReferences = mdl.skinReferences;
        // Ensure we have enough data
        reader.seek(mdl.skinReferenceOffset);
        for (let i = 0; i < mdl.skinFamilyCount; ++i) {
            skinReferences[i] = [];
            for (let j = 0; j < mdl.skinReferenceCount; ++j) {
                skinReferences[i].push(reader.getInt16());
            }
        }
        //mdl.skinReferences = skinReferences;
    }
    #parseTextures(reader, mdl) {
        const textures = mdl.textures;
        for (let i = 0; i < mdl.textureCount; ++i) {
            const texture = this.#parseTexture(reader, mdl, mdl.textureOffset + i * TEXTURE_STRUCT_SIZE);
            texture.name = texture.name;
            textures.push(texture);
        }
    }
    #parseTexture(reader, mdl, startOffset) {
        reader.seek(startOffset);
        const nameOffset = reader.getInt32() + startOffset;
        // Ensure we have enough data for the name
        const texture = new MdlTexture();
        reader.getInt32();
        reader.getInt32();
        reader.getInt32();
        reader.getInt32();
        reader.getInt32();
        texture.name = reader.getNullString(nameOffset);
        texture.originalName = texture.name;
        /*
        if (!mdl.baseTexturePath) {
            const regex = /(.*(\\|\/))* /i;
            const result = regex.exec(texture.name);
            if (result) {
                mdl.baseTexturePath = result[0];
            }
        }
        */
        return texture;
    }
    #parseTextureDirs(reader, mdl) {
        for (let i = 0; i < mdl.textureDirCount; ++i) {
            const nameOffset = reader.getInt32(mdl.textureDirOffset + i * 4);
            const textureDir = reader.getNullString(nameOffset);
            if (textureDir !== null) {
                mdl.texturesDir.push(textureDir.replace(/\\/g, '/').toLowerCase());
            }
        }
    }
    #parseModelGroups(reader, mdl) {
        for (let i = 0; i < mdl.includeModelCount; ++i) {
            mdl.modelGroups.push(this.#parseModelGroup(reader, mdl, mdl.includeModelOffset + i * STUDIO_MODEL_GROUP_STRUCT_SIZE));
        }
    }
    #parseModelGroup(reader, mdl, startOffset) {
        reader.seek(startOffset);
        const labelOffset = reader.getInt32() + startOffset;
        const nameOffset = reader.getInt32() + startOffset;
        const modelgroup = new MdlStudioModelGroup();
        modelgroup.label = reader.getNullString(labelOffset);
        modelgroup.name = reader.getNullString(nameOffset);
        return modelgroup;
    }
    #parseAnimDescriptions(reader, mdl) {
        const animDescriptions = mdl.animDesc;
        for (let i = 0; i < mdl.localAnimCount; ++i) {
            const animDescription = this.#parseAnimDescription(reader, mdl, mdl.localAnimOffset + i * STUDIO_ANIM_DESC_STRUCT_SIZE);
            animDescriptions.push(animDescription);
        }
    }
    #parseAnimDescription(reader, mdl, startOffset) {
        reader.seek(startOffset + 4); //skip 4 first bytes
        const nameOffset = reader.getInt32() + startOffset;
        const animDesc = new MdlStudioAnimDesc();
        animDesc.mdl = mdl;
        animDesc.startOffset = startOffset; //TODOv2: remove?Non
        animDesc.fps = reader.getFloat32();
        animDesc.flags = reader.getInt32();
        animDesc.numframes = reader.getInt32();
        animDesc.nummovements = reader.getInt32();
        reader.getInt32();
        reader.skip(24);
        animDesc.animblock = reader.getInt32();
        animDesc.animIndex = reader.getInt32();
        animDesc.numikrules = reader.getInt32();
        reader.getInt32();
        reader.getInt32();
        animDesc.numlocalhierarchy = reader.getInt32();
        reader.getInt32();
        animDesc.sectionOffset = reader.getInt32();
        animDesc.sectionframes = reader.getInt32();
        animDesc.zeroframespan = reader.getInt16();
        animDesc.zeroframecount = reader.getInt16();
        //console.log(animDesc.zeroframecount);
        animDesc.zeroframeOffset = reader.getInt32();
        reader.getFloat32();
        if (animDesc.sectionframes != 0) {
            Math.ceil(animDesc.numframes / animDesc.sectionframes) + 1;
        }
        /*
        for (let i = 0; i < numSection; i++) {
            const section = this._parseAnimSection(reader, animDesc, i);//TODOv3
            if (section) {
                animDesc.animSections.push(section);
            }
        }
        */
        animDesc.name = reader.getNullString(nameOffset);
        return animDesc;
    }
    #parseSequences(reader, mdl) {
        for (let i = 0; i < mdl.localSeqCount; ++i) {
            const sequence = this.#parseSequence(reader, mdl, mdl.localSeqOffset + i * STUDIO_SEQUENCE_DESC_STRUCT_SIZE);
            sequence.id = i;
            mdl.sequences.push(sequence);
        }
    }
    #parseSequence(reader, mdl, startOffset) {
        reader.seek(startOffset + 4); //skip 4 first bytes
        const nameOffset = reader.getInt32() + startOffset;
        const activityNameOffset = reader.getInt32() + startOffset;
        const sequence = new MdlStudioSeqDesc();
        sequence.mdl = mdl;
        sequence.startOffset = startOffset; //TODO: remove me
        sequence.flags = reader.getInt32();
        sequence.activity = reader.getInt32();
        sequence.actweight = reader.getInt32();
        sequence.numevents = reader.getInt32();
        sequence.eventindex = reader.getInt32();
        // Bounding box
        reader.getVector3(undefined, undefined, sequence.bbmin);
        reader.getVector3(undefined, undefined, sequence.bbmax);
        sequence.numblends = reader.getInt32();
        sequence.animindexindex = reader.getInt32() + startOffset;
        sequence.movementindex = reader.getInt32();
        sequence.groupsize[0] = reader.getInt32();
        sequence.groupsize[1] = reader.getInt32();
        sequence.paramindex.push(reader.getInt32());
        sequence.paramindex.push(reader.getInt32());
        sequence.paramstart.push(reader.getFloat32());
        sequence.paramstart.push(reader.getFloat32());
        sequence.paramend.push(reader.getFloat32());
        sequence.paramend.push(reader.getFloat32());
        sequence.paramparent = reader.getInt32();
        sequence.fadeintime = reader.getFloat32();
        sequence.fadeouttime = reader.getFloat32();
        sequence.localentrynode = reader.getInt32();
        sequence.localexitnode = reader.getInt32();
        sequence.nodeflags = reader.getInt32();
        sequence.entryphase = reader.getFloat32();
        sequence.exitphase = reader.getFloat32();
        sequence.lastframe = reader.getFloat32();
        sequence.nextseq = reader.getInt32();
        sequence.pose = reader.getInt32();
        sequence.numikrules = reader.getInt32();
        sequence.numautolayers = reader.getInt32();
        sequence.autolayerindex = reader.getInt32() + startOffset;
        sequence.weightlistindex = reader.getInt32();
        sequence.posekeyindex = reader.getInt32() + startOffset;
        sequence.numiklocks = reader.getInt32();
        sequence.iklockindex = reader.getInt32();
        sequence.keyvalueindex = reader.getInt32();
        sequence.keyvaluesize = reader.getInt32();
        sequence.cycleposeindex = reader.getInt32();
        //TODO: check size
        reader.seek(sequence.animindexindex);
        for (let i = 0; i < sequence.groupsize[1]; ++i) {
            const arrI = new Array(sequence.groupsize[0]);
            sequence.blend.push(arrI);
            for (let j = 0; j < sequence.groupsize[0]; ++j) { //TODO: optimize
                arrI[j] = reader.getInt16();
            }
        }
        if (sequence.numautolayers && sequence.autolayerindex) {
            //const size = sequence.numautolayers * STUDIO_AUTO_LAYER_STRUCT_SIZE;
            for (let i = 0; i < sequence.numautolayers; ++i) {
                reader.seek(sequence.autolayerindex + i * STUDIO_AUTO_LAYER_STRUCT_SIZE);
                //this.readAutoLayer();
                const autoLayer = new MdlStudioAutoLayer();
                autoLayer.iSequence = reader.getInt16();
                autoLayer.iPose = reader.getInt16();
                autoLayer.flags = reader.getInt32();
                autoLayer.start = reader.getFloat32();
                autoLayer.peak = reader.getFloat32();
                autoLayer.tail = reader.getFloat32();
                autoLayer.end = reader.getFloat32();
                sequence.autolayer.push(autoLayer);
            }
        }
        sequence.name = reader.getNullString(nameOffset).toLowerCase();
        //console.log(sequence.name);
        sequence.activityName = reader.getNullString(activityNameOffset);
        // TODO: check size
        for (let boneIndex = 0; boneIndex < mdl.boneCount; ++boneIndex) {
            reader.seek(startOffset + sequence.weightlistindex + boneIndex * 4);
            sequence.weightlist.push(reader.getFloat32());
        }
        for (let eventIndex = 0; eventIndex < sequence.numevents; ++eventIndex) {
            reader.seek(startOffset + sequence.eventindex + STUDIO_EVENT_STRUCT_SIZE * eventIndex);
            const event = this.#parseStudioEvent(reader, mdl, startOffset + sequence.eventindex + STUDIO_EVENT_STRUCT_SIZE * eventIndex);
            sequence.events.push(event);
            /*if (sequence.name.toLowerCase().indexOf('taunt07') != -1) {
                console.log(sequence.name, event);
            }*/
        }
        return sequence;
    }
    #parseStudioEvent(reader, mdl, startOffset) {
        reader.seek(startOffset);
        const studioEvent = new MdlStudioEvent();
        studioEvent.cycle = reader.getFloat32();
        studioEvent.event = reader.getInt32();
        studioEvent.type = reader.getInt32();
        studioEvent.options = reader.getString(64).replace(/\u0000/g, '');
        const nameOffset = reader.getInt32() + startOffset;
        studioEvent.name = reader.getNullString(nameOffset);
        return studioEvent;
    }
    #parseBones(reader, mdl) {
        const bones = mdl.bones;
        const boneNames = mdl.boneNames;
        for (let i = 0; i < mdl.boneCount; ++i) {
            const bone = this.#parseBone(reader, mdl.boneOffset + i * BONE_STRUCT_SIZE);
            if (bone.parentBone != -1) {
                //bone.setParent(bones[bone.parentBone]);
                bone.parent = bones[bone.parentBone] ?? null;
                //bone.worldPos = vec3.create();
                //bone.worldQuat = quat.create();
            }
            bones.push(bone);
            bone.boneId = bones.length - 1;
            boneNames.set(bone.lowcasename, bones.length - 1);
        }
    }
    #parseBone(reader, startOffset) {
        reader.seek(startOffset);
        const nameOffset = reader.getInt32() + startOffset;
        const bone = new MdlBone();
        bone.parentBone = reader.getInt32();
        bone.bonecontroller = [];
        for (let i = 0; i < 6; ++i) {
            bone.bonecontroller.push(reader.getInt32());
        }
        bone.position = reader.getVector3();
        bone.quaternion = reader.getVector4();
        reader.getVector3(undefined, undefined, bone.rot);
        reader.getVector3(undefined, undefined, bone.posscale);
        reader.getVector3(undefined, undefined, bone.rotscale);
        const poseToBone = readMatrix3x4(reader);
        bone.poseToBone = poseToBone;
        bone.initPoseToBone = poseToBone;
        //bone.invPoseToBone = mat4.invert(mat4.create(), bone.poseToBone);
        reader.getVector4(undefined, undefined, bone.qAlignment);
        bone.flags = reader.getInt32();
        bone.proctype = reader.getInt32();
        bone.procindex = reader.getInt32();
        bone.physicsbone = reader.getInt32();
        bone.surfacepropidx = reader.getInt32();
        bone.contents = reader.getInt32();
        reader.skip(8 * 4);
        if (bone.procindex && (bone.proctype == 5)) {
            reader.seek(startOffset + bone.procindex);
            //this.readJiggleBone();//TODO
        }
        bone.name = reader.getNullString(nameOffset);
        bone.lowcasename = bone.name.toLowerCase();
        return bone;
    }
    _parseAnimSection(reader, animDesc, frameIndex) {
        //_parseAnimSection(reader, animDesc, sectionIndex) {
        if (animDesc.sectionframes != 0) {
            const sectionIndex = Math.floor(frameIndex / animDesc.sectionframes); //TODOv3
            const sectionOffset1 = animDesc.startOffset + animDesc.sectionOffset + sectionIndex * 8; //TODOv2: name
            reader.seek(sectionOffset1);
            const block = reader.getInt32(); //block;//TODOv2
            const sectionOffset = reader.getInt32();
            if (block == 0) {
                const section = [];
                let blockOffset = 0;
                let anim;
                do {
                    anim = this.#parseAnimBlock(reader, animDesc.startOffset + sectionOffset + blockOffset);
                    if (!anim) {
                        return null;
                    }
                    section.push(anim);
                    blockOffset += anim.nextOffset;
                } while (anim.nextOffset);
                return section;
            }
        }
        else { // animDesc.sectionframes == 0
            const section = [];
            if (animDesc.animblock == 0) {
                if (animDesc.animIndex) {
                    let blockOffset = 0;
                    let anim;
                    do {
                        anim = this.#parseAnimBlock(reader, animDesc.startOffset + animDesc.animIndex + blockOffset);
                        if (!anim) {
                            return null;
                        }
                        section.push(anim);
                        blockOffset += anim.nextOffset;
                    } while (anim.nextOffset);
                }
            }
            //animDesc.animSections.push(section);
            return section;
        }
        return null;
    }
    #parseAnimBlock(reader, startOffset) {
        reader.seek(startOffset);
        const anim = new MdlStudioAnim();
        //anim.baseOffset = reader.tell();TODOv2
        anim.bone = reader.getUint8();
        anim.flags = reader.getUint8();
        anim.nextOffset = reader.getInt16();
        //anim.values = [];TODOv2
        // valid if animation unvaring over timeline
        if ((anim.flags & STUDIO_ANIM_RAWROT) == STUDIO_ANIM_RAWROT) { // 1: STUDIO_ANIM_RAWROT
            //reader.getString(6); //TODO: read Quaternion48
            readQuaternion48(reader, anim.rawrot);
        }
        if ((anim.flags & STUDIO_ANIM_RAWROT2) == STUDIO_ANIM_RAWROT2) { // 2: STUDIO_ANIM_RAWROT2
            readQuaternion64(reader, anim.rawrot2);
        }
        if ((anim.flags & STUDIO_ANIM_RAWPOS) == STUDIO_ANIM_RAWPOS) { // 3: STUDIO_ANIM_RAWROT
            reader.getVector48(undefined, undefined, anim.rawpos);
        }
        if ((anim.flags & STUDIO_ANIM_ANIMROT) == STUDIO_ANIM_ANIMROT) { // 1: STUDIO_ANIM_ANIMROT
            parseAnimValuePtr(reader, anim.animValuePtrRot);
        }
        if ((anim.flags & STUDIO_ANIM_ANIMPOS) == STUDIO_ANIM_ANIMPOS) { // 2: STUDIO_ANIM_ANIMPOS
            parseAnimValuePtr(reader, anim.animValuePtrPos);
        }
        return anim;
    }
    #parseAttachments(reader, mdl) {
        const attachments = mdl.attachments;
        const attachmentNames = mdl.attachmentNames;
        if (mdl.attachmentCount && mdl.attachmentOffset) {
            //const size = mdl.attachmentCount * ATTACHMENT_STRUCT_SIZE;
            for (let i = 0; i < mdl.attachmentCount; ++i) {
                const attachment = this.#parseAttachment(reader, mdl, mdl.attachmentOffset + i * ATTACHMENT_STRUCT_SIZE);
                attachments.push(attachment);
                attachmentNames.set(attachment.name.toLowerCase(), attachment);
            }
        }
    }
    #parseAttachment(reader, mdl, startOffset) {
        const nameOffset = reader.getInt32(startOffset) + startOffset;
        const attachment = new MdlAttachment();
        attachment.mdl = mdl;
        attachment.flags = reader.getInt32();
        attachment.localbone = reader.getInt32();
        //attachment.local = [];
        for (let i = 0; i < 12; ++i) { //local
            attachment.local[i] = reader.getFloat32();
        }
        attachment.name = reader.getNullString(nameOffset);
        attachment.lowcasename = attachment.name.toLowerCase();
        return attachment;
    }
    #parseFlexRules(reader, mdl) {
        if (mdl.numFlexRules && mdl.flexRulesIndex) {
            //const size = mdl.numFlexRules * STUDIO_FLEX_RULE_STRUCT_SIZE;
            for (let i = 0; i < mdl.numFlexRules; ++i) {
                mdl.flexRules.push(this.#parseFlexRule(reader, mdl.flexRulesIndex + i * STUDIO_FLEX_RULE_STRUCT_SIZE));
            }
        }
    }
    #parseFlexRule(reader, startOffset) {
        reader.seek(startOffset);
        const rule = new MdlStudioFlexRule();
        rule.flex = reader.getInt32();
        const numops = reader.getInt32();
        const opindex = startOffset + reader.getInt32();
        for (let i = 0; i < numops; ++i) {
            reader.seek(opindex + i * STUDIO_FLEX_OP_STRUCT_SIZE);
            const op = new MdlStudioFlexOp();
            op.op = reader.getInt32();
            const unionOffset = reader.tell();
            op.index = reader.getInt32();
            op.value = reader.getFloat32(unionOffset);
            rule.ops.push(op);
        }
        return rule;
    }
    #parseFlexControllers(reader, mdl) {
        if (mdl.flexControllerCount && mdl.flexControllerIndex) {
            for (let i = 0; i < mdl.flexControllerCount; ++i) {
                mdl.flexControllers.push(this.#parseFlexController(reader, mdl, mdl.flexControllerIndex + i * STUDIO_FLEX_CONTROLLER_STRUCT_SIZE));
            }
        }
    }
    #parseFlexController(reader, mdl, startOffset) {
        reader.seek(startOffset);
        const typeOffset = reader.getInt32() + startOffset;
        const nameOffset = reader.getInt32() + startOffset;
        const flexController = new MdlStudioFlexController();
        flexController.localToGlobal = reader.getInt32();
        flexController.min = reader.getFloat32();
        flexController.max = reader.getFloat32();
        reader.seek(typeOffset);
        flexController.type = reader.getNullString();
        reader.seek(nameOffset);
        flexController.name = reader.getNullString().toLowerCase();
        // TODO: hack; fix this
        if (flexController.localToGlobal == -1) {
            flexController.localToGlobal = mdl.flexController.getController(flexController.name, flexController.min, flexController.max);
            //TODOv3
            //TODOv4
        }
        return flexController;
    }
}
registerLoader('Source1MdlLoader', Source1MdlLoader);
function readMatrix3x4(reader) {
    const matrix = mat4.create();
    matrix[0] = reader.getFloat32();
    matrix[4] = reader.getFloat32();
    matrix[8] = reader.getFloat32();
    matrix[12] = reader.getFloat32();
    matrix[1] = reader.getFloat32();
    matrix[5] = reader.getFloat32();
    matrix[9] = reader.getFloat32();
    matrix[13] = reader.getFloat32();
    matrix[2] = reader.getFloat32();
    matrix[6] = reader.getFloat32();
    matrix[10] = reader.getFloat32();
    matrix[14] = reader.getFloat32();
    return matrix;
}
function parseHitBoxSets(reader, mdl) {
    const hitboxSetCount = mdl.hitboxCount;
    let hitboxSetOffset = mdl.hitboxOffset;
    if (hitboxSetCount && hitboxSetOffset) {
        for (let i = 0; i < hitboxSetCount; ++i) {
            mdl.hitboxSets.push(parseHitboxSet(reader, mdl, hitboxSetOffset));
            hitboxSetOffset += STUDIO_HITBOX_SET_STRUCT_SIZE;
        }
        //mdl.hitboxSets = hitboxSets;
    }
}
function parseHitboxSet(reader, mdl, startOffset) {
    const hitboxSet = new MdlStudioHitboxSet();
    const nameOffset = reader.getInt32(startOffset) + startOffset;
    const hitboxCount = reader.getInt32();
    let hitboxOffset = reader.getInt32() + startOffset;
    hitboxSet.name = reader.getNullString(nameOffset);
    const hitboxes = [];
    for (let i = 0; i < hitboxCount; ++i) {
        hitboxes.push(parseHitbox(reader, hitboxOffset));
        hitboxOffset += STUDIO_HITBOX_STRUCT_SIZE;
    }
    hitboxSet.hitboxes = hitboxes;
    return hitboxSet;
}
function parseHitbox(reader, startOffset) {
    reader.seek(startOffset);
    const hitbox = new MdlStudioHitbox();
    hitbox.boneId = reader.getInt32();
    hitbox.groupId = reader.getInt32();
    reader.getVector3(undefined, undefined, hitbox.bbmin);
    reader.getVector3(undefined, undefined, hitbox.bbmax);
    hitbox.name = reader.getNullString(reader.getInt32() + startOffset);
    return hitbox;
}
function parseAnimValuePtr(reader, animValuePtr) {
    animValuePtr.base = reader.tell();
    for (let i = 0; i < 3; ++i) {
        animValuePtr.offset.push(reader.getInt16());
    }
}
function parsePoseParameters(reader, mdl) {
    const poseParameters = mdl.poseParameters;
    for (let i = 0; i < mdl.localPoseParamCount; ++i) {
        const poseParameter = parsePoseParameter(reader, mdl.localPoseParamOffset + i * STUDIO_POSE_PARAMETER_STRUCT_SIZE);
        poseParameters.push(poseParameter);
    }
}
function parsePoseParameter(reader, startOffset) {
    reader.seek(startOffset);
    const nameOffset = reader.getInt32() + startOffset;
    const poseParameter = new MdlStudioPoseParam();
    poseParameter.flags = reader.getInt32();
    poseParameter.start = reader.getFloat32();
    poseParameter.end = reader.getFloat32();
    poseParameter.loop = reader.getFloat32();
    poseParameter.midpoint = RemapValClamped(0.5, poseParameter.start, poseParameter.end, 0, 1);
    reader.seek(nameOffset);
    poseParameter.name = reader.getNullString();
    return poseParameter;
}

class ParticleColor {
    r;
    g;
    b;
    a;
    constructor(r = 0, g = 0, b = 0, a = 255) {
        // TODO: move / 255 in caller
        this.r = r / 255.0;
        this.g = g / 255.0;
        this.b = b / 255.0;
        this.a = a / 255.0;
    }
    randomize(color1, color2) {
        const f = Math.random();
        this.r = (color2.r - color1.r) * f + color1.r;
        this.g = (color2.g - color1.g) * f + color1.g;
        this.b = (color2.b - color1.b) * f + color1.b;
    }
    setColor(color) {
        this.r = color.r;
        this.g = color.g;
        this.b = color.b;
        return this;
    }
    setColorAlpha(color) {
        this.r = color.r;
        this.g = color.g;
        this.b = color.b;
        this.a = color.a;
        return this;
    }
    fromVec3(v) {
        this.r = v[0];
        this.g = v[1];
        this.b = v[2];
        return this;
    }
    fromVec4(v) {
        this.r = v[0];
        this.g = v[1];
        this.b = v[2];
        this.a = v[3];
        return this;
    }
    getRed() {
        return Math.round(this.r * 255.0);
    }
    getGreen() {
        return Math.round(this.g * 255.0);
    }
    getBlue() {
        return Math.round(this.b * 255.0);
    }
    getAlpha() {
        return Math.round(this.a * 255.0);
    }
    setRed(r) {
        this.r = r / 255.0;
    }
    setGreen(g) {
        this.g = g / 255.0;
    }
    setBlue(b) {
        this.b = b / 255.0;
    }
    toString() {
        return '' + this.getRed() + ' ' + this.getGreen() + ' ' + this.getBlue() + ' ' + this.getAlpha();
    }
    setWhite() {
        this.r = 1.0;
        this.g = 1.0;
        this.b = 1.0;
        this.a = 1.0;
    }
}
const BLACK = new ParticleColor();
const WHITE = new ParticleColor(255, 255, 255, 255);

const PARAM_TYPE_INT = 'int';
const PARAM_TYPE_FLOAT = 'float';
const PARAM_TYPE_VECTOR = 'vector3';
const PARAM_TYPE_VECTOR3 = 'vector3';
const PARAM_TYPE_COLOR = 'color';
const PARAM_TYPE_BOOL = 'bool';
const PARAM_TYPE_STRING = 'string';
const PARAM_TYPE_ID = 'elementid';
const PARAM_TYPE_UNKNOWN = 'unknown';
const ELEMENT_TYPES = [
    PARAM_TYPE_UNKNOWN,
    PARAM_TYPE_ID,
    PARAM_TYPE_INT,
    PARAM_TYPE_FLOAT,
    PARAM_TYPE_BOOL,
    PARAM_TYPE_STRING,
    '', //TODO	time
    '', //TODO color
    '', //TODO verctor2
    PARAM_TYPE_VECTOR,
    '', //TODO verctor4
];

class Source1ParticleOperators {
    static #functions = {}; //TODO: create Map
    static #functionsType = {}; //TODO: create Map
    static getOperator(system, name) {
        const n = name.replace(/\_/g, ' ').toLowerCase();
        if (!this.#functions[n]) {
            return null;
        }
        return new this.#functions[n](system);
    }
    static #register(type, name, className) {
        this.#functions[name.replace(/\_/g, ' ').toLowerCase()] = className;
        this.#functionsType[type] = this.#functionsType[type] ?? [];
        this.#functionsType[type].push(name);
    }
    static getOperators(type) {
        return this.#functionsType[type] ?? [];
    }
    static registerOperator(name, operator) {
        if (operator) {
            this.#register('Operators', name, operator);
        }
        else {
            this.#register('Operators', name.functionName, name);
        }
    }
}

const DEFAULT_MAX_PARTICLES$2 = 1000;
const HARD_MAX_PARTICLES = 5000;
const PARTICLE_ORIENTATION_SCREEN_ALIGNED = 0; //Point towards camera
const PARTICLE_ORIENTATION_SCREEN_Z_ALIGNED = 1; //parallel to camera axis
const PARTICLE_ORIENTATION_WORLD_Z_ALIGNED = 2;
const PARTICLE_ORIENTATION_ALIGN_TO_PARTICLE_NORMAL = 3;
const PARTICLE_ORIENTATION_SCREENALIGN_TO_PARTICLE_NORMAL = 4;
const PARTICLE_ORIENTATION_FULL_3AXIS_ROTATION = 5;

/**
 * TODO
 */
class Source1Particle {
    currentTime = 0;
    previousElapsedTime = 0;
    name;
    id;
    isAlive = false;
    position = vec3.create();
    prevPosition = vec3.create();
    cpPosition = vec3.create();
    cpOrientation = quat.create(); //TODO: rename this var
    cpOrientationInvert = quat.create();
    velocity = vec3.create();
    color = new ParticleColor(255, 255, 255);
    initialColor = new ParticleColor(255, 255, 255);
    uMin = 0;
    uMax = 1;
    vMin = 0;
    vMax = 1;
    system;
    cTime = 0;
    timeToLive = 0;
    initialTimeToLive = 0;
    proportionOfLife = 0;
    u = 0;
    v = 0;
    radius = 1;
    initialRadius = 1;
    rotationRoll = 0;
    initialRoll = 0;
    rotationSpeedRoll = 0;
    rotationYaw = 0;
    startAlpha = 175 / 255;
    alpha = 175 / 255;
    alpha2 = 1.0;
    sequence = 0;
    initialSequence = 0;
    frame = 0;
    PositionFromParentParticles = false;
    posLockedToCP = -2; // TODO: turn into boolean
    rotLockedToCP = -2; // TODO: turn into boolean
    trailLength = 0.1;
    initialCPPosition = null;
    initialVecOffset = null;
    initialCPQuaternion = null;
    renderScreenVelocityRotate = false;
    initialVec;
    bones;
    m_flRotateRate = 0; // TODO: rename, default value
    m_flForward = 0; // TODO: rename, default value
    deltaL = 0;
    constructor(id, system) {
        this.name = 'Particle ' + id;
        this.id = id;
        //this.offsetPosition = vec3.create();
        this.system = system;
        this.reset();
        /*
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_XYZ, 0.0f, 0.0f, 0.0f);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_PREV_XYZ, 0.0f, 0.0f, 0.0f);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_LIFE_DURATION, 1.0f);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_RADIUS, pDef->m_flConstantRadius);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_ROTATION, pDef->m_flConstantRotation);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_ROTATION_SPEED, pDef->m_flConstantRotationSpeed);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_TINT_RGB,
                pDef->m_ConstantColor.r() / 255.0f, pDef->m_ConstantColor.g() / 255.0f,
                pDef->m_ConstantColor.g() / 255.0f);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_ALPHA, pDef->m_ConstantColor.a() / 255.0f);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_CREATION_TIME, 0.0f);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_SEQUENCE_NUMBER, pDef->m_nConstantSequenceNumber);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_SEQUENCE_NUMBER1, pDef->m_nConstantSequenceNumber1);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_TRAIL_LENGTH, 0.1f);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_PARTICLE_ID, 0);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_YAW, 0);*/
    }
    step(elapsedTime) {
        this.currentTime += elapsedTime;
        if (this.timeToLive) {
            this.proportionOfLife = this.currentTime / this.timeToLive;
        }
    }
    start() {
        this.isAlive = true;
        this.currentTime = 0;
        this.proportionOfLife = 0;
        //this.trail = new Array();
    }
    die() {
        this.isAlive = false;
    }
    reset() {
        //this.firstRender = true;
        this.currentTime = 0;
        this.proportionOfLife = 0;
        this.timeToLive = 1;
        vec3.zero(this.position);
        vec3.zero(this.prevPosition);
        vec3.zero(this.cpPosition);
        vec4.zero(this.cpOrientation);
        //vec3.zero(this.offsetPosition);
        vec3.zero(this.velocity);
        this.color.setWhite();
        this.initialColor.setWhite();
        this.u = 0;
        this.v = 0;
        this.radius = 1;
        this.initialRadius = 1;
        this.rotationRoll = 0;
        this.initialRoll = 0;
        this.rotationSpeedRoll = 0;
        this.rotationYaw = 0;
        this.startAlpha = 175 / 255;
        this.alpha = this.startAlpha;
        this.alpha2 = 1.0;
        // sequence number for animated textures
        this.sequence = 0;
        this.frame = 0;
        this.PositionFromParentParticles = false;
        this.posLockedToCP = -2;
        this.rotLockedToCP = -2;
        this.trailLength = 0.1;
        this.initialCPPosition = null;
        this.initialCPQuaternion = null;
        this.renderScreenVelocityRotate = false;
    }
    setInitialField(field /*TODO: use enum*/, value, mulInitial) {
        this.setField(field, value, mulInitial, true);
    }
    setField(field = 0, value, mulInitial = false, setInitial = false) {
        if (isNaN(field)) {
            return;
        }
        //console.log('Field ' + field + ' ' + value);
        switch (field) {
            case 0: // Position
                vec3.copy(this.position, value);
                break;
            case 1: // Time to live
                //if (mulInitial) {value*=this.initialSequence;}
                //this.sequence = Math.round(value);
                if (mulInitial) {
                    value += this.initialTimeToLive;
                }
                this.timeToLive = value;
                //console.log(value);
                break;
            case 2: // Previous position
                vec3.copy(this.prevPosition, value);
                break;
            case 3:
                if (mulInitial) {
                    value += this.initialRadius;
                }
                this.radius = value;
                if (setInitial) {
                    this.initialRadius = value;
                }
                break;
            case 4: //roll
                //value*=57.3;
                if (value instanceof Float32Array) {
                    value = value[0];
                }
                if (mulInitial) {
                    value += this.initialRoll;
                }
                this.rotationRoll = value; //TODO
                break;
            case 5:
                this.rotationSpeedRoll = value;
                break;
            case 6: // Color
                if (mulInitial) {
                    value[0] += this.initialColor.r;
                    value[1] += this.initialColor.g;
                    value[2] += this.initialColor.b;
                }
                value[0] = clamp$1(value[0], 0.0, 1.0);
                value[1] = clamp$1(value[1], 0.0, 1.0);
                value[2] = clamp$1(value[2], 0.0, 1.0);
                this.color.fromVec3(value);
                if (setInitial) {
                    this.initialColor.fromVec3(value);
                }
                break;
            case 7: // Alpha
                if (mulInitial) {
                    value *= this.startAlpha;
                }
                if (setInitial) {
                    this.startAlpha = value;
                }
                this.alpha = value;
                break;
            //case 8: // creation time
            //case 9: // sequence#
            //case 10: // trail length
            case 12: // yaw
                if (value instanceof Float32Array) {
                    value = value[0];
                }
                this.rotationYaw = value; //TODO
                break;
            case 16: // Alpha2
                this.alpha2 = value;
                break;
        }
    }
    /**
    * TODO
    */
    /*
    // required
    DEFPARTICLE_ATTRIBUTE(XYZ, 0);

    // particle lifetime (duration) of particle as a float.
    DEFPARTICLE_ATTRIBUTE(LIFE_DURATION, 1);

    // prev coordinates for verlet integration
    DEFPARTICLE_ATTRIBUTE(PREV_XYZ, 2);

    // radius of particle
    DEFPARTICLE_ATTRIBUTE(RADIUS, 3);

    // rotation angle of particle
    DEFPARTICLE_ATTRIBUTE(ROTATION, 4);

    // rotation speed of particle
    DEFPARTICLE_ATTRIBUTE(ROTATION_SPEED, 5);

    // tint of particle
    DEFPARTICLE_ATTRIBUTE(TINT_RGB, 6);

    // alpha tint of particle
    DEFPARTICLE_ATTRIBUTE(ALPHA, 7);

    // creation time stamp (relative to particle system creation)
    DEFPARTICLE_ATTRIBUTE(CREATION_TIME, 8);

    // sequnece # (which animation sequence number this particle uses)
    DEFPARTICLE_ATTRIBUTE(SEQUENCE_NUMBER, 9);

    // length of the trail
    DEFPARTICLE_ATTRIBUTE(TRAIL_LENGTH, 10);

    // unique particle identifier
    DEFPARTICLE_ATTRIBUTE(PARTICLE_ID, 11);

    // unique rotation around up vector
    DEFPARTICLE_ATTRIBUTE(YAW, 12);

    // second sequnece # (which animation sequence number this particle uses)
    DEFPARTICLE_ATTRIBUTE(SEQUENCE_NUMBER1, 13);

    // hit box index
    DEFPARTICLE_ATTRIBUTE(HITBOX_INDEX, 14);

    DEFPARTICLE_ATTRIBUTE(HITBOX_RELATIVE_XYZ, 15);

    DEFPARTICLE_ATTRIBUTE( ALPHA2, 16 );
    */
    getField(field = 0, initial = false) {
        switch (field) {
            case 1: // Time to live
                return initial ? this.initialTimeToLive : this.timeToLive;
            case 3:
                return this.radius;
            case 4:
                return this.rotationRoll;
            case 5:
                return this.rotationSpeedRoll;
            case 7:
                return this.alpha;
            case 8: //creation time
                return this.cTime;
            case 12: //yaw
                return this.rotationYaw;
            case 16: //alpha2
                return this.alpha2;
        }
        return 0;
    }
    /**
    * TODO
    */
    setInitialSequence(sequence) {
        this.sequence = sequence;
        this.initialSequence = sequence;
    }
    /**
    * TODO
    */
    setInitialRadius(radius) {
        this.radius = radius;
        this.initialRadius = radius;
    }
    /**
    * TODO
    */
    setInitialTTL(timeToLive) {
        this.timeToLive = timeToLive;
        this.initialTimeToLive = timeToLive;
    }
    /**
    * TODO
    */
    setInitialColor(color) {
        this.color = color;
        this.initialColor = color;
    }
    /**
    * Set particle initial rotation roll.
    * @param {Number} roll Initial rotation roll.
    */
    setInitialRoll(roll) {
        this.rotationRoll = roll;
        this.initialRoll = roll;
    }
    /**
    * Get particle world position
    * @param {vec3|null} The receiving vector. Created if null.
    * @return {vec3} The world position.
    */
    getWorldPos(worldPos) {
        worldPos = worldPos || vec3.create();
        //vec3.transformQuat(worldPos, this.position, this.cpOrientation);
        //vec3.transformQuat(worldPos, this.position, quat.create());
        //vec3.transformQuat(worldPos, this.position, this.system.currentOrientation);
        vec3.transformQuat(worldPos, this.position, this.cpOrientation);
        if (this.initialCPPosition) ;
        vec3.copy(worldPos, this.position);
        return worldPos;
    }
    /**
    * Get particle world position
    * @param {vec3|null} The receiving vector. Created if null.
    * @return {vec3} The world position.
    */
    getLocalPos(worldPos) {
        worldPos = worldPos || vec3.create();
        vec3.transformQuat(worldPos, this.position, this.cpOrientation);
        vec3.transformQuat(worldPos, this.position, quat.create());
        //vec3.add(worldPos, worldPos, this.cpPosition);
        return worldPos;
    }
}
/* FIELDS
0:velocity ??
1: TTL
3:radius
4:roll
5:roll speed ??
6: color
7: alpha
8:current time
10:scale
12:yaw???
//-----------------------------------------------------------------------------
// Particle attributes
//-----------------------------------------------------------------------------
#define MAX_PARTICLE_ATTRIBUTES 32

#define DEFPARTICLE_ATTRIBUTE(name, bit)						\
    const int PARTICLE_ATTRIBUTE_##name##_MASK = (1 << bit);	\
    const int PARTICLE_ATTRIBUTE_##name = bit;

// required
DEFPARTICLE_ATTRIBUTE(XYZ, 0);

// particle lifetime (duration) of particle as a float.
DEFPARTICLE_ATTRIBUTE(LIFE_DURATION, 1);

// prev coordinates for verlet integration
DEFPARTICLE_ATTRIBUTE(PREV_XYZ, 2);

// radius of particle
DEFPARTICLE_ATTRIBUTE(RADIUS, 3);

// rotation angle of particle
DEFPARTICLE_ATTRIBUTE(ROTATION, 4);

// rotation speed of particle
DEFPARTICLE_ATTRIBUTE(ROTATION_SPEED, 5);

// tint of particle
DEFPARTICLE_ATTRIBUTE(TINT_RGB, 6);

// alpha tint of particle
DEFPARTICLE_ATTRIBUTE(ALPHA, 7);

// creation time stamp (relative to particle system creation)
DEFPARTICLE_ATTRIBUTE(CREATION_TIME, 8);

// sequnece # (which animation sequence number this particle uses)
DEFPARTICLE_ATTRIBUTE(SEQUENCE_NUMBER, 9);

// length of the trail
DEFPARTICLE_ATTRIBUTE(TRAIL_LENGTH, 10);

// unique particle identifier
DEFPARTICLE_ATTRIBUTE(PARTICLE_ID, 11);

// unique rotation around up vector
DEFPARTICLE_ATTRIBUTE(YAW, 12);

// second sequnece # (which animation sequence number this particle uses)
DEFPARTICLE_ATTRIBUTE(SEQUENCE_NUMBER1, 13);

// hit box index
DEFPARTICLE_ATTRIBUTE(HITBOX_INDEX, 14);

DEFPARTICLE_ATTRIBUTE(HITBOX_RELATIVE_XYZ, 15);

*/
/**
 * TODO
 */

var _a;
const MAX_PARTICLE_CONTROL_POINTS = 64;
let systemNumber = 0;
class ParamType {
    param;
    type;
    constructor(param, type) {
        this.param = param;
        this.type = type;
    }
}
class Source1ParticleSystem extends Entity {
    isParticleSystem = true;
    repository;
    #autoKill = false;
    #looping = false;
    isLoopable = true;
    #sequenceNumber = 0;
    #materialPromiseResolve;
    #materialPromise;
    #renderers = new Map();
    #particleCount = 0;
    #randomSeed = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
    #maximumTimeStep = 0.1;
    animable = true;
    resetable = true;
    paramList = [];
    parameters = {};
    minimumTickRate = 0;
    maximumTickRate = 1;
    // particle to emit when the system starts
    initialParticles = 0;
    currentParticles = 0;
    currentTime = 0;
    // elapsed time since last ste
    elapsedTime = 0.05;
    previousElapsedTime = 0.05;
    speed = 1;
    isRunning = false;
    radius = 1;
    //attachmentBone = null;
    // List of living particles
    #livingParticles = []; // TODO: turn into queue ?
    // List of dead but reusable particles
    #poolParticles = []; // TODO: turn into queue ?
    currentOrientation = quat.create();
    prevOrientation = quat.create();
    emitters = {}; //new Array();//todo transform to map
    initializers = {}; // = new Array();//todo transform to map
    operators = {}; //new Array();//todo transform to map
    forces = new Map();
    constraints = {}; //new Array();//todo transform to map
    #controlPoints = [];
    #childrenSystems = []; //todo transform to map
    tempChildren = {}; //new Array();//todo transform to map
    operatorRandomSampleOffset = 0;
    parentSystem;
    firstStep = false;
    pcf;
    material;
    materialName;
    maxParticles = DEFAULT_MAX_PARTICLES$2;
    resetDelay = 0;
    snapshot;
    static #speed = 1.0;
    static #simulationSteps = 1;
    //constructor(repository, parameters, id) {
    constructor(params) {
        params.name = params.name ?? `System ${systemNumber++}`;
        super(params);
        this.repository = params.repository;
        this.addParam('max_particles', PARAM_TYPE_INT, 50);
        this.addParam('initial_particles', PARAM_TYPE_INT, 0);
        this.addParam('material', PARAM_TYPE_STRING, '');
        this.addParam('snapshot', PARAM_TYPE_STRING, '');
        this.addParam('color', PARAM_TYPE_COLOR, new ParticleColor(255, 255, 255, 255));
        this.addParam('radius', PARAM_TYPE_FLOAT, 1);
        this.addParam('name', PARAM_TYPE_STRING, params.name);
        this.addParam('id', PARAM_TYPE_ID, params.id);
        this.addParam('minimum sim tick rate', PARAM_TYPE_FLOAT, 0);
        this.addParam('maximum sim tick rate', PARAM_TYPE_FLOAT, 1);
        this.addParam('maximum time step', PARAM_TYPE_FLOAT, 0.1);
        //this.maxParticles = null;
        //this.getControlPoint(0);
        /*for (let i = 0; i < MAX_PARTICLE_CONTROL_POINTS; ++i) {
            let cp = new ControlPoint();
            cp.name = i;
            this.addChild(cp);
            this.controlPoints.push(cp);

            vec3.set(cp.fVector, 0, 1, 0);
            vec3.set(cp.uVector, 0, 0, 1);
            vec3.set(cp.rVector, 1, 0, 0);
        }*/
    }
    start() {
        if (this.isRunning)
            return;
        Source1ParticleControler.setActive(this);
        this.firstStep = true;
        this.updateChilds();
        this.#reset();
        this.#startChildren();
        //		this.emitInitialParticles();
        this.isRunning = true;
    }
    #startChildren() {
        for (const childrenSystem of this.#childrenSystems) {
            childrenSystem.start();
        }
    }
    stop() {
        this.stopChildren();
        this.isRunning = false;
        for (const particle of this.#livingParticles) {
            this.#poolParticles.push(particle);
        }
        this.#livingParticles.splice(0);
    }
    stopChildren() {
        for (const childrenSystem of this.#childrenSystems) {
            childrenSystem.stop();
        }
    }
    do(action, params) {
        switch (action) {
            case 'reset':
                this.reset();
                break;
        }
    }
    reset() {
        this.stop();
        this.start();
    }
    #reset() {
        //console.log('Reset PS');
        this.currentTime = 0;
        this.elapsedTime = 0.05;
        this.previousElapsedTime = 0.05;
        this.#resetChilds();
        this.#resetEmitters();
        this.#resetInitializers();
    }
    #resetChilds() {
        for (const childrenSystem of this.#childrenSystems) {
            childrenSystem.#reset();
        }
    }
    #resetEmitters() {
        for (const i in this.emitters) { //TODOv3
            this.emitters[i].reset();
        }
    }
    #resetInitializers() {
        for (const i in this.initializers) {
            this.initializers[i].reset();
        }
    }
    updateChilds() {
        for (const i in this.tempChildren) {
            const ps = this.pcf?.getSystem(this.tempChildren[i]);
            if (ps) {
                this.addChildSystem(ps);
                delete this.tempChildren[i];
            }
        }
    }
    step(elapsedTime) {
        if (!this.isPlaying()) {
            elapsedTime = 0.0000001;
        }
        for (let i = 0; i < _a.#simulationSteps; i++) {
            this.#step(elapsedTime / _a.#simulationSteps);
        }
    }
    #step(elapsedTime) {
        if (!this.isRunning || _a.#speed == 0) {
            return;
        }
        elapsedTime = Math.min(elapsedTime, this.#maximumTimeStep);
        this.previousElapsedTime = this.elapsedTime;
        this.elapsedTime = elapsedTime;
        //elapsedTime = clamp(elapsedTime, this.minimumTickRate, this.maximumTickRate);
        this.stepControlPoint();
        if (this.firstStep) {
            this.firstStep = false;
            elapsedTime = 0.05;
            this.#emitInitialParticles(elapsedTime);
        }
        this.elapsedTime = elapsedTime * this.speed * _a.#speed;
        this.#stepOperators1();
        this.stepControlPoint();
        this.#stepEmitters();
        this.currentTime += this.elapsedTime;
        //this.stepForces();
        if (!this.parentSystem) {
            this.setCpOrientation();
        }
        else {
            this.setCpOrientation();
        }
        this.#stepOperators();
        //this.stepConstraints();
        /*if (this.livingParticles.length == 0 && this.allowReset) {
            this.resetDelay+=this.elapsedTime;
            if (this.resetDelay>RESET_DELAY) this.reset();
        };*/
        if (this.material) {
            this.#stepRenderers(elapsedTime);
        }
        this.#stepChildren(elapsedTime);
    }
    #emitInitialParticles(elapsedTime) {
        for (let i = 0; i < this.initialParticles; ++i) {
            this.createParticle(0, elapsedTime);
        }
    }
    #stepEmitters() {
        for (const i in this.emitters) {
            this.emitters[i].doEmit(this.elapsedTime);
        }
    }
    /**
     * Step operators for each particle, killing it if necessary.
     */
    #stepOperators() {
        for (let i = 0; i < this.#livingParticles.length; ++i) {
            const particle = this.#livingParticles[i];
            particle.step(this.elapsedTime);
            this.operatorRandomSampleOffset = 0;
            for (const j in this.operators) {
                const operator = this.operators[j];
                operator.operateParticle(particle, this.elapsedTime);
                // break the loop if the particle is dead
                if (!particle.isAlive)
                    break;
                this.operatorRandomSampleOffset += 17;
            }
            //particle.step(this.elapsedTime);
            if (!particle.isAlive) {
                this.#poolParticles.push(particle);
                this.#livingParticles.splice(i, 1);
                --i;
            }
        }
        if (this.#livingParticles.length == 0) {
            for (const j in this.operators) {
                const operator = this.operators[j];
                switch (operator.functionName) {
                    case 'set control point positions':
                        operator.operateParticle(null, this.elapsedTime);
                        break;
                }
            }
            this.#checkFinished();
        }
    }
    #checkFinished() {
        if (this.#finished()) {
            if (this.#autoKill) {
                this.stop();
                this.remove();
                return;
            }
            if (this.#looping) {
                //TODO: add delay
                this.#reset();
            }
        }
    }
    #finished() {
        if (Object.keys(this.tempChildren).length) {
            return false;
        }
        for (const i in this.emitters) {
            const emitter = this.emitters[i];
            if (!emitter.finished()) {
                return false;
            }
        }
        for (const child of this.#childrenSystems) {
            if ((child.#livingParticles.length > 0) || !child.#finished()) {
                return false;
            }
        }
        return true;
    }
    #stepOperators1() {
        if (this.#livingParticles.length == 0) {
            for (const j in this.operators) {
                const operator = this.operators[j];
                switch (operator.functionName) {
                    case 'set control point positions':
                        operator.operateParticle(null, this.elapsedTime);
                        break;
                }
            }
        }
    }
    /**
     * Step forces for each particle.
     */
    stepForces() {
        for (let i = 0; i < this.#livingParticles.length; ++i) {
            const particle = this.#livingParticles[i];
            for (const force of this.forces.values()) {
                //const force = this.forces[j];
                force.forceParticle(particle, this.elapsedTime);
            }
        }
    }
    stepConstraints(particle) {
        //TODOv3: multiple passes
        for (const j in this.constraints) {
            const constraint = this.constraints[j];
            constraint.constraintParticle(particle);
        }
    }
    #stepRenderers(elapsedTime) {
        for (const [_, renderer] of this.#renderers) {
            renderer.updateParticles(this, this.#livingParticles, elapsedTime);
        }
    }
    #stepChildren(elapsedTime) {
        for (const j in this.#childrenSystems) { //TODOv3
            const child = this.#childrenSystems[j];
            child.#step(elapsedTime);
        }
    }
    createParticle(creationTime, elapsedTime) {
        if (this.#livingParticles.length < this.maxParticles) {
            // first try to get one from the pool
            if (this.#poolParticles.length > 0) {
                const particle = this.#poolParticles.pop();
                //init the particle to its initial state;
                particle.reset();
                particle.cTime = creationTime;
                this.#initControlPoint(particle);
                this.#startParticle(particle, elapsedTime);
                return particle;
            }
            const particle = new Source1Particle(/*'Particle ' + */ (this.#randomSeed + this.#particleCount++) % MAX_FLOATS, this);
            particle.cTime = creationTime;
            this.#initControlPoint(particle);
            this.#startParticle(particle, elapsedTime);
            ++this.currentParticles;
            return particle;
        }
        //console.error('No particle has been emitted. Try to raise max particles');
        return null;
    }
    #startParticle(particle, elapsedTime) {
        this.resetDelay = 0;
        this.#livingParticles.push(particle);
        this.#preInitParticle(particle);
        particle.previousElapsedTime = elapsedTime;
        particle.start();
        // Init modifiers in a 2nd loop
        for (const i in this.initializers) {
            const initializer = this.initializers[i];
            if (!initializer.initMultipleOverride()) {
                initializer.initializeParticle(particle, elapsedTime);
            }
        }
        for (const i in this.initializers) {
            const initializer = this.initializers[i];
            if (initializer.initMultipleOverride()) {
                initializer.initializeParticle(particle, elapsedTime);
            }
        }
    }
    #preInitParticle(particle) {
        const radius = this.getParameter('radius') || 1;
        const color = this.getParameter('color') ?? WHITE;
        particle.setInitialRadius(radius);
        particle.setInitialSequence(this.#sequenceNumber);
        particle.color.setColorAlpha(color); //TODO: remove alpha
        particle.startAlpha = color.a;
        particle.alpha = color.a;
        //particle.creationTime = this.currentTime;
    }
    #initControlPoint(particle) {
        this.getWorldPosition(particle.cpPosition);
    }
    getWorldPosition(vec = vec3.create()) {
        return vec3.zero(vec);
    }
    stepControlPoint() {
        for (let i = 0; i < this.#controlPoints.length; i++) {
            const cp = this.#controlPoints[i];
            if (!cp) {
                continue;
            }
            cp.step();
        }
        if (this.parentSystem) {
            this.setOrientation(this.parentSystem.getWorldQuaternion());
        }
    }
    setParam(element) {
        if (!element) {
            return null;
        }
        const parameter = element.typeName;
        const type = element.type;
        const value = element.value;
        return this.setParameter(parameter, type, value);
    }
    addParam(param, type, value) {
        this.paramList.push(new ParamType(param, type));
        this.setParameter(param, type, value);
    }
    setParameter(parameter, type /*TODO: create an enum*/, value) {
        if (parameter == '')
            return;
        if (this.parameters[parameter] === undefined) {
            this.parameters[parameter] = {};
        }
        this.parameters[parameter].type = type;
        this.parameters[parameter].value = value;
        this.propertyChanged(parameter);
        return this;
    }
    propertyChanged(name) {
        const value = this.getParameter(name);
        switch (name) {
            case 'material':
                this.setMaterialName(value);
                break;
            case 'max_particles':
                this.setMaxParticles(value);
                break;
            case 'snapshot':
                this.setSnapshot(value);
                break;
            /*
        case 'snapshot_control_point':
            this.setSnapshotCP(value);
            break;
            */
            case 'radius':
                this.setRadius(value);
                break;
            case 'initial_particles':
                this.setInitialParticles(value);
                break;
            case 'minimum sim tick rate':
                this.setMinimumTickRate(value);
                break;
            case 'maximum sim tick rate':
                this.setMaximumTickRate(value);
                break;
            case 'maximum time step':
                this.#maximumTimeStep = value;
                break;
            case 'sequence_number':
                this.#sequenceNumber = value;
                break;
        }
    }
    getParameter(parameterName) {
        const parameter = this.parameters[parameterName];
        if (parameter === undefined) {
            return null;
        }
        return parameter.value;
    }
    setMaxParticles(max) {
        this.maxParticles = Math.max(Math.min(max, HARD_MAX_PARTICLES), 1);
    }
    setRadius(radius) {
        this.radius = radius;
    }
    setInitialParticles(initial) {
        this.initialParticles = initial;
    }
    setMinimumTickRate(minimum) {
        this.minimumTickRate = minimum;
    }
    setMaximumTickRate(maximum) {
        this.maximumTickRate = maximum;
    }
    async setMaterialName(materialName) {
        if (!materialName || materialName === '') {
            return;
        }
        this.materialName = materialName;
        const material = await Source1MaterialManager.getMaterial(this.repository, materialName);
        if (material) {
            this.material = material;
            material.addUser(this);
            if (this.#materialPromiseResolve) {
                this.#materialPromiseResolve(material);
            }
        }
    }
    #getMaterial() {
        this.#materialPromise = this.#materialPromise ?? new Promise(resolve => {
            this.#materialPromiseResolve = resolve;
        });
        return this.#materialPromise;
    }
    setSnapshot(snapshot /*TODO: better type*/) {
        if (!snapshot || snapshot === '') {
            return;
        }
        if (snapshot !== this.snapshot) {
            this.snapshot = snapshot;
            //this.loadSnapshot();//TODOv3
        }
    }
    addSub(type, object, id) {
        switch (type) {
            case 'operator':
            case 'operators':
                this.#addOperator(object, id);
                break;
            case 'force':
            case 'forces':
                this.#addForce(object, id);
                break;
            case 'constraint':
            case 'constraints':
                this.#addConstraint(object, id);
                break;
            case 'emitter':
            case 'emitters':
                this.#addEmitter(object, id);
                break;
            case 'initializer':
            case 'initializers':
                this.#addInitializer(object, id);
                break;
            case 'renderer':
            case 'renderers':
                this.#addRenderer(object, id);
                break;
        }
    }
    #addEmitter(emitter, id) {
        this.emitters[id] = emitter;
    }
    #addInitializer(initializer, id) {
        this.initializers[id] = initializer;
    }
    #addOperator(operator, id) {
        this.operators[id] = operator;
    }
    /*
    removeOperator(id: string) {//TODOv3 improve
        delete this.emitters[id];
        delete this.initializers[id];
        delete this.operators[id];
        this.forces.delete(id);
        delete this.constraints[id];
        this.#renderers.delete(id);
        //delete this.childrenSystems[id];
        //this.removeChild(id);
    }
    */
    #addForce(force, id) {
        this.forces.set(id, force);
    }
    #addConstraint(constraint, id) {
        this.constraints[id] = constraint;
    }
    #addRenderer(renderer, id) {
        this.#renderers.set(id, renderer);
        this.#getMaterial().then((material) => renderer.initRenderer());
    }
    getControlPoint(controlPointId) {
        if (controlPointId < 0 || controlPointId >= MAX_PARTICLE_CONTROL_POINTS) {
            return null;
        }
        const parentSystem = this.parentSystem;
        if (parentSystem !== undefined) {
            return this.#controlPoints[controlPointId] ?? parentSystem.getControlPoint(controlPointId);
        }
        let controlPoint = this.#controlPoints[controlPointId];
        if (controlPoint === undefined) {
            controlPoint = this.#createControlPoint(controlPointId);
        }
        return controlPoint;
    }
    getControlPoints() {
        return this.#controlPoints;
    }
    getOwnControlPoint(controlPointId) {
        return this.#controlPoints[controlPointId] ?? this.#createControlPoint(controlPointId);
    }
    #createControlPoint(controlPointId) {
        const controlPoint = new ControlPoint();
        controlPoint.name = String(controlPointId);
        if (controlPointId == 0) {
            this.addChild(controlPoint);
        }
        else {
            //Attach to first control point
            //this.getControlPoint(0).addChild(controlPoint);
            this.addChild(controlPoint);
        }
        this.#controlPoints[controlPointId] = controlPoint;
        vec3.set(controlPoint.fVector, 0, 1, 0);
        vec3.set(controlPoint.uVector, 0, 0, 1);
        vec3.set(controlPoint.rVector, 1, 0, 0);
        const parentSystem = this.parentSystem;
        if (parentSystem !== undefined) {
            const parentControlPoint = parentSystem.getControlPoint(controlPointId);
            if (parentControlPoint) {
                controlPoint.parentControlPoint = parentControlPoint;
            }
        }
        return controlPoint;
    }
    addTempChild(name, id) {
        this.tempChildren[id] = name;
    }
    addChildSystem(particleSystem) {
        this.#childrenSystems.push(particleSystem);
        particleSystem.setParent(this);
        this.addChild(particleSystem);
        particleSystem.serializable = false;
        /*let parentControlPoint = this.getControlPoint(0);
        let childControlPoint = particleSystem.getControlPoint(0);
        parentControlPoint.addChild(childControlPoint);*/
        /*for (let i = 0; i < MAX_PARTICLE_CONTROL_POINTS; ++i) {
            let parentCp = this.controlPoints[i];
            let childCp = particleSystem.controlPoints[i];
            parentCp.addChild(childCp);
        }*/
        //particleSystem.setSkyBox(this.skybox);TODOv3
    }
    setParent(parentSystem) {
        return this.parentSystem = parentSystem;
    }
    /**
     * Orient all particles relative to control point #0.
     */
    setCpOrientation() {
        return; //TODOV3
        /*
        const cp = this.getControlPoint(0);
        if (cp) {
            const orientation = cp.getWorldQuaternion();
            for (let i = 0; i < this.livingParticles.length; ++i) {
                const particle = this.livingParticles[i];
                quat.copy(particle.cpOrientation, orientation);
                quat.copy(particle.cpOrientation, this.getWorldQuaternion());
            }
        }*/
    }
    /**
     * Set control point orientation
     * @param (Object quat) orientation New orientation
     */
    setOrientation(orientation) {
        quat.copy(this.prevOrientation, this.currentOrientation);
        quat.copy(this.currentOrientation, orientation);
    }
    setChildControlPointPosition(first, last, position) {
        for (const child of this.#childrenSystems) {
            for (let cpId = first; cpId <= last; ++cpId) {
                const cp = child.getOwnControlPoint(cpId);
                if (cp) {
                    cp.position = position;
                    //The control point is now world positioned
                    //Therefore we remove it from the hierarchy
                    //cp.remove();
                }
            }
        }
    }
    setChildControlPointOrientation(first, last, orientation) {
        for (const child of this.#childrenSystems) {
            for (let cpId = first; cpId <= last; ++cpId) {
                const cp = child.getOwnControlPoint(cpId);
                if (cp) {
                    cp.setQuaternion(orientation);
                    //The control point is now world positioned
                    //Therefore we remove it from the hierarchy
                    //cp.remove();
                }
            }
        }
    }
    getParticle(index) {
        if (index == undefined) {
            index = Math.floor(Math.random() * this.#livingParticles.length);
        }
        /*if (index >= this.livingParticles.length) {
            index = Math.floor(Math.random() * this.poolParticles.length);
            return this.poolParticles[index];
        }*/
        return this.#livingParticles[index];
    }
    getControlPointPosition(cpId) {
        const cp = this.getControlPoint(cpId);
        if (cp) {
            return cp.getWorldPosition();
        }
        return vec3.create();
    }
    setControlPointPosition(cpId, position) {
        const cp = this.getOwnControlPoint(cpId);
        if (cp) {
            cp.position = position;
        }
    }
    setControlPointParent(controlPointId, parentControlPointId) {
        this.getControlPoint(controlPointId);
        this.parentSystem;
        /*
                if (cp && cpParent) {
                    cp.setParent(cpParent);
                }*/
        // Not sure it should be done resursively ?
        // This function is only used in 'set control point positions'
        /*for (let child of this.childrenSystems) {
            child.setControlPointParent(controlPointId, parentControlPointId);
        }*/
    }
    getWorldQuaternion(q = quat.create()) {
        quat.copy(q, this._quaternion);
        return q;
    }
    getBoundingBox(boundingBox = new BoundingBox()) {
        boundingBox.reset();
        return boundingBox;
    }
    set autoKill(autoKill) {
        this.#autoKill = autoKill;
    }
    get autoKill() {
        return this.#autoKill;
    }
    setLooping(looping) {
        this.#looping = looping;
    }
    getLooping() {
        return this.#looping;
    }
    dispose() {
        super.dispose();
        this.#controlPoints.forEach(element => element.dispose());
        this.#controlPoints.length = 0;
        this.material?.removeUser(this);
        for (const [_, renderer] of this.#renderers) {
            renderer.dispose();
        }
        for (const child of this.#childrenSystems) {
            child.dispose();
        }
    }
    getBounds(min = vec3.create(), max = vec3.create()) {
        if (!this.#livingParticles.length) {
            vec3.set(min, -1, -1, -1);
            vec3.set(max, 1, 1, 1);
        }
        else {
            vec3.set(min, Infinity, Infinity, Infinity);
            vec3.set(max, -Infinity, -Infinity, -Infinity);
            for (const particle of this.#livingParticles) {
                vec3.min(min, min, particle.position);
                vec3.max(max, max, particle.position);
            }
        }
    }
    static setSpeed(speed) {
        _a.#speed = speed;
    }
    static setSimulationSteps(simulationSteps) {
        simulationSteps = Math.round(simulationSteps);
        if (simulationSteps > 0 && simulationSteps <= 10) {
            _a.#simulationSteps = simulationSteps;
        }
    }
    getChildrenSystems() {
        return this.#childrenSystems;
    }
    getActiveParticlesCount() {
        return this.#livingParticles.length; //TODO: optimize
    }
    buildContextMenu() {
        const startStop = this.isRunning ? { i18n: '#stop', f: () => this.stop() } : { i18n: '#start', f: () => this.start() };
        return Object.assign(super.buildContextMenu(), {
            SourceEngineParticleSystem_1: null,
            startStop: startStop,
            reset: { i18n: '#reset', f: () => this.reset() },
        });
    }
    toJSON() {
        const json = super.toJSON();
        json.repository = this.repository;
        if (!this.isRunning) {
            json.isrunning = false;
        }
        const jControlPoint = [];
        this.#controlPoints.forEach((element, index) => jControlPoint[index] = element.id);
        json.controlpoints = jControlPoint;
        return json;
    }
    static async constructFromJSON(json /*TODO: better type*/, entities, loadedPromise) {
        const entity = await Source1ParticleControler.createSystem(json.repository, json.name);
        if (entity) {
            loadedPromise.then(() => {
                console.error(entities);
                const jControlPoint = json.controlpoints;
                if (jControlPoint) {
                    for (let i = 0; i < jControlPoint.length; ++i) {
                        const cpEntity = entities.get(jControlPoint[i]);
                        if (cpEntity) {
                            entity.#controlPoints[i] = cpEntity;
                        }
                    }
                }
                if (json.isrunning !== false) {
                    entity.start();
                }
            });
        }
        return entity;
    }
    static getEntityName() {
        return 'Source1ParticleSystem';
    }
}
_a = Source1ParticleSystem;
Source1ParticleSystem.prototype.isParticleSystem = true;
registerEntity(Source1ParticleSystem);
Source1ParticleControler.setParticleConstructor(Source1ParticleSystem);

class SourcePCF {
    repository;
    path;
    stringDict = [];
    elementsDict = [];
    systems = {}; //TODO: turn into map
    systems2 = {}; //TODO: turn into map
    binaryVersion = 0;
    constructor(repository, path) {
        this.repository = repository;
        this.path = path;
    }
    getSystemElement(systemName) {
        return this.systems[systemName];
    }
    addSystem(element) {
        this.systems[element.name] = element;
        this.systems2[element.guid2] = element;
    }
    getSystem(systemName) {
        const element = this.systems[systemName];
        if (!element) {
            return null;
        }
        const attributes = element.attributes;
        const ps = new Source1ParticleSystem({ repository: this.repository, name: systemName });
        ps.pcf = this; // Store PCF to load children
        ps.repository = this.repository;
        for (const attribute of attributes) {
            switch (attribute.typeName) {
                case 'renderers':
                case 'operators':
                case 'initializers':
                case 'emitters':
                case 'forces':
                case 'constraints':
                case 'children':
                    this.addOperators(ps, attribute.value /*TODO: check actual value*/, attribute.typeName);
                    break;
                default:
                    ps.setParam(attribute);
            }
        }
        return ps;
    }
    initSystem(system) {
        const element = this.systems[system.name];
        if (!element) {
            return null;
        }
        const attributes = element.attributes;
        system.pcf = this; // Store PCF to load children
        system.repository = this.repository;
        for (const attribute of attributes) {
            switch (attribute.typeName) {
                case 'renderers':
                case 'operators':
                case 'initializers':
                case 'emitters':
                case 'forces':
                case 'constraints':
                case 'children':
                    this.addOperators(system, attribute.value /*TODO: check actual value*/, attribute.typeName);
                    break;
                default:
                    system.setParam(attribute);
            }
        }
        return system;
    }
    addOperators(system, list, listType) {
        for (let i = 0; i < list.length; ++i) {
            const ope = list[i] /*TODO: check actual value*/;
            if (ope.type == 'DmeParticleOperator') {
                const operator = Source1ParticleOperators.getOperator(system, ope.name);
                if (operator) {
                    system.addSub(listType, operator, generateRandomUUID());
                    this.addAttributes(operator, ope.attributes);
                }
            }
            else {
                if (ope.type == 'DmeParticleChild') {
                    const attribs = ope.attributes;
                    for (const attrib of attribs) {
                        if (attrib.typeName == 'child' && attrib.value) {
                            system.addTempChild(attrib.value /*TODO: check actual value*/.name, ope.guid2);
                        }
                    }
                }
            }
        }
    }
    addAttributes(operator, list) {
        for (const attrib of list) {
            operator.setParameter(attrib.typeName, ELEMENT_TYPES[attrib.type], attrib.value);
        }
    }
}
const DmeElement = 'DmeElement';
const DmeParticleSystemDefinition = 'DmeParticleSystemDefinition';

const data_size = [
    0, 4, 4, 4, 1, 0, 0, 4, 4, 8, 12, 16, 12, 16, 64,
    4, 4, 4, 1, 0, 0, 4, 4, 8, 12, 16, 12, 16, 64,
];
const BINARY_FORMAT_POS = 25;
class Source1PcfLoader extends SourceBinaryLoader {
    parse(repository, path, content) {
        const pcf = new SourcePCF(repository, path);
        const reader = new BinaryReader(content);
        const str = reader.getString(Math.min(1000, content.byteLength));
        let startOffset = str.indexOf('-->');
        if (startOffset === 0) {
            return null;
        }
        startOffset += 5;
        pcf.binaryVersion = Number(str.substring(BINARY_FORMAT_POS, BINARY_FORMAT_POS + 1));
        if (pcf.binaryVersion !== 2 && pcf.binaryVersion !== 5) {
            console.log('Binary version unknown. Loading of file may be unaccurate.');
        }
        this.#parseHeader(reader, pcf, startOffset);
        //console.info(pcf);
        //console.info(pcfToSTring(pcf));
        //saveFile(new File([pcfToSTring(pcf)], 'pcf'));
        return pcf;
    }
    #parseHeader(reader, pcf, startOffset) {
        reader.seek(startOffset);
        let nStrings = 0;
        let nElements = 0;
        if (pcf.binaryVersion < 5) {
            nStrings = reader.getUint16();
        }
        else {
            nStrings = reader.getUint32();
        }
        for (let i = 0; i < nStrings; ++i) {
            pcf.stringDict.push(reader.getNullString());
        }
        if (pcf.binaryVersion < 5) {
            nElements = reader.getUint32();
        }
        else {
            nElements = reader.getUint32();
        }
        for (let i = 0; i < nElements; i++) {
            pcf.elementsDict.push(this.#parseElement(reader, pcf));
        }
        for (let i = 0; i < nElements; i++) {
            pcf.elementsDict[i].attributes = this.#parseAttributes(reader, pcf);
        }
    }
    #parseElement(reader, pcf) {
        const element = new CDmxElement();
        if (pcf.binaryVersion < 5) {
            element.type = this.getString(pcf, reader.getUint16());
        }
        else {
            element.type = this.getString(pcf, reader.getUint32());
        }
        if (pcf.binaryVersion < 5) {
            element.name = reader.getNullString();
        }
        else {
            element.name = this.getString(pcf, reader.getUint32());
        }
        element.guid = reader.getBytes(16);
        element.guid2 = guidToString(element.guid);
        if (element.type == DmeParticleSystemDefinition) {
            pcf.addSystem(element);
        }
        return element;
    }
    #parseAttributes(reader, pcf) {
        const attributes = [];
        const nAttributes = reader.getUint32();
        for (let i = 0; i < nAttributes; ++i) {
            attributes.push(this.#parseAttribute(reader, pcf));
        }
        return attributes;
    }
    #parseAttribute(reader, pcf) {
        const attribute = {};
        if (pcf.binaryVersion < 5) {
            attribute.typeName = this.getString(pcf, reader.getUint16());
        }
        else {
            attribute.typeName = this.getString(pcf, reader.getUint32());
        }
        attribute.type = reader.getUint8();
        if (attribute.type > 14) {
            attribute.value = this.#parseArray(reader, pcf, attribute.type);
        }
        else {
            attribute.value = this.#parseValue(reader, pcf, attribute.type);
        }
        return attribute;
    }
    #parseArray(reader, pcf, type) {
        const valuesCount = reader.getUint32();
        const value = [];
        for (let i = 0; i < valuesCount; ++i) {
            value.push(this.#parseValue(reader, pcf, type));
        }
        return value;
    }
    #parseValue(reader, pcf, type) {
        let size = data_size[type];
        let value = undefined;
        switch (type % 14) {
            case 1: // Element
                value = this.getElement(pcf, reader.getInt32());
                break;
            case 2: // Integer
                value = reader.getInt32();
                break;
            case 3: // Float
                value = reader.getFloat32();
                break;
            case 4: // Bool
                value = reader.getInt8();
                break;
            case 7: // Time
                value = reader.getInt32() / 10000.0;
                break;
            case 8: // Color
                //value = {r:reader.getUint8(), g:reader.getUint8(), b:reader.getUint8(), a:reader.getUint8()};
                value = new ParticleColor(reader.getUint8(), reader.getUint8(), reader.getUint8(), reader.getUint8());
                //value = [reader.getUint8(), reader.getUint8(), reader.getUint8(), reader.getUint8()];
                break;
            case 9: // vec2
                value = vec2.fromValues(reader.getFloat32(), reader.getFloat32());
                break;
            case 10: // vec3
                value = vec3.fromValues(reader.getFloat32(), reader.getFloat32(), reader.getFloat32());
                break;
            case 11: // vec4
                value = vec4.fromValues(reader.getFloat32(), reader.getFloat32(), reader.getFloat32(), reader.getFloat32());
                break;
            case 5:
                if (pcf.binaryVersion < 5) {
                    value = reader.getNullString();
                }
                else {
                    value = this.getString(pcf, reader.getInt32());
                }
                break;
            case 6:
                size = reader.getInt32();
                reader.seek(reader.tell() + size);
                break;
            default:
                console.error('unknown type', type, 'in #parseValue', pcf);
                throw 'fix me';
        }
        return value;
    }
    getString(pcf, index) {
        if (pcf) {
            const s = pcf.stringDict[index];
            if (s) {
                return s;
            }
            else {
                return '';
            }
        }
        return '';
    }
    getElement(pcf, index) {
        if (pcf) {
            const e = pcf.elementsDict[index];
            if (e) {
                return e;
            }
            else {
                return null;
            }
        }
        return null;
    }
}
registerLoader('Source1PcfLoader', Source1PcfLoader);
class CDmxElement {
    type;
    name;
    guid;
    guid2;
    attributes;
    inlineSubElements() {
        const subs = new Map();
        const done = new Set();
        let current;
        const stack = [this];
        do {
            current = stack.pop();
            if (!current || done.has(current)) {
                continue;
            }
            done.add(current);
            if (subs.has(current)) {
                subs.set(current, false);
            }
            else {
                subs.set(current, true);
            }
            for (const attribute of current.attributes) {
                switch (attribute.type) {
                    case CDmxAttributeType.Element:
                        // prevent inlining
                        subs.set(attribute.value, false);
                        stack.push(attribute.value);
                        break;
                    case CDmxAttributeType.ElementArray:
                        for (const subElement of attribute.value) {
                            stack.push(subElement);
                        }
                        break;
                }
            }
        } while (current);
        return subs;
    }
}
var CDmxAttributeType;
(function (CDmxAttributeType) {
    CDmxAttributeType[CDmxAttributeType["Unknown"] = 0] = "Unknown";
    CDmxAttributeType[CDmxAttributeType["Element"] = 1] = "Element";
    CDmxAttributeType[CDmxAttributeType["Integer"] = 2] = "Integer";
    CDmxAttributeType[CDmxAttributeType["Float"] = 3] = "Float";
    CDmxAttributeType[CDmxAttributeType["Bool"] = 4] = "Bool";
    CDmxAttributeType[CDmxAttributeType["String"] = 5] = "String";
    CDmxAttributeType[CDmxAttributeType["Void"] = 6] = "Void";
    CDmxAttributeType[CDmxAttributeType["Time"] = 7] = "Time";
    CDmxAttributeType[CDmxAttributeType["Color"] = 8] = "Color";
    CDmxAttributeType[CDmxAttributeType["Vec2"] = 9] = "Vec2";
    CDmxAttributeType[CDmxAttributeType["Vec3"] = 10] = "Vec3";
    CDmxAttributeType[CDmxAttributeType["Vec4"] = 11] = "Vec4";
    CDmxAttributeType[CDmxAttributeType["QAngle"] = 12] = "QAngle";
    CDmxAttributeType[CDmxAttributeType["Quaternion"] = 13] = "Quaternion";
    CDmxAttributeType[CDmxAttributeType["VMatrix"] = 14] = "VMatrix";
    CDmxAttributeType[CDmxAttributeType["ElementArray"] = 15] = "ElementArray";
    CDmxAttributeType[CDmxAttributeType["IntegerArray"] = 16] = "IntegerArray";
    CDmxAttributeType[CDmxAttributeType["FloatArray"] = 17] = "FloatArray";
    CDmxAttributeType[CDmxAttributeType["BoolArray"] = 18] = "BoolArray";
    CDmxAttributeType[CDmxAttributeType["StringArray"] = 19] = "StringArray";
    CDmxAttributeType[CDmxAttributeType["VoidArray"] = 20] = "VoidArray";
    CDmxAttributeType[CDmxAttributeType["TimeArray"] = 21] = "TimeArray";
    CDmxAttributeType[CDmxAttributeType["ColorArray"] = 22] = "ColorArray";
    CDmxAttributeType[CDmxAttributeType["Vec2Array"] = 23] = "Vec2Array";
    CDmxAttributeType[CDmxAttributeType["Vec3Array"] = 24] = "Vec3Array";
    CDmxAttributeType[CDmxAttributeType["Vec4Array"] = 25] = "Vec4Array";
    CDmxAttributeType[CDmxAttributeType["QAngleArray"] = 26] = "QAngleArray";
    CDmxAttributeType[CDmxAttributeType["QuaternionArray"] = 27] = "QuaternionArray";
    CDmxAttributeType[CDmxAttributeType["VMatrixArray"] = 28] = "VMatrixArray";
})(CDmxAttributeType || (CDmxAttributeType = {}));
function pcfToSTring(pcf) {
    const element = pcf.elementsDict[0];
    if (!element) {
        return null;
    }
    const inlineSubElements = element.inlineSubElements();
    const lines = [];
    const context = { tabs: 0, inlineSubElements: inlineSubElements, line: 1, elementsLine: new Map() };
    lines.push(cDmxElementToSTring(element, context));
    ++context.line;
    context.tabs = 0;
    for (const [subElement, inline] of inlineSubElements) {
        if (!inline) {
            lines.push(cDmxElementToSTring(subElement, context));
            ++context.line;
            lines.push('');
            ++context.line;
        }
    }
    return { text: lines.join('\n'), elementsLine: context.elementsLine };
}
function cDmxElementsToSTring(elements, context) {
    let lines = [];
    for (const element of elements) {
        if (context.inlineSubElements.get(element)) {
            lines.push(cDmxElementToSTring(element, context) + ',');
            ++context.line;
        }
        else {
            lines.push(`${makeTabs(context.tabs)}${element.name} "element" "${element.guid2}",`);
            ++context.line;
        }
    }
    if (lines.length > 0) {
        --context.line;
    }
    return lines.join('\n');
}
function guidToString(bytes) {
    let a = Array.from(bytes);
    // Reverse some bytes because microsoft
    a = a.slice(0, 4).reverse().concat(a.slice(4, 6).reverse()).concat(a.slice(6, 8).reverse()).concat(a.slice(8));
    return a.map((b) => ('00' + b.toString(16)).slice(-2))
        .join('')
        .replace(/(.{8})(.{4})(.{4})(.{4})(.{12})/, '$1-$2-$3-$4-$5');
}
function cDmxElementToSTring(element, context) {
    let lines = [];
    context.elementsLine.set(element.guid2, context.line);
    if (element.type == 'DmeParticleSystemDefinition') {
        context.elementsLine.set(element.name, context.line);
    }
    lines.push(makeTabs(context.tabs) + `"${element.type}"`);
    ++context.line;
    lines.push(makeTabs(context.tabs) + '{');
    ++context.line;
    ++context.tabs;
    lines.push(makeTabs(context.tabs) + `"id" "elementid" "${element.guid2}"`);
    ++context.line;
    lines.push(makeTabs(context.tabs) + `"name" "string" "${element.name}"`);
    ++context.line;
    for (const attribute of element.attributes) {
        lines.push(makeTabs(context.tabs) + cDmxAttributeToSTring(attribute, context));
        ++context.line;
    }
    --context.tabs;
    lines.push(makeTabs(context.tabs) + '}');
    //++context.line;
    return lines.join('\n');
}
function cDmxAttributeToSTring(attribute, context) {
    let line = makeTabs(context.tabs);
    line = `"${attribute.typeName}"`;
    switch (attribute.type) {
        case CDmxAttributeType.Element:
            line += ` "element" "${attribute.value.guid2}"`;
            break;
        case CDmxAttributeType.Integer:
            line += ` "int" ${attribute.value}`;
            break;
        case CDmxAttributeType.Float:
            line += ` "float" ${attribute.value}`;
            break;
        case CDmxAttributeType.Bool:
            line += ` "bool" ${attribute.value ? '1' : '0'}`;
            break;
        case CDmxAttributeType.String:
            line += ` "string" "${attribute.value}"`;
            break;
        case CDmxAttributeType.Color:
            line += ` "color" "${attribute.value.r * 255} ${attribute.value.g * 255} ${attribute.value.b * 255} ${attribute.value.a * 255}"`;
            break;
        case CDmxAttributeType.Vec2:
            line += ` "vector2" "${attribute.value[0]} ${attribute.value[1]}"`;
            break;
        case CDmxAttributeType.Vec3:
            line += ` "vector3" "${attribute.value[0]} ${attribute.value[1]} ${attribute.value[2]}"`;
            break;
        case CDmxAttributeType.Vec4:
            line += ` "vector4" "${attribute.value[0]} ${attribute.value[1]} ${attribute.value[2]} ${attribute.value[3]}"`;
            break;
        case CDmxAttributeType.ElementArray:
            line += ' "element_array"\n';
            ++context.line;
            line += makeTabs(context.tabs);
            line += '[\n';
            ++context.line;
            ++context.tabs;
            line += cDmxElementsToSTring(attribute.value, context);
            line += '\n';
            ++context.line;
            --context.tabs;
            line += makeTabs(context.tabs);
            line += ']';
            break;
        default:
            console.error('do type ', attribute.type, attribute);
    }
    return line;
}
function makeTabs(count) {
    let s = '';
    for (let i = 0; i < count; i++) {
        s += '\t';
    }
    return s;
}
/*
                "DmeParticleChild"
                {
                    "id" "elementid" "6faed681-cad8-46bd-b75f-e1ef20ca5453"
                    "name" "string" "utaunt_sharkfin2_water_base"
                    "child" "element" "3c594b90-3c2d-4076-bcc7-c2e875923a12"
                    "delay" "float" "0"
                },
*/

/**
 * DummyEntity
 */
class DummyEntity extends MapEntity {
    setKeyValues(kvElement) {
        super.setKeyValues(kvElement);
        const result = /^\*(\d*)$/.exec(kvElement /*TODO: fix that*/.model);
        if (result && result.length >= 2) {
            this.map.funcBrushesRemoveMe.push({
                model: Number(result[1]),
                origin: ParseVector(vec3.create(), kvElement /*TODO: fix that*/.origin) ?? vec3.create(),
            });
        }
    }
}
MapEntities.registerEntity('env_sprite', DummyEntity);
//MapEntities.registerEntity('light_spot', DummyEntity);
MapEntities.registerEntity('worldspawn', DummyEntity);
MapEntities.registerEntity('info_player_teamspawn', DummyEntity);
MapEntities.registerEntity('team_round_timer', DummyEntity);
MapEntities.registerEntity('team_control_point_master', DummyEntity);
MapEntities.registerEntity('tf_gamerules', DummyEntity);
MapEntities.registerEntity('filter_activator_tfteam', DummyEntity);
MapEntities.registerEntity('env_lightglow', DummyEntity);
//MapEntities.registerEntity('light', DummyEntity);
MapEntities.registerEntity('point_spotlight', DummyEntity);
MapEntities.registerEntity('func_nobuild', DummyEntity);
MapEntities.registerEntity('keyframe_rope', DummyEntity);
MapEntities.registerEntity('move_rope', DummyEntity);
MapEntities.registerEntity('func_regenerate', DummyEntity);
MapEntities.registerEntity('env_soundscape', DummyEntity);
MapEntities.registerEntity('env_soundscape_proxy', DummyEntity);
MapEntities.registerEntity('func_areaportal', DummyEntity);
MapEntities.registerEntity('func_illusionary', DummyEntity);
MapEntities.registerEntity('func_respawnroomvisualizer', DummyEntity);
MapEntities.registerEntity('func_respawnroom', DummyEntity);
MapEntities.registerEntity('trigger_capture_area', DummyEntity);
MapEntities.registerEntity('info_player_start', DummyEntity);
MapEntities.registerEntity('env_tonemap_controller', DummyEntity);
MapEntities.registerEntity('prop_physics_multiplayer', DummyEntity);
MapEntities.registerEntity('ambient_generic', DummyEntity);
//MapEntities.registerEntity('info_particle_system', DummyEntity);
//MapEntities.registerEntity('light_environment', DummyEntity);
MapEntities.registerEntity('shadow_control', DummyEntity);
MapEntities.registerEntity('env_sun', DummyEntity);
MapEntities.registerEntity('water_lod_control', DummyEntity);
MapEntities.registerEntity('env_fog_controller', DummyEntity);
MapEntities.registerEntity('item_grenadepack', DummyEntity);
MapEntities.registerEntity('env_smokestack', DummyEntity);
MapEntities.registerEntity('func_rotating', DummyEntity);
MapEntities.registerEntity('logic_relay', DummyEntity);
MapEntities.registerEntity('game_round_win', DummyEntity);
MapEntities.registerEntity('game_intro_viewpoint', DummyEntity);
MapEntities.registerEntity('func_occluder', DummyEntity);
MapEntities.registerEntity('sunlight_shadow_control', DummyEntity);
//MapEntities.registerEntity('prop_dynamic_override', DummyEntity);
MapEntities.registerEntity('prop_ragdoll', DummyEntity);
MapEntities.registerEntity('info_target', DummyEntity);
MapEntities.registerEntity('math_counter', DummyEntity);

class FuncBrush extends MapEntity {
    setKeyValues(kvElement) {
        super.setKeyValues(kvElement);
        const result = /^\*(\d*)$/.exec(kvElement /*TODO: fix that*/.model);
        if (result && result.length >= 2) {
            if (kvElement /*TODO: fix that*/.rendermode && kvElement /*TODO: fix that*/.rendermode != 10) {
                this.map.funcBrushesRemoveMe.push({ model: Number(result[1]), origin: ParseVector(vec3.create(), kvElement /*TODO: fix that*/.origin) ?? vec3.create() });
                console.error(kvElement /*TODO: fix that*/.origin, kvElement);
            }
        }
    }
}
MapEntities.registerEntity('func_brush', FuncBrush);

/**
 * func_detail
 */
class FuncDetail extends MapEntity {
    setKeyValues(kvElement) {
        super.setKeyValues(kvElement);
        const result = /^\*(\d*)$/.exec(kvElement /*TODO: fix that*/.model);
        if (result && result.length >= 2) {
            const origin = vec3.create();
            ParseVector(origin, kvElement /*TODO: fix that*/.origin);
            this.map.funcBrushesRemoveMe.push({ model: Number(result[1]), origin: origin });
        }
    }
}
MapEntities.registerEntity('func_detail', FuncDetail);
MapEntities.registerEntity('func_detail_blocker', FuncDetail);
MapEntities.registerEntity('func_lod', FuncDetail);

/**
 * Output Event
 */
class OutputEvent {
    outputName;
    constructor(outputName) {
        this.outputName = outputName.toLowerCase();
    }
    fireOutput(activator, caller) {
        caller.fireOutput(this.outputName);
    }
}

/**
 * Map entity
 */
class FuncDoor extends MapEntity {
    onFullyOpen = new OutputEvent('OnFullyOpen');
    onFullyClosed = new OutputEvent('OnFullyClosed');
    model = null;
    speed = 0;
    moveDir = vec3.create();
    pos1 = vec3.create();
    pos2 = vec3.create();
    finalDest = vec3.create();
    setKeyValues(kvElement) {
        super.setKeyValues(kvElement);
        const result = /^\*(\d*)$/.exec(kvElement /*TODO: fix that*/.model);
        if (result && result.length >= 2) {
            this.model = { model: Number(result[1]), origin: ParseVector(vec3.create(), kvElement /*TODO: fix that*/.origin) ?? vec3.create(), position: vec3.create(), dirty: true };
            //if (kvElement.rendermode && kvElement.rendermode != 10) {
            this.map.funcBrushesRemoveMe.push(this.model);
            //}
        }
        kvElement /*TODO: fix that*/.movedistance;
        this.speed = kvElement /*TODO: fix that*/.speed;
        vec3.zero(this.moveDir);
        const moveDir = ParseAngles(vec3.create() /*TODO: optimize*/, kvElement /*TODO: fix that*/.movedir);
        if (moveDir) {
            AngleVectors(moveDir, this.moveDir);
        }
        if (!this.model?.model) {
            return;
        }
        const vecOBB = this.map.getOBBSize(this.model.model);
        if (vecOBB) {
            this.pos1 = this.getAbsOrigin(); //vec3.scaleAndAdd(vec3.create(), this.getAbsOrigin(), this.moveDir, -movedistance * kvElement.startposition);
            const a = this.moveDir;
            const b = vecOBB;
            const dotProductAbs = Math.abs(a[0] * b[0]) + Math.abs(a[1] * b[1]) + Math.abs(a[2] * b[2]); //vec3.dot(vec3.create(), this.moveDir, vecOBB);
            this.pos2 = vec3.scaleAndAdd(this.pos2, this.pos1, this.moveDir, dotProductAbs); //todo : lip
            vec3.copy(this.finalDest, this.getAbsOrigin());
        }
    }
    setInput(inputName) {
        switch (inputName.toLowerCase()) {
            case 'open':
                this.inputOpen();
                break;
            case 'close':
                this.inputClose();
                break;
            /*
            DEFINE_INPUTFUNC(FIELD_VOID,	'Open', InputOpen),
            DEFINE_INPUTFUNC(FIELD_VOID,	'Close', InputClose),
            DEFINE_INPUTFUNC(FIELD_FLOAT, 'SetPosition', InputSetPosition),
            DEFINE_INPUTFUNC(FIELD_FLOAT, 'SetSpeed', InputSetSpeed),
            */
        }
    }
    update(scene, camera, delta) {
        super.update(scene, camera, delta);
        if (this.model && this.model.origin) {
            if ((this._position[0] != this.model.origin[0]) || (this._position[1] != this.model.origin[1]) || (this._position[2] != this.model.origin[2])) {
                //vec3.copy(this.model.origin, this._position);
                this.model.position = this._position;
                this.model.dirty = true; //removeme ?
            }
        }
        if (this.m_flMoveDoneTime <= this.m_flLocalTime && this.m_flMoveDoneTime > 0) {
            this.setMoveDoneTime(-1);
            //vec3.copy(this.origin, this.finalDest);
            this.position = this.finalDest;
            vec3.set(this.m_vecVelocity, 0, 0, 0);
            this.moveDone();
        }
    }
    inputOpen() {
        if (vec3.squaredDistance(this.getAbsOrigin(), this.pos2) != 0) {
            this.moveTo(this.pos2, this.speed);
        }
    }
    inputClose() {
        if (vec3.squaredDistance(this.getAbsOrigin(), this.pos1) != 0) {
            this.moveTo(this.pos1, this.speed);
        }
    }
    moveTo(position, speed) {
        if (speed) {
            this.linearMove(position, speed);
        }
    }
    linearMove(destination, speed) {
        this.finalDest = vec3.clone(destination);
        const origin = this.getLocalOrigin();
        if (vec3.squaredDistance(origin, destination) < 0.001) {
            this.moveDone();
            return;
        }
        const vecDelta = vec3.sub(vec3.create(), destination, origin);
        const travelTime = vec3.length(vecDelta) / speed;
        this.setMoveDoneTime(travelTime);
        this.setLocalVelocity(vec3.scale(vecDelta, vecDelta, 1.0 / travelTime));
    }
    moveDone() {
        if (vec3.squaredDistance(this.getAbsOrigin(), this.pos2) == 0) {
            this.onFullyOpen.fireOutput(this, this);
        }
        else if (vec3.squaredDistance(this.getAbsOrigin(), this.pos1) == 0) {
            this.onFullyClosed.fireOutput(this, this);
        }
    }
    getAbsOrigin() {
        return this._position;
    }
}
MapEntities.registerEntity('func_door', FuncDoor);

class MapEntityAmbientLight extends MapEntity {
    #ambientLight = new AmbientLight();
    setKeyValues(kvElement) {
        super.setKeyValues(kvElement);
        this.map.addChild(this.#ambientLight);
        this.#ambientLight.position = this._position;
    }
    setKeyValue(key, value) {
        const ambientLight = this.#ambientLight;
        //pointLight.range = 1000;
        switch (key) {
            case '_ambient':
                parseLightColorIntensity(value, ambientLight, 0.1);
                break;
            //TODO: other parameters
            default:
                super.setKeyValue(key, value);
        }
    }
    update(scene, camera, delta) {
        super.update(scene, camera, delta);
        this.#ambientLight.setPosition(this._position);
    }
}
MapEntities.registerEntity('light_environment', MapEntityAmbientLight);
/*
{
"origin" "216 -632 -48.4408"
"SunSpreadAngle" "0"
"pitch" "-45"
"angles" "-45 204 0"
"_lightscaleHDR" "1"
"_lightHDR" "-1 -1 -1 1"
"_light" "253 243 208 500"
"_AmbientScaleHDR" "1"
"_ambientHDR" "-1 -1 -1 1"
"_ambient" "124 138 203 500"
"classname" "light_environment"
"hammerid" "1351"
}
*/

//const colorIntensity = vec4.create();
class MapEntityLight extends MapEntity {
    pointLight = new PointLight();
    setKeyValues(kvElement) {
        super.setKeyValues(kvElement);
        this.map.addChild(this.pointLight);
        this.pointLight.position = this._position;
    }
    setKeyValue(key, value) {
        const pointLight = this.pointLight;
        pointLight.range = 1000;
        switch (key) {
            case '_zero_percent_distance':
                pointLight.range = Number(value);
                break;
            case '_light':
                parseLightColorIntensity(value, pointLight, 1.0);
                break;
            //TODO: other parameters
            default:
                super.setKeyValue(key, value);
        }
    }
    update(scene, camera, delta) {
        super.update(scene, camera, delta);
        this.pointLight.setPosition(this._position);
    }
}
MapEntities.registerEntity('light', MapEntityLight);

class PropDynamic extends MapEntity {
    #model = null;
    setKeyValues(kvElement) {
        super.setKeyValues(kvElement);
        this.setupModel(kvElement);
    }
    async setupModel(kvElement) {
        const entity = kvElement;
        if (entity && kvElement /*TODO: fix that*/.model) {
            const model = await this.setModel(kvElement /*TODO: fix that*/.model);
            const skin = kvElement /*TODO: fix that*/.skin ?? 0;
            if (model) {
                model.skin = skin;
                if (model) {
                    model.position = this._position;
                    model.quaternion = this._quaternion;
                }
                if (kvElement /*TODO: fix that*/.defaultanim) {
                    model.playSequence(kvElement /*TODO: fix that*/.defaultanim);
                }
                else {
                    model.playDefaultAnim();
                } //TODO: RandomAnimation, StartDisabled, SetBodyGroup
                if (kvElement /*TODO: fix that*/.startdisabled == 1) {
                    model.setVisible(false);
                }
            }
        }
    }
    /*
        setKeyValue(key, value) {
            await super.setKeyValue(key, value);
            let model;
            switch (key) {
                case 'model':
                    await this.setModel(value);
                    break;
                case 'origin':
                    model = this.model;
                    if (model) {
                        model.position = this._position;
                    }
                    break;
                case 'angles':
                    model = this.model;
                    if (model) {
                        model.quaternion = this._quaternion;
                    }
                    break;
            }
        }*/
    async setModel(modelName) {
        modelName = modelName.replace(/\.mdl$/g, '');
        const model = await Source1ModelManager.createInstance(this.map.repository, modelName, true);
        /*model.position = this.position;
        model.quaternion = this._quaternion;*/
        this.#model = model;
        this.map.dynamicProps.addChild(model);
        /*.then(
            (model) => {
                this.map.dynamicProps.addChild(model);
                model.position = this.position;
                model.quaternion = this._quaternion;
                //TODOv3: animate
            }
        );*/
        return model;
    }
    setInput(inputName, parameters /*TODO: improve type*/) {
        switch (inputName.toLowerCase()) {
            case 'skin':
                this.#model?.setSkin(parameters);
                break;
        }
    }
    update(scene, camera, delta) {
        super.update(scene, camera, delta);
        const model = this.#model; //fixme this
        if (model) {
            model.position = this._position;
            model.quaternion = this._quaternion;
        }
    }
}
MapEntities.registerEntity('prop_dynamic', PropDynamic);
MapEntities.registerEntity('prop_dynamic_override', PropDynamic);
//SEMapEntities.registerEntity('prop_static', SEEntityPropDynamic);
MapEntities.registerEntity('prop_scalable', PropDynamic);
MapEntities.registerEntity('prop_physics_override', PropDynamic);

const tempQuaternion$1 = quat.create();
const tempVec3$i = vec3.create();
const SPOTLIGHT_DEFAULT_QUATERNION = quat.fromValues(0, -1, 0, 1);
class PropLightSpot extends MapEntity {
    spotLight = new SpotLight();
    //this.spotLight.visible = false;
    _angles = vec3.fromValues(-90, 0, 0);
    constructor(params) {
        super(params);
        this.quaternion = SPOTLIGHT_DEFAULT_QUATERNION;
    }
    setKeyValues(kvElement) {
        super.setKeyValues(kvElement);
        this.map.addChild(this.spotLight);
        this.spotLight.position = this._position;
        this.spotLight.quaternion = this._quaternion;
    }
    setKeyValue(key, value) {
        const spotLight = this.spotLight;
        spotLight.range = 1000;
        switch (key) {
            case '_zero_percent_distance':
                spotLight.range = Number(value);
                break;
            case '_cone':
                spotLight.angle = value * DEG_TO_RAD;
                break;
            case '_inner_cone':
                spotLight.innerAngle = value * DEG_TO_RAD;
                break;
            case '_light':
                parseLightColorIntensity(value, spotLight, 0.1);
                break;
            case 'pitch':
                //angles should suffice
                this._angles[0] = -value * DEG_TO_RAD;
                this.setAngles();
                break;
            case 'angles':
                ParseAngles2(tempVec3$i, value);
                this._angles[1] = tempVec3$i[1];
                this._angles[2] = tempVec3$i[1];
                this.setAngles();
                break;
            case '_quadratic_attn':
                //TODO
                break;
            case '_linear_attn':
                //TODO
                break;
            case '_lightscalehdr':
                //TODO
                break;
            case '_lighthdr':
                //TODO
                break;
            default:
                super.setKeyValue(key, value);
        }
    }
    setAngles() {
        AngleQuaternion(this._angles, tempQuaternion$1);
        quat.mul(this._quaternion, SPOTLIGHT_DEFAULT_QUATERNION, tempQuaternion$1);
    }
    setInput(input, parameters /*TODO: improve type*/) {
        throw 'code me';
        /*
        switch (inputName.toLowerCase()) {
            case 'skin':
                this.model.setSkin(parameter);
                break;
        }*/
    }
    update(scene, camera, delta) {
        super.update(scene, camera, delta);
        this.spotLight.setPosition(this._position);
        this.spotLight.quaternion = this._quaternion;
    }
}
MapEntities.registerEntity('light_spot', PropLightSpot);
MapEntities.registerEntity('light_glspot', PropLightSpot);

class SkyCamera extends MapEntity {
    camera = new Camera();
    setKeyValues(kvElement) {
        super.setKeyValues(kvElement);
        const scale = kvElement /*TODO: fix that*/.scale;
        this.camera.scale = vec3.fromValues(scale, scale, scale);
        this.camera.position = this._position;
    }
}
MapEntities.registerEntity('sky_camera', SkyCamera);

class AnimatedTexture extends Texture {
    frames = [];
    addFrame(frame, texture) {
        this.frames[frame] = texture;
        texture.addUser(this);
    }
    getFrame(frame) {
        frame = Math.floor(frame) % this.frames.length;
        return this.frames[frame]; //TODOv3 handle missing textures
    }
    hasOnlyUser(user) {
        if (!super.hasOnlyUser(user)) {
            return false;
        }
        for (const frame of this.frames) {
            if (!frame.hasOnlyUser(this)) {
                return false;
            }
        }
        return true;
    }
    dispose() {
        if (this.hasNoUser()) {
            // Check if frames have other users
            for (const frame of this.frames) {
                if (!frame.hasOnlyUser(this)) {
                    return;
                }
            }
            super.dispose();
            this.frames.forEach(frame => frame.removeUser(this));
        }
    }
}

const MAX_IMAGES_PER_FRAME_ON_DISK = 4;
const MAX_IMAGES_PER_FRAME_IN_MEMORY = 2;
const SEQUENCE_SAMPLE_COUNT = 1024;
class SequenceSampleTextureCoords_t {
    m_fLeft_U0 = 0;
    m_fTop_V0 = 0;
    m_fRight_U0 = 0;
    m_fBottom_V0 = 0;
    m_fLeft_U1 = 0;
    m_fTop_V1 = 0;
    m_fRight_U1 = 0;
    m_fBottom_V1 = 0;
}
class SheetSequenceSample_t {
    m_fBlendFactor = 0;
    m_TextureCoordData = [];
    constructor() {
        for (let i = 0; i < MAX_IMAGES_PER_FRAME_IN_MEMORY; ++i) {
            this.m_TextureCoordData[i] = new SequenceSampleTextureCoords_t();
        }
    }
}

class Source1VtfLoader extends SourceBinaryLoader {
    async load(repositoryName, path) {
        return super.load(repositoryName, path);
    }
    parse(repository, fileName, arrayBuffer) {
        const vtf = new Source1Vtf(repository, fileName);
        try {
            const reader = new BinaryReader(arrayBuffer);
            this.#parseHeader(reader, vtf);
            if (vtf.isHigherThan72()) {
                for (let i = 0; i < vtf.numResources; ++i) {
                    vtf.resEntries.push({ type: reader.getUint32(), resData: reader.getUint32() });
                }
            }
            else {
                if (vtf.lowResImageFormat == -1) {
                    vtf.resEntries.push({ type: VTF_ENTRY_IMAGE_DATAS, resData: vtf.headerSize });
                }
                else {
                    vtf.resEntries.push({ type: 1, resData: vtf.headerSize });
                    if (vtf.lowResImageWidth == 0 && vtf.lowResImageHeight == 0) {
                        vtf.resEntries.push({ type: VTF_ENTRY_IMAGE_DATAS, resData: vtf.headerSize });
                    }
                    else {
                        vtf.resEntries.push({ type: VTF_ENTRY_IMAGE_DATAS, resData: vtf.headerSize + Math.max(2, vtf.lowResImageWidth * vtf.lowResImageHeight * 0.5) }); // 0.5 bytes per pixel
                    }
                }
            }
            if (vtf.isHigherThan72()) {
                reader.seek(vtf.headerSize);
            }
            this.#parseResEntries(reader, vtf);
        }
        catch (err) {
            return null;
        }
        return vtf;
    }
    #parseHeader(reader, vtf) {
        reader.seek(4); //skip first 4 char TODO: check == 'VTF\0' ?
        vtf.setVerionMaj(reader.getUint32());
        vtf.setVerionMin(reader.getUint32());
        vtf.headerSize = reader.getUint32();
        vtf.width = reader.getUint16();
        vtf.height = reader.getUint16();
        vtf.setFlags(reader.getUint32());
        vtf.frames = reader.getUint16();
        vtf.firstFrame = reader.getUint16();
        reader.seek(reader.tell() + 4); //padding
        vtf.reflectivity = reader.getVector3();
        reader.seek(reader.tell() + 4); //padding
        vtf.bumpmapScale = reader.getFloat32();
        vtf.highResImageFormat = reader.getInt32();
        vtf.mipmapCount = reader.getUint8();
        vtf.lowResImageFormat = reader.getInt32();
        vtf.lowResImageWidth = reader.getUint8();
        vtf.lowResImageHeight = reader.getUint8();
        if (vtf.isHigherThan71()) {
            vtf.depth = reader.getUint16();
        }
        if (vtf.isHigherThan72()) {
            reader.seek(reader.tell() + 3); //padding
            vtf.numResources = reader.getUint32();
            reader.seek(reader.tell() + 8); //padding
        }
    }
    #parseResEntries(reader, vtf) {
        reader.tell();
        for (let resIndex = 0; resIndex < vtf.resEntries.length; ++resIndex) {
            this.#parseResEntry(reader, vtf, vtf.resEntries[resIndex]);
        }
    }
    #parseResEntry(reader, vtf, entry) {
        switch (entry.type) {
            case 1: // Low-res image data
                //TODO
                break;
            case VTF_ENTRY_IMAGE_DATAS:
                //TODO
                if (vtf.mipmapCount > 0) {
                    this.#parseImageData(reader, vtf, entry);
                }
                else {
                    console.error('vtf.mipmapCount == 0');
                }
                break;
            case 16: // sheet
                this.#parseSheet(reader, vtf, entry);
                break;
        }
    }
    #parseImageData(reader, vtf, entry) {
        reader.seek(entry.resData);
        let mipmapWidth = vtf.width * Math.pow(0.5, vtf.mipmapCount - 1);
        let mipmapHeight = vtf.height * Math.pow(0.5, vtf.mipmapCount - 1);
        entry.mipMaps = [];
        for (let mipmapIndex = 0; mipmapIndex < vtf.mipmapCount; ++mipmapIndex) {
            this.#parseMipMap(reader, vtf, entry, mipmapIndex, mipmapWidth, mipmapHeight);
            mipmapWidth *= 2;
            mipmapHeight *= 2;
        }
    }
    #parseSheet(reader, vtf, entry) {
        reader.seek(entry.resData);
        const sheet = new SpriteSheet();
        vtf.sheet = sheet;
        reader.getUint32(); // TODO: use length ?
        const nVersion = reader.getUint32();
        const nNumCoordsPerFrame = (nVersion) ? MAX_IMAGES_PER_FRAME_ON_DISK : 1;
        let nNumSequences = reader.getUint32();
        /*
        if (sheet.format == 0) {//TODOv3 : where comes sheet.format ?
            valuesCount = 4;
        }
        */
        //for (let groupIndex=0; groupIndex < sheet.groupsCount; ++groupIndex) {
        while (nNumSequences--) {
            const group = sheet.addSequence();
            group.duration = 0;
            //group.m_pSamples = [];
            //group.m_pSamples2 = [];
            //sheet.sequences.push(group);
            reader.getUint32();
            group.clamp = reader.getUint32() != 0;
            const frameCount = reader.getUint32();
            //let m_pSample = [];
            //sheet.m_pSamples[nSequenceNumber] = m_pSample;
            /*
            for (let i = 0; i < nTimeSamples; i++) {
                group.m_pSamples[i] = new SheetSequenceSample_t();
            }
            */
            const samples = [];
            for (let i = 0; i < SEQUENCE_SAMPLE_COUNT; i++) {
                samples[i] = new SheetSequenceSample_t();
            }
            //group.frames = [];
            const fTotalSequenceTime = reader.getFloat32();
            const InterpKnot = new Float32Array(SEQUENCE_SAMPLE_COUNT);
            const InterpValue = new Float32Array(SEQUENCE_SAMPLE_COUNT);
            let fCurTime = 0.;
            for (let frameIndex = 0; frameIndex < frameCount; ++frameIndex) {
                const frame = group.addFrame(); //new SheetSequenceSample_t();
                //group.m_pSamples2.push(frameSample);
                //const frame = Object.create(null);
                //group.frames.push(frame);
                //frame.values = [];
                //frame.duration = reader.getFloat32();
                const fThisDuration = reader.getFloat32();
                InterpValue[frameIndex] = frameIndex;
                InterpKnot[frameIndex] = SEQUENCE_SAMPLE_COUNT * (fCurTime / fTotalSequenceTime);
                fCurTime += fThisDuration;
                group.duration += fThisDuration; //frame.duration;
                frame.duration = fThisDuration;
                /*for (let i = 0; i < valuesCount; ++i) {
                    frame.values.push(reader.getFloat32());
                }*/
                const seq = samples[frameIndex];
                if (!seq) {
                    continue;
                }
                for (let nImage = 0; nImage < nNumCoordsPerFrame; nImage++) {
                    const coord = frame.addCoord(); //.m_TextureCoordData[nImage];
                    //const s2 = frame.m_TextureCoordData[nImage];
                    coord.uMin = reader.getFloat32();
                    coord.vMin = reader.getFloat32();
                    coord.uMax = reader.getFloat32();
                    coord.vMax = reader.getFloat32();
                    /*
                    if (s) {
                        s.m_fLeft_U0 = reader.getFloat32();
                        s.m_fTop_V0 = reader.getFloat32();
                        s.m_fRight_U0 = reader.getFloat32();
                        s.m_fBottom_V0 = reader.getFloat32();

                        if (s2) {
                            s2.m_fLeft_U0 = s.m_fLeft_U0;
                            s2.m_fTop_V0 = s.m_fTop_V0;
                            s2.m_fRight_U0 = s.m_fRight_U0;
                            s2.m_fBottom_V0 = s.m_fBottom_V0;
                        }
                    } else {
                        //drop it ?
                        reader.getFloat32();
                        reader.getFloat32();
                        reader.getFloat32();
                        reader.getFloat32();
                    }
                    */
                }
            }
            group.duration += fCurTime;
            // now, fill in the whole table
            /*
            for (let nIdx = 0; nIdx < nTimeSamples; ++nIdx) {
                //float flIdxA, flIdxB, flInterp;
                const result = GetInterpolationData(InterpKnot, InterpValue, frameCount,
                    SEQUENCE_SAMPLE_COUNT,
                    nIdx,
                    /*TODO* /false/*!group.clamp*/ /*,
                    &flIdxA, &flIdxB, &flInterp * /);
const sA = samples[result.pValueA];
const sB = samples[result.pValueB];
const oseq = group.frames[nIdx];
if (!sA || !sB) {
    continue;
}

//oseq.m_fBlendFactor = result.pInterpolationValue;
/*
for (let nImage = 0; nImage < MAX_IMAGES_PER_FRAME_IN_MEMORY; nImage++) {
    const src0 = sA.m_TextureCoordData[nImage];
    const src1 = sB.m_TextureCoordData[nImage];
    if (!src0 || !src1) {
        continue;
    }

    const o = oseq.m_TextureCoordData[nImage];
    o.m_fLeft_U0 = src0.m_fLeft_U0;
    o.m_fTop_V0 = src0.m_fTop_V0;
    o.m_fRight_U0 = src0.m_fRight_U0;
    o.m_fBottom_V0 = src0.m_fBottom_V0;
    o.m_fLeft_U1 = src1.m_fLeft_U0;
    o.m_fTop_V1 = src1.m_fTop_V0;
    o.m_fRight_U1 = src1.m_fRight_U0;
    o.m_fBottom_V1 = src1.m_fBottom_V0;
}
* /
}
*/
        }
    }
    #parseMipMap(reader, vtf, entry, mipmaplvl, mipmapWidth, mipmapHeight) {
        //TODO: frame face, zlice
        let startingByte = reader.tell();
        // Mipmap minimum size is 1*1 px
        mipmapWidth = Math.max(1.0, vtf.width * Math.pow(0.5, vtf.mipmapCount - mipmaplvl - 1));
        mipmapHeight = Math.max(1.0, vtf.height * Math.pow(0.5, vtf.mipmapCount - mipmaplvl - 1));
        const mipmap = { width: mipmapWidth, height: mipmapHeight, frames: [] };
        entry.mipMaps.push(mipmap);
        let faceIndex;
        let face;
        for (let frameIndex = 0; frameIndex < vtf.frames; ++frameIndex) {
            const frame = [];
            mipmap.frames.push(frame);
            for (faceIndex = 0; faceIndex < vtf.faceCount; faceIndex++) {
                if (vtf.faceCount == 1) {
                    face = [];
                }
                else {
                    face = [];
                }
                face = frame;
                let entrySize;
                let s;
                switch (vtf.highResImageFormat) {
                    case IMAGE_FORMAT_ABGR8888: //1
                        entrySize = mipmapWidth * mipmapHeight * 4; // 4 byte per pixel
                        face.push(str2abABGR(reader, startingByte, entrySize));
                        startingByte += entrySize;
                        reader.skip(entrySize);
                        break;
                    case IMAGE_FORMAT_RGB888_BLUESCREEN:
                    case IMAGE_FORMAT_BGR888_BLUESCREEN:
                        entrySize = mipmapWidth * mipmapHeight * 2; // 2 byte per pixel
                        face.push(str2ab(reader, startingByte, entrySize));
                        startingByte += entrySize;
                        reader.skip(entrySize);
                        break;
                    case IMAGE_FORMAT_RGB888:
                        entrySize = mipmapWidth * mipmapHeight * 3; // 3 byte per pixel
                        face.push(str2ab(reader, startingByte, entrySize));
                        startingByte += entrySize;
                        reader.skip(entrySize);
                        break;
                    case IMAGE_FORMAT_BGR888:
                        entrySize = mipmapWidth * mipmapHeight * 3; // 3 byte per pixel
                        s = reader.getString(entrySize);
                        face.push(str2abBGR(s));
                        break;
                    case IMAGE_FORMAT_RGBA8888:
                        entrySize = mipmapWidth * mipmapHeight * 4; // 4 byte per pixel
                        face.push(str2ab(reader, startingByte, entrySize));
                        startingByte += entrySize;
                        reader.skip(entrySize);
                        break;
                    case IMAGE_FORMAT_BGRA8888:
                        entrySize = mipmapWidth * mipmapHeight * 4; // 4 byte per pixel
                        s = reader.getString(entrySize);
                        face.push(str2abBGRA(s));
                        break;
                    case IMAGE_FORMAT_DXT1:
                        entrySize = Math.max(mipmapWidth * mipmapHeight * 0.5, 8); // 0.5 byte per pixel
                        face.push(str2ab(reader, startingByte, entrySize));
                        startingByte += entrySize;
                        reader.skip(entrySize);
                        break;
                    case IMAGE_FORMAT_DXT3:
                        entrySize = Math.max(mipmapWidth * mipmapHeight, 16); // 1 byte per pixel
                        face.push(str2ab(reader, startingByte, entrySize));
                        startingByte += entrySize;
                        reader.skip(entrySize);
                        break;
                    case IMAGE_FORMAT_DXT5:
                        entrySize = Math.max(mipmapWidth, 4) * Math.max(mipmapHeight, 4); // 1 byte per pixel
                        face.push(str2ab(reader, startingByte, entrySize));
                        startingByte += entrySize;
                        reader.skip(entrySize);
                        break;
                    case IMAGE_FORMAT_RGBA16161616F:
                        entrySize = mipmapWidth * mipmapHeight * 8; // 8 bytes per pixel
                        s = reader.getString(entrySize);
                        face.push(str2abRGBA16F(s));
                        break;
                }
            }
        }
    }
}
function str2abRGBA16F(str) {
    const len = str.length / 2;
    const buf = new ArrayBuffer(str.length * 2);
    const bufView = new Float32Array(buf);
    let j;
    for (let i = 0; i < len; ++i) {
        j = i * 2;
        bufView[i] = float16(str.charCodeAt(j + 0), str.charCodeAt(j + 1)); //(str.charCodeAt(i+0) + str.charCodeAt(i+1)*256);
    }
    return bufView;
}
function float16(byte1, byte2) {
    const b = new Uint8Array([byte1, byte2]);
    const sign = b[1] >> 7;
    const exponent = ((b[1] & 0x7C) >> 2);
    const mantissa = ((b[1] & 0x03) << 8) | b[0];
    if (exponent == 0) {
        return (sign ? -1 : 1) * TWO_POW_MINUS_14 * (mantissa / TWO_POW_10);
    }
    else if (exponent == 0x1F) {
        return mantissa ? NaN : ((sign ? -1 : 1) * Infinity);
    }
    return (sign ? -1 : 1) * Math.pow(2, exponent - 15) * (1 + (mantissa / TWO_POW_10));
}
function str2ab(reader, start, length) {
    return new Uint8Array(reader.buffer.slice(start, start + length));
}
function str2abBGR(str) {
    // assume str.length is divisible by 3
    const buf = new ArrayBuffer(str.length);
    const bufView = new Uint8Array(buf);
    for (let i = 0, strLen = str.length; i < strLen; i += 3) {
        bufView[i] = str.charCodeAt(i + 2);
        bufView[i + 1] = str.charCodeAt(i + 1);
        bufView[i + 2] = str.charCodeAt(i);
    }
    return bufView;
}
function str2abBGRA(str) {
    // assume str.length is divisible by 4
    const buf = new ArrayBuffer(str.length);
    const bufView = new Uint8Array(buf);
    for (let i = 0, strLen = str.length; i < strLen; i += 4) {
        bufView[i] = str.charCodeAt(i + 2);
        bufView[i + 1] = str.charCodeAt(i + 1);
        bufView[i + 2] = str.charCodeAt(i);
        bufView[i + 3] = str.charCodeAt(i + 3);
    }
    return bufView;
}
/*
function str2abABGR(reader, start, length) {
// assume str.length is divisible by 4
    const buf = new ArrayBuffer(str.length);
    const bufView = new Uint8Array(buf);
    for (let i = 0, strLen = str.length; i < strLen; i += 4) {
        bufView[i	] = str.charCodeAt(i+3);
        bufView[i+1] = str.charCodeAt(i+2);
        bufView[i+2] = str.charCodeAt(i+1);
        bufView[i+3] = str.charCodeAt(i	);
    }
    return bufView;
}*/
function str2abABGR(reader, start, length) {
    const arr = new Uint8Array(reader.buffer.slice(start, start + length));
    for (let i = 0, l = arr.length; i < l; i += 4) {
        let temp = arr[i];
        arr[i] = arr[i + 3];
        arr[i + 3] = temp;
        temp = arr[i + 1];
        arr[i + 1] = arr[i + 2];
        arr[i + 2] = temp;
    }
    return arr;
}

let internalTextureId = 0;
class Source1TextureManagerClass {
    #texturesList = new Map2();
    #vtfList = new Map2();
    #defaultTexture = new AnimatedTexture();
    #defaultTextureCube = new AnimatedTexture();
    fallbackRepository = '';
    constructor() {
        Graphics$1.ready.then(() => {
            this.#defaultTexture.addFrame(0, TextureManager.createCheckerTexture(new Color(0.5, 0.75, 1)));
            this.#defaultTextureCube.addFrame(0, TextureManager.createCheckerTexture(new Color(0.5, 0.75, 1), undefined, undefined, true));
            this.#defaultTexture.addUser(this);
            this.#defaultTextureCube.addUser(this);
        });
        setInterval(() => this.#cleanup(), TEXTURE_CLEANUP_DELAY);
    }
    getTexture(repository, path, needCubeMap = false, srgb = true) {
        const animatedTexture = this.#getTexture(repository, path, needCubeMap, srgb);
        return animatedTexture ?? (needCubeMap ? this.#defaultTextureCube : this.#defaultTexture);
    }
    async getVtf(repository, path) {
        // TODO: fix that concurent calls of the same texture will load it multiple times
        let vtf = this.#vtfList.get(repository, path);
        if (vtf !== undefined) {
            return vtf;
        }
        vtf = await new Source1VtfLoader().load(repository, path);
        if (vtf) {
            this.#vtfList.set(repository, path, vtf);
        }
        return vtf;
    }
    #getTexture(repository, path, needCubeMap, srgb = true, allocatedTexture) {
        path = path.replace(/\.vtf$/, '');
        path = path.replace(/\.psd/, '');
        path = path.toLowerCase();
        const texture = this.#texturesList.get(repository, path);
        if (texture !== undefined) {
            return texture;
        }
        const pathWithMaterials = 'materials/' + path + '.vtf'; //TODOv3
        //const fullPath = repository + pathWithMaterials;
        if (!this.#texturesList.has(repository, path)) {
            const animatedTexture = allocatedTexture ?? new AnimatedTexture(); //TODOv3: merge with TextureManager.createTexture(); below
            this.setTexture(repository, path, animatedTexture);
            this.getVtf(repository, pathWithMaterials).then((vtf) => {
                if (vtf) {
                    vtfToTexture(vtf, animatedTexture, srgb);
                }
                else {
                    const texture = this.#getTexture(this.fallbackRepository, path, needCubeMap, srgb, animatedTexture);
                    if (texture) {
                        this.setTexture(repository, path, texture);
                    }
                }
            });
        }
        return this.#texturesList.get(repository, path) ?? null;
    }
    async getTextureAsync(repository, path, frame, needCubeMap, defaultTexture, srgb = true) {
        frame = Math.floor(frame);
        path = path.replace(/\.vtf$/, '');
        path = path.replace(/\.psd/, '');
        path = path.toLowerCase();
        const texture = this.#texturesList.get(repository, path);
        if (texture) {
            return texture; //.getFrame(frame);//TODOv3: add frame back
        }
        const pathWithMaterials = 'materials/' + path + '.vtf'; //TODOv3
        //const fullPath = repository + pathWithMaterials;
        const animatedTexture = new AnimatedTexture(); //TODOv3: merge with TextureManager.createTexture(); below
        this.setTexture(repository, path, animatedTexture);
        const vtf = await this.getVtf(repository, pathWithMaterials);
        if (vtf) {
            vtfToTexture(vtf, animatedTexture, srgb);
        }
        else {
            this.removeTexture(repository, path);
            return null;
        }
        return this.#texturesList.get(repository, path)?.getFrame(frame) ?? defaultTexture ?? (needCubeMap ? this.#defaultTextureCube : this.#defaultTexture); //TODOv3
    }
    getInternalTextureName() {
        return 'source1texturemanager_' + (++internalTextureId);
    }
    addInternalTexture(repository, texture) {
        const textureName = this.getInternalTextureName();
        texture = texture ?? new AnimatedTexture(); //TODOv3: add params + create animated texture
        this.setTexture(repository, textureName, texture);
        texture.addFrame(0, TextureManager.createTexture());
        return { name: textureName, texture: texture };
    }
    setTexture(repository, path, texture) {
        texture.addUser(this);
        this.#texturesList.set(repository, path, texture);
    }
    removeTexture(repository, path) {
        const texture = this.#texturesList.get(repository, path);
        if (texture) {
            texture.removeUser(this);
            this.#texturesList.delete(repository, path);
        }
    }
    #cleanup() {
        for (const [repo, path, texture] of this.#texturesList) {
            if (texture.hasOnlyUser(this)) {
                texture.removeUser(this);
                this.#texturesList.delete(repo, path);
            }
        }
    }
}
const Source1TextureManager = new Source1TextureManagerClass();
function vtfToTexture(vtf, animatedTexture, srgb) {
    const alphaBits = vtf.getAlphaBits();
    //animatedTexture.vtf = vtf;
    animatedTexture.setAlphaBits(alphaBits);
    const glContext = Graphics$1.glContext;
    for (let frameIndex = 0; frameIndex < vtf.frames; frameIndex++) {
        const texture = TextureManager.createTexture(); //TODOv3: add params
        texture.properties.set('vtf', vtf);
        texture.setAlphaBits(alphaBits);
        const currentMipMap = vtf.mipmapCount; //TODOv3: choose mipmap
        vtf.fillTexture(glContext, texture, currentMipMap, frameIndex, srgb);
        animatedTexture.addFrame(frameIndex, texture);
    }
}

/**
 * Proxy manager
 */
class ProxyManager {
    static #proxyList = {}; //TODO: turn into map
    static getProxy(proxyName) {
        if (!proxyName) {
            return;
        }
        proxyName = proxyName.toLowerCase();
        const proxy = this.#proxyList[proxyName];
        if (!proxy) {
            return null;
        }
        return new proxy();
    }
    static registerProxy(proxyName, proxyClass) {
        if (!proxyClass) {
            return;
        }
        const name = proxyName.toLowerCase();
        this.#proxyList[name] = proxyClass;
    }
}

/*export setResult(variables, value) {
    let resultVarName = this.getData('resultvar');
    if (resultVarName) {
        resultVarName = resultVarName.toLowerCase();
        if (resultVarName.indexOf('[') != -1) {
            let result = (/([^\[]*)\[(\d*)\]/g).exec(resultVarName);
            if (result && result.length == 3) {
                const v = variables.get(result[1].toLowerCase());
                if (v) {
                    v[result[2]] = value;
                }
            }
        } else {
            variables.set(resultVarName, value);
        }
    }
}
*/
/**
 * Source engine material interface
 */
class Proxy {
    datas = null;
    /**
     * TODO
     */
    setParams(datas /*TODO: improve type*/, variables) {
        this.datas = datas;
        this.init(variables);
    }
    /**
     * TODO
     */
    getData(name) {
        const result = this.datas[name];
        if (typeof result == 'string') {
            return result.toLowerCase();
        }
        return result;
    }
    /**
     * Dummy function
     */
    init(variables) {
    }
    /**
     * Dummy function
     */
    execute(variables, proxyParams, time) {
    }
    setResult(variables, value /*TODO: improve type*/) {
        let resultVarName = this.getData('resultvar');
        if (resultVarName) {
            resultVarName = resultVarName.toLowerCase();
            if (resultVarName.indexOf('[') != -1) {
                const result = (/([^\[]*)\[(\d*)\]/g).exec(resultVarName);
                if (result && result.length == 3) {
                    const v = variables.get(result[1].toLowerCase());
                    if (v) {
                        if (typeof value == 'number') {
                            v[result[2]] = value;
                        }
                        else { //array
                            v[result[2]] = value[result[2]];
                        }
                    }
                }
            }
            else {
                let v = variables.get(resultVarName);
                if ((v === undefined) && (value instanceof Array || value instanceof Float32Array)) {
                    v = new Float32Array(value.length);
                    variables.set(resultVarName, v);
                }
                if (v instanceof Array || v instanceof Float32Array) {
                    v[0] = value?.[0] ?? value;
                    v[1] = value?.[1] ?? value;
                    v[2] = value?.[2] ?? value;
                }
                else {
                    variables.set(resultVarName, value);
                }
            }
        }
    }
    getVariable(variables, name) {
        const result = this.datas[name];
        if (typeof result == 'string') {
            if (result.startsWith('$')) {
                const varName = result.toLowerCase();
                return variables.get(varName);
            }
            else {
                return result.toLowerCase();
            }
        }
        return result;
    }
}

class TextureTransform extends Proxy {
    centerVar = '';
    translateVar = '';
    rotateVar = '';
    scaleVar = '';
    resultVar = '';
    init(variables) {
        this.centerVar = this.getData('centervar');
        this.translateVar = this.getData('translatevar');
        this.rotateVar = this.getData('rotatevar');
        this.scaleVar = this.getData('scalevar');
        this.resultVar = this.getData('resultvar');
        variables.set(this.resultVar, mat4.create()); //TODO: fixme
    }
    execute(variables, proxyParams, time) {
        let center = vec2.fromValues(0.5, 0.5);
        const mat = mat4.create(); //TODOv3 optimize
        const temp = mat4.create(); //TODOv3 optimize
        if (this.centerVar) {
            center = variables.get(this.centerVar) || center;
        }
        MatrixBuildTranslation(mat, -center[0], -center[1], 0.0);
        if (this.scaleVar) { //mat4.identity(out);
            const scale = variables.get(this.scaleVar);
            if (scale) {
                if (typeof scale == 'number') {
                    MatrixBuildScale(temp, scale, scale, 1.0);
                }
                else {
                    MatrixBuildScale(temp, scale[0], scale[1], 1.0);
                }
                mat4.mul(mat, temp, mat);
            }
        }
        if (this.rotateVar) {
            const rotate = variables.get(this.rotateVar);
            mat4.identity(temp);
            mat4.rotateZ(temp, temp, DEG_TO_RAD * (rotate));
            //MatrixBuildRotateZ(temp, angle);
            //MatrixMultiply(temp, mat, mat);
            mat4.mul(mat, temp, mat);
        }
        MatrixBuildTranslation(temp, center[0], center[1], 0.0);
        mat4.mul(mat, temp, mat);
        //mat[12] += center[0];
        //mat[13] += center[1];
        if (this.translateVar) {
            const translation = variables.get(this.translateVar);
            MatrixBuildTranslation(temp, translation[0], translation[1], 0.0);
            //MatrixMultiply(temp, mat, mat);
            mat4.mul(mat, temp, mat);
        }
        const v = variables.get(this.resultVar);
        if (v) {
            mat4.copy(v, mat);
        }
        else {
            variables.set(this.resultVar, mat4.clone(mat));
        }
    }
}
ProxyManager.registerProxy('TextureTransform', TextureTransform);
function MatrixBuildTranslation(dst, x, y, z) {
    mat4.identity(dst);
    dst[12] = x;
    dst[13] = y;
    dst[14] = z;
}
// Builds a scale matrix
function MatrixBuildScale(dst, x, y, z) {
    dst[0] = x;
    dst[1] = 0;
    dst[2] = 0;
    dst[3] = 0;
    dst[4] = 0;
    dst[5] = y;
    dst[6] = 0;
    dst[7] = 0;
    dst[8] = 0;
    dst[9] = 0;
    dst[10] = z;
    dst[11] = 0;
    dst[12] = 0;
    dst[13] = 0;
    dst[14] = 0;
    dst[15] = 1;
}
/*TextureTransform
 Generates a texture transform matrix for use with $basetexturetransform etc.

centerVar
scaleVar
rotateVar
translateVar
Optional input variables for the matrix. Each one can be a float or a 2D vector.
resultVar


        'TextureTransform'
        {
            'translateVar' '$temp'
            'resultVar' '$basetexturetransform'
        }
*/

const IDENTITY_MAT4$3 = mat4.create();
function GetTextureTransform(str, mat = mat4.create()) {
    const center = vec2.fromValues(0.5, 0.5);
    //const mat = mat4.create();
    const temp = mat4.create();
    const centerResult = /center *(\d*(?:\.\d)?) *(\d*(?:\.\d)?)/.exec(str);
    const scaleResult = /scale *(\d*(?:\.\d)?) *(\d*(?:\.\d)?)/.exec(str);
    const rotateResult = /rotate *(\d*(?:\.\d)?)/.exec(str);
    const translateResult = /translate *(\d*(?:\.\d)?) *(\d*(?:\.\d)?)/.exec(str);
    if (centerResult) {
        vec2.set(center, Number(centerResult[1]), Number(centerResult[2]));
        MatrixBuildTranslation(mat, -center[0], -center[1], 0.0);
    }
    if (scaleResult) {
        MatrixBuildScale(temp, Number(scaleResult[1]), Number(scaleResult[2]), 1.0);
        mat4.mul(mat, temp, mat);
    }
    if (rotateResult) {
        mat4.identity(temp);
        mat4.rotateZ(temp, temp, DEG_TO_RAD * Number(rotateResult[1]));
        mat4.mul(mat, temp, mat);
    }
    MatrixBuildTranslation(temp, center[0], center[1], 0.0);
    mat4.mul(mat, temp, mat);
    if (translateResult) {
        MatrixBuildTranslation(temp, Number(translateResult[1]), Number(translateResult[2]), 0.0);
        mat4.mul(mat, temp, mat);
    }
    return mat;
}
const SHADER_PARAM_TYPE_INTEGER = 1;
const SHADER_PARAM_TYPE_COLOR = 2;
const SHADER_PARAM_TYPE_VEC2 = 3;
const SHADER_PARAM_TYPE_FLOAT = 7;
const SHADER_PARAM_TYPE_BOOL = 8;
const SHADER_PARAM_TYPE_STRING = 12;
const VMT_PARAMETERS = {
    $alpha: [SHADER_PARAM_TYPE_FLOAT, 1.0],
    $color: [SHADER_PARAM_TYPE_COLOR, [1, 1, 1]],
    $color2: [SHADER_PARAM_TYPE_COLOR, [1, 1, 1]],
    $envmaptint: [SHADER_PARAM_TYPE_COLOR, [1, 1, 1]],
    $phong: [SHADER_PARAM_TYPE_BOOL, 0],
    $phongalbedotint: [SHADER_PARAM_TYPE_BOOL, false],
    $phongexponent: [SHADER_PARAM_TYPE_FLOAT, 5.0],
    $phongexponentfactor: [SHADER_PARAM_TYPE_FLOAT, 0.0],
    $phongexponenttexture: [SHADER_PARAM_TYPE_STRING, ''],
    $phongboost: [SHADER_PARAM_TYPE_FLOAT, 1.0],
    $lightwarptexture: [SHADER_PARAM_TYPE_STRING, ''],
    $selfillumtint: [SHADER_PARAM_TYPE_COLOR, [1, 1, 1]],
    $detailscale: [SHADER_PARAM_TYPE_VEC2, [1, 1]],
    $detailblendmode: [SHADER_PARAM_TYPE_INTEGER, 0],
    $no_draw: [SHADER_PARAM_TYPE_BOOL, false],
};
function initDefaultParameters(defaultParameters, parameters, variables) {
    if (defaultParameters) {
        for (const parameterName in defaultParameters) {
            if (parameters[parameterName] === undefined) {
                const defaultParam = defaultParameters[parameterName];
                //variables.set(parameterName, defaultParam[1]);
                switch (defaultParam[0]) {
                    case SHADER_PARAM_TYPE_COLOR:
                        variables.set(parameterName, vec3.clone(defaultParam[1]));
                        break;
                    default:
                        variables.set(parameterName, defaultParam[1]);
                        break;
                }
            }
        }
    }
}
let defaultTexture;
function getDefaultTexture() {
    if (!defaultTexture) {
        defaultTexture = TextureManager.createFlatTexture(new Color(1, 1, 1));
        defaultTexture.addUser(Source1Material);
    }
    return defaultTexture;
}
var TextureRole;
(function (TextureRole) {
    TextureRole[TextureRole["Color"] = 0] = "Color";
    TextureRole[TextureRole["Color2"] = 0] = "Color2";
    TextureRole[TextureRole["Normal"] = 1] = "Normal";
    TextureRole[TextureRole["LightWarp"] = 2] = "LightWarp";
    TextureRole[TextureRole["PhongExponent"] = 3] = "PhongExponent";
    TextureRole[TextureRole["SelfIllumMask"] = 4] = "SelfIllumMask";
    TextureRole[TextureRole["Env"] = 5] = "Env";
    TextureRole[TextureRole["Detail"] = 6] = "Detail";
    TextureRole[TextureRole["SheenMask"] = 7] = "SheenMask";
    TextureRole[TextureRole["Sheen"] = 8] = "Sheen";
    TextureRole[TextureRole["Mask"] = 9] = "Mask";
    TextureRole[TextureRole["Mask2"] = 10] = "Mask2";
    TextureRole[TextureRole["Iris"] = 11] = "Iris";
    TextureRole[TextureRole["Cornea"] = 12] = "Cornea";
    TextureRole[TextureRole["Pattern"] = 13] = "Pattern";
    TextureRole[TextureRole["Ao"] = 14] = "Ao";
    TextureRole[TextureRole["Wear"] = 15] = "Wear";
    TextureRole[TextureRole["Grunge"] = 16] = "Grunge";
    TextureRole[TextureRole["Exponent"] = 17] = "Exponent";
    TextureRole[TextureRole["Surface"] = 18] = "Surface";
    TextureRole[TextureRole["Pos"] = 19] = "Pos";
    TextureRole[TextureRole["BlendModulate"] = 20] = "BlendModulate";
    TextureRole[TextureRole["Holo"] = 21] = "Holo";
    TextureRole[TextureRole["HoloSpectrum"] = 22] = "HoloSpectrum";
    TextureRole[TextureRole["Scratches"] = 23] = "Scratches";
})(TextureRole || (TextureRole = {}));
class Source1Material extends Material {
    #initialized = false;
    #detailTextureTransform = mat4.create();
    vmt;
    //static #defaultTexture;
    repository;
    path;
    proxyParams = {};
    proxies = [];
    variables = new Map();
    #textures = new Map();
    useSrgb = true;
    constructor(repository, path, vmt, params = {}) {
        super(params);
        this.vmt = vmt;
        this.repository = repository;
        this.path = path;
    }
    init() {
        if (this.#initialized) {
            return;
        }
        const vmt = this.vmt;
        this.#initialized = true;
        this.#initUniforms();
        const variables = this.variables;
        initDefaultParameters(VMT_PARAMETERS, this.vmt, variables);
        initDefaultParameters(this.getDefaultParameters(), this.vmt, variables);
        const readParameters = (parameters) => {
            for (const parameterName in parameters) {
                const value = parameters[parameterName];
                const sanitized = this.sanitizeValue(parameterName, value);
                if (sanitized) {
                    this.variables.set(parameterName, sanitized);
                }
                else if ((typeof value) == 'string') {
                    //try a single number
                    const n = Number(value);
                    if (!Number.isNaN(n)) {
                        this.variables.set(parameterName, n);
                    }
                    else {
                        const color = readColor(value);
                        if (color) {
                            this.variables.set(parameterName, color);
                        }
                        else {
                            const v2 = readVec2(value);
                            if (v2) {
                                this.variables.set(parameterName, v2);
                            }
                            else {
                                if (isNaN(Number(value))) {
                                    this.variables.set(parameterName, value);
                                }
                                else {
                                    this.variables.set(parameterName, Number(value));
                                }
                            }
                        }
                    }
                }
                else {
                    this.variables.set(parameterName, value);
                }
            }
        };
        readParameters(vmt);
        if (vmt['>=dx90']) {
            readParameters(vmt['>=dx90']);
        }
        const baseTexture = variables.get('$basetexture');
        if (baseTexture) {
            this.setColorMap(this.getTexture(TextureRole.Color, this.repository, baseTexture, vmt['$frame'] ?? 0, false, this.useSrgb ?? true));
        }
        else {
            this.setColorMap(getDefaultTexture());
        }
        if (vmt['$bumpmap']) {
            this.setNormalMap(this.getTexture(TextureRole.Normal, this.repository, vmt['$bumpmap'], 0, false, false));
        }
        else {
            this.setNormalMap(null);
        }
        let translucent = false;
        if (vmt['$alpha']) {
            this.setTransparency(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
            this.setDefine('IS_TRANSLUCENT');
            translucent = true;
        }
        if (vmt['$vertexalpha'] == 1) {
            this.setTransparency(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
            this.setDefine('IS_TRANSLUCENT');
            translucent = true;
            //TODOv3 activate proper define in shader
            //also add vertexcolor
        }
        if (vmt['$translucent'] == 1) {
            this.setBlending(MATERIAL_BLENDING_NORMAL);
            this.setDefine('IS_TRANSLUCENT');
            translucent = true;
        }
        if (vmt['$additive'] == 1) {
            if (translucent) {
                this.setBlending(MATERIAL_BLENDING_ADDITIVE);
            }
            else {
                this.setBlending(MATERIAL_BLENDING_ADDITIVE, true);
            }
            this.setDefine('IS_ADDITIVE');
        }
        if (vmt['$alphatest'] == 1) {
            this.alphaTest = true;
            this.alphaTestReference = Number.parseFloat(vmt['$alphatestreference'] ?? 0.5);
        }
        if (vmt['$vertexalpha'] == 1) {
            this.setDefine('VERTEX_ALPHA');
        }
        if (vmt['$vertexcolor'] == 1) {
            this.setDefine('VERTEX_COLOR');
        }
        const envmaptint = variables.get('$envmaptint');
        if (envmaptint) {
            this.uniforms['uCubeMapTint'] = envmaptint;
        }
        else {
            this.uniforms['uCubeMapTint'] = vec3.fromValues(1.0, 1.0, 1.0);
        }
        if (variables.get('$normalmapalphaenvmapmask') == 1) {
            this.setDefine('USE_NORMAL_ALPHA_AS_ENVMAP_MASK');
        }
        if (variables.get('$no_draw')) {
            this.setDefine('NO_DRAW');
        }
        this.uniforms['uTextureTransform'] = IDENTITY_MAT4$3;
        if (vmt['$basetexturetransform']) {
            const textureTransform = GetTextureTransform(vmt['$basetexturetransform']);
            if (textureTransform) {
                this.variables.set('$basetexturetransform', textureTransform);
                this.uniforms['uTextureTransform'] = textureTransform;
            }
        }
        if (vmt['$nocull'] == 1) {
            this.renderFace(RenderFace.Both);
        }
        const lightWarpTexture = vmt['$lightwarptexture'];
        this.setTexture('lightWarpMap', lightWarpTexture ? this.getTexture(TextureRole.LightWarp, this.repository, lightWarpTexture, 0) : null, 'USE_LIGHT_WARP_MAP');
        if (vmt['$phong'] == 1) {
            this.setDefine('USE_PHONG_SHADING');
            // The $phongexponenttexture is overrided by $phongexponent
            const phongExponentTexture = vmt['$phongexponenttexture'];
            this.setTexture('phongExponentMap', phongExponentTexture ? this.getTexture(TextureRole.PhongExponent, this.repository, phongExponentTexture, 0) : null, 'USE_PHONG_EXPONENT_MAP');
            if (phongExponentTexture) {
                this.uniforms['uPhongExponentFactor'] = variables.get('$phongexponentfactor');
            }
            this.uniforms['uPhongExponent'] = variables.get('$phongexponent');
            this.uniforms['uPhongBoost'] = variables.get('$phongboost');
            if (vmt['$basemapalphaphongmask'] == 1) {
                this.setDefine('USE_COLOR_ALPHA_AS_PHONG_MASK');
            }
            if (vmt['$phongalbedotint'] == 1) {
                this.setDefine('USE_PHONG_ALBEDO_TINT');
            }
            /*VertexLitGeneric
            {
                $phong 1

                $bumpmap				[texture]
                $phongexponent			5			// either/or
                $phongexponenttexture	[texture]	// either/or
                $phongboost				1.0
                $phongfresnelranges		"[0 0.5 1]"
                basemapalphaphongmask
            }*/
        }
        if (variables.get('$selfillum') == 1) {
            this.setDefine('USE_SELF_ILLUM');
            if (variables.get('$selfillum_envmapmask_alpha') == 1) {
                this.setDefine('USE_SELF_ILLUM_ENVMAPMASK_ALPHA');
            }
            const selfIllumTint = variables.get('$selfillumtint');
            if (selfIllumTint) {
                this.uniforms['uSelfIllumTint'] = selfIllumTint;
            }
            else {
                this.uniforms['uSelfIllumTint'] = vec3.fromValues(1.0, 1.0, 1.0);
            }
            const selfIllumMask = variables.get('$selfillummask');
            this.setTexture('uSelfIllumMaskMap', selfIllumMask ? this.getTexture(TextureRole.SelfIllumMask, this.repository, selfIllumMask, 0) : null, 'USE_SELF_ILLUM_MASK_MAP');
            if (variables.get('$selfillumfresnel') == 1) {
                this.setDefine('USE_SELF_ILLUM_FRESNEL');
                const selfIllumFresnelMinMaxExp = variables.get('$selfillumfresnelminmaxexp') ?? vec3.fromValues(0.0, 1.0, 1.0);
                const constScaleBiasExp = vec4.fromValues(1.0, 0.0, 1.0, 0.0);
                const flMin = selfIllumFresnelMinMaxExp[0];
                const flMax = selfIllumFresnelMinMaxExp[1];
                const flExp = selfIllumFresnelMinMaxExp[2];
                constScaleBiasExp[1] = (flMax != 0.0) ? (flMin / flMax) : 0.0; // Bias
                constScaleBiasExp[0] = 1.0 - constScaleBiasExp[1]; // Scale
                constScaleBiasExp[2] = flExp; // Exp
                constScaleBiasExp[3] = flMax; // Brightness
                this.uniforms['uSelfIllumScaleBiasExpBrightness'] = constScaleBiasExp;
            }
            /*
                        $selfillum
                        selfIllumFresnelMinMaxExp
                        selfillumtint
                        selfIllumFresnel
                        selfillummask
                        selfillum_envmapmask_alpha
                        selfillumtexture
                        selfillummaskscale
                        */
        }
        const ssbump = this.variables.get('$ssbump');
        if (ssbump == 1) {
            this.setDefine('USE_SSBUMP');
        }
        else {
            this.removeDefine('USE_SSBUMP');
        }
        const proxies = vmt['proxies'];
        if (proxies) {
            this.#initProxies(proxies);
        }
        //this.blend = true;
        //this.blendFuncSource = GL_SRC_ALPHA;
        //this.blendFuncDestination = GL_ONE_MINUS_SRC_ALPHA;
        //this.blendFuncDestination = GL_ONE;
        //TODO: $ignorez
    }
    getTexture(role, repository, path, frame, needCubeMap = false, srgb = true) {
        const animated = Source1TextureManager.getTexture(repository, path, needCubeMap, srgb);
        const previousTexture = this.#textures.get(role);
        if (animated && (previousTexture != animated)) {
            previousTexture?.removeUser(this);
            animated.addUser(this);
            this.#textures.set(role, animated);
        }
        return animated?.getFrame(frame) ?? null;
    }
    #initUniforms() {
        this.uniforms['uDetailTextureTransform'] = this.#detailTextureTransform;
    }
    getTexCoords(flCreationTime, flCurTime, flAgeScale, nSequence) {
        const texture = this.uniforms['colorMap'];
        if (!texture) {
            return null;
        }
        const vtf = texture.properties.get('vtf');
        const sheet = vtf?.sheet;
        if (sheet) {
            //SETextureControler.getAnimSheet('materials/' + this.baseTexture);
            if (sheet) {
                let group = sheet.sequences[nSequence];
                if (!group) { // In case sequence # is outside VTF range
                    group = sheet.sequences[0];
                }
                if (group) {
                    if (group.frames.length == 1) {
                        return group.getFrame(0);
                    }
                    let flAge = flCurTime - flCreationTime;
                    flAge *= flAgeScale;
                    let nFrame = Math.abs(Math.round(flAge));
                    return group.getFrame((nFrame * group.frames.length / 1024) << 0);
                }
                /*
                let group = sheet.sequences[nSequence]
                if (!group) { // In case sequence # is outside VTF range
                    group = sheet.sequences[0];
                }

                if (group) {
                    if (group.frames.length == 1) {
                        return group.m_pSamples[0];
                    }

                    let flAge = flCurTime - flCreationTime;
                    flAge *= flAgeScale;
                    let nFrame = Math.abs(Math.round(flAge));

                    if (group.clamp) {
                        nFrame = Math.min(nFrame, SEQUENCE_SAMPLE_COUNT - 1);
                    } else {
                        nFrame &= SEQUENCE_SAMPLE_COUNT - 1;
                    }
                    return group.m_pSamples[nFrame];
                }
                */
            }
        }
        return null;
    }
    getFrameSpan(sequence) {
        const texture = this.uniforms['colorMap'];
        if (!texture) {
            return;
        }
        const vtf = texture.properties.get('vtf');
        const sheet = vtf?.sheet;
        if (sheet) {
            //const sheet = texture.vtf.sheet;//SETextureControler.getAnimSheet('materials/' + this.baseTexture);
            if (sheet) {
                let group = sheet.sequences[sequence];
                if (!group) {
                    group = sheet.sequences[0];
                }
                if (group) {
                    return group.duration;
                }
            }
        }
        return null;
    }
    /**
     * Init proxies
     * @param proxies {Array} List of proxies
     */
    #initProxies(proxies) {
        if (!proxies) {
            return;
        }
        for (const proxyIndex in proxies) {
            if (proxies.hasOwnProperty(proxyIndex)) {
                const proxyName = proxyIndex.replace(/#\d+$/, '');
                const proxy = ProxyManager.getProxy(proxyName);
                if (proxy) {
                    proxy.setParams(proxies[proxyIndex], this.variables);
                    this.proxies.push(proxy);
                }
            }
        }
    }
    updateMaterial(time, mesh) {
        this.#processProxies(time, mesh.materialsParams);
    }
    /**
     * Process proxies
     * @param proxyParams {Object} Param passed to proxies
     */
    #processProxies(time, proxyParams = {}) {
        for (const proxy of this.proxies) {
            proxy.execute(this.variables, proxyParams, time);
        }
        this._afterProcessProxies(proxyParams);
        this.afterProcessProxies(proxyParams);
    }
    _afterProcessProxies(proxyParams = {} /*TODO: improve type*/) {
        const variables = this.variables;
        const parameters = this.vmt;
        const baseTexture = variables.get('$basetexture');
        if (baseTexture) {
            const texture = this.getTexture(TextureRole.Color, this.repository, baseTexture, parameters['$frame'] ?? variables.get('$frame') ?? 0);
            this.setColorMap(texture);
            // Disable self illum if texture doesn't have alpha channel (fix for D-eye-monds)
            this.setDefine('COLOR_MAP_ALPHA_BITS', String(texture?.getAlphaBits() ?? 0));
        }
        const normalMap = variables.get('$bumpmap') ?? variables.get('$normalmap');
        if (normalMap) {
            this.setNormalMap(this.getTexture(TextureRole.Normal, this.repository, normalMap, 0));
        }
        else {
            this.setNormalMap(null);
        }
        let envmap = variables.get('$envmap');
        if (envmap) {
            if (envmap == 'env_cubemap') {
                envmap = 'editor/cubemap'; //TODO: set default cubmap as a constant
            }
            this.setCubeMap(this.getTexture(TextureRole.Env, this.repository, envmap, 0, true));
        }
        const baseTextureTransform = variables.get('$basetexturetransform');
        if (baseTextureTransform) {
            this.uniforms['uTextureTransform'] = baseTextureTransform;
            this.setDefine('USE_TEXTURE_TRANSFORM');
        }
        //TODO: remove this
        const phongExponentTexture = variables.get('$phongexponenttexture');
        if (phongExponentTexture) {
            this.setTexture('phongExponentMap', this.getTexture(TextureRole.PhongExponent, this.repository, phongExponentTexture, 0), 'USE_PHONG_EXPONENT_MAP');
        }
        const lightWarpTexture = parameters['$lightwarptexture'];
        this.setTexture('lightWarpMap', lightWarpTexture ? this.getTexture(TextureRole.LightWarp, this.repository, lightWarpTexture, 0) : null, 'USE_LIGHT_WARP_MAP');
        if (variables.get('$selfillum') == 1) {
            const selfIllumTint = variables.get('$selfillumtint');
            if (selfIllumTint) {
                this.uniforms['uSelfIllumTint'] = selfIllumTint;
            }
            const selfIllumMask = variables.get('$selfillummask');
            if (selfIllumMask) {
                this.setTexture('uSelfIllumMaskMap', this.getTexture(TextureRole.SelfIllumMask, this.repository, selfIllumMask, 0));
            }
        }
        const detailTexture = variables.get('$detail');
        if (detailTexture) {
            this.setDetailMap(this.getTexture(TextureRole.Detail, this.repository, detailTexture, variables.get('$detailframe') ?? 0));
            const detailTextureTransform = variables.get('$detailtexturetransform');
            if (detailTextureTransform) {
                const textureTransform = GetTextureTransform(detailTextureTransform, this.#detailTextureTransform);
                if (textureTransform) {
                    this.variables.set('$detailtexturetransform', textureTransform);
                }
            }
            else {
                const detailScale = variables.get('$detailscale');
                if (detailScale) {
                    MatrixBuildScale(this.#detailTextureTransform, detailScale[0], detailScale[1], 1.0);
                    this.setDefine('USE_DETAIL_TEXTURE_TRANSFORM');
                    /*let textureTransform = GetTextureTransform(parameters['$basetexturetransform']);
                    if (textureTransform) {
                        this.variables.set('$basetexturetransform', textureTransform);
                        this.uniforms['uTextureTransform'] = textureTransform;
                    }*/
                }
                else {
                    this.removeDefine('USE_DETAIL_TEXTURE_TRANSFORM');
                }
            }
            this.setDefine('DETAIL_BLEND_MODE', variables.get('$detailblendmode') ?? 0);
            this.uniforms['uDetailBlendFactor'] = variables.get('$detailblendfactor') ?? 0;
        }
    }
    afterProcessProxies(proxyParams = {} /*TODO: improve type*/) {
    }
    getAlpha() {
        return clamp$1(this.variables.get('$alpha'), 0.0, 1.0);
    }
    computeModulationColor(out) {
        const color = this.variables.get('$color'); //TODOv3: check variable type
        const color2 = this.variables.get('$color2'); //TODOv3: check variable type
        if (color2) {
            out[0] = color[0] * color2[0];
            out[1] = color[1] * color2[1];
            out[2] = color[2] * color2[2];
            out[3] = this.getAlpha();
        }
        else {
            out[0] = color[0];
            out[1] = color[1];
            out[2] = color[2];
            out[3] = this.getAlpha();
        }
        return out;
    }
    getDefaultParameters() {
        return {};
    }
    sanitizeValue(parameterName, value /*TODO: create type */) {
        const param = VMT_PARAMETERS[parameterName] ?? this.getDefaultParameters()[parameterName];
        if (param) {
            switch (param[0]) {
                case SHADER_PARAM_TYPE_COLOR:
                    return readColor(value);
                case SHADER_PARAM_TYPE_FLOAT:
                    const fl = Number(value);
                    if (!Number.isNaN(fl)) {
                        return fl;
                    }
                    const c = readColor(value);
                    if (c) {
                        return c[0];
                    }
                    return param[1];
                case SHADER_PARAM_TYPE_INTEGER:
                    return Number(value) << 0;
                case SHADER_PARAM_TYPE_BOOL:
                    return Number(value);
                case SHADER_PARAM_TYPE_STRING:
                    return value;
                case SHADER_PARAM_TYPE_VEC2:
                    return readVec2(value);
            }
        }
        return null;
    }
    setKeyValue(key, value /*TODO: create type*/) {
        const sanitized = this.sanitizeValue(key, value);
        if (sanitized) {
            this.variables.set(key, sanitized);
        }
        else {
            this.variables.set(key, value);
        }
    }
    clone() {
        return new Source1Material(this.repository, this.path, this.vmt, this.parameters);
    }
    dispose() {
        super.dispose();
        if (this.hasNoUser()) {
            for (const [_, texture] of this.#textures) {
                texture.removeUser(this);
            }
        }
    }
}
//TODO: store regexes
function readColor(value, color) {
    color = color || vec3.create();
    // With { } : color values in 0-255 range
    value = value.trim();
    let regex = /\{ *(\d*) *(\d*) *(\d*) *(\d*)* *\}/i;
    let result = regex.exec(value);
    if (result) {
        vec3.set(color, Number(result[1]) / 255.0, Number(result[2]) / 255.0, Number(result[3]) / 255.0);
        return color;
    }
    // With [] : color values in 0.0-1.0 range
    regex = /\[ *(\d*(\.\d*)?) *(\d*(\.\d*)?) *(\d*(\.\d*)?) *\]/i;
    result = regex.exec(value);
    if (result) {
        vec3.set(color, Number(result[1]), Number(result[3]), Number(result[5]));
        return color;
    }
    // With nothing : color values in 0.0-1.0 range
    regex = /^ *(\d*(\.\d*)?) *(\d*(\.\d*)?) *(\d*(\.\d*)?) *$/i;
    result = regex.exec(value);
    if (result) {
        vec3.set(color, Number(result[1]), Number(result[3]), Number(result[5]));
        return color;
    }
    //try a single number
    const n = Number(value);
    if (!Number.isNaN(n)) {
        vec3.set(color, n, n, n);
        return color;
    }
    return null;
}
function readVec2(value, vec) {
    vec = vec || vec2.create();
    const regex = /\[ *(-?\d*(\.\d*)?) *(-?\d*(\.\d*)?) *\]/i;
    const result = regex.exec(value);
    if (result) {
        return vec2.set(vec, Number(result[1]), Number(result[3]));
    }
    const f = Number.parseFloat(value);
    if (Number.isNaN(f)) {
        return;
    }
    return vec2.set(vec, f, f);
}
/*

enum MaterialVarFlags_t
{
    MATERIAL_VAR_DEBUG					  = (1 << 0),
    MATERIAL_VAR_NO_DEBUG_OVERRIDE		  = (1 << 1),
    MATERIAL_VAR_NO_DRAW				  = (1 << 2),
    MATERIAL_VAR_USE_IN_FILLRATE_MODE	  = (1 << 3),

    MATERIAL_VAR_VERTEXCOLOR			  = (1 << 4),
    MATERIAL_VAR_VERTEXALPHA			  = (1 << 5),
    MATERIAL_VAR_SELFILLUM				  = (1 << 6),
    MATERIAL_VAR_ADDITIVE				  = (1 << 7),
    MATERIAL_VAR_ALPHATEST				  = (1 << 8),
    MATERIAL_VAR_MULTIPASS				  = (1 << 9),
    MATERIAL_VAR_ZNEARER				  = (1 << 10),
    MATERIAL_VAR_MODEL					  = (1 << 11),
    MATERIAL_VAR_FLAT					  = (1 << 12),
    MATERIAL_VAR_NOCULL					  = (1 << 13),
    MATERIAL_VAR_NOFOG					  = (1 << 14),
    MATERIAL_VAR_IGNOREZ				  = (1 << 15),
    MATERIAL_VAR_DECAL					  = (1 << 16),
    MATERIAL_VAR_ENVMAPSPHERE			  = (1 << 17),
    MATERIAL_VAR_NOALPHAMOD				  = (1 << 18),
    MATERIAL_VAR_ENVMAPCAMERASPACE	      = (1 << 19),
    MATERIAL_VAR_BASEALPHAENVMAPMASK	  = (1 << 20),
    MATERIAL_VAR_TRANSLUCENT              = (1 << 21),
    MATERIAL_VAR_NORMALMAPALPHAENVMAPMASK = (1 << 22),
    MATERIAL_VAR_NEEDS_SOFTWARE_SKINNING  = (1 << 23),
    MATERIAL_VAR_OPAQUETEXTURE			  = (1 << 24),
    MATERIAL_VAR_ENVMAPMODE				  = (1 << 25),
    MATERIAL_VAR_SUPPRESS_DECALS		  = (1 << 26),
    MATERIAL_VAR_HALFLAMBERT			  = (1 << 27),
    MATERIAL_VAR_WIREFRAME                = (1 << 28),
    MATERIAL_VAR_ALLOWALPHATOCOVERAGE     = (1 << 29),
    MATERIAL_VAR_IGNORE_ALPHA_MODULATION  = (1 << 30),

    // NOTE: Only add flags here that either should be read from
    // .vmts or can be set directly from client code. Other, internal
    // flags should to into the flag enum in imaterialinternal.h
};
*/
/*
static const char* s_pShaderStateString[] =
{
    "$debug",
    "$no_fullbright",
    "$no_draw",
    "$use_in_fillrate_mode",

    "$vertexcolor",
    "$vertexalpha",
    "$selfillum",
    "$additive",
    "$alphatest",
    "$multipass",
    "$znearer",
    "$model",
    "$flat",
    "$nocull",
    "$nofog",
    "$ignorez",
    "$decal",
    "$envmapsphere",
    "$noalphamod",
    "$envmapcameraspace",
    "$basealphaenvmapmask",
    "$translucent",
    "$normalmapalphaenvmapmask",
    "$softwareskin",
    "$opaquetexture",
    "$envmapmode",
    "$nodecal",
    "$halflambert",
    "$wireframe",
    "$allowalphatocoverage",

    ""			// last one must be null
};
*/

//TODO: deprecate
class CharacterMaterial extends Source1Material {
    #diffuseModulation = vec4.fromValues(1.0, 1.0, 1.0, 1.0);
    constructor(repository, path, vmt, params = {}) {
        super(repository, path, vmt, params);
        const variables = this.variables;
        //"$masks1"                   models/weapons/v_models/arms/glove_bloodhound/glove_bloodhound_masks1
        //"$masks2"                   models/weapons/v_models/arms/glove_bloodhound/glove_bloodhound_masks2
        const masks1Texture = variables.get('$masks1');
        if (masks1Texture) {
            this.uniforms['mask1Map'] = this.getTexture(TextureRole.Mask, this.repository, masks1Texture, 0);
            this.setDefine('USE_MASK1_MAP'); //TODOv3: set this automaticaly
        }
        else {
            this.removeDefine('USE_MASK1_MAP'); //TODOv3: set this automaticaly
        }
        const masks2Texture = variables.get('$masks2');
        if (masks2Texture) {
            this.uniforms['mask2Map'] = this.getTexture(TextureRole.Mask2, this.repository, masks2Texture, 0);
            this.setDefine('USE_MASK2_MAP'); //TODOv3: set this automaticaly
        }
        else {
            this.removeDefine('USE_MASK2_MAP'); //TODOv3: set this automaticaly
        }
        //this.uniforms['phongfresnelranges'] = Source1Material.readColor(parameters['$phongfresnelranges']);
        /*float fPixelFogType = pShaderAPI->GetPixelFogCombo() == 1 ? 1 : 0;
        float fWriteDepthToAlpha = bWriteDepthToAlpha && IsPC() ? 1 : 0;
        float fWriteWaterFogToDestAlpha = (pShaderAPI->GetPixelFogCombo() == 1 && bWriteWaterFogToAlpha) ? 1 : 0;
        float fVertexAlpha = bHasVertexAlpha ? 1 : 0;*/
        this.uniforms['g_ShaderControls'] = vec4.fromValues(1, 0, 1, 0); //TODOv3
        this.uniforms['g_DiffuseModulation'] = this.#diffuseModulation;
        const btbba = this.variables.get('$blendtintbybasealpha');
        if (btbba && btbba == 1) {
            this.setDefine('BLEND_TINT_BY_BASE_ALPHA');
            this.uniforms['uBlendTintColorOverBase'] = this.variables.get('$blendtintcoloroverbase') ?? 0;
        }
        else {
            this.removeDefine('BLEND_TINT_BY_BASE_ALPHA');
        }
        this.uniforms['g_cCloakColorTint'] = vec3.create();
        this.variables.set('$SheenMaskScaleX', 1.0);
        this.variables.set('$SheenMaskScaleY', 1.0);
        this.variables.set('$SheenMaskOffsetX', 0.0);
        this.variables.set('$SheenMaskOffsetY', 0.0);
        this.variables.set('$SheenMaskDirection', 0.0);
    }
    afterProcessProxies(proxyParams = {}) {
        const variables = this.variables;
        const parameters = this.vmt;
        const sheenMapMaskFrame = variables.get('$sheenmapmaskframe'); //variables.get('$sheenmapmaskframe')
        if (parameters['$sheenmapmask']) {
            this.uniforms['sheenMaskMap'] = this.getTexture(TextureRole.SheenMask, this.repository, parameters['$sheenmapmask'], sheenMapMaskFrame);
            this.setDefine('USE_SHEEN_MASK_MAP'); //TODOv3: set this automaticaly
            this.uniforms['g_vPackedConst6'] = vec4.fromValues(variables.get('$SheenMaskScaleX'), variables.get('$SheenMaskScaleY'), variables.get('$SheenMaskOffsetX'), variables.get('$SheenMaskOffsetY'));
            this.uniforms['g_vPackedConst7'] = vec4.fromValues(variables.get('$SheenMaskDirection'), 0, 0, 0);
        }
        if (parameters['$sheenmap']) {
            this.uniforms['sheenMap'] = this.getTexture(TextureRole.Sheen, this.repository, parameters['$sheenmap'], 0, true);
            this.setDefine('USE_SHEEN_MAP'); //TODOv3: set this automaticaly
        }
        if (proxyParams['SheenTintColor']) {
            this.uniforms['g_cCloakColorTint'] = proxyParams['SheenTintColor'];
        }
        else {
            const sheenmaptint = variables.get('$sheenmaptint');
            if (sheenmaptint) {
                this.uniforms['g_cCloakColorTint'] = sheenmaptint;
            }
        }
        const masks1Texture = variables.get('$masks1');
        if (masks1Texture) {
            this.uniforms['mask1Map'] = this.getTexture(TextureRole.Mask, this.repository, masks1Texture, 0);
            this.setDefine('USE_MASK1_MAP'); //TODOv3: set this automaticaly
        }
        const masks2Texture = variables.get('$masks2');
        if (masks2Texture) {
            this.uniforms['mask2Map'] = this.getTexture(TextureRole.Mask2, this.repository, masks2Texture, 0);
            this.setDefine('USE_MASK2_MAP'); //TODOv3: set this automaticaly
        }
        //uniform vec4 g_vPackedConst6;
        //uniform vec4 g_vPackedConst7;
        //TODOv3: only do this if a variable is changed
        this.uniforms['g_DiffuseModulation'] = this.computeModulationColor(this.#diffuseModulation);
    }
    clone() {
        return new CharacterMaterial(this.repository, this.path, this.vmt, this.parameters);
    }
    get shaderSource() {
        return 'source1_character'; //TODO: setup proper shader
    }
}
Source1VmtLoader.registerMaterial('character', CharacterMaterial);

const DEFAULT_WEAR_PROGRESS = 0.0; //0.45;
//TODO: deprecate
class CustomWeaponMaterial extends Source1Material {
    diffuseModulation = vec4.fromValues(1.0, 1.0, 1.0, 1.0);
    constructor(repository, path, vmt, params = {}) {
        super(repository, path, vmt, params);
        //this.uniforms['phongfresnelranges'] = Source1Material.readColor(parameters['$phongfresnelranges']);
        /*float fPixelFogType = pShaderAPI->GetPixelFogCombo() == 1 ? 1 : 0;
        float fWriteDepthToAlpha = bWriteDepthToAlpha && IsPC() ? 1 : 0;
        float fWriteWaterFogToDestAlpha = (pShaderAPI->GetPixelFogCombo() == 1 && bWriteWaterFogToAlpha) ? 1 : 0;
        float fVertexAlpha = bHasVertexAlpha ? 1 : 0;*/
        this.uniforms['g_ShaderControls'] = vec4.fromValues(1, 0, 1, 0); //TODOv3
        this.uniforms['g_PreviewPhongBoosts'] = vec4.fromValues(1, 1, 1, 1);
        this.uniforms['g_DiffuseModulation'] = this.diffuseModulation;
        const btbba = this.variables.get('$blendtintbybasealpha');
        if (btbba && btbba == 1) {
            this.setDefine('BLEND_TINT_BY_BASE_ALPHA');
            this.uniforms['uBlendTintColorOverBase'] = this.variables.get('$blendtintcoloroverbase') ?? 0;
        }
        else {
            this.removeDefine('BLEND_TINT_BY_BASE_ALPHA');
        }
        this.uniforms['g_cCloakColorTint'] = vec3.create();
        this.variables.set('$SheenMaskScaleX', 1.0);
        this.variables.set('$SheenMaskScaleY', 1.0);
        this.variables.set('$SheenMaskOffsetX', 0.0);
        this.variables.set('$SheenMaskOffsetY', 0.0);
        this.variables.set('$SheenMaskDirection', 0.0);
    }
    afterProcessProxies(proxyParams) {
        const variables = this.variables;
        const parameters = this.vmt;
        const sheenMapMaskFrame = variables.get('$sheenmapmaskframe'); //variables.get('$sheenmapmaskframe')
        if (parameters['$sheenmapmask']) {
            this.uniforms['sheenMaskMap'] = this.getTexture(TextureRole.SheenMask, this.repository, parameters['$sheenmapmask'], sheenMapMaskFrame);
            this.setDefine('USE_SHEEN_MASK_MAP'); //TODOv3: set this automaticaly
            this.uniforms['g_vPackedConst6'] = vec4.fromValues(variables.get('$SheenMaskScaleX'), variables.get('$SheenMaskScaleY'), variables.get('$SheenMaskOffsetX'), variables.get('$SheenMaskOffsetY'));
            this.uniforms['g_vPackedConst7'] = vec4.fromValues(variables.get('$SheenMaskDirection'), 0, 0, 0);
        }
        if (parameters['$sheenmap']) {
            this.uniforms['sheenMap'] = this.getTexture(TextureRole.Sheen, this.repository, parameters['$sheenmap'], 0, true);
            this.setDefine('USE_SHEEN_MAP'); //TODOv3: set this automaticaly
        }
        if (parameters['$maskstexture']) {
            this.uniforms['mask1Map'] = this.getTexture(TextureRole.Mask, this.repository, parameters['$maskstexture'], 0);
            this.setDefine('USE_MASK1_MAP'); //TODOv3: set this automaticaly
        }
        if (parameters['$pattern']) {
            this.uniforms['patternMap'] = this.getTexture(TextureRole.Pattern, this.repository, parameters['$pattern'], 0);
            this.setDefine('USE_PATTERN_MAP'); //TODOv3: set this automaticaly
        }
        if (parameters['$aotexture']) {
            this.uniforms['aoMap'] = this.getTexture(TextureRole.Ao, this.repository, parameters['$aotexture'], 0);
            this.setDefine('USE_AO_MAP'); //TODOv3: set this automaticaly
        }
        if (parameters['$weartexture']) {
            this.uniforms['scratchesMap'] = this.getTexture(TextureRole.Scratches, this.repository, parameters['$weartexture'], 0);
            this.setDefine('USE_SCRATCHES_MAP'); //TODOv3: set this automaticaly
        }
        if (parameters['$grungetexture']) {
            this.uniforms['grungeMap'] = this.getTexture(TextureRole.Grunge, this.repository, parameters['$grungetexture'], 0);
            this.setDefine('USE_GRUNGE_MAP'); //TODOv3: set this automaticaly
        }
        const expTexture = parameters['$exptexture'];
        if (expTexture) {
            this.uniforms['exponentMap'] = this.getTexture(TextureRole.Exponent, this.repository, expTexture, 0);
            this.setDefine('USE_EXPONENT_MAP'); //TODOv3: set this automaticaly
        }
        const surfaceTexture = parameters['$surfacetexture'];
        if (surfaceTexture) {
            this.uniforms['surfaceMap'] = this.getTexture(TextureRole.Surface, this.repository, surfaceTexture, 0);
            this.setDefine('USE_SURFACE_MAP'); //TODOv3: set this automaticaly
        }
        const posTexture = parameters['$postexture'];
        if (posTexture) {
            this.uniforms['posMap'] = this.getTexture(TextureRole.Pos, this.repository, posTexture, 0);
            this.setDefine('USE_POS_MAP'); //TODOv3: set this automaticaly
        }
        /*

                    if( bAOTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER0, true );		// [sRGB] Ambient Occlusion
                    }
                    if( bWearTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER1, true );		// Scratches
                    }
                    if( bExpTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER2, true );		// Exponent
                    }
                    if ( bBaseTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER3, true );		// [sRGB] Base
                    }
                    if( bMasksTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER4, true );		// Masks
                    }
                    if( bGrungeTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER5, true );		// [sRGB] Grunge
                    }
                    if( bSurfaceTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER6, true );		// Obj-space normal and cavity
                    }
                    if( bPosTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER7, true );		// High-precision Position
                    }
                    if( bPaintTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER8, true );		// Paint
                    }	*/
        if (proxyParams['SheenTintColor']) {
            this.uniforms['g_cCloakColorTint'] = proxyParams['SheenTintColor'];
        }
        else {
            const sheenmaptint = variables.get('$sheenmaptint');
            if (sheenmaptint) {
                this.uniforms['g_cCloakColorTint'] = sheenmaptint;
            }
        }
        const wearProgress = proxyParams['WearProgress'] ?? 0;
        if (wearProgress !== undefined) {
            this.uniforms['uWearProgress'] = wearProgress;
        }
        else {
            this.uniforms['uWearProgress'] = DEFAULT_WEAR_PROGRESS;
        }
        //uniform vec4 g_vPackedConst6;
        //uniform vec4 g_vPackedConst7;
        //TODOv3: only do this if a variable is changed
        this.uniforms['g_DiffuseModulation'] = this.computeModulationColor(this.diffuseModulation);
    }
    set style(style) {
        this.setDefine('PAINT_STYLE', style);
    }
    setColorUniform(uniformName, value) {
        const color = readColor(value);
        if (color) {
            //vec3.scale(color, color, 1 / 255.0);
            this.uniforms[uniformName] = color;
        }
    }
    set color0(color) {
        this.setColorUniform('uCamoColor0', color);
    }
    set color1(color) {
        this.setColorUniform('uCamoColor1', color);
    }
    set color2(color) {
        this.setColorUniform('uCamoColor2', color);
    }
    set color3(color) {
        this.setColorUniform('uCamoColor3', color);
    }
    /*
        setUniformTransform(uniformName, scale, translation, rotation) {
            let transformMatrix = this.getTexCoordTransform(scale, translation, rotation);
            this.uniforms[uniformName] = new Float32Array([
                                                            transformMatrix[0], transformMatrix[4], transformMatrix[8], transformMatrix[12],
                                                            transformMatrix[1], transformMatrix[5], transformMatrix[9], transformMatrix[13]
                                                            ]);
        }

        setPatternTexCoordTransform(scale, translation, rotation) {
            this.setUniformTransform('g_patternTexCoordTransform[0]', scale, translation, rotation);
        }

        setWearTexCoordTransform(scale, translation, rotation) {
            this.setUniformTransform('g_wearTexCoordTransform[0]', scale, translation, rotation);
        }

        setGrungeTexCoordTransform(scale, translation, rotation) {
            this.setUniformTransform('g_grungeTexCoordTransform[0]', scale, translation, rotation);
        }
    */
    setPatternScale(scale) {
        this.uniforms['g_PreviewPhongBoosts'][2] = scale;
    }
    /*

        "name": "aa_vertigo",
        "desc": "#PaintKit_aa_vertigo",
        "rarity": "mythical",
        "pattern": "vertigo",
        "wear_default": "0.150000",
        "style": "6",
        "color0": "102 92 85",
        "color1": "16 16 16",
        "color2": "16 16 16",
        "color3": "16 16 16",
        "pattern_scale": "1.400000",
        "pattern_offset_x_start": "0.040000",
        "pattern_offset_x_end": "0.140000",
        "pattern_offset_y_start": "-0.440000",
        "pattern_offset_y_end": "-0.180000",
        "pattern_rotate_start": "7",
        "pattern_rotate_end": "25",
        "wear_remap_min": "0.000000",
        "wear_remap_max": "0.080000",
        "phongexponent": "32",
        "phongalbedoboost": "80"
        */
    clone() {
        return new CustomWeaponMaterial(this.repository, this.path, this.vmt, this.parameters);
    }
    get shaderSource() {
        return 'source1_customweapon';
    }
}
Source1VmtLoader.registerMaterial('customweapon', CustomWeaponMaterial);

vec3.create();
class EyeRefractMaterial extends Source1Material {
    #initialized = false;
    #eyeOrigin = vec3.create();
    #eyeForward = vec3.create();
    #eyeUp = vec3.create();
    #eyeRight = vec3.create();
    #irisProjectionU = vec4.create();
    #irisProjectionV = vec4.create();
    useSrgb = false;
    init() {
        if (this.#initialized) {
            return;
        }
        this.#initialized = true;
        super.init();
        const vmt = this.vmt;
        if (vmt['$iris']) {
            this.setColorMap(this.getTexture(TextureRole.Iris, this.repository, vmt['$iris'], vmt['$frame'] || 0));
        }
        else {
            this.setColorMap(TextureManager.createCheckerTexture());
        }
    }
    afterProcessProxies() {
        this.variables;
        const parameters = this.vmt;
        if (parameters['$iris']) {
            this.setColorMap(this.getTexture(TextureRole.Iris, this.repository, parameters['$iris'], parameters['$frame'] || 0));
        }
        if (parameters['$corneatexture']) {
            this.setTexture('corneaMap', this.getTexture(TextureRole.Cornea, this.repository, parameters['$corneatexture'], 0));
        }
        /*
        const eyeballArray = this.properties.get('eyeballArray');
        const skeleton = this.properties.get('skeleton');
        if (eyeballArray && skeleton) {//TODOv3: do this only once
            let eyeBall = eyeballArray[this.properties.get('materialParam')];
            if (eyeBall) {
                let bone = skeleton._bones[eyeBall.bone];
                if (bone) {
                    bone.getWorldPosOffset(eyeBall.org, this.#eyeOrigin);
                    this.uniforms['u#eyeOrigin'] = this.#eyeOrigin;
                }
            }
        }
        */
    }
    beforeRender(camera) {
        const eyeballArray = this.properties.get('eyeballArray');
        const skeleton = this.properties.get('skeleton');
        if (eyeballArray && skeleton) { //TODOv3: do this only once
            const eyeBall = eyeballArray[this.properties.get('materialParam')];
            if (eyeBall) {
                const bone = skeleton._bones[eyeBall.bone];
                if (bone) {
                    bone.getWorldPosOffset(eyeBall.org, this.#eyeOrigin);
                    vec3.transformQuat(this.#eyeUp, eyeBall.up, bone.worldQuat);
                    vec3.sub(this.#eyeForward, camera.position, this.#eyeOrigin);
                    vec3.cross(this.#eyeRight, this.#eyeForward, this.#eyeUp);
                    vec3.normalize(this.#eyeRight, this.#eyeRight);
                    vec3.scaleAndAdd(this.#eyeForward, this.#eyeForward, this.#eyeRight, eyeBall.zoffset);
                    vec3.normalize(this.#eyeForward, this.#eyeForward);
                    vec3.cross(this.#eyeRight, this.#eyeForward, this.#eyeUp); //TODOv3: fix this bullshit
                    vec3.normalize(this.#eyeRight, this.#eyeRight);
                    vec3.cross(this.#eyeUp, this.#eyeRight, this.#eyeForward); //TODOv3: fix this bullshit
                    vec3.normalize(this.#eyeUp, this.#eyeUp);
                    const scale = eyeBall.irisScale; //(1 / eyeBall.irisScale);TODOv3
                    vec3.scale(this.#irisProjectionU, this.#eyeRight, -scale);
                    vec3.scale(this.#irisProjectionV, this.#eyeUp, -scale);
                    this.#irisProjectionU[3] = -vec3.dot(this.#eyeOrigin, this.#irisProjectionU) + 0.5;
                    this.#irisProjectionV[3] = -vec3.dot(this.#eyeOrigin, this.#irisProjectionV) + 0.5;
                    this.uniforms['uIrisProjectionU'] = this.#irisProjectionU;
                    this.uniforms['uIrisProjectionV'] = this.#irisProjectionV;
                    this.uniforms['uEyeOrigin'] = this.#eyeOrigin;
                }
            }
        }
    }
    clone() {
        return new EyeRefractMaterial(this.repository, this.path, this.vmt, this.parameters);
    }
    get shaderSource() {
        return 'source1_eyerefract';
    }
}
Source1VmtLoader.registerMaterial('eyerefract', EyeRefractMaterial);

class LightMappedGenericMaterial extends Source1Material {
    clone() {
        return new LightMappedGenericMaterial(this.repository, this.path, this.vmt, this.parameters);
    }
    getShaderSource() {
        return 'source1_lightmappedgeneric';
    }
}
Source1VmtLoader.registerMaterial('lightmappedgeneric', LightMappedGenericMaterial);

/**
 * Add proxy. Copies the value of a variable to another.
 * @comment input variable name: srcvar1
 * @comment input variable name: srcvar2
 * @comment ouput variable name: resultVar
 */
class Add extends Proxy {
    execute(variables, proxyParams, time) {
        super.setResult(variables, variables.get(this.getData('srcvar1')));
        const v1 = variables.get(this.getData('srcvar1'));
        const v2 = variables.get(this.getData('srcvar2'));
        if ((v1 === null) || (v2 === null) || (v1 === undefined) || (v2 === undefined)) {
            super.setResult(variables, null);
            return;
        }
        if (typeof v1 == 'number') {
            if (typeof v2 == 'number') {
                super.setResult(variables, v1 + v2);
            }
            else { //array
                super.setResult(variables, vec3.fromValues(v1 + v2[0], v1 + v2[1], v1 + v2[2]));
            }
        }
        else {
            if (typeof v2 == 'number') {
                super.setResult(variables, vec3.fromValues(v1[0] + v2, v1[1] + v2, v1[2] + v2));
            }
            else { //array
                super.setResult(variables, vec3.fromValues(v1[0] + v2[0], v1[1] + v2[1], v1[2] + v2[2]));
            }
        }
    }
}
ProxyManager.registerProxy('Add', Add);

class AnimatedTextureProxy extends Proxy {
    #animatedtexturevar = '';
    #animatedtextureframenumvar = '';
    #animatedtextureframerate = 1;
    init() {
        this.#animatedtexturevar = this.datas['animatedtexturevar'];
        this.#animatedtextureframenumvar = this.datas['animatedtextureframenumvar'];
        this.#animatedtextureframerate = this.datas['animatedtextureframerate'];
    }
    execute(variables, proxyParams, time) {
        //TODO: use #animatedtexturevar
        variables.set(this.#animatedtextureframenumvar, time * this.#animatedtextureframerate);
    }
}
ProxyManager.registerProxy('AnimatedTexture', AnimatedTextureProxy);
/*AnimatedTexture
 Increments the current frame of an animated VTF.

animatedtexturevar
Texture to increment frame for (i.e. $basetexture, $bumpmap, $normalmap (both $bumpmap and $normalmap use $bumpframe))
animatedtextureframenumvar
Frame variable to increment (i.e. $frame, $bumpframe)
animatedtextureframerate
Framerate in frames per second. Fixed; cannot be changed once set.



            'animatedtextureframenumvar' '$frame'
            'animatedtextureframenumvar' '$detailframe'
*/

class AnimatedWeaponSheen extends Proxy {
    #animatedtexturevar = '';
    #animatedtextureframenumvar = '';
    #animatedtextureframerate = 1;
    init() {
        this.#animatedtexturevar = this.datas['animatedtexturevar'];
        this.#animatedtextureframenumvar = this.datas['animatedtextureframenumvar'];
        this.#animatedtextureframerate = this.datas['animatedtextureframerate'];
    }
    execute(variables, proxyParams, time) {
        if (proxyParams['SheenTintColor']) {
            variables.set(this.#animatedtextureframenumvar, time * this.#animatedtextureframerate);
        }
        else {
            variables.set(this.#animatedtextureframenumvar, 0);
        }
        if (proxyParams['SheenMaskScaleX']) {
            variables.set('$SheenMaskScaleX', proxyParams['SheenMaskScaleX']);
            variables.set('$SheenMaskScaleY', proxyParams['SheenMaskScaleY']);
            variables.set('$SheenMaskOffsetX', proxyParams['SheenMaskOffsetX']);
            variables.set('$SheenMaskOffsetY', proxyParams['SheenMaskOffsetY']);
            variables.set('$SheenMaskDirection', proxyParams['SheenMaskDirection']);
        }
    }
}
ProxyManager.registerProxy('AnimatedWeaponSheen', AnimatedWeaponSheen);
/*AnimatedWeaponSheen
 Increments the current frame of an animated VTF.

animatedtexturevar
Texture to increment frame for (i.e. $basetexture, $bumpmap, $normalmap (both $bumpmap and $normalmap use $bumpframe))
animatedtextureframenumvar
Frame variable to increment (i.e. $frame, $bumpframe)
animatedtextureframerate
Framerate in frames per second. Fixed; cannot be changed once set.



            'animatedtextureframenumvar' '$frame'
            'animatedtextureframenumvar' '$detailframe'
*/

const minValue = 5.0;
const maxValue = 1.0;
class BenefactorLevel extends Proxy {
    #resultVar = '';
    init() {
        this.#resultVar = this.datas['resultvar'];
    }
    execute(variables, proxyParams, time) {
        const value = 1.0;
        variables.set(this.#resultVar, minValue + (maxValue - minValue) * value);
    }
}
ProxyManager.registerProxy('BenefactorLevel', BenefactorLevel);

class BuildingInvis extends Proxy {
}
ProxyManager.registerProxy('building_invis', BuildingInvis);

const TEMP_MAT4 = mat4.create();
class BuildingRescueLevel extends Proxy {
    #r = '';
    init() {
        this.#r = this.datas['resultvar'];
    }
    execute(variables, proxyParams, time) {
        const v = variables.get(this.#r);
        if (v) {
            const iAmmo = 200;
            const maxAmmo = 200;
            const iIncreasedRangeCost = 100;
            let scale = 1.0;
            {
                scale = (3.0 - ((iAmmo - iIncreasedRangeCost) / (maxAmmo - iIncreasedRangeCost) * 3.0) + 1.0);
            }
            MatrixBuildTranslation(v, -0.5, -0.5, 0.0);
            // scale
            {
                MatrixBuildScale(TEMP_MAT4, 1.0, scale, 1.0);
                mat4.mul(v, TEMP_MAT4, v);
            }
            MatrixBuildTranslation(TEMP_MAT4, 0.5, 0.5, 0.0);
            mat4.mul(v, TEMP_MAT4, v);
        }
    }
}
ProxyManager.registerProxy('BuildingRescueLevel', BuildingRescueLevel);

/**
 * BurnLevel proxy.
 * @comment ouput variable name: resultVar
 */
class BurnLevel extends Proxy {
    #r = '';
    init() {
        this.#r = this.datas['resultvar'];
    }
    execute(variables, proxyParams, time) {
        variables.set(this.#r, proxyParams.burnlevel ?? 0);
    }
}
ProxyManager.registerProxy('BurnLevel', BurnLevel);

class Clamp extends Proxy {
    #srcvar1 = '';
    #resultvar = '';
    #minVal = 0;
    #maxVal = 1;
    init() {
        //TODO : removeme
        this.#srcvar1 = this.datas['srcvar1'];
        this.#resultvar = this.datas['resultvar'];
        this.#minVal = this.datas['min'] ?? 0;
        this.#maxVal = this.datas['max'] ?? 1;
    }
    execute(variables, proxyParams, time) {
        const v1 = variables.get(this.getData('srcvar1'));
        if ((v1 === null) || (v1 === undefined)) {
            variables.set(this.#resultvar, null);
            return;
        }
        if (typeof v1 == 'number') {
            super.setResult(variables, Math.min(Math.max(v1, this.#minVal), this.#maxVal));
        }
        else { //array
            const clampedArray = [];
            for (const i in v1) {
                clampedArray[i] = Math.min(Math.max(v1[i], this.#minVal), this.#maxVal);
            }
            super.setResult(variables, clampedArray);
            /*if (typeof v2=='number') {
                //variables.set(this.r, vec3.fromValues(v1[0]*v2, v1[1]*v2, v1[2]*v2));
                super.setResult(variables, vec3.fromValues(v1[0]*v2, v1[1]*v2, v1[2]*v2));
            } else {//array
                //variables.set(this.r, vec3.fromValues(v1[0]*v2[0], v1[1]*v2[1], v1[2]*v2[2]));
                super.setResult(variables, vec3.fromValues(v1[0]*v2[0], v1[1]*v2[1], v1[2]*v2[2]));
            }*/
        }
    }
}
ProxyManager.registerProxy('Clamp', Clamp);

class CommunityWeapon extends Proxy {
}
ProxyManager.registerProxy('communityweapon', CommunityWeapon);

/**
 * CustomSteamImageOnModel proxy.
 * @comment ouput variable name: resultVar
 */
class CustomSteamImageOnModel extends Proxy {
    #defaultTexture = '';
    execute(variables, proxyParams, time) {
        if (!this.#defaultTexture) {
            this.#defaultTexture = variables.get('$basetexture');
        }
        if (proxyParams['customtexture']) {
            variables.set('$basetexture', proxyParams['customtexture']);
        }
        else {
            variables.set('$basetexture', this.#defaultTexture);
        }
    }
}
ProxyManager.registerProxy('customsteamimageonmodel', CustomSteamImageOnModel);

/**
 * Divide proxy. Copies the value of a variable to another.
 * @comment input variable name: srcvar1
 * @comment input variable name: srcvar2
 * @comment ouput variable name: resultVar
 */
class Divide extends Proxy {
    execute(variables, proxyParams, time) {
        super.setResult(variables, variables.get(this.getData('srcvar1')));
        const v1 = variables.get(this.getData('srcvar1'));
        const v2 = variables.get(this.getData('srcvar2'));
        if ((v1 === null) || (v2 === null) || (v1 === undefined) || (v2 === undefined)) {
            super.setResult(variables, null);
            return;
        }
        if (typeof v1 == 'number') {
            if (typeof v2 == 'number') {
                //variables.get(this.r, v1*v2);
                super.setResult(variables, v1 / v2);
            }
            else { //array
                //variables.get(this.r, vec3.fromValues(v1*v2[0], v1*v2[1], v1*v2[2]));
                super.setResult(variables, vec3.fromValues(v1 / v2[0], v1 / v2[1], v1 / v2[2]));
            }
        }
        else {
            if (typeof v2 == 'number') {
                //variables.get(this.r, vec3.fromValues(v1[0]*v2, v1[1]*v2, v1[2]*v2));
                super.setResult(variables, vec3.fromValues(v1[0] / v2, v1[1] / v2, v1[2] / v2));
            }
            else { //array
                //variables.get(this.r, vec3.fromValues(v1[0]*v2[0], v1[1]*v2[1], v1[2]*v2[2]));
                super.setResult(variables, vec3.fromValues(v2[0] ? (v1[0] / v2[0]) : 0, v2[1] ? (v1[1] / v2[1]) : 0, v2[2] ? (v1[2] / v2[2]) : 0));
            }
        }
    }
}
ProxyManager.registerProxy('Divide', Divide);

/**
 * Equals proxy. Copies the value of a variable to another.
 * @comment input variable name: srcvar1
 * @comment ouput variable name: resultVar
 */
class Equals extends Proxy {
    execute(variables, proxyParams, time) {
        super.setResult(variables, variables.get(this.getData('srcvar1')));
    }
}
ProxyManager.registerProxy('Equals', Equals);

const scale = 0.6;
const loBeat = 1.0 * scale;
const hiBeat = 0.8 * scale;
class HeartbeatScale extends Proxy {
    #sineperiod = 1;
    #resultVar = '';
    #delta = 0;
    #mid = 0;
    #p = 0;
    init() {
        this.#sineperiod = 1;
        this.#resultVar = this.datas['resultvar'];
        this.#delta = 0.2;
        this.#mid = 1.0;
        this.#p = 2 * Math.PI / this.#sineperiod;
    }
    execute(variables, proxyParams, time) {
        let s1 = Math.sin(time * TWO_PI);
        s1 = clamp$1(s1, 0.0, 1.0);
        s1 *= s1;
        s1 *= s1;
        s1 = clamp$1(s1, 0.5, 1.0);
        s1 -= 0.5;
        s1 *= 2.0;
        let s2 = Math.sin((time + 0.25) * TWO_PI);
        s2 = clamp$1(s2, 0.0, 1.0);
        s2 *= s2;
        s2 *= s2;
        s2 = clamp$1(s2, 0.5, 1.0);
        s2 -= 0.5;
        s2 *= 2.0;
        const beat = Math.max(s1, s2);
        const scaledBeat = loBeat + (hiBeat - loBeat) * beat;
        variables.set(this.#resultVar, scaledBeat);
    }
}
ProxyManager.registerProxy('HeartbeatScale', HeartbeatScale);

class IntProxy extends Proxy {
    init() {
    }
    execute(variables, proxyParams, time) {
        super.setResult(variables, variables.get(this.getData('srcvar1')));
        const v1 = variables.get(this.getData('srcvar1'));
        //const v2 = variables.get(this.getData('srcvar2'));
        if ((v1 === null) || (v1 === undefined)) {
            super.setResult(variables, null);
            return;
        }
        if (typeof v1 == 'number') {
            super.setResult(variables, Math.round(v1));
        }
        else {
            super.setResult(variables, vec3.fromValues(Math.round(v1[0]), Math.round(v1[1]), Math.round(v1[2])));
        }
    }
}
ProxyManager.registerProxy('Int', IntProxy);

/**
 * Invis proxy.
 * @comment ouput variable name: resultVar
 */
class Invis extends Proxy {
}
ProxyManager.registerProxy('Invis', Invis);

/**
 * ItemTintColor Proxy
 */
class ItemTintColor extends Proxy {
    #resultvar = '';
    init() {
        this.#resultvar = this.datas['resultvar'];
    }
    execute(variables, proxyParams, time) {
        variables.set(this.#resultvar, proxyParams.ItemTintColor);
    }
}
ProxyManager.registerProxy('ItemTintColor', ItemTintColor);

class LessOrEqualProxy extends Proxy {
    execute(variables, proxyParams, time) {
        super.setResult(variables, variables.get(this.getData('srcvar1')));
        const srcVar1 = variables.get(this.getData('srcvar1'));
        const srcVar2 = variables.get(this.getData('srcvar2'));
        if (typeof srcVar1 == 'number' && typeof srcVar2 == 'number') {
            if (srcVar1 <= srcVar2) {
                super.setResult(variables, variables.get(this.getData('lessequalvar')));
            }
            else {
                super.setResult(variables, variables.get(this.getData('greatervar')));
            }
        }
        else {
            super.setResult(variables, srcVar1);
        }
    }
}
ProxyManager.registerProxy('LessOrEqual', LessOrEqualProxy);
/*
        "LessOrEqual"
        {
            "srcVar1"		"$glowSineFlashGap"
            "srcVar2"		"$flashMin"
            "resultVar"		"$glowSineFlash"
            "greaterVar"		"$glowSineFlash"
            "LessEqualVar"		"$flashOff"
        }
*/

class LinearRamp extends Proxy {
    #rate = 1;
    init() {
        this.#rate = Number(this.datas['rate'] ?? 1);
    }
    execute(variables, proxyParams, time) {
        const initialValue = Number(this.getVariable(variables, 'initialvalue') ?? 0);
        super.setResult(variables, initialValue + time * this.#rate);
    }
}
ProxyManager.registerProxy('LinearRamp', LinearRamp);

/**
 * ModelGlowColor proxy.
 * @comment ouput variable name: resultVar
 */
class ModelGlowColor extends Proxy {
    #resultVar = '';
    init() {
        this.#resultVar = this.datas['resultvar'];
    }
    execute(variables, proxyParams, time) {
        variables.set(this.#resultVar, proxyParams.ModelGlowColor ?? [1, 1, 1]);
    }
}
ProxyManager.registerProxy('ModelGlowColor', ModelGlowColor);

/**
 * Multiply proxy. Copies the value of a variable to another.
 * @comment input variable name: srcvar1
 * @comment input variable name: srcvar2
 * @comment ouput variable name: resultVar
 */
class Multiply extends Proxy {
    init() {
    }
    execute(variables, proxyParams, time) {
        super.setResult(variables, variables.get(this.getData('srcvar1')));
        const v1 = variables.get(this.getData('srcvar1'));
        const v2 = variables.get(this.getData('srcvar2'));
        if ((v1 === null) || (v2 === null) || (v1 === undefined) || (v2 === undefined)) {
            super.setResult(variables, null);
            return;
        }
        if (typeof v1 == 'number') {
            if (typeof v2 == 'number') {
                super.setResult(variables, v1 * v2);
            }
            else { //array
                super.setResult(variables, vec3.fromValues(v1 * v2[0], v1 * v2[1], v1 * v2[2]));
            }
        }
        else {
            if (typeof v2 == 'number') {
                super.setResult(variables, vec3.fromValues(v1[0] * v2, v1[1] * v2, v1[2] * v2));
            }
            else { //array
                super.setResult(variables, vec3.fromValues(v1[0] * v2[0], v1[1] * v2[1], v1[2] * v2[2]));
            }
        }
    }
}
ProxyManager.registerProxy('Multiply', Multiply);

/**
 * SelectFirstIfNonZero Proxy
 */
class SelectFirstIfNonZero extends Proxy {
    #srcVar1 = '';
    #srcVar2 = '';
    init() {
        this.#srcVar1 = (this.datas['srcvar1'] ?? '').toLowerCase();
        this.#srcVar2 = (this.datas['srcvar2'] ?? '').toLowerCase();
    }
    execute(variables, proxyParams, time) {
        super.setResult(variables, this.isNonZero(variables.get(this.#srcVar1)) ? variables.get(this.#srcVar1) : variables.get(this.#srcVar2));
    }
    isNonZero(value /*TODO: improve type*/) {
        if (!value)
            return false;
        if (value instanceof Array || value instanceof Float32Array) {
            for (let i = 0; i < value.length; ++i) {
                if (value[i]) {
                    return true;
                }
            }
        }
        return false;
    }
}
ProxyManager.registerProxy('SelectFirstIfNonZero', SelectFirstIfNonZero);

class Sine extends Proxy {
    //#delta;
    //#mid;
    #period = 1;
    #sineperiod = 1;
    #timeoffset = 1;
    init() {
        this.#sineperiod = Number(this.datas['sineperiod'] ?? 1);
        //this.sinemin = this.datas['sinemin']*1; //TODO: check number
        //this.sinemax = this.datas['sinemax']*1;
        this.#timeoffset = Number(this.datas['timeoffset'] ?? 0);
        //this.#delta = (this.sinemax - this.sinemin)/2;
        //this.#mid = this.sinemin + this.#delta;
        this.#period = 2 * Math.PI / this.#sineperiod;
        //this.#delta = 1.0;
    }
    execute(variables, proxyParams, time) {
        //TODO: use timeoffset
        const sineMin = this.getVariable(variables, 'sinemin') * 1;
        const sineMax = this.getVariable(variables, 'sinemax') * 1;
        const delta = (sineMax - sineMin) * 0.5;
        const mid = sineMin + delta;
        const value = mid + delta * Math.sin(time * this.#period);
        super.setResult(variables, value);
    }
}
ProxyManager.registerProxy('Sine', Sine);
/*Sine
Sine
 A sine wave.

sineperiod
Period between wave peaks, in seconds.
sinemin
sinemax
Values at the top and bottom of the wave
timeoffset
Used to offset the starting position of the wave
resultVar

resultVar $selfillumtint // The shader parameter to be manipulated
*/

/**
 * SpyInvis proxy.
 * @comment ouput variable name: resultVar
 */
class SpyInvis extends Proxy {
}
ProxyManager.registerProxy('Spy_Invis', SpyInvis);

/**
 * StatTrakDigit Proxy
 */
class StatTrakDigit extends Proxy {
    #displayDigit = 0;
    #resultVar = '';
    #trimZeros = false;
    init() {
        this.#trimZeros = this.datas['trimzeros'];
        this.#resultVar = this.datas['resultvar'];
        this.#displayDigit = this.datas['displaydigit'] ?? 0;
    }
    execute(variables, proxyParams, time) {
        const number = proxyParams.StatTrakNumber || 0;
        const numberasstring = String(number);
        let digit = Math.floor(number / (Math.pow(10, this.#displayDigit)) % 10);
        // Trim zeroes
        if (this.#trimZeros && digit == 0 && (this.#displayDigit >= numberasstring.length)) {
            digit = 10; // Blank frame
        }
        variables.set(this.#resultVar, digit);
    }
}
ProxyManager.registerProxy('StatTrakDigit', StatTrakDigit);

class StatTrakIllum extends Proxy {
    #resultVar = '';
    #minVal = 0;
    #maxVal = 0;
    init() {
        this.#resultVar = this.datas['resultvar'];
        this.#minVal = Number(this.datas['minval'] ?? 0);
        this.#maxVal = Number(this.datas['maxval'] ?? 1);
    }
    execute(variables, proxyParams, time) {
        const glowMultiplier = proxyParams.GlowMultiplier ?? 0.5;
        const value = lerp(this.#minVal, this.#maxVal, glowMultiplier);
        variables.set(this.#resultVar, vec3.fromValues(value, value, value));
    }
}
ProxyManager.registerProxy('StatTrakIllum', StatTrakIllum);

class StickybombGlowColor extends Proxy {
    #resultVar = '';
    init() {
        this.#resultVar = this.datas['resultvar'];
    }
    execute(variables, proxyParams, time) {
        variables.set(this.#resultVar, [1, 1, 1]);
    }
}
ProxyManager.registerProxy('StickybombGlowColor', StickybombGlowColor);

function toNumber(string) {
    const num = Number(string);
    if (!Number.isNaN(num)) {
        return num;
    }
}
class TextureScroll extends Proxy {
    #textureScrollVar = '';
    #textureScrollRate = 1;
    #textureScrollAngle = 0;
    #textureScale = 1;
    init(variables) {
        this.#textureScrollVar = (this.datas['texturescrollvar'] ?? '').toLowerCase();
        this.#textureScrollRate = toNumber(this.datas['texturescrollrate']) ?? 1;
        this.#textureScrollAngle = toNumber(String(DEG_TO_RAD * (this.datas['texturescrollangle']))) ?? 0;
        this.#textureScale = toNumber(this.datas['texturescale']) ?? 1;
        variables.set(this.#textureScrollVar, mat4.create()); //TODO: fixme
    }
    execute(variables, proxyParams, time) {
        const rate = this.#textureScrollRate;
        const angle = this.#textureScrollAngle;
        const scale = this.#textureScale;
        const sOffset = time * Math.cos(angle) * rate;
        const tOffset = time * Math.sin(angle) * rate;
        // make sure that we are positive
        /*if(sOffset < 0.0) {
            sOffset += 1.0 + -(int)sOffset;
        }
        if(tOffset < 0.0) {
            tOffset += 1.0 + -(int)tOffset;
        }*/
        // make sure that we are in a [0,1] range
        //sOffset = sOffset - (int)sOffset;
        //tOffset = tOffset - (int)tOffset;
        const v = variables.get(this.#textureScrollVar);
        if (v) {
            v[0] = scale;
            v[1] = 0;
            v[2] = 0;
            v[3] = 0;
            v[4] = 0;
            v[5] = scale;
            v[6] = 0;
            v[7] = 0;
            v[8] = 0;
            v[9] = 0;
            v[10] = 1;
            v[11] = 0;
            v[12] = sOffset;
            v[13] = tOffset;
            v[14] = 0;
            v[15] = 1;
        }
        /*
            if (m_pTextureScrollVar->GetType() == MATERIAL_VAR_TYPE_MATRIX)
            {
                VMatrix mat(scale, 0.0f, 0.0f, sOffset,
                    0.0f, scale, 0.0f, tOffset,
                    0.0f, 0.0f, 1.0f, 0.0f,
                    0.0f, 0.0f, 0.0f, 1.0f);
                m_pTextureScrollVar->SetMatrixValue(mat);
            }
            else
            {
                m_pTextureScrollVar->SetVecValue(sOffset, tOffset, 0.0f);
            }*/
    }
}
ProxyManager.registerProxy('TextureScroll', TextureScroll);
/*TextureScroll
 Returns a transform matrix or vector that will translate a texture at a given angle at a given rate.

textureScrollVar
Destination for the resulting transformation.
textureScrollRate
Rate of scroll in units per second.
textureScrollAngle
Angle of rotation to move along. (90 = up, 180 = left, etc)

        'TextureScroll'
        {
            'texturescrollvar'	'$BUMPTRANSFORM'
            'texturescrollrate'	.45
            'texturescrollangle'	85
        }
*/

class UniformNoiseProxy extends Proxy {
    execute(variables, proxyParams, time) {
        super.setResult(variables, variables.get(this.getData('srcvar1')));
        const minVal = (this.getData('minval') ?? 0) * 1;
        const maxVal = (this.getData('maxval') ?? 1) * 1;
        super.setResult(variables, Math.random() * (maxVal - minVal) + minVal);
    }
}
ProxyManager.registerProxy('UniformNoise', UniformNoiseProxy);
/*
        "UniformNoise"
        {
            "minVal"		"-0.001000"
            "maxVal"		"0.001000"
            "resultVar"		"$noise_alpha"
        }
*/

class WaterLod extends Proxy {
}
ProxyManager.registerProxy('WaterLod', WaterLod);

class WeaponInvis extends Proxy {
}
ProxyManager.registerProxy('weapon_invis', WeaponInvis);

const RESULT_VAR = '$basetexturetransform';
// TODO: deprecate ?  afaik was only used for csgo
class WeaponLabelText extends Proxy {
    #displayDigit = 0;
    init() {
        this.#displayDigit = this.datas['displaydigit'] ?? 0;
    }
    execute(variables, proxyParams, time) {
        const text = proxyParams.WeaponLabelText || '';
        const car = text.charCodeAt(this.#displayDigit);
        const mat = mat4.create(); //TODOv3 optimize
        // 96 ASCII characters starting from 0x20 (space)
        let x, y;
        if ((car >= 32) && (car < 128)) {
            const i = car - 32;
            x = i % 12;
            y = Math.floor(i / 12);
        }
        else {
            x = 0;
            y = 0;
        }
        // Texture is 12*8 characters
        //const btt = variables.get('$basetexturetransform') || vec2.create();
        //btt[0]=x/12;
        // /btt[1]=y/8;
        //variables.set('$basetexturetransform', btt);
        MatrixBuildTranslation(mat, x / 12, y / 8, 0.0);
        const v = variables.get(RESULT_VAR);
        if (v) {
            mat4.copy(v, mat);
        }
        else {
            variables.set(RESULT_VAR, mat4.clone(mat));
        }
    }
}
ProxyManager.registerProxy('WeaponLabelText', WeaponLabelText);
ProxyManager.registerProxy('WeaponLabelTextPreview', WeaponLabelText);

class WeaponSkin extends Proxy {
    #defaultTexture = null;
    execute(variables, proxyParams, time) {
        if (!this.#defaultTexture) {
            this.#defaultTexture = variables.get('$basetexture');
        }
        if (proxyParams['WeaponSkin']) {
            variables.set('$basetexture', proxyParams['WeaponSkin']);
        }
        else {
            variables.set('$basetexture', this.#defaultTexture);
        }
    }
}
ProxyManager.registerProxy('WeaponSkin', WeaponSkin);

/**
 * YellowLevel proxy.
 * @comment ouput variable name: resultVar
 */
const URINE_RED = vec3.fromValues(6, 9, 2);
const URINE_BLU = vec3.fromValues(7, 5, 1);
class YellowLevel extends Proxy {
    #resultVar = '';
    init() {
        this.#resultVar = this.datas['resultvar'];
    }
    execute(variables, proxyParams, time) {
        if (!proxyParams.jarate) {
            variables.set(this.#resultVar, vec3.fromValues(1, 1, 1));
        }
        else {
            if (proxyParams.team == 0) {
                variables.set(this.#resultVar, vec3.scale(vec3.create(), URINE_RED, proxyParams.jarate));
            }
            else {
                variables.set(this.#resultVar, vec3.scale(vec3.create(), URINE_BLU, proxyParams.jarate));
            }
        }
    }
}
ProxyManager.registerProxy('YellowLevel', YellowLevel);

class RefractMaterial extends Source1Material {
    clone() {
        return new RefractMaterial(this.repository, this.path, this.vmt, this.parameters);
    }
    getShaderSource() {
        return 'source1_refract';
    }
}
Source1VmtLoader.registerMaterial('refract', RefractMaterial);

class SpriteCardMaterial extends Source1Material {
    #initialized = false;
    constructor(repository, path, vmt, params = {}) {
        super(repository, path, vmt, params);
        if (vmt['$color']) {
            this.useSrgb = false;
        }
        // Disable back face culling
        this.renderFace(RenderFace.Both);
        this.colorMask[3] = 0.0;
        this.setDefine('IS_TRANSLUCENT');
        this.setDefine('IS_SPRITE_CARD_MATERIAL');
        this.setDefine('USE_PARTICLE_YAW', '0'); //This material never yaw
    }
    init() {
        if (this.#initialized) {
            return;
        }
        const vmt = this.vmt;
        this.#initialized = true;
        super.init();
        if ( /*bAdditive2ndTexture || bAddOverBlend || */vmt['$addself'] !== undefined) {
            this.setTransparency(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
        }
        else {
            if (vmt['$additive'] == 1) {
                this.setTransparency(GL_SRC_ALPHA, GL_ONE);
            }
            else {
                this.setTransparency(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
            }
        }
        // this material always has blending
        //this.setTransparency(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        if (vmt['$additive'] == 1) ;
        /*if (parameters['$addself']) {
            this.setDefine('ALPHA_TEST', false);
        } else {
            this.setDefine('ALPHA_TEST');
            this.uniforms['uAlphaTestReference'] = Number.parseFloat(parameters['$alphatestreference'] || 0.5);
        }*/
        if (vmt['$addself'] !== undefined) {
            this.uniforms['uAddSelf'] = Number.parseFloat(vmt['$addself']);
            this.setDefine('ADD_SELF');
            //this.setTransparency(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
        }
        //this.setTransparency(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
        const overbrightFactor = this.variables.get('$overbrightfactor') ?? this.variables.get('srgb?$overbrightfactor'); //TODO: improve this
        this.uniforms['uOverbrightFactor'] = overbrightFactor ?? 1.0;
        //this.modeRGB = GL_MAX;
        this.modeAlpha = GL_MAX;
    }
    clone() {
        return new SpriteCardMaterial(this.repository, this.path, this.vmt, this.parameters);
    }
    get shaderSource() {
        return 'source1_spritecard';
    }
}
Source1VmtLoader.registerMaterial('spritecard', SpriteCardMaterial);

var RenderMode;
(function (RenderMode) {
    RenderMode[RenderMode["Normal"] = 0] = "Normal";
    RenderMode[RenderMode["TransColor"] = 1] = "TransColor";
    RenderMode[RenderMode["TransTexture"] = 2] = "TransTexture";
    RenderMode[RenderMode["Glow"] = 3] = "Glow";
    RenderMode[RenderMode["TransAlpha"] = 4] = "TransAlpha";
    RenderMode[RenderMode["TransAdd"] = 5] = "TransAdd";
    RenderMode[RenderMode["Environmental"] = 6] = "Environmental";
    RenderMode[RenderMode["TransAddFrameBlend"] = 7] = "TransAddFrameBlend";
    RenderMode[RenderMode["TransAlphaAdd"] = 8] = "TransAlphaAdd";
    RenderMode[RenderMode["WorldGlow"] = 9] = "WorldGlow";
    RenderMode[RenderMode["None"] = 10] = "None";
})(RenderMode || (RenderMode = {}));
class SpriteMaterial extends Source1Material {
    #initialized = false;
    constructor(repository, path, vmt, params = {}) {
        super(repository, path, vmt, params);
        // Disable back face culling
        this.renderFace(RenderFace.Both);
        this.colorMask[3] = 0.0;
        this.setDefine('IS_TRANSLUCENT');
    }
    init() {
        if (this.#initialized) {
            return;
        }
        const vmt = this.vmt;
        this.#initialized = true;
        super.init();
        if ( /*bAdditive2ndTexture || bAddOverBlend || */vmt['$addself'] !== undefined) {
            this.setTransparency(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
        }
        else {
            if (vmt['$additive'] == 1) {
                this.setTransparency(GL_SRC_ALPHA, GL_ONE);
            }
            else {
                this.setTransparency(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
            }
        }
        switch (Number(vmt['$spriterendermode'])) {
            //TODO: add other modes
            case RenderMode.TransAdd:
                this.setTransparency(GL_SRC_ALPHA, GL_ONE);
                break;
        }
        // this material always has blending
        //this.setTransparency(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        if (vmt['$additive'] == 1) ;
        /*if (parameters['$addself']) {
            this.setDefine('ALPHA_TEST', false);
        } else {
            this.setDefine('ALPHA_TEST');
            this.uniforms['uAlphaTestReference'] = Number.parseFloat(parameters['$alphatestreference'] || 0.5);
        }*/
        if (vmt['$addself'] !== undefined) {
            this.uniforms['uAddSelf'] = Number.parseFloat(vmt['$addself']);
            this.setDefine('ADD_SELF');
            //this.setTransparency(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
        }
        //this.setTransparency(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
        const overbrightFactor = this.variables.get('$overbrightfactor') ?? this.variables.get('srgb?$overbrightfactor'); //TODO: improve this
        this.uniforms['uOverbrightFactor'] = overbrightFactor ?? 1.0;
        //this.modeRGB = GL_MAX;
        this.modeAlpha = GL_MAX;
    }
    clone() {
        return new SpriteMaterial(this.repository, this.path, this.vmt, this.parameters);
    }
    get shaderSource() {
        return 'source1_sprite';
    }
}
Source1VmtLoader.registerMaterial('sprite', SpriteMaterial);

class UnlitGenericMaterial extends Source1Material {
    #diffuseModulation = vec4.fromValues(1.0, 1.0, 1.0, 1.0);
    #initialized = false;
    constructor(repository, path, vmt, params = {}) {
        super(repository, path, vmt, params);
        this.uniforms['g_ShaderControls'] = vec4.fromValues(1, 0, 1, 0); //TODOv3
        this.uniforms['g_DiffuseModulation'] = this.#diffuseModulation;
    }
    init() {
        if (this.#initialized) {
            return;
        }
        const vmt = this.vmt;
        this.#initialized = true;
        super.init();
        if (vmt['$additive'] == 1) {
            //this.setBlending('additive');
            this.setBlending(MATERIAL_BLENDING_ADDITIVE);
        }
    }
    clone() {
        return new UnlitGenericMaterial(this.repository, this.path, this.vmt, this.parameters);
    }
    get shaderSource() {
        //Note: this is vertexlitgeneric without lighting
        return 'source1_unlitgeneric';
    }
}
Source1VmtLoader.registerMaterial('unlitgeneric', UnlitGenericMaterial);

const IDENTITY_MATRIX = mat4.create();
class UnlitTwoTextureMaterial extends Source1Material {
    #initialized = false;
    init() {
        if (this.#initialized) {
            return;
        }
        const vmt = this.vmt;
        this.#initialized = true;
        super.init();
        if (vmt['$texture2']) {
            this.setColor2Map(this.getTexture(TextureRole.Color2, this.repository, vmt['$texture2'], vmt['$frame2'] ?? 0));
        }
        else {
            this.setColor2Map(TextureManager.createCheckerTexture());
        }
        this.setTransparency(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
        if (vmt['$additive'] == 1) {
            this.setTransparency(GL_SRC_ALPHA, GL_ONE);
            //this.setBlending('additive');
        }
        this.modeAlpha = GL_MAX;
        this.uniforms['uTextureTransform'] = IDENTITY_MATRIX;
        this.uniforms['uTexture2Transform'] = IDENTITY_MATRIX;
        this.setDefine('USE_TEXTURE_TRANSFORM');
        this.setDefine('USE_TEXTURE2_TRANSFORM');
    }
    clone() {
        return new UnlitTwoTextureMaterial(this.repository, this.path, this.vmt, this.parameters);
    }
    get shaderSource() {
        return 'source1_unlittwotexture';
    }
    afterProcessProxies() {
        const variables = this.variables;
        const parameters = this.vmt;
        const texture2Transform = variables.get('$texture2transform');
        if (texture2Transform) {
            this.uniforms['uTexture2Transform'] = texture2Transform;
        }
        {
            if (parameters['$texture2']) {
                this.setColor2Map(this.getTexture(TextureRole.Color2, this.repository, parameters['$texture2'], parameters['$frame2'] ?? variables.get('$frame2') ?? 0));
            }
        }
    }
}
Source1VmtLoader.registerMaterial('unlittwotexture', UnlitTwoTextureMaterial);

class VertexLitGenericMaterial extends Source1Material {
    #diffuseModulation = vec4.fromValues(1.0, 1.0, 1.0, 1.0);
    #initialized = false;
    useSrgb = false;
    init() {
        if (this.#initialized) {
            return;
        }
        this.#initialized = true;
        super.init();
        //this.uniforms['phongfresnelranges'] = Source1Material.readColor(parameters['$phongfresnelranges']);
        /*float fPixelFogType = pShaderAPI->GetPixelFogCombo() == 1 ? 1 : 0;
        float fWriteDepthToAlpha = bWriteDepthToAlpha && IsPC() ? 1 : 0;
        float fWriteWaterFogToDestAlpha = (pShaderAPI->GetPixelFogCombo() == 1 && bWriteWaterFogToAlpha) ? 1 : 0;
        float fVertexAlpha = bHasVertexAlpha ? 1 : 0;*/
        this.uniforms['g_ShaderControls'] = vec4.fromValues(1, 0, 1, 0); //TODOv3
        this.uniforms['g_DiffuseModulation'] = this.#diffuseModulation;
        const btbba = this.variables.get('$blendtintbybasealpha');
        if (btbba == 1) {
            this.alphaTest = false;
            this.variables.set('$alphatest', 0);
            if (this.variables.get('$selfillum') != 1) {
                this.removeDefine('USE_SELF_ILLUM');
                this.setDefine('BLEND_TINT_BY_BASE_ALPHA');
                this.uniforms['uBlendTintColorOverBase'] = this.variables.get('$blendtintcoloroverbase') ?? 0;
                // TODO : properly set these variables
                this.variables.set('$translucent', 0);
                this.removeDefine('ALPHA_TEST');
                this.setBlending(MATERIAL_BLENDING_NONE);
                this.removeDefine('IS_TRANSLUCENT');
                if (this.variables.get('$additive') == 1) {
                    this.setBlending(MATERIAL_BLENDING_ADDITIVE, true);
                }
            }
            //TODO end
        }
        else {
            this.removeDefine('BLEND_TINT_BY_BASE_ALPHA');
        }
        this.uniforms['g_cCloakColorTint'] = vec3.create();
        this.variables.set('$SheenMaskScaleX', 1.0);
        this.variables.set('$SheenMaskScaleY', 1.0);
        this.variables.set('$SheenMaskOffsetX', 0.0);
        this.variables.set('$SheenMaskOffsetY', 0.0);
        this.variables.set('$SheenMaskDirection', 0.0);
    }
    afterProcessProxies(proxyParams) {
        const variables = this.variables;
        const parameters = this.vmt;
        const sheenMapMaskFrame = variables.get('$sheenmapmaskframe'); //variables.get('$sheenmapmaskframe')
        if (parameters['$sheenmapmask']) {
            this.setTexture('sheenMaskMap', this.getTexture(TextureRole.SheenMask, this.repository, parameters['$sheenmapmask'], sheenMapMaskFrame), 'USE_SHEEN_MASK_MAP');
            this.uniforms['g_vPackedConst6'] = vec4.fromValues(variables.get('$SheenMaskScaleX'), variables.get('$SheenMaskScaleY'), variables.get('$SheenMaskOffsetX'), variables.get('$SheenMaskOffsetY'));
            this.uniforms['g_vPackedConst7'] = vec4.fromValues(variables.get('$SheenMaskDirection'), 0, 0, 0);
        }
        if (parameters['$sheenmap']) {
            this.setTexture('sheenMap', this.getTexture(TextureRole.Sheen, this.repository, parameters['$sheenmap'], 0, true), 'USE_SHEEN_MAP');
        }
        if (proxyParams['SheenTintColor']) {
            this.uniforms['g_cCloakColorTint'] = proxyParams['SheenTintColor'];
        }
        else {
            const sheenmaptint = variables.get('$sheenmaptint');
            if (sheenmaptint) {
                this.uniforms['g_cCloakColorTint'] = sheenmaptint;
            }
        }
        //uniform vec4 g_vPackedConst6;
        //uniform vec4 g_vPackedConst7;
        //TODOv3: only do this if a variable is changed
        this.uniforms['g_DiffuseModulation'] = this.computeModulationColor(this.#diffuseModulation);
    }
    clone() {
        return new VertexLitGenericMaterial(this.repository, this.path, this.vmt, this.parameters);
    }
    get shaderSource() {
        return 'source1_vertexlitgeneric';
    }
}
Source1VmtLoader.registerMaterial('vertexlitgeneric', VertexLitGenericMaterial);
//MaterialManager.registerMaterial('VertexLitGeneric', VertexLitGenericMaterial, Source1MaterialManager);

class WaterMaterial extends Source1Material {
    #initialized = false;
    init() {
        if (this.#initialized) {
            return;
        }
        this.#initialized = true;
        super.init();
        // Disable back face culling
        this.renderFace(RenderFace.Both);
        this.setTransparency(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        this.setDefine('IS_TRANSLUCENT');
    }
    clone() {
        return new WaterMaterial(this.repository, this.path, this.vmt, this.parameters);
    }
    getShaderSource() {
        return 'source1_water';
    }
}
Source1VmtLoader.registerMaterial('water', WaterMaterial);

//TODO: deprecate
class WeaponDecalMaterial extends Source1Material {
    #initialized = false;
    init() {
        if (this.#initialized) {
            return;
        }
        this.#initialized = true;
        super.init();
        const variables = this.variables;
        this.setDefine('MIRROR', variables.get('$mirrorhorizontal') ?? 0);
        this.setDefine('DESATBASETINT', variables.get('$desatbasetint') ? '1' : '0');
        this.uniforms['uTintLerpBase'] = variables.get('$desatbasetint');
        this.polygonOffset = true;
        this.polygonOffsetFactor = -5;
        this.polygonOffsetUnits = -5;
        this.setPatternTexCoordTransform(vec2.fromValues(1, 1), vec2.create(), 0);
    }
    afterProcessProxies(proxyParams) {
        const variables = this.variables;
        const parameters = this.vmt;
        this.setDefine('DECALSTYLE', variables.get('$decalstyle') ?? 0); //TODO: set this on variable change
        const baseTexture = variables.get('$basetexture');
        if (baseTexture) {
            this.uniforms['colorMap'] = this.getTexture(TextureRole.Color, this.repository, baseTexture, 0);
            this.setDefine('USE_COLOR_MAP'); //TODOv3: set this automaticaly
        }
        const sheenMapMaskFrame = variables.get('$sheenmapmaskframe'); //variables.get('$sheenmapmaskframe')
        if (parameters['$sheenmapmask']) {
            this.uniforms['sheenMaskMap'] = this.getTexture(TextureRole.SheenMask, this.repository, parameters['$sheenmapmask'], sheenMapMaskFrame);
            this.setDefine('USE_SHEEN_MASK_MAP'); //TODOv3: set this automaticaly
            this.uniforms['g_vPackedConst6'] = vec4.fromValues(variables.get('$SheenMaskScaleX'), variables.get('$SheenMaskScaleY'), variables.get('$SheenMaskOffsetX'), variables.get('$SheenMaskOffsetY'));
            this.uniforms['g_vPackedConst7'] = vec4.fromValues(variables.get('$SheenMaskDirection'), 0, 0, 0);
        }
        if (parameters['$sheenmap']) {
            this.uniforms['sheenMap'] = this.getTexture(TextureRole.Sheen, this.repository, parameters['$sheenmap'], 0, true);
            this.setDefine('USE_SHEEN_MAP'); //TODOv3: set this automaticaly
        }
        if (parameters['$maskstexture']) {
            this.uniforms['mask1Map'] = this.getTexture(TextureRole.Mask, this.repository, parameters['$maskstexture'], 0);
            this.setDefine('USE_MASK1_MAP'); //TODOv3: set this automaticaly
        }
        if (parameters['$pattern']) {
            this.uniforms['patternMap'] = this.getTexture(TextureRole.Pattern, this.repository, parameters['$pattern'], 0);
            this.setDefine('USE_PATTERN_MAP'); //TODOv3: set this automaticaly
        }
        const aoTexture = variables.get('$aotexture');
        if (aoTexture) {
            this.uniforms['aoMap'] = this.getTexture(TextureRole.Ao, this.repository, aoTexture, 0);
            this.setDefine('USE_AO_MAP'); //TODOv3: set this automaticaly
        }
        const wearTexture = variables.get('$weartexture');
        if (wearTexture) {
            this.uniforms['scratchesMap'] = this.getTexture(TextureRole.Scratches, this.repository, wearTexture, 0);
            this.setDefine('USE_SCRATCHES_MAP'); //TODOv3: set this automaticaly
        }
        const grungeTexture = variables.get('$grungetexture');
        if (grungeTexture) {
            this.uniforms['grungeMap'] = this.getTexture(TextureRole.Grunge, this.repository, grungeTexture, 0);
            this.setDefine('USE_GRUNGE_MAP'); //TODOv3: set this automaticaly
        }
        const expTexture = parameters['$exptexture'];
        if (expTexture) {
            this.uniforms['exponentMap'] = this.getTexture(TextureRole.Exponent, this.repository, expTexture, 0);
            this.setDefine('USE_EXPONENT_MAP'); //TODOv3: set this automaticaly
        }
        const holoMaskTexture = variables.get('$holomask');
        if (holoMaskTexture) {
            this.uniforms['holoMaskMap'] = this.getTexture(TextureRole.Holo, this.repository, holoMaskTexture, 0);
            this.setDefine('USE_HOLO_MASK_MAP'); //TODOv3: set this automaticaly
        }
        const holoSpectrumTexture = variables.get('$holospectrum');
        if (holoSpectrumTexture) {
            this.uniforms['holoSpectrumMap'] = this.getTexture(TextureRole.HoloSpectrum, this.repository, holoSpectrumTexture, 0);
            this.setDefine('USE_HOLO_SPECTRUM_MAP'); //TODOv3: set this automaticaly
        }
        /*

                    if( bAOTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER0, true );		// [sRGB] Ambient Occlusion
                    }
                    if( bWearTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER1, true );		// Scratches
                    }
                    if( bExpTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER2, true );		// Exponent
                    }
                    if ( bBaseTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER3, true );		// [sRGB] Base
                    }
                    if( bMasksTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER4, true );		// Masks
                    }
                    if( bGrungeTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER5, true );		// [sRGB] Grunge
                    }
                    if( bSurfaceTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER6, true );		// Obj-space normal and cavity
                    }
                    if( bPosTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER7, true );		// High-precision Position
                    }
                    if( bPaintTexture )
                    {
                        pShaderShadow->EnableTexture( SHADER_SAMPLER8, true );		// Paint
                    }	*/
        this.uniforms['uColorTint'] = variables.get('$colortint');
        this.uniforms['uColorTin2'] = variables.get('$colortint2');
        this.uniforms['uColorTint3'] = variables.get('$colortin3');
        this.uniforms['uColorTint4'] = variables.get('$colortint4');
        // Todo: optimize
        this.uniforms['uPhongParams'] = vec4.fromValues(4.0, 1.0, 1.0, 2.0); //TODO: set actual values
        this.uniforms['uPhongFresnel'] = vec4.fromValues(1.0, 1.0, 1.0, 0.0); //TODO: set actual values
        const wearProgress = proxyParams['WearProgress'] ?? 0.0; //TODO
        variables.get('$wearremapmid');
        const flX = wearProgress;
        const flP = variables.get('$wearremapmid');
        let flRemappedWear = 2.0 * (1.0 - flX) * flX * flP + (flX * flX);
        //remap wear to custom min/max bounds
        flRemappedWear *= (variables.get('$wearremapmax') - variables.get('$wearremapmin'));
        flRemappedWear += variables.get('$wearremapmin');
        //we already shipped wear progress levels, this is an additional param that individual stickers
        //can drive to bias their wear AGAIN as they move away from 0
        flRemappedWear += flX * flX * variables.get('$wearbias');
        //lerp wear width along wear progress
        //float flLerpedWearWidth = Lerp( variables[info.m_nWearProgress]->GetFloatValue(), variables[info.m_nWearWidthMin]->GetFloatValue(), variables[info.m_nWearWidthMax]->GetFloatValue() );
        const flLerpedWearWidth = lerp(variables.get('$wearwidthmin'), variables.get('$wearwidthmax'), wearProgress);
        this.uniforms['uWearParams'] = vec4.fromValues(wearProgress, flLerpedWearWidth, flRemappedWear, variables.get('$unwearstrength'));
    }
    set style(style) {
        this.setDefine('PAINT_STYLE', style);
    }
    setColorUniform(uniformName, value) {
        const color = readColor(value);
        if (color) {
            //vec3.scale(color, color, 1 / 255.0);
            this.uniforms[uniformName] = color;
        }
    }
    set color0(color) {
        this.setColorUniform('uCamoColor0', color);
    }
    set color1(color) {
        this.setColorUniform('uCamoColor1', color);
    }
    set color2(color) {
        this.setColorUniform('uCamoColor2', color);
    }
    set color3(color) {
        this.setColorUniform('uCamoColor3', color);
    }
    setPatternTexCoordTransform(scale, translation, rotation) {
        const transformMatrix = this.#getTexCoordTransform(scale, translation, rotation);
        this.uniforms['g_patternTexCoordTransform[0]'] = new Float32Array([
            transformMatrix[0], transformMatrix[4], transformMatrix[8], transformMatrix[12],
            transformMatrix[1], transformMatrix[5], transformMatrix[9], transformMatrix[13]
        ]);
    }
    #getTexCoordTransform(scale, translation, rotation) {
        const transformMatrix = mat4.create();
        const tempMatrix = mat4.create();
        const tempVec3 = vec3.create();
        tempVec3[0] = translation[0] - 0.5;
        tempVec3[1] = translation[1] - 0.5;
        tempVec3[2] = 0.0;
        mat4.fromTranslation(transformMatrix, tempVec3);
        tempVec3[0] = scale[0];
        tempVec3[1] = scale[1];
        tempVec3[2] = 1.0;
        mat4.fromScaling(tempMatrix, tempVec3);
        mat4.multiply(transformMatrix, transformMatrix, tempMatrix);
        mat4.fromZRotation(tempMatrix, rotation);
        mat4.multiply(transformMatrix, transformMatrix, tempMatrix);
        const offset = vec2.fromValues(0.5 / scale[0], 0.5 / scale[1]);
        vec2.rotate(offset, offset, vec2.create(), -rotation);
        tempVec3[0] = offset[0];
        tempVec3[1] = offset[1];
        tempVec3[2] = 0.0;
        mat4.fromTranslation(tempMatrix, tempVec3);
        mat4.multiply(transformMatrix, transformMatrix, tempMatrix);
        return transformMatrix;
    }
    getDefaultParameters() {
        return WEAPON_DECAL_DEFAULT_PARAMETERS;
    }
    clone() {
        return new WeaponDecalMaterial(this.repository, this.path, this.vmt, this.parameters);
    }
    get shaderSource() {
        return 'source1_weapondecal';
    }
}
Source1VmtLoader.registerMaterial('weapondecal', WeaponDecalMaterial);
const WEAPON_DECAL_DEFAULT_PARAMETERS = {
    //$basetexture : [SHADER_PARAM_TYPE_STRING, 'models/weapons/customization/stickers/default/sticker_default'],
    //$aotexture : [SHADER_PARAM_TYPE_STRING, 'models/weapons/customization/stickers/default/ao_default'],
    $grungetexture: [SHADER_PARAM_TYPE_STRING, 'models/weapons/customization/shared/sticker_paper'],
    $weartexture: [SHADER_PARAM_TYPE_STRING, 'models/weapons/customization/shared/paint_wear'],
    $decalstyle: [SHADER_PARAM_TYPE_INTEGER, 0],
    $colortint: [SHADER_PARAM_TYPE_COLOR, [255, 255, 255]],
    $colortint2: [SHADER_PARAM_TYPE_COLOR, [0, 0, 0]],
    $colortint3: [SHADER_PARAM_TYPE_COLOR, [0, 0, 0]],
    $colortint4: [SHADER_PARAM_TYPE_COLOR, [0, 0, 0]],
    $unwearstrength: [SHADER_PARAM_TYPE_FLOAT, 0.2],
    $wearremapmin: [SHADER_PARAM_TYPE_FLOAT, 0.8],
    $wearremapmid: [SHADER_PARAM_TYPE_FLOAT, 0.75],
    $wearremapmax: [SHADER_PARAM_TYPE_FLOAT, 1.],
    $wearwidthmin: [SHADER_PARAM_TYPE_FLOAT, 0.06],
    $wearwidthmax: [SHADER_PARAM_TYPE_FLOAT, 0.12],
    $wearbias: [SHADER_PARAM_TYPE_FLOAT, 0.0],
    $desatbasetint: [SHADER_PARAM_TYPE_FLOAT, 0.0],
};

class WorldVertexTransitionMaterial extends Source1Material {
    #initialized = false;
    init() {
        if (this.#initialized) {
            return;
        }
        this.#initialized = true;
        super.init();
    }
    afterProcessProxies(proxyParams) {
        this.variables;
        this.vmt;
        const baseTexture2 = this.variables.get('$basetexture2');
        this.setColor2Map(baseTexture2 ? this.getTexture(TextureRole.Color2, this.repository, baseTexture2, 0, true) : null);
        const blendModulateTexture = this.variables.get('$blendmodulatetexture');
        if (blendModulateTexture) {
            this.setTexture('blendModulateMap', this.getTexture(TextureRole.BlendModulate, this.repository, blendModulateTexture, 0, true), 'USE_BLEND_MODULATE_MAP');
        }
    }
    clone() {
        return new WorldVertexTransitionMaterial(this.repository, this.path, this.vmt, this.parameters);
    }
    getShaderSource() {
        return 'source1_worldvertextransition';
    }
}
Source1VmtLoader.registerMaterial('worldvertextransition', WorldVertexTransitionMaterial);

class Source1ParticleOperator {
    #parameters = {};
    particleSystem;
    material; //for renderers// TODO: put  in a subclas ?
    materialLoaded = false;
    paramList = [];
    #endCapState = -1;
    mesh; //for renderers// TODO: put  in a subclas ?
    constructor(system) {
        this.setNameId(this.functionName);
        this.particleSystem = system;
    }
    get functionName() {
        return this.constructor.getFunctionName();
    }
    static get functionName() {
        return 'Operator';
    }
    static getFunctionName() {
        return this.functionName;
    }
    initializeParticle(particle, elapsedTime) {
        if (!particle) {
            return;
        }
        this.doInit(particle, elapsedTime);
    }
    operateParticle(particle, elapsedTime) {
        if (this.#endCapState != 1) {
            this.doOperate(particle, elapsedTime);
        }
    }
    forceParticle(particle, elapsedTime, accumulatedForces) {
        if (!particle) {
            return;
        }
        this.doForce(particle, elapsedTime, accumulatedForces);
    }
    constraintParticle(particle) {
        if (!particle) {
            return;
        }
        this.applyConstraint(particle);
    }
    doEmit(elapsedTime) { }
    doInit(particle, elapsedTime) { }
    doOperate(particle, elapsedTime) { }
    doForce(particle, elapsedTime, accumulatedForces, strength) { }
    applyConstraint(particle) { }
    doRender(particle, elapsedTime, material) { }
    initRenderer( /*particleSystem: Source1ParticleSystem*/) { }
    updateParticles(particleSystem, particleList, elapsedTime) { }
    emitParticle(creationTime, elapsedTime) {
        return this.particleSystem.createParticle(creationTime, elapsedTime);
    }
    /*
    renderParticle(particleList: SourceEngineParticle[], elapsedTime: number, material) {
        if (!particleList) {
            return;
        }
        this.doRender(particleList, elapsedTime, material);
    }
    */
    setMaterial(material) {
        this.material = material;
    }
    paramChanged(name, value) {
        // Override this function is you need a notification when a parm is modified
    }
    setParameter(parameter, type, value) {
        if (parameter == '' || parameter == undefined) {
            return this;
        }
        if (parameter == 'operator end cap state') {
            this.#endCapState = value;
        }
        if (this.#parameters[parameter] == undefined) {
            this.#parameters[parameter] = {};
        }
        this.#parameters[parameter].type = type;
        this.#parameters[parameter].value = value;
        //this.propertyChanged(parameter);
        this.paramChanged(parameter, value);
        return this;
    }
    getParameter(parameter) {
        const p = this.#parameters[parameter];
        if (p == undefined) {
            return null;
        }
        return p.value;
    }
    getParameters() {
        return this.#parameters;
    }
    /*
    setParameters(parameters) {
        for (const i in parameters) {
            const pair = parameters[i];
            this.setParameter(pair[0], pair[1], pair[2]);
        }
        return this;
    }
    */
    setNameId(name) {
        //this.functionName = name;
        this.addParam('id', PARAM_TYPE_ID, generateRandomUUID()); //TODO
        this.addParam('name', PARAM_TYPE_STRING, name);
        this.addParam('functionName', PARAM_TYPE_STRING, name);
    }
    doNothing() {
    }
    reset() {
    }
    getOperatorFade() {
        return this.getOperatorStrength();
    }
    getOperatorStrength() {
        if (!this.particleSystem) {
            return 0;
        }
        let start_fadein = this.getParameter('operator start fadein') ?? 0;
        let end_fadein = this.getParameter('operator end fadein') ?? 0;
        let start_fadeout = this.getParameter('operator start fadeout') ?? 0;
        let end_fadeout = this.getParameter('operator end fadeout') ?? 0;
        const fade_oscillate = this.getParameter('operator fade oscillate') ?? 0;
        let currentTime = this.particleSystem.currentTime;
        if (fade_oscillate > 0) {
            currentTime = (currentTime / fade_oscillate) % 1.;
        }
        if (start_fadein > currentTime) {
            return 0;
        }
        if (end_fadeout > 0 && end_fadeout < currentTime) {
            return 0;
        }
        let flStrength = 1.0;
        if (end_fadein > currentTime && end_fadein > start_fadein) {
            flStrength = Math.min(flStrength, (currentTime - start_fadein) / (end_fadein - start_fadein));
        }
        if ((currentTime > start_fadeout) &&
            (end_fadeout > start_fadeout)) {
            flStrength = Math.min(flStrength, (currentTime - end_fadeout) / (start_fadeout - end_fadeout));
        }
        return flStrength;
        /*
        float FadeInOut( float flFadeInStart, float flFadeInEnd, float flFadeOutStart, float flFadeOutEnd, float flCurTime )
        {
            if ( flFadeInStart > flCurTime )						// started yet?
                return 0.0;

            if ( ( flFadeOutEnd > 0. ) && ( flFadeOutEnd < flCurTime ) ) // timed out?
                return 0.;

            // handle out of order cases
            flFadeInEnd = max( flFadeInEnd, flFadeInStart );
            flFadeOutStart = max( flFadeOutStart, flFadeInEnd );
            flFadeOutEnd = max( flFadeOutEnd, flFadeOutStart );

            float flStrength = 1.0;
            if (
                ( flFadeInEnd > flCurTime ) &&
                ( flFadeInEnd > flFadeInStart ) )
                flStrength = min( flStrength, FLerp( 0, 1, flFadeInStart, flFadeInEnd, flCurTime ) );

            if ( ( flCurTime > flFadeOutStart) &&
                 ( flFadeOutEnd > flFadeOutStart) )
                flStrength = min ( flStrength, FLerp( 0, 1, flFadeOutEnd, flFadeOutStart, flCurTime ) );

            return flStrength;

        }
        */
    }
    getParamList() {
        return this.paramList;
    }
    addParam(param, type, value) {
        this.paramList.push(new ParamType(param, type));
        this.setParameter(param, type, value);
    }
    /*
        toString() {
            const s = '';
            s = '"DmeParticleOperator"\n{\n';

            for (let i in this.#parameters) {
                const parameter = this.#parameters[i];
                if (parameter) {
                    if (parameter.type == 'string') {
                        s += '"' + i + '" "' + parameter.type + '" "' + escapeValue(parameter.value) + '"\n'
                    } else {
                        s += '"' + i + '" "' + parameter.type + '" "' + parameter.value + '"\n'
                    }
                } else {
                    if (ERROR) { console.error('parameter is null'); }
                }
            }
            s += '}';
            return s;
        }
    */
    getInputValue(inputField /*TODO: create enum*/, particle) {
        let input = 0;
        switch (inputField) {
            case 0: //creation time
                input = vec3.clone(particle.position);
                break;
            case 8: //creation time
                input = particle.cTime;
                break;
        }
        return input;
    }
    getInputValueAsVector(inputField, particle, v) {
        switch (inputField) {
            case 0: //creation time
                vec3.copy(v, particle.position);
                break;
            case 4:
                v[0] = particle.rotationRoll;
                v[1] = particle.rotationRoll;
                v[2] = particle.rotationRoll;
                break;
            case 8: //creation time
                v[0] = particle.cTime;
                v[1] = particle.cTime;
                v[2] = particle.cTime;
                break;
        }
    }
    setOutputValue(outputField, value /*TODO: imrpove type*/, particle) {
        particle.setInitialField(outputField, value, false /*TODO*/);
    }
    initMultipleOverride() {
        return false;
    }
    finished() {
        return false;
    }
    setOrientationType(orientationType /*TODO: use source2 enum*/) {
        switch (orientationType) {
            case 0:
                this.mesh?.setDefine('PARTICLE_ORIENTATION', PARTICLE_ORIENTATION_SCREEN_ALIGNED);
                break;
            case 1:
                this.mesh?.setDefine('PARTICLE_ORIENTATION', PARTICLE_ORIENTATION_SCREEN_Z_ALIGNED);
                break;
            case 2:
                this.mesh?.setDefine('USE_PARTICLE_YAW', 0);
                this.mesh?.setDefine('PARTICLE_ORIENTATION', PARTICLE_ORIENTATION_WORLD_Z_ALIGNED);
                break;
            case 3:
                this.mesh?.setDefine('PARTICLE_ORIENTATION', PARTICLE_ORIENTATION_WORLD_Z_ALIGNED);
                break;
            default:
                console.error('Unknown orientationType ', orientationType);
        }
    }
    dispose() {
    }
}

const tempVec3_1$2 = vec3.create();
const tempVec3_2$8 = vec3.create();
class CollisionViaTraces extends Source1ParticleOperator {
    static functionName = 'Collision via traces';
    #raycaster = new Raycaster();
    #world;
    #collisionMode = -1; /*TODO: create enum*/
    ;
    constructor(system) {
        super(system);
        this.addParam('collision mode', PARAM_TYPE_INT, 0);
        this.addParam('amount of bounce', PARAM_TYPE_FLOAT, 0.0);
        this.addParam('amount of slide', PARAM_TYPE_FLOAT, 0.0);
        this.addParam('radius scale', PARAM_TYPE_FLOAT, 1.0);
        this.addParam('brush only', PARAM_TYPE_BOOL, 0);
        this.addParam('collision group', PARAM_TYPE_STRING, 0.0);
        this.addParam('control point offset for fast collisions', PARAM_TYPE_VECTOR, vec3.create());
        this.addParam('control point movement distance tolerance', PARAM_TYPE_FLOAT, 5.0);
        this.addParam('kill particle on collision', PARAM_TYPE_BOOL, 0.0);
        this.addParam('trace accuracy tolerance', PARAM_TYPE_FLOAT, 24.0);
        //DMXELEMENT_UNPACK_FIELD( "collision mode", "0", int, m_nCollisionMode )
        //DMXELEMENT_UNPACK_FIELD( "amount of bounce", "0", float, m_flBounceAmount )
        //DMXELEMENT_UNPACK_FIELD( "amount of slide", "0", float, m_flSlideAmount )
        //DMXELEMENT_UNPACK_FIELD( "radius scale", "1", float, m_flRadiusScale )
        //DMXELEMENT_UNPACK_FIELD( "brush only", "0", bool, m_bBrushOnly )
        //DMXELEMENT_UNPACK_FIELD_STRING( "collision group", "NONE", m_CollisionGroupName )
        //DMXELEMENT_UNPACK_FIELD( "control point offset for fast collisions", "0 0 0", Vector, m_vecCpOffset )
        //DMXELEMENT_UNPACK_FIELD( "control point movement distance tolerance", "5", float, m_flCpMovementTolerance )
        //DMXELEMENT_UNPACK_FIELD( "kill particle on collision", "0", bool, m_bKillonContact )
        //DMXELEMENT_UNPACK_FIELD( "trace accuracy tolerance", "24", float, m_flTraceTolerance )
    }
    paramChanged(name, value) {
        switch (name) {
            case 'collision mode':
                this.#collisionMode = value;
                console.log('collisionMode', this.#collisionMode);
                break;
        }
    }
    applyConstraint(particle) {
        {
            if (particle.position[2] < 0.0) {
                particle.position[2] = 0.0;
            }
        }
        //TODO: do a proper collision
    }
    #worldCollision(particle, world) {
        //const cp = this.particleSystem.getControlPoint(0);
        //particle.prevPosition[2] = 50;
        const rayDirection = vec3.sub(tempVec3_1$2, particle.position, particle.prevPosition);
        vec3.len(rayDirection);
        vec3.normalize(rayDirection, rayDirection);
        // We probably already are on the surface, move back the ray origin to prevent falling thru
        const rayPosition = vec3.scaleAndAdd(tempVec3_2$8, particle.prevPosition, rayDirection, -0.001);
        const intersections = this.#raycaster.castRay(rayPosition, rayDirection, [world], true);
        if (intersections.length) {
            //console.error(intersections);
            let min = Infinity;
            for (const intersection of intersections) {
                if (intersection.distance < min) {
                    vec3.copy(particle.position, intersection.position);
                    min = intersection.distance;
                }
            }
        }
    }
    #getWorld() {
        const iterator = this.particleSystem.getParentIterator();
        for (const e of iterator) {
            if (e.is('Scene')) {
                const world = e.getWorld();
                if (world) {
                    this.#world = world;
                    iterator.return(null);
                    return world;
                }
            }
        }
    }
}
Source1ParticleOperators.registerOperator(CollisionViaTraces);

const cpPosition$1 = vec3.create();
const tempVec3_2$7 = vec3.create();
class ConstrainDistanceToControlPoint extends Source1ParticleOperator {
    static functionName = 'Constrain distance to control point';
    constructor(system) {
        super(system);
        //this.setNameId('Constrain distance to control point');
        this.addParam('minimum distance', PARAM_TYPE_FLOAT, 0.0);
        this.addParam('maximum distance', PARAM_TYPE_FLOAT, 100.0);
        this.addParam('control point number', PARAM_TYPE_INT, 0);
        this.addParam('offset of center', PARAM_TYPE_VECTOR, vec3.create());
        this.addParam('global center point', PARAM_TYPE_BOOL, 0);
        //	DMXELEMENT_UNPACK_FIELD('minimum distance', '0', float, m_fMinDistance)
        //	DMXELEMENT_UNPACK_FIELD('maximum distance', '100', float, m_fMaxDistance)
        //	DMXELEMENT_UNPACK_FIELD('control point number', '0', int, m_nControlPointNumber)
        //	DMXELEMENT_UNPACK_FIELD('offset of center', '0 0 0', Vector, m_CenterOffset)
        //	DMXELEMENT_UNPACK_FIELD('global center point', '0', bool, m_bGlobalCenter)
    }
    applyConstraint(particle) {
        const minDistance = this.getParameter('minimum distance');
        const maxDistance = this.getParameter('maximum distance');
        this.getParameter('offset of center');
        const cpNumber = this.getParameter('control point number');
        const cp = this.particleSystem.getControlPoint(cpNumber);
        const v = vec3.copy(tempVec3_2$7, particle.position);
        if (cp) {
            vec3.sub(v, v, cp.getWorldPosition(cpPosition$1));
        }
        const distance = vec3.length(v);
        if (distance > 0) {
            vec3.scale(v, v, 1 / distance);
            if (distance < minDistance) {
                vec3.scale(v, v, minDistance);
                vec3.add(particle.position, cpPosition$1, v);
            }
            else {
                if (distance > maxDistance) {
                    vec3.scale(v, v, maxDistance);
                    vec3.add(particle.position, cpPosition$1, v);
                }
            }
        }
    }
}
Source1ParticleOperators.registerOperator(ConstrainDistanceToControlPoint);

const a$4 = vec3.create();
const b$1 = vec3.create();
/*
    DMXELEMENT_UNPACK_FIELD( "minimum distance", "0", float, m_fMinDistance )
    DMXELEMENT_UNPACK_FIELD( "maximum distance", "100", float, m_flMaxDistance0 )
    DMXELEMENT_UNPACK_FIELD( "maximum distance middle", "-1", float, m_flMaxDistanceMid )
    DMXELEMENT_UNPACK_FIELD( "maximum distance end", "-1", float, m_flMaxDistance1 )
    DMXELEMENT_UNPACK_FIELD( "travel time", "10", float, m_flTravelTime )
    DMXELEMENT_UNPACK_FIELD( "random bulge", "0", float, m_PathParameters.m_flBulge )
    DMXELEMENT_UNPACK_FIELD( "start control point number", "0", int, m_PathParameters.m_nStartControlPointNumber )
    DMXELEMENT_UNPACK_FIELD( "end control point number", "0", int, m_PathParameters.m_nEndControlPointNumber )
    DMXELEMENT_UNPACK_FIELD( "bulge control 0=random 1=orientation of start pnt 2=orientation of end point", "0", int, m_PathParameters.m_nBulgeControl )
    DMXELEMENT_UNPACK_FIELD( "mid point position", "0.5", float, m_PathParameters.m_flMidPoint )
    */
class ConstrainDistanceToPathBetweenTwoControlPoints extends Source1ParticleOperator {
    static functionName = 'Constrain distance to path between two control points';
    constructor(system) {
        super(system);
        //this.setNameId('constrain distance to path between two control points');
        this.addParam('start control point number', PARAM_TYPE_INT, 0);
        this.addParam('end control point number', PARAM_TYPE_INT, 0);
        this.addParam('travel time', PARAM_TYPE_FLOAT, 10);
        this.addParam('minimum distance', PARAM_TYPE_FLOAT, 0);
        this.addParam('maximum distance', PARAM_TYPE_FLOAT, 100);
        this.addParam('offset of center', PARAM_TYPE_VECTOR, vec3.create());
        // TODO: add more parameters
    }
    applyConstraint(particle) {
        const startNumber = this.getParameter('start control point number') || 0;
        const endNumber = this.getParameter('end control point number') || 1;
        let travelTime = this.getParameter('travel time') || 1;
        travelTime = clamp$1(particle.currentTime / travelTime, 0, 1);
        const startCP = this.particleSystem.getControlPoint(startNumber);
        const endCP = this.particleSystem.getControlPoint(endNumber);
        if (startCP && endCP) {
            const delta = vec3.sub(vec3.create(), endCP.getWorldPosition(b$1), startCP.getWorldPosition(a$4));
            vec3.scaleAndAdd(particle.position, a$4, delta, travelTime);
        }
    }
}
Source1ParticleOperators.registerOperator(ConstrainDistanceToPathBetweenTwoControlPoints);

class EmitContinuously extends Source1ParticleOperator {
    static functionName = 'emit continuously';
    remainder = 0;
    constructor(system) {
        super(system);
        //this.setNameId('Emit Continuously');
        this.addParam('emission_start_time', PARAM_TYPE_FLOAT, 0);
        this.addParam('emission_rate', PARAM_TYPE_FLOAT, 100);
        this.addParam('emission_duration', PARAM_TYPE_FLOAT, 0);
    }
    doEmit(elapsedTime) {
        const emission_start_time = this.getParameter('emission_start_time') || 0;
        let emission_rate = this.getParameter('emission_rate') || 100;
        const emission_duration = this.getParameter('emission_duration') || 0;
        const fade = this.getOperatorFade();
        emission_rate *= fade;
        //console.log(emission_rate + ' ' + this.remainder);
        let currentTime = this.particleSystem.currentTime;
        if (currentTime < emission_start_time)
            return;
        if (emission_duration != 0 && (currentTime > emission_start_time + emission_duration))
            return;
        let nToEmit = this.remainder + elapsedTime * emission_rate;
        this.remainder = nToEmit % 1;
        nToEmit = Math.floor(nToEmit);
        const timeStampStep = elapsedTime / nToEmit;
        for (let i = 0; i < nToEmit; ++i) {
            const particle = this.emitParticle(currentTime, elapsedTime);
            if (particle == null) {
                break; // Break if a particule can't emitted (max reached)
            }
            currentTime += timeStampStep;
        }
    }
    finished() {
        const emission_start_time = this.getParameter('emission_start_time') ?? 0;
        const emission_duration = this.getParameter('emission_duration') ?? 0;
        const currentTime = this.particleSystem.currentTime;
        return emission_duration != 0 && (currentTime > emission_start_time + emission_duration);
    }
}
Source1ParticleOperators.registerOperator(EmitContinuously);

/**
 *TODO
 */
class EmitInstantaneously extends Source1ParticleOperator {
    static functionName = 'emit_instantaneously';
    #emitted = false;
    constructor(system) {
        super(system);
        //this.setNameId('Emit Instantaneously');
        this.addParam('emission_start_time', PARAM_TYPE_FLOAT, 0.0);
        this.addParam('num_to_emit_minimum', PARAM_TYPE_INT, -1);
        this.addParam('num_to_emit', PARAM_TYPE_INT, 100);
        this.addParam('maximum emission per frame', PARAM_TYPE_INT, -1);
        this.addParam('emission count scale control point', PARAM_TYPE_INT, -1);
        this.addParam('emission count scale control point field', PARAM_TYPE_INT, 0);
        //	DMXELEMENT_UNPACK_FIELD('emission_start_time', '0', float, m_flStartTime)
        //	DMXELEMENT_UNPACK_FIELD('num_to_emit_minimum', '-1', int, m_nMinParticlesToEmit)
        //	DMXELEMENT_UNPACK_FIELD('num_to_emit', '100', int, m_nParticlesToEmit)
        //	DMXELEMENT_UNPACK_FIELD('maximum emission per frame', '-1', int, m_nPerFrameNum)
        //	DMXELEMENT_UNPACK_FIELD('emission count scale control point', '-1', int, m_nScaleControlPoint)
        //	DMXELEMENT_UNPACK_FIELD('emission count scale control point field', '0', int, m_nScaleControlPointField)
    }
    doEmit(elapsedTime) {
        if (this.#emitted) {
            return;
        }
        const m_flStartTime = this.getParameter('emission_start_time');
        const num_to_emit = this.getParameter('num_to_emit');
        const currentTime = this.particleSystem.currentTime;
        if (currentTime < m_flStartTime)
            return;
        for (let i = 0; i < num_to_emit; ++i) {
            const particle = this.emitParticle(currentTime, elapsedTime); //TODO: change particle time ?
            if (particle == null) {
                break; // Break if a particule can't emitted (max reached)
            }
        }
        this.#emitted = true;
    }
    reset() {
        this.#emitted = false;
    }
    finished() {
        return this.#emitted;
    }
}
Source1ParticleOperators.registerOperator(EmitInstantaneously);

class EmitNoise extends Source1ParticleOperator {
    static functionName = 'emit noise';
    #remainder = 0;
    constructor(system) {
        super(system);
        this.addParam('emission_start_time', PARAM_TYPE_FLOAT, 0);
        this.addParam('emission_duration', PARAM_TYPE_FLOAT, 0);
        this.addParam('scale emission to used control points', PARAM_TYPE_FLOAT, 0);
        this.addParam('time noise coordinate scale', PARAM_TYPE_FLOAT, 0.1);
        this.addParam('time coordinate offset', PARAM_TYPE_FLOAT, 0);
        this.addParam('absolute value', PARAM_TYPE_BOOL, 0);
        this.addParam('invert absolute value', PARAM_TYPE_BOOL, 0);
        this.addParam('emission minimum', PARAM_TYPE_FLOAT, 0);
        this.addParam('emission maximum', PARAM_TYPE_FLOAT, 100);
        this.addParam('world time noise coordinate scale', PARAM_TYPE_FLOAT, 0);
    }
    doEmit(elapsedTime) {
        const emission_start_time = this.getParameter('emission_start_time');
        const emissionMinimum = this.getParameter('emission minimum');
        const emissionMaximum = this.getParameter('emission maximum');
        const emission_duration = this.getParameter('emission_duration');
        let emission_rate = (emissionMinimum + emissionMaximum) / 2;
        const fade = this.getOperatorFade();
        emission_rate *= fade;
        //console.log(emission_rate + ' ' + this.remainder);
        let currentTime = this.particleSystem.currentTime;
        if (currentTime < emission_start_time)
            return;
        if (emission_duration != 0 && (currentTime > emission_start_time + emission_duration))
            return;
        let nToEmit = this.#remainder + elapsedTime * emission_rate;
        this.#remainder = nToEmit % 1;
        nToEmit = Math.floor(nToEmit);
        const timeStampStep = elapsedTime / nToEmit;
        for (let i = 0; i < nToEmit; ++i) {
            const particle = this.emitParticle(currentTime, elapsedTime);
            if (particle == null) {
                break; // Break if a particule can't emitted (max reached)
            }
            currentTime += timeStampStep;
        }
    }
}
Source1ParticleOperators.registerOperator(EmitNoise);

const tempVec3$h = vec3.create();
let AttractToControlPoint$1 = class AttractToControlPoint extends Source1ParticleOperator {
    static functionName = 'Pull towards control point';
    constructor(system) {
        super(system);
        this.addParam('control point number', PARAM_TYPE_INT, 0);
        this.addParam('amount of force', PARAM_TYPE_FLOAT, 0);
        this.addParam('falloff power', PARAM_TYPE_FLOAT, 2);
        //	DMXELEMENT_UNPACK_FIELD('amount of force', '0', float, m_fForceAmount)
        //	DMXELEMENT_UNPACK_FIELD('falloff power', '2', float, m_fFalloffPower)
        //	DMXELEMENT_UNPACK_FIELD('control point number', '0', int, m_nControlPointNumber)
    }
    doForce(particle, elapsedTime, accumulatedForces, strength = 1) {
        //console.log(particle.position);
        const m_fForceAmount = this.getParameter('amount of force');
        const cpNumber = this.getParameter('control point number');
        const m_fFalloffPower = this.getParameter('falloff power');
        const fForceScale = -m_fForceAmount * 1.0 /*flStrength*/;
        const cp = this.particleSystem.getControlPoint(cpNumber);
        if (!cp) {
            return;
        }
        const ofs = vec3.clone(particle.position);
        vec3.subtract(ofs, ofs, cp.getWorldPosition(tempVec3$h)); //TODO: add particle base cp
        let len = vec3.length(ofs);
        if (len === 0) {
            len = FLT_EPSILON;
        }
        vec3.scale(ofs, ofs, fForceScale / len * Math.pow(len, -m_fFalloffPower));
        ///console.log(len, Math.pow(len, power_frac), ofs);
        //vec3.scale(ofs, ofs, 10000000);//TODO
        //vec3.scale(v, v, 1 / Math.pow(len, power_frac));
        vec3.add(accumulatedForces, accumulatedForces, ofs);
    }
};
Source1ParticleOperators.registerOperator(AttractToControlPoint$1);

let RandomForce$1 = class RandomForce extends Source1ParticleOperator {
    static functionName = 'random force';
    constructor(system) {
        super(system);
        this.addParam('min force', PARAM_TYPE_VECTOR, vec3.create());
        this.addParam('max force', PARAM_TYPE_VECTOR, vec3.create());
        this.addParam('amount of force', PARAM_TYPE_FLOAT, 0);
    }
    doForce(particle, elapsedTime, accumulatedForces, strength = 1) {
        const minForce = this.getParameter('min force') || vec3.create();
        const maxForce = this.getParameter('max force') || vec3.create();
        const f = vec3RandomBox(vec3.create(), minForce, maxForce);
        /*if (elapsedTime) {
            vec3.scale(f, f , 1 / elapsedTime);
        }*/
        vec3.add(accumulatedForces, accumulatedForces, f);
    }
};
Source1ParticleOperators.registerOperator(RandomForce$1);

const tempVec3$g = vec3.create();
const tempVec3_2$6 = vec3.create();
vec3.create();
quat.create();
let TwistAroundAxis$1 = class TwistAroundAxis extends Source1ParticleOperator {
    static functionName = 'twist around axis';
    constructor(system) {
        super(system);
        this.addParam('twist axis', PARAM_TYPE_VECTOR, vec3.fromValues(0, 0, 1));
        this.addParam('amount of force', PARAM_TYPE_FLOAT, 0);
        this.addParam('object local space axis 0/1', PARAM_TYPE_BOOL, 0);
    }
    doForce(particle, elapsedTime, accumulatedForces, strength = 1) {
        const axis = this.getParameter('twist axis'); //TODO: set in world space
        const amountOfForce = this.getParameter('amount of force');
        this.getParameter('object local space axis 0/1');
        const cp = particle.system.getControlPoint(0);
        const offsetToAxis = vec3.sub(tempVec3$g, particle.position, cp.getWorldPosition(tempVec3$g));
        /*
                if (!localSpace) {
                    cp.getWorldQuaternion(tempQuat);
                    axis = vec3.transformQuat(tempAxis, axis, tempQuat);
                }
                    */
        vec3.normalize(offsetToAxis, offsetToAxis);
        vec3.scale(tempVec3_2$6, offsetToAxis, vec3.dot(offsetToAxis, axis));
        vec3.sub(offsetToAxis, offsetToAxis, tempVec3_2$6);
        vec3.normalize(offsetToAxis, offsetToAxis);
        const f = vec3.cross(tempVec3_2$6, axis, offsetToAxis);
        vec3.scale(f, f, amountOfForce * strength);
        vec3.add(accumulatedForces, accumulatedForces, f);
    }
};
Source1ParticleOperators.registerOperator(TwistAroundAxis$1);

class AlphaRandom extends Source1ParticleOperator {
    static functionName = 'Alpha Random';
    constructor(system) {
        super(system);
        this.addParam('alpha_min', PARAM_TYPE_INT, 0);
        this.addParam('alpha_max', PARAM_TYPE_INT, 255);
        this.addParam('alpha_random_exponent', PARAM_TYPE_FLOAT, 1.0);
        //	DMXELEMENT_UNPACK_FIELD('alpha_min', '255', int, m_nAlphaMin)
        //	DMXELEMENT_UNPACK_FIELD('alpha_max', '255', int, m_nAlphaMax)
        //	DMXELEMENT_UNPACK_FIELD('alpha_random_exponent', '1', float, m_flAlphaRandExponent)
    }
    doInit(particle, elapsedTime) {
        const alpha_min = this.getParameter('alpha_min') / 255.0;
        const alpha_max = this.getParameter('alpha_max') / 255.0;
        const alpha_random_exponent = this.getParameter('alpha_random_exponent');
        const alpha = RandomFloatExp(alpha_min, alpha_max, alpha_random_exponent);
        particle.alpha = alpha;
        particle.startAlpha = alpha;
    }
}
Source1ParticleOperators.registerOperator(AlphaRandom);

class ColorRandom extends Source1ParticleOperator {
    static functionName = 'Color Random';
    constructor(system) {
        super(system);
        this.addParam('color1', PARAM_TYPE_COLOR, BLACK);
        this.addParam('color2', PARAM_TYPE_COLOR, WHITE);
    }
    doInit(particle, elapsedTime) {
        particle.color.randomize(this.getParameter('color1'), this.getParameter('color2'));
        particle.initialColor.setColor(particle.color);
    }
}
Source1ParticleOperators.registerOperator(ColorRandom);

class LifetimeFromSequence extends Source1ParticleOperator {
    static functionName = 'Lifetime From Sequence';
    constructor(system) {
        super(system);
        this.addParam('Frames Per Second', PARAM_TYPE_FLOAT, 30);
    }
    doInit(particle, elapsedTime) {
        const paramFramesPerSecond = this.getParameter('Frames Per Second');
        if (this.particleSystem.material) {
            const frameSpan = this.particleSystem.material.getFrameSpan(particle.sequence);
            if (frameSpan !== null) {
                const lifetime = frameSpan / paramFramesPerSecond;
                //particle.timeToLive = lifetime;
                particle.setInitialTTL(lifetime / 2.0);
            }
        }
    }
    initMultipleOverride() {
        return true;
    }
}
Source1ParticleOperators.registerOperator(LifetimeFromSequence);

class LifetimeRandom extends Source1ParticleOperator {
    static functionName = 'Lifetime Random';
    constructor(system) {
        super(system);
        this.addParam('lifetime_min', PARAM_TYPE_FLOAT, 0);
        this.addParam('lifetime_max', PARAM_TYPE_FLOAT, 0);
        this.addParam('lifetime_random_exponent', PARAM_TYPE_FLOAT, 1);
    }
    doInit(particle, elapsedTime) {
        const lifetime_min = this.getParameter('lifetime_min');
        const lifetime_max = this.getParameter('lifetime_max');
        const lifetime_random_exponent = this.getParameter('lifetime_random_exponent');
        //const lifetime = (lifetime_max - lifetime_min) * Math.random() + lifetime_min;
        particle.setInitialTTL(RandomFloatExp(lifetime_min, lifetime_max, lifetime_random_exponent));
    }
}
Source1ParticleOperators.registerOperator(LifetimeRandom);

const a$3 = vec3.create();
class PositionAlongPathRandom extends Source1ParticleOperator {
    static functionName = 'Position Along Path Random';
    #sequence = 0;
    constructor(system) {
        super(system);
        this.addParam('restart behavior (0 = bounce, 1 = loop )', PARAM_TYPE_BOOL, 0);
        this.addParam('particles to map from start to end', PARAM_TYPE_FLOAT, 2);
        this.addParam('mid point position', PARAM_TYPE_FLOAT, 0.5);
        this.addParam('bulge control 0=random 1=orientation of start pnt 2=orientation of end point', PARAM_TYPE_INT, 0);
        this.addParam('start control point number', PARAM_TYPE_INT, 1);
        this.addParam('end control point number', PARAM_TYPE_INT, 2);
        this.addParam('bulge', PARAM_TYPE_FLOAT, 0);
        this.addParam('maximum distance', PARAM_TYPE_FLOAT, 0);
    }
    doInit(particle, elapsedTime) {
        const startNumber = this.getParameter('start control point number') ?? 1;
        const endNumber = this.getParameter('end control point number') ?? 2;
        const startCP = this.particleSystem.getControlPoint(startNumber);
        const endCP = this.particleSystem.getControlPoint(endNumber);
        if (!startCP || !endCP) {
            return;
        }
        const nbPart = this.getParameter('particles to map from start to end') || 2;
        const delta = startCP.deltaPosFrom(endCP);
        this.#sequence / nbPart;
        vec3.scale(delta, delta, Math.random());
        vec3.add(particle.position, startCP.getWorldPosition(a$3), delta);
        vec3.copy(particle.prevPosition, particle.position);
        ++this.#sequence;
        if (this.#sequence > nbPart) { //TODO: handle loop
            this.#sequence = 0;
        }
    }
    reset() {
        this.#sequence = 0;
    }
}
Source1ParticleOperators.registerOperator(PositionAlongPathRandom);

const tempVec3_1$1 = vec3.create();
const tempVec3_2$5 = vec3.create();
class PositionAlongPathSequential extends Source1ParticleOperator {
    static functionName = 'Position Along Path Sequential';
    #sequence = 0;
    constructor(system) {
        super(system);
        this.addParam('maximum distance', PARAM_TYPE_FLOAT, 0.0);
        this.addParam('bulge', PARAM_TYPE_FLOAT, 0.0);
        this.addParam('start control point number', PARAM_TYPE_INT, 0);
        this.addParam('end control point number', PARAM_TYPE_INT, 0);
        this.addParam('bulge control 0=random 1=orientation of start pnt 2=orientation of end point', PARAM_TYPE_INT, 0);
        this.addParam('mid point position', PARAM_TYPE_FLOAT, 0.5);
        this.addParam('particles to map from start to end', PARAM_TYPE_FLOAT, 100);
        this.addParam('restart behavior (0 = bounce, 1 = loop )', PARAM_TYPE_BOOL, 1);
    }
    doInit(particle, elapsedTime) {
        const startControlPointNumber = this.getParameter('start control point number');
        const endControlPointNumber = this.getParameter('end control point number');
        const startCP = this.particleSystem.getControlPoint(startControlPointNumber);
        const endCP = this.particleSystem.getControlPoint(endControlPointNumber);
        const nbPart = this.getParameter('particles to map from start to end');
        if (!startCP || !endCP) {
            return;
        }
        startCP.deltaPosFrom(endCP, tempVec3_1$1);
        const s = this.#sequence / nbPart;
        vec3.scale(tempVec3_1$1, tempVec3_1$1, s);
        vec3.add(particle.position, startCP.getWorldPosition(tempVec3_2$5), tempVec3_1$1);
        vec3.copy(particle.prevPosition, particle.position);
        ++this.#sequence;
        if (this.#sequence > nbPart) {
            const restartBehavior = this.getParameter('restart behavior (0 = bounce, 1 = loop )');
            if (restartBehavior == 1) {
                this.#sequence = 0;
            }
            else {
                this.#sequence = nbPart;
            }
        }
    }
    reset() {
        this.#sequence = 0;
    }
}
Source1ParticleOperators.registerOperator(PositionAlongPathSequential);

vec3.create();
vec3.create();
const DEFAULT_VELOCITY_SCALE$1 = 0; /* TODO: check default value*/
let PositionFromParentParticles$1 = class PositionFromParentParticles extends Source1ParticleOperator {
    static functionName = 'Position From Parent Particles';
    #velocitySCale = DEFAULT_VELOCITY_SCALE$1;
    paramChanged(name, param) {
        switch (name) {
            case 'Inherited Velocity Scale':
                this.#velocitySCale = param; //TODO: convert to number
                break;
            default:
                super.paramChanged(name, param);
                break;
        }
    }
    doInit(particle, elapsedTime) {
        const parent = this.particleSystem.parentSystem;
        if (!parent) {
            vec3.zero(particle.position);
            vec3.zero(particle.prevPosition);
            return;
        }
        const particleCount = parent.getActiveParticlesCount();
        if (particleCount == 0) {
            particle.die();
        }
        const base = parent.getParticle();
        if (base != null) {
            /*particle.timeToLive = 0;
            particle.die();
            return;*/
            //TODO: do subframe
            //base.getWorldPos(particle.position);
            base.getLocalPos(particle.position);
            vec3.lerp(particle.prevPosition, base.position, base.prevPosition, this.#velocitySCale);
            //vec3.copy(particle.prevPosition, particle.position);
        }
        else {
            particle.die();
        }
        particle.PositionFromParentParticles = true;
    }
};
Source1ParticleOperators.registerOperator(PositionFromParentParticles$1);

const tempVec3$f = vec3.create();
class PositionModifyOffsetRandom extends Source1ParticleOperator {
    static functionName = 'Position Modify Offset Random';
    constructor(system) {
        super(system);
        this.addParam('offset min', PARAM_TYPE_VECTOR, vec3.create());
        this.addParam('offset max', PARAM_TYPE_VECTOR, vec3.create());
        this.addParam('control_point_number', PARAM_TYPE_INT, 0);
        this.addParam('offset in local space 0/1', PARAM_TYPE_BOOL, 0);
        this.addParam('offset proportional to radius 0/1', PARAM_TYPE_BOOL, 0);
        //	DMXELEMENT_UNPACK_FIELD('control_point_number', '0', int, m_nControlPointNumber)
        //	DMXELEMENT_UNPACK_FIELD('offset min', '0 0 0', Vector, m_OffsetMin)
        //	DMXELEMENT_UNPACK_FIELD('offset max', '0 0 0', Vector, m_OffsetMax)
        //	DMXELEMENT_UNPACK_FIELD('offset in local space 0/1', '0', bool, m_bLocalCoords)
        //	DMXELEMENT_UNPACK_FIELD('offset proportional to radius 0/1', '0', bool, m_bProportional)
    }
    doInit(particle, elapsedTime) {
        const localSpace = this.getParameter('offset in local space 0/1');
        const offsetMin = this.getParameter('offset min');
        const offsetMax = this.getParameter('offset max');
        vec2.random(vec2.create(), 1.0);
        const controlPointNumber = this.getParameter('control_point_number');
        const offset = vec3RandomBox(tempVec3$f, offsetMin, offsetMax);
        if (localSpace == 1) {
            const cp = particle.system.getControlPoint(controlPointNumber);
            if (cp) {
                vec3.transformQuat(offset, offset, cp.getWorldQuaternion());
            }
            /*const a = offset[1];
            offset[1] = offset[2];
            offset[2] = a;*/
            /*
// assume in2 is a rotation and rotate the input vector
void VectorRotate(const float *in1, const matrix3x4_t& in2, float *out)
{
    Assert(s_bMathlibInitialized);
    Assert(in1 != out);
    out[0] = DotProduct(in1, in2[0]);
    out[1] = DotProduct(in1, in2[1]);
    out[2] = DotProduct(in1, in2[2]);
}
*/
        }
        if (particle.initialVec) {
            particle.initialVecOffset = vec3.clone(offset); //TODO: optimize
        }
        vec3.add(particle.position, particle.position, offset);
        vec3.add(particle.prevPosition, particle.prevPosition, offset);
    }
    initMultipleOverride() {
        return true;
    }
}
Source1ParticleOperators.registerOperator(PositionModifyOffsetRandom);

const a$2 = vec3.create();
class PositionOnModelRandom extends Source1ParticleOperator {
    static functionName = 'Position on Model Random';
    constructor(system) {
        super(system);
        this.addParam('control_point_number', PARAM_TYPE_INT, 0);
        this.addParam('force to be inside model', PARAM_TYPE_INT, 0);
        this.addParam('hitbox scale', PARAM_TYPE_INT, 1);
        this.addParam('direction bias', PARAM_TYPE_VECTOR, vec3.create());
        //	DMXELEMENT_UNPACK_FIELD( 'control_point_number', '0', int, m_nControlPointNumber )
        //	DMXELEMENT_UNPACK_FIELD( 'force to be inside model', '0', int, m_nForceInModel )
        //	DMXELEMENT_UNPACK_FIELD( 'hitbox scale', '1.0', int, m_flHitBoxScale )
        //	DMXELEMENT_UNPACK_FIELD( 'direction bias', '0 0 0', Vector, m_vecDirectionBias )
    }
    doInit(particle, elapsedTime) {
        const controlPointNumber = this.getParameter('control_point_number');
        const forceInModel = this.getParameter('force to be inside model');
        if (forceInModel > 5) {
            particle.die();
            return;
        }
        const controlPoint = particle.system.getControlPoint(controlPointNumber);
        if (!controlPoint) {
            return;
        }
        // TODO : Actually we should get the model parenting the control point
        const controllingModel = controlPoint.parentModel;
        if (controllingModel && controllingModel.getRandomPointOnModel) {
            //TODOv3
            particle.bones = [];
            particle.initialVec = vec3.create();
            const position = controllingModel.getRandomPointOnModel(vec3.create(), particle.initialVec, particle.bones);
            //vec3.copy(particle.position, position);
            //vec3.copy(particle.prevPosition, position);
            if (controlPoint) {
                vec3.copy(particle.position, position);
                vec3.copy(particle.prevPosition, position);
            }
        }
        else {
            if (controlPoint) {
                vec3.copy(particle.position, controlPoint.getWorldPosition(a$2));
                vec3.copy(particle.prevPosition, particle.position);
            }
        }
    }
}
Source1ParticleOperators.registerOperator(PositionOnModelRandom);

const tempVec3$e = vec3.create();
class PositionWithinBoxRandom extends Source1ParticleOperator {
    static functionName = 'Position Within Box Random';
    constructor(system) {
        super(system);
        this.addParam('min', PARAM_TYPE_VECTOR, vec3.create());
        this.addParam('max', PARAM_TYPE_VECTOR, vec3.create());
        this.addParam('control point number', PARAM_TYPE_INT, 0);
        //	DMXELEMENT_UNPACK_FIELD('min', '0 0 0', Vector, m_vecMin)
        //	DMXELEMENT_UNPACK_FIELD('max', '0 0 0', Vector, m_vecMax)
        //	DMXELEMENT_UNPACK_FIELD('control point number', '0', int, m_nControlPointNumber)
    }
    doInit(particle, elapsedTime) {
        const min = this.getParameter('min');
        const max = this.getParameter('max');
        const controlPointNumber = this.getParameter('control point number');
        vec3RandomBox(particle.position, min, max);
        vec3.copy(particle.prevPosition, particle.position);
        const controlPoint = particle.system.getControlPoint(controlPointNumber);
        if (controlPoint) {
            controlPoint.getWorldPosition(tempVec3$e);
            vec3.add(particle.position, particle.position, tempVec3$e);
            vec3.add(particle.prevPosition, particle.prevPosition, tempVec3$e);
        }
    }
}
Source1ParticleOperators.registerOperator(PositionWithinBoxRandom);

const tempVec3$d = vec3.create();
class PositionWithinSphereRandom extends Source1ParticleOperator {
    static functionName = 'Position Within Sphere Random';
    constructor(system) {
        super(system);
        this.addParam('distance_min', PARAM_TYPE_FLOAT, 0);
        this.addParam('distance_max', PARAM_TYPE_FLOAT, 0);
        this.addParam('distance_bias', PARAM_TYPE_VECTOR, vec3.fromValues(1, 1, 1));
        this.addParam('distance_bias_absolute_value', PARAM_TYPE_VECTOR, vec3.fromValues(0, 0, 0));
        this.addParam('speed_in_local_coordinate_system_min', PARAM_TYPE_VECTOR, vec3.create());
        this.addParam('speed_in_local_coordinate_system_max', PARAM_TYPE_VECTOR, vec3.create());
        this.addParam('speed_min', PARAM_TYPE_FLOAT, 0);
        this.addParam('speed_max', PARAM_TYPE_FLOAT, 0);
        this.addParam('control_point_number', PARAM_TYPE_INT, 0);
        //	DMXELEMENT_UNPACK_FIELD('distance_min', '0', float, m_fRadiusMin)
        //	DMXELEMENT_UNPACK_FIELD('distance_max', '0', float, m_fRadiusMax)
        //	DMXELEMENT_UNPACK_FIELD('distance_bias', '1 1 1', Vector, m_vecDistanceBias)
        //	DMXELEMENT_UNPACK_FIELD('distance_bias_absolute_value', '0 0 0', Vector, m_vecDistanceBiasAbs)
        //	DMXELEMENT_UNPACK_FIELD('bias in local system', '0', bool, m_bLocalCoords)
        //	DMXELEMENT_UNPACK_FIELD('control_point_number', '0', int, m_nControlPointNumber)
        //	DMXELEMENT_UNPACK_FIELD('speed_min', '0', float, m_fSpeedMin)
        //	DMXELEMENT_UNPACK_FIELD('speed_max', '0', float, m_fSpeedMax)
        //	DMXELEMENT_UNPACK_FIELD('speed_random_exponent', '1', float, m_fSpeedRandExp)
        //	DMXELEMENT_UNPACK_FIELD('speed_in_local_coordinate_system_min', '0 0 0', Vector, m_LocalCoordinateSystemSpeedMin)
        //	DMXELEMENT_UNPACK_FIELD('speed_in_local_coordinate_system_max', '0 0 0', Vector, m_LocalCoordinateSystemSpeedMax)
        //	DMXELEMENT_UNPACK_FIELD('create in model', '0', int, m_nCreateInModel)
        //	DMXELEMENT_UNPACK_FIELD('randomly distribute to highest supplied Control Point', '0', bool, m_bUseHighestEndCP)
        //	DMXELEMENT_UNPACK_FIELD('randomly distribution growth time', '0', float, m_flEndCPGrowthTime)
    }
    doInit(particle, elapsedTime) {
        const m_fRadiusMin = this.getParameter('distance_min');
        const m_fRadiusMax = this.getParameter('distance_max');
        const speed_min = this.getParameter('speed_min');
        const speed_max = this.getParameter('speed_max');
        const m_vecDistanceBias = this.getParameter('distance_bias');
        const m_vecDistanceBiasAbs = this.getParameter('distance_bias_absolute_value');
        const controlPointNumber = this.getParameter('control_point_number');
        const m_bLocalCoords = this.getParameter('bias in local system');
        const m_bDistanceBias = (m_vecDistanceBias[0] != 1.0) || (m_vecDistanceBias[1] != 1.0) || (m_vecDistanceBias[2] != 1.0);
        const m_bDistanceBiasAbs = (m_vecDistanceBiasAbs[0] != 0.0) || (m_vecDistanceBiasAbs[1] != 0.0) || (m_vecDistanceBiasAbs[2] != 0.0);
        const speed_in_local_coordinate_system_min = this.getParameter('speed_in_local_coordinate_system_min');
        const speed_in_local_coordinate_system_max = this.getParameter('speed_in_local_coordinate_system_max');
        //const distance = (distance_max - distance_min) * Math.random() + distance_min;
        const speed = (speed_max - speed_min) * Math.random() + speed_min;
        //const v = vec3.random(vec3.create(), distance);
        //Lerp(flLength, m_fRadiusMin, m_fRadiusMax);
        const randpos = vec3.create(); //, randDir;
        let cp;
        //for(int nTryCtr = 0 ; nTryCtr < 10; nTryCtr++)
        {
            const flLength = RandomVectorInUnitSphere(randpos);
            // Absolute value and biasing for creating hemispheres and ovoids.
            if (m_bDistanceBiasAbs) {
                if (m_vecDistanceBiasAbs[0] != 0.0) {
                    randpos[0] = Math.abs(randpos[0]);
                }
                if (m_vecDistanceBiasAbs[1] != 0.0) {
                    randpos[1] = Math.abs(randpos[1]);
                }
                if (m_vecDistanceBiasAbs[2] != 0.0) {
                    randpos[2] = Math.abs(randpos[2]);
                }
            }
            vec3.mul(randpos, randpos, m_vecDistanceBias); //randpos *= m_vecDistanceBias;
            vec3.normalize(randpos, randpos); //randpos.NormalizeInPlace();
            vec3.clone(randpos);
            vec3.scale(randpos, randpos, lerp(m_fRadiusMin, m_fRadiusMax, flLength)); //randpos *= Lerp(flLength, m_fRadiusMin, m_fRadiusMax);
            if (!m_bDistanceBias || !m_bLocalCoords) {
                /*Vector vecControlPoint;
                pParticles->GetControlPointAtTime(nCurrentControlPoint, *ct, &vecControlPoint);
                randpos += vecControlPoint;*/
                cp = particle.system.getControlPoint(controlPointNumber);
                if (cp) {
                    cp.getWorldPosition(tempVec3$d);
                    vec3.add(randpos, randpos, tempVec3$d);
                }
            }
            else {
                /*matrix3x4_t mat;
                pParticles->GetControlPointTransformAtTime(nCurrentControlPoint, *ct, &mat);
                Vector vecTransformLocal = vec3_origin;
                VectorTransform(randpos, mat, vecTransformLocal);
                randpos = vecTransformLocal;*/
                cp = particle.system.getControlPoint(controlPointNumber);
                if (cp) {
                    vec3.transformQuat(randpos, randpos, cp.getWorldQuaternion());
                    cp.getWorldPosition(tempVec3$d);
                    vec3.add(randpos, randpos, tempVec3$d);
                }
            }
        }
        //vec3.multiply(v, v, distance_bias);
        //vec3.add(particle.position, particle.position, v);
        //const cp = particle.system.getControlPoint(controlPointNumber);
        if (cp) {
            cp.getWorldQuaternion(particle.cpOrientation);
        }
        vec3.copy(particle.position, randpos);
        vec3RandomBox(particle.velocity, speed_in_local_coordinate_system_min, speed_in_local_coordinate_system_max); //particle.velocity.randomize(speed_in_local_coordinate_system_min, speed_in_local_coordinate_system_max);
        particle.velocity[1] = -particle.velocity[1]; //For some reason y is inversed
        if (cp) {
            vec3.transformQuat(particle.velocity, particle.velocity, cp.getWorldQuaternion());
        }
        //vec3.transformQuat(particle.velocity, particle.velocity, particle.cpOrientation/*cp.getWorldQuaternion()*/);
        if (speed) {
            const v = vec3.random(vec3.create(), speed);
            vec3.add(particle.velocity, particle.velocity, v);
            //vec3.add(randpos, randpos, v);
        }
        quat.invert(particle.cpOrientationInvert, particle.cpOrientation);
        //vec3.transformQuat(particle.velocity, particle.velocity, particle.cpOrientation);
        const vGrav = vec3.clone(particle.velocity);
        particle.velocity[0] = vGrav[2];
        particle.velocity[1] = vGrav[1];
        particle.velocity[2] = -vGrav[0];
        particle.velocity[0] = vGrav[0];
        particle.velocity[1] = vGrav[1];
        particle.velocity[2] = vGrav[2];
        //particle.velocity[2] = -vGrav[2];
        //vec3.add(particle.prevPosition, particle.position, particle.velocity);//TODO: fix
        vec3.scaleAndAdd(randpos, randpos, particle.velocity, -elapsedTime);
        vec3.copy(particle.prevPosition, randpos);
        //vec3.scaleAndAdd(particle.position, particle.prevPosition, particle.velocity, 0.01);//TODO: fix
        //vec3.copy(particle.prevPosition, particle.position, particle.velocity);//TODO: fix
    }
}
Source1ParticleOperators.registerOperator(PositionWithinSphereRandom);
Source1ParticleOperators.registerOperator('Position Within Sphere', PositionWithinSphereRandom);

class RadiusRandom extends Source1ParticleOperator {
    static functionName = 'Radius Random';
    constructor(system) {
        super(system);
        this.addParam('radius_min', PARAM_TYPE_FLOAT, 1);
        this.addParam('radius_max', PARAM_TYPE_FLOAT, 1);
    }
    doInit(particle, elapsedTime) {
        const radius_min = this.getParameter('radius_min') ?? 1;
        const radius_max = this.getParameter('radius_max') ?? 1;
        const radius = (radius_max - radius_min) * Math.random() + radius_min;
        particle.setInitialRadius(radius);
    }
}
Source1ParticleOperators.registerOperator(RadiusRandom);

vec3.create();
class RemapControlPointToScalar extends Source1ParticleOperator {
    static functionName = 'remap control point to scalar';
    constructor(system) {
        super(system);
        this.addParam('operator strength scale control point', PARAM_TYPE_INT, 1);
        this.addParam('input control point number', PARAM_TYPE_INT, 0);
        this.addParam('input minimum', PARAM_TYPE_FLOAT, 0);
        this.addParam('input maximum', PARAM_TYPE_FLOAT, 1);
        this.addParam('output minimum', PARAM_TYPE_FLOAT, 0);
        this.addParam('output maximum', PARAM_TYPE_FLOAT, 1);
        this.addParam('input field 0-2 X/Y/Z', PARAM_TYPE_INT, 0); // X/Y/Z
        this.addParam('output field', PARAM_TYPE_INT, 1);
        this.addParam('output is scalar of initial random range', PARAM_TYPE_BOOL, 0);
        /*
                    'operator start fadein' 'float' '0'
                    'operator end fadein' 'float' '0'
                    'operator start fadeout' 'float' '0'
                    'operator end fadeout' 'float' '0'
                    'operator fade oscillate' 'float' '0'
                    'emitter lifetime start time (seconds)' 'float' '-1'
                    'emitter lifetime end time (seconds)' 'float' '-1'
                    'input control point number' 'int' '1'
                    'input minimum' 'float' '0.25'
                    'input maximum' 'float' '1'
                    'input field 0-2 X/Y/Z' 'int' '0'
                    'output field' 'int' '7'
                    'output minimum' 'float' '1'
                    'output maximum' 'float' '0'
                    'output is scalar of initial random range' 'bool' '0'
                    */
    }
    doInit(particle, elapsedTime) {
        /*if (!this.firstTime) {
            console.error('I don\'t know what i\'m supposed to do ' + this.functionName);
            console.log(this.parameters);
            this.firstTime = true;
            return;
        }*/
        const inputMinimum = this.getParameter('input minimum');
        const inputMaximum = this.getParameter('input maximum');
        const outputMinimum = this.getParameter('output minimum');
        const outputMaximum = this.getParameter('output maximum');
        const inputField = this.getParameter('input field 0-2 X/Y/Z');
        const outputField = this.getParameter('output field');
        const cpNumber = this.getParameter('input control point number');
        const cp = this.particleSystem.getControlPoint(cpNumber);
        if (cp && (inputField == 0 || inputField == 1 || inputField == 2)) {
            const v = cp._position[inputField]; //this.getInputValue(inputField, cpNumber);
            const d = (v - inputMinimum) / (inputMaximum - inputMinimum);
            const out = d * (outputMaximum - outputMinimum) + outputMinimum;
            //out = Clamp(out, outputMinimum, outputMaximum);
            this.setOutputValue(outputField, out, particle);
        }
    }
    initMultipleOverride() {
        return true;
    }
}
Source1ParticleOperators.registerOperator(RemapControlPointToScalar);

const tempVec3_1 = vec3.create();
const tempVec3_2$4 = vec3.create();
const tempVec3_3$1 = vec3.create();
const tempVec3_4 = vec3.create();
const tempVec3_5 = vec3.create();
vec3.create();
class RemapControlPointToVector extends Source1ParticleOperator {
    static functionName = 'remap control point to vector';
    constructor(system) {
        super(system);
        this.addParam('operator strength scale control point', PARAM_TYPE_INT, 1);
        this.addParam('input control point number', PARAM_TYPE_INT, 0);
        this.addParam('input minimum', PARAM_TYPE_VECTOR, vec3.create());
        this.addParam('input maximum', PARAM_TYPE_VECTOR, vec3.create());
        this.addParam('output minimum', PARAM_TYPE_VECTOR, vec3.create());
        this.addParam('output maximum', PARAM_TYPE_VECTOR, vec3.create());
        this.addParam('output field', PARAM_TYPE_INT, 1);
        this.addParam('output is scalar of initial random range', PARAM_TYPE_BOOL, 0);
        /*'operator strength scale control point' 'int' '16'
        'input control point number' 'int' '15'
        'input maximum' 'vector3' '255 255 255'
        'output field' 'int' '6'
        'output maximum' 'vector3' '1 1 1'*/
    }
    doInit(particle, elapsedTime) {
        const inputMinimum = this.getParameter('input minimum');
        const inputMaximum = this.getParameter('input maximum');
        const outputMinimum = this.getParameter('output minimum');
        const outputMaximum = this.getParameter('output maximum');
        const outputField = this.getParameter('output field');
        const cpNumber = this.getParameter('input control point number');
        const init = this.getParameter('output is scalar of initial random range');
        const cp = this.particleSystem.getControlPoint(cpNumber);
        if (cp) {
            const iDelta = vec3.sub(tempVec3_1, inputMaximum, inputMinimum);
            const oDelta = vec3.sub(tempVec3_2$4, outputMaximum, outputMinimum);
            const vDelta = vec3.sub(tempVec3_3$1, cp._position, inputMinimum);
            const v1Delta = vec3.div(tempVec3_4, vDelta, iDelta);
            const v2Delta = vec3.mul(tempVec3_5, v1Delta, oDelta);
            vec3.add(v2Delta, v2Delta, outputMinimum);
            particle.setInitialField(outputField, v2Delta, init);
        }
    }
    initMultipleOverride() {
        return true;
    }
}
Source1ParticleOperators.registerOperator(RemapControlPointToVector);

class RemapInitialScalar extends Source1ParticleOperator {
    static functionName = 'Remap Initial Scalar';
    constructor(system) {
        super(system);
        this.addParam('input minimum', PARAM_TYPE_FLOAT, 0);
        this.addParam('input maximum', PARAM_TYPE_FLOAT, 1);
        this.addParam('output minimum', PARAM_TYPE_FLOAT, 0);
        this.addParam('output maximum', PARAM_TYPE_FLOAT, 1);
        this.addParam('input field', PARAM_TYPE_INT, 0);
        this.addParam('output field', PARAM_TYPE_INT, 0);
        this.addParam('emitter lifetime start time (seconds)', PARAM_TYPE_FLOAT, -1);
        this.addParam('emitter lifetime end time (seconds)', PARAM_TYPE_FLOAT, -1);
        this.addParam('output is scalar of initial random range', PARAM_TYPE_BOOL, 0);
    }
    doInit(particle, elapsedTime) {
        const emitterStartTime = this.getParameter('emitter lifetime start time (seconds)');
        const emitterEndTime = this.getParameter('emitter lifetime end time (seconds)');
        const currentTime = this.particleSystem.currentTime;
        if ((emitterStartTime != -1) && (currentTime < emitterStartTime))
            return;
        if ((emitterEndTime != -1) && (currentTime > emitterEndTime))
            return;
        const inputMinimum = this.getParameter('input minimum');
        const inputMaximum = this.getParameter('input maximum');
        const outputMinimum = this.getParameter('output minimum');
        const outputMaximum = this.getParameter('output maximum');
        const inputField = this.getParameter('input field');
        const outputField = this.getParameter('output field');
        const init = this.getParameter('output is scalar of initial random range');
        //const v = this.getInputValue(inputField, particle);
        const v = particle.getField(inputField);
        const d = (v - inputMinimum) / (inputMaximum - inputMinimum);
        const out = d * (outputMaximum - outputMinimum) + outputMinimum;
        //out = clamp(out, outputMinimum, outputMaximum);
        //this.setOutputValue(outputField, out, particle);
        particle.setField(outputField, out, init);
    }
    initMultipleOverride() {
        return true;
    }
}
Source1ParticleOperators.registerOperator(RemapInitialScalar);

class RemapNoiseToScalar extends Source1ParticleOperator {
    static functionName = 'remap noise to scalar';
    constructor(system) {
        super(system);
        this.addParam('output field', PARAM_TYPE_INT, 0);
        this.addParam('output minimum', PARAM_TYPE_FLOAT, 0);
        this.addParam('output maximum', PARAM_TYPE_FLOAT, 0);
    }
    doInit(particle, elapsedTime) {
        const field = this.getParameter('output field') || 1;
        const minimum = this.getParameter('output minimum') || 0.0;
        const maximum = this.getParameter('output maximum') || 1.0;
        //TODO: do a proper noise
        const noise = (maximum - minimum) * Math.random() + minimum;
        particle.setInitialField(field, noise, false);
    }
}
Source1ParticleOperators.registerOperator(RemapNoiseToScalar);
/*

                    'id' 'elementid' '7668c8af-2f2a-4c07-9e93-f9e6123b172e'
                    'name' 'string' 'Remap Noise to Scalar'
                    'functionName' 'string' 'Remap Noise to Scalar'
                    'world time noise coordinate scale' 'float' '0'
                    'output maximum' 'float' '3'
                    'output minimum' 'float' '1'
                    'invert absolute value' 'bool' '0'
                    'absolute value' 'bool' '0'
                    'spatial coordinate offset' 'vector3' '0 0 0'
                    'time coordinate offset' 'float' '0'
                    'output field' 'int' '3'
                    'spatial noise coordinate scale' 'float' '3'
                    'time noise coordinate scale' 'float' '5'
                    'operator fade oscillate' 'float' '0'
                    'operator end fadeout' 'float' '0'
                    'operator start fadeout' 'float' '0'
                    'operator end fadein' 'float' '0'
                    'operator start fadein' 'float' '0'
*/

const tempQuat$4 = quat.create();
const tempVec3$c = vec3.create();
const tempVec3_2$3 = vec3.create();
class RemapScalarToVector extends Source1ParticleOperator {
    static functionName = 'Remap Scalar to Vector';
    constructor(system) {
        super(system);
        this.addParam('emitter lifetime start time (seconds)', PARAM_TYPE_FLOAT, -1);
        this.addParam('emitter lifetime end time (seconds)', PARAM_TYPE_FLOAT, -1);
        this.addParam('input field', PARAM_TYPE_INT, 8);
        this.addParam('input minimum', PARAM_TYPE_FLOAT, 0);
        this.addParam('input maximum', PARAM_TYPE_FLOAT, 1);
        this.addParam('output field', PARAM_TYPE_INT, 0);
        this.addParam('output minimum', PARAM_TYPE_VECTOR3, vec3.create());
        this.addParam('output maximum', PARAM_TYPE_VECTOR3, vec3.fromValues(1, 1, 1));
        this.addParam('output is scalar of initial random range', PARAM_TYPE_BOOL, 0);
        this.addParam('use local system', PARAM_TYPE_BOOL, 1);
        this.addParam('control_point_number', PARAM_TYPE_INT, 0);
    }
    doInit(particle, elapsedTime) {
        const m_flStartTime = this.getParameter('emitter lifetime start time (seconds)');
        const m_flEndTime = this.getParameter('emitter lifetime end time (seconds)');
        const m_nControlPointNumber = this.getParameter('control_point_number');
        const m_nFieldInput = this.getParameter('input field');
        const m_flInputMin = this.getParameter('input minimum');
        const m_flInputMax = this.getParameter('input maximum');
        const m_nFieldOutput = this.getParameter('output field');
        const m_vecOutputMin = this.getParameter('output minimum');
        const m_vecOutputMax = this.getParameter('output maximum');
        const m_bLocalCoords = this.getParameter('use local system');
        if ((m_flStartTime != -1) && (m_flStartTime != -1) && ((particle.currentTime < m_flStartTime) || (particle.currentTime >= m_flEndTime))) {
            return;
        }
        const input = particle.getField(m_nFieldInput);
        tempVec3$c[0] = RemapValClamped(input, m_flInputMin, m_flInputMax, m_vecOutputMin[0], m_vecOutputMax[0]);
        tempVec3$c[1] = RemapValClamped(input, m_flInputMin, m_flInputMax, m_vecOutputMin[1], m_vecOutputMax[1]);
        tempVec3$c[2] = RemapValClamped(input, m_flInputMin, m_flInputMax, m_vecOutputMin[2], m_vecOutputMax[2]);
        const cp = this.particleSystem.getControlPoint(m_nControlPointNumber);
        if (m_nFieldOutput == 0 && cp) { // Position
            if (!m_bLocalCoords) {
                vec3.add(tempVec3$c, cp.getWorldPosition(tempVec3_2$3), tempVec3$c);
            }
            else {
                if (cp) {
                    cp.getWorldQuaternion(tempQuat$4);
                    vec3.transformQuat(tempVec3$c, tempVec3$c, tempQuat$4);
                    vec3.add(tempVec3$c, cp.getWorldPosition(tempVec3_2$3), tempVec3$c);
                }
                particle.setField(0, tempVec3$c); //position
                particle.setField(2, tempVec3$c); //previous position
            }
        }
        else {
            throw 'code me';
        }
    }
    initMultipleOverride() {
        return true;
    }
}
Source1ParticleOperators.registerOperator(RemapScalarToVector);

class RotationRandom extends Source1ParticleOperator {
    static functionName = 'Rotation Random';
    constructor(system) {
        super(system);
        this.addParam('rotation_initial', PARAM_TYPE_FLOAT, 0.0);
        this.addParam('rotation_offset_min', PARAM_TYPE_FLOAT, 0.0);
        this.addParam('rotation_offset_max', PARAM_TYPE_FLOAT, 360.0);
        //	DMXELEMENT_UNPACK_FIELD('rotation_initial', '0', float, m_flDegrees)
        //	DMXELEMENT_UNPACK_FIELD('rotation_offset_min', '0', float, m_flDegreesMin)
        //	DMXELEMENT_UNPACK_FIELD('rotation_offset_max', '360', float, m_flDegreesMax)
        //	DMXELEMENT_UNPACK_FIELD('rotation_random_exponent', '1', float, m_flRotationRandExponent)
    }
    doInit(particle, elapsedTime) {
        const rotation_initial = this.getParameter('rotation_initial');
        const rotation_offset_min = this.getParameter('rotation_offset_min');
        const rotation_offset_max = this.getParameter('rotation_offset_max');
        //TODO :exponent
        const rotation = (rotation_initial + (rotation_offset_max - rotation_offset_min) * Math.random() + rotation_offset_min) * DEG_TO_RAD;
        particle.setInitialRoll(rotation);
    }
    initMultipleOverride() {
        return true;
    }
}
Source1ParticleOperators.registerOperator(RotationRandom);

class RotationSpeedRandom extends Source1ParticleOperator {
    static functionName = 'Rotation Speed Random';
    constructor(system) {
        super(system);
        this.addParam('rotation_speed_constant', PARAM_TYPE_FLOAT, 0.0);
        this.addParam('rotation_speed_random_min', PARAM_TYPE_FLOAT, 0.0);
        this.addParam('rotation_speed_random_max', PARAM_TYPE_FLOAT, 360.0);
        this.addParam('rotation_speed_random_exponent', PARAM_TYPE_FLOAT, 1.0);
        this.addParam('randomly_flip_direction', PARAM_TYPE_BOOL, 1);
        //	DMXELEMENT_UNPACK_FIELD('rotation_speed_constant', '0', float, m_flDegrees)
        //	DMXELEMENT_UNPACK_FIELD('rotation_speed_random_min', '0', float, m_flDegreesMin)
        //	DMXELEMENT_UNPACK_FIELD('rotation_speed_random_max', '360', float, m_flDegreesMax)
        //	DMXELEMENT_UNPACK_FIELD('rotation_speed_random_exponent', '1', float, m_flRotationRandExponent)
        //	DMXELEMENT_UNPACK_FIELD('randomly_flip_direction', '1', bool, m_bRandomlyFlipDirection)
    }
    doInit(particle, elapsedTime) {
        const m_flDegrees = this.getParameter('rotation_speed_constant');
        const m_flDegreesMin = this.getParameter('rotation_speed_random_min');
        const m_flDegreesMax = this.getParameter('rotation_speed_random_max');
        const randomly_flip_direction = this.getParameter('randomly_flip_direction');
        const m_flRotationRandExponent = this.getParameter('rotation_speed_random_exponent');
        const m_flRadians = m_flDegrees * DEG_TO_RAD;
        const m_flRadiansMin = m_flDegreesMin * DEG_TO_RAD;
        const m_flRadiansMax = m_flDegreesMax * DEG_TO_RAD;
        let rotationSpeed = m_flRadians + RandomFloatExp(m_flRadiansMin, m_flRadiansMax, m_flRotationRandExponent);
        if (randomly_flip_direction == 1 && Math.random() > 0.5) {
            rotationSpeed = -rotationSpeed;
        }
        particle.rotationSpeedRoll = rotationSpeed;
    }
}
Source1ParticleOperators.registerOperator(RotationSpeedRandom);

class RotationYawFlipRandom extends Source1ParticleOperator {
    static functionName = 'Rotation Yaw Flip Random';
    constructor(system) {
        super(system);
        this.addParam('Flip Percentage', PARAM_TYPE_FLOAT, 0.5);
        //DMXELEMENT_UNPACK_FIELD('Flip Percentage', '.5', float, m_flPercent)
    }
    doInit(particle, elapsedTime) {
        const flip_percent = this.getParameter('Flip Percentage') || 0.5;
        particle.rotationYaw += (Math.random() < flip_percent) ? 180 : 0;
    }
    initMultipleOverride() {
        return true;
    }
}
Source1ParticleOperators.registerOperator(RotationYawFlipRandom);

class RotationYawRandom extends Source1ParticleOperator {
    static functionName = 'Rotation Yaw Random';
    constructor(system) {
        super(system);
        this.addParam('Percentage', PARAM_TYPE_FLOAT, 0.5);
        this.addParam('yaw_offset_min', PARAM_TYPE_FLOAT, 0);
        this.addParam('yaw_offset_max', PARAM_TYPE_FLOAT, 360);
    }
    doInit(particle, elapsedTime) {
        this.getParameter('Percentage') ?? 0.5; //TODO
        const yaw_offset_min = this.getParameter('yaw_offset_min') ?? 0;
        const yaw_offset_max = this.getParameter('yaw_offset_max') ?? 360;
        const yaw_initial = this.getParameter('yaw_initial') ?? 0;
        particle.rotationYaw = yaw_initial + (yaw_offset_max - yaw_offset_min) * Math.random() + yaw_offset_min;
    }
}
Source1ParticleOperators.registerOperator(RotationYawRandom);

class SequenceRandom extends Source1ParticleOperator {
    static functionName = 'Sequence Random';
    constructor(system) {
        super(system);
        this.addParam('sequence_min', PARAM_TYPE_FLOAT, 0);
        this.addParam('sequence_max', PARAM_TYPE_FLOAT, 0);
    }
    doInit(particle, elapsedTime) {
        const sequence_min = this.getParameter('sequence_min');
        const sequence_max = this.getParameter('sequence_max');
        const sequence = Math.round((sequence_max - sequence_min) * Math.random()) + sequence_min;
        particle.setInitialSequence(sequence);
    }
}
Source1ParticleOperators.registerOperator(SequenceRandom);

class TrailLengthRandom extends Source1ParticleOperator {
    static functionName = 'Trail Length Random';
    constructor(system) {
        super(system);
        this.addParam('length_min', PARAM_TYPE_FLOAT, 0.1);
        this.addParam('length_max', PARAM_TYPE_FLOAT, 0.1);
        this.addParam('length_random_exponent', PARAM_TYPE_FLOAT, 1);
        //	DMXELEMENT_UNPACK_FIELD('length_min', '0.1', float, m_flMinLength)
        //	DMXELEMENT_UNPACK_FIELD('length_max', '0.1', float, m_flMaxLength)
        //	DMXELEMENT_UNPACK_FIELD('length_random_exponent', '1', float, m_flLengthRandExponent)
    }
    doInit(particle, elapsedTime) {
        const length_min = this.getParameter('length_min');
        const length_max = this.getParameter('length_max');
        const length_random_exponent = this.getParameter('length_random_exponent');
        particle.trailLength = RandomFloatExp(length_min, length_max, length_random_exponent);
    }
}
Source1ParticleOperators.registerOperator(TrailLengthRandom);

const Four_Zeros = 0;
const Four_Ones = 1;
const Four_Twos = 2;
const Four_PointFives = 0.5;
function CmpGtSIMD(a, b) {
    return a > b;
}
function CmpGeSIMD(a, b) {
    return a >= b;
}
function CmpLtSIMD(a, b) {
    return a < b;
}
function AndSIMD(a, b) {
    return a && b;
}
function MulSIMD(a, b) {
    return a * b;
}
function DivSIMD(a, b) {
    return a / b;
}
function AddSIMD(a, b) {
    return a + b;
}
function SubSIMD(a, b) {
    return a - b;
}
function ReciprocalEstSIMD(a) {
    return 1 / a;
}
function ReciprocalSIMD(a) {
    return 1 / a;
}
function MaxSIMD(a, b) {
    return Math.max(a, b);
}
function MinSIMD(a, b) {
    return Math.min(a, b);
}
function BiasSIMD(val, precalc_param) {
    // similar to bias function except pass precalced bias value from calling PreCalcBiasParameter.
    // !!speed!! use reciprocal est?
    // !!speed!! could save one op by precalcing _2_ values
    return DivSIMD(val, AddSIMD(MulSIMD(precalc_param, SubSIMD(Four_Ones, val)), Four_Ones));
}
function MaskedAssign(ReplacementMask, NewValue, OldValue) {
    // TODO: params are vec4
    return ReplacementMask ? NewValue : OldValue;
    /*return OrSIMD(
        AndSIMD(ReplacementMask, NewValue),
        AndNotSIMD(ReplacementMask, OldValue));*/
}
function SinEst01SIMD(val) {
    return Math.sin(val * Math.PI);
}
function SimpleSplineRemapValWithDeltasClamped(val, A, BMinusA, OneOverBMinusA, C, DMinusC) {
    //	if (A == B)
    //		return val >= B ? D : C;
    let cVal = (val - A) * OneOverBMinusA; //fltx4 cVal = MulSIMD(SubSIMD(val, A), OneOverBMinusA);
    cVal = Math.min(Math.max(0.0, cVal), 1.0); //Clamp(cVal, 0.0, 1.0);//cVal = MinSIMD(Four_Ones, MaxSIMD(Four_Zeros, cVal));
    return C + DMinusC * SimpleSpline(cVal); //AddSIMD(C, MulSIMD(DMinusC, SimpleSpline(cVal)));
}

const perm_a = [
    66, 147, 106, 213, 89, 115, 239, 25, 171, 175, 9, 114, 141, 226, 118, 128, 41, 208, 4, 56,
    180, 248, 43, 82, 246, 219, 94, 245, 133, 131, 222, 103, 160, 130, 168, 145, 238, 38, 23, 6,
    236, 67, 99, 2, 70, 232, 80, 209, 1, 3, 68, 65, 102, 210, 13, 73, 55, 252, 187, 170, 22, 36,
    52, 181, 117, 163, 46, 79, 166, 224, 148, 75, 113, 95, 156, 185, 220, 164, 51, 142, 161, 35,
    206, 251, 45, 136, 197, 190, 132, 32, 218, 127, 63, 27, 137, 93, 242, 20, 189, 108, 183,
    122, 139, 191, 249, 253, 87, 98, 69, 0, 144, 64, 24, 214, 97, 116, 158, 42, 107, 15, 53, 212,
    83, 111, 152, 240, 74, 237, 62, 77, 205, 149, 26, 151, 178, 204, 91, 176, 234, 49, 154, 203,
    33, 221, 125, 134, 165, 124, 86, 39, 37, 60, 150, 157, 179, 109, 110, 44, 159, 153, 5, 100,
    10, 207, 40, 186, 96, 215, 143, 162, 230, 184, 101, 54, 174, 247, 76, 59, 241, 223, 192, 84,
    104, 78, 169, 146, 138, 30, 48, 85, 233, 19, 29, 92, 126, 17, 199, 250, 31, 81, 188, 225, 28,
    112, 88, 11, 182, 173, 211, 129, 194, 172, 14, 120, 200, 167, 135, 12, 177, 227, 229, 155,
    201, 61, 105, 195, 193, 244, 235, 58, 8, 196, 123, 254, 16, 18, 50, 121, 71, 243, 90, 57,
    202, 119, 255, 47, 7, 198, 228, 21, 217, 216, 231, 140, 72, 34
];
const perm_b = [
    123, 108, 201, 64, 40, 75, 24, 221, 137, 110, 191, 142, 9, 69, 230, 83, 7, 247, 51, 54, 115,
    133, 180, 248, 109, 116, 62, 99, 251, 55, 89, 253, 65, 106, 228, 167, 131, 132, 58, 143,
    97, 102, 163, 202, 149, 234, 12, 117, 174, 94, 121, 74, 32, 113, 20, 60, 159, 182, 204, 29,
    244, 118, 3, 178, 255, 38, 6, 114, 36, 93, 30, 134, 213, 90, 245, 209, 88, 232, 162, 125,
    84, 166, 70, 136, 208, 231, 27, 71, 157, 80, 76, 0, 170, 225, 203, 176, 33, 161, 196, 128,
    252, 236, 246, 2, 138, 1, 250, 197, 77, 243, 218, 242, 19, 164, 68, 212, 14, 237, 144, 63,
    46, 103, 177, 188, 85, 223, 8, 160, 222, 4, 216, 219, 35, 15, 44, 23, 126, 127, 100, 226,
    235, 37, 168, 101, 49, 22, 11, 73, 61, 135, 111, 183, 72, 96, 185, 239, 82, 18, 50, 155,
    186, 153, 17, 233, 146, 156, 107, 5, 254, 10, 192, 198, 148, 207, 104, 13, 124, 48, 95,
    129, 120, 206, 199, 81, 249, 91, 150, 210, 119, 240, 122, 194, 92, 34, 28, 205, 175, 227,
    179, 220, 140, 152, 79, 26, 195, 47, 66, 173, 169, 241, 53, 184, 187, 145, 112, 238, 214,
    147, 98, 171, 229, 200, 151, 25, 67, 78, 189, 217, 130, 224, 57, 172, 59, 41, 43, 16, 105,
    158, 165, 21, 45, 56, 141, 139, 215, 190, 86, 42, 52, 39, 87, 181, 31, 154, 193, 211
];
const perm_c = [
    97, 65, 96, 25, 122, 26, 219, 85, 148, 251, 102, 0, 140, 130, 136, 213, 138, 60, 236, 52,
    178, 131, 115, 183, 144, 78, 147, 168, 39, 45, 169, 70, 57, 146, 67, 142, 252, 216, 28, 54,
    86, 222, 194, 200, 48, 5, 205, 125, 214, 56, 181, 255, 196, 155, 37, 218, 153, 208, 66,
    242, 73, 248, 206, 61, 62, 246, 177, 2, 197, 107, 162, 152, 89, 41, 6, 160, 94, 8, 201, 38,
    235, 228, 165, 93, 111, 239, 74, 231, 121, 47, 166, 221, 157, 64, 77, 244, 29, 105, 150,
    123, 190, 191, 225, 118, 133, 42, 10, 84, 185, 159, 124, 132, 240, 180, 44, 1, 9, 19, 99,
    254, 12, 207, 186, 71, 234, 184, 11, 20, 16, 193, 139, 175, 98, 59, 113, 27, 170, 230, 91,
    187, 46, 156, 249, 108, 195, 171, 114, 14, 188, 82, 192, 233, 24, 32, 241, 87, 164, 90, 43,
    163, 245, 92, 40, 215, 55, 226, 15, 3, 112, 158, 250, 172, 22, 227, 137, 35, 128, 145, 247,
    161, 119, 80, 217, 189, 81, 7, 63, 202, 120, 223, 83, 179, 4, 106, 199, 229, 95, 53, 50, 33,
    182, 72, 143, 23, 243, 75, 18, 173, 141, 167, 198, 204, 58, 174, 237, 17, 129, 238, 127,
    31, 101, 176, 36, 30, 110, 209, 34, 203, 135, 232, 68, 149, 49, 134, 126, 212, 79, 76, 117,
    104, 210, 211, 224, 253, 100, 220, 109, 116, 88, 13, 151, 154, 69, 21, 51, 103
];
const impulse_xcoords = [
    0.788235, 0.541176, 0.972549, 0.082353, 0.352941, 0.811765, 0.286275, 0.752941,
    0.203922, 0.705882, 0.537255, 0.886275, 0.580392, 0.137255, 0.800000, 0.533333,
    0.117647, 0.447059, 0.129412, 0.925490, 0.086275, 0.478431, 0.666667, 0.568627,
    0.678431, 0.313725, 0.321569, 0.349020, 0.988235, 0.419608, 0.898039, 0.219608,
    0.243137, 0.623529, 0.501961, 0.772549, 0.952941, 0.517647, 0.949020, 0.701961,
    0.454902, 0.505882, 0.564706, 0.960784, 0.207843, 0.007843, 0.831373, 0.184314,
    0.576471, 0.462745, 0.572549, 0.247059, 0.262745, 0.694118, 0.615686, 0.121569,
    0.384314, 0.749020, 0.145098, 0.717647, 0.415686, 0.607843, 0.105882, 0.101961,
    0.200000, 0.807843, 0.521569, 0.780392, 0.466667, 0.552941, 0.996078, 0.627451,
    0.992157, 0.529412, 0.407843, 0.011765, 0.709804, 0.458824, 0.058824, 0.819608,
    0.176471, 0.317647, 0.392157, 0.223529, 0.156863, 0.490196, 0.325490, 0.074510,
    0.239216, 0.164706, 0.890196, 0.603922, 0.921569, 0.839216, 0.854902, 0.098039,
    0.686275, 0.843137, 0.152941, 0.372549, 0.062745, 0.474510, 0.486275, 0.227451,
    0.400000, 0.298039, 0.309804, 0.274510, 0.054902, 0.815686, 0.647059, 0.635294,
    0.662745, 0.976471, 0.094118, 0.509804, 0.650980, 0.211765, 0.180392, 0.003922,
    0.827451, 0.278431, 0.023529, 0.525490, 0.450980, 0.725490, 0.690196, 0.941176,
    0.639216, 0.560784, 0.196078, 0.364706, 0.043137, 0.494118, 0.796078, 0.113725,
    0.760784, 0.729412, 0.258824, 0.290196, 0.584314, 0.674510, 0.823529, 0.905882,
    0.917647, 0.070588, 0.862745, 0.345098, 0.913725, 0.937255, 0.031373, 0.215686,
    0.768627, 0.333333, 0.411765, 0.423529, 0.945098, 0.721569, 0.039216, 0.792157,
    0.956863, 0.266667, 0.254902, 0.047059, 0.294118, 0.658824, 0.250980, 1.000000,
    0.984314, 0.756863, 0.027451, 0.305882, 0.835294, 0.513725, 0.360784, 0.776471,
    0.611765, 0.192157, 0.866667, 0.858824, 0.592157, 0.803922, 0.141176, 0.435294,
    0.588235, 0.619608, 0.341176, 0.109804, 0.356863, 0.270588, 0.737255, 0.847059,
    0.050980, 0.764706, 0.019608, 0.870588, 0.933333, 0.784314, 0.549020, 0.337255,
    0.631373, 0.929412, 0.231373, 0.427451, 0.078431, 0.498039, 0.968627, 0.654902,
    0.125490, 0.698039, 0.015686, 0.878431, 0.713725, 0.368627, 0.431373, 0.874510,
    0.403922, 0.556863, 0.443137, 0.964706, 0.909804, 0.301961, 0.035294, 0.850980,
    0.882353, 0.741176, 0.380392, 0.133333, 0.470588, 0.643137, 0.282353, 0.396078,
    0.980392, 0.168627, 0.149020, 0.235294, 0.670588, 0.596078, 0.733333, 0.160784,
    0.376471, 0.682353, 0.545098, 0.482353, 0.745098, 0.894118, 0.188235, 0.329412,
    0.439216, 0.901961, 0.000000, 0.600000, 0.388235, 0.172549, 0.090196, 0.066667
];

function GetLatticePointValue(idx_x, idx_y, idx_z) {
    let ret_idx = perm_a[idx_x & 0xff];
    ret_idx = perm_b[(idx_y + ret_idx) & 0xff];
    ret_idx = perm_c[(idx_z + ret_idx) & 0xff];
    return impulse_xcoords[ret_idx];
}
const MAGIC_NUMBER = 1 << 15;
const Four_MagicNumbers = MAGIC_NUMBER;
const DATAVIEW = new DataView(new ArrayBuffer(4));
const INV_256 = 1 / 256.;
function NoiseSIMD(x, y, z) {
    // use magic to convert to integer index
    /*fltx4 x_idx = AndSIMD( MASK255, AddSIMD( x, Four_MagicNumbers ) );
    fltx4 y_idx = AndSIMD( MASK255, AddSIMD( y, Four_MagicNumbers ) );
    fltx4 z_idx = AndSIMD( MASK255, AddSIMD( z, Four_MagicNumbers ) );*/
    DATAVIEW.setFloat32(0, AddSIMD(x, Four_MagicNumbers), true);
    const x_idx = DATAVIEW.getUint16(0, true);
    DATAVIEW.setFloat32(0, AddSIMD(y, Four_MagicNumbers), true);
    const y_idx = DATAVIEW.getUint16(0, true);
    DATAVIEW.setFloat32(0, AddSIMD(z, Four_MagicNumbers), true);
    const z_idx = DATAVIEW.getUint16(0, true);
    //console.log(x_idx, y_idx, z_idx);
    /*fltx4 lattice000 = Four_Zeros, lattice001 = Four_Zeros, lattice010 = Four_Zeros, lattice011 = Four_Zeros;
    fltx4 lattice100 = Four_Zeros, lattice101 = Four_Zeros, lattice110 = Four_Zeros, lattice111 = Four_Zeros;*/
    let lattice000 = Four_Zeros, lattice001 = Four_Zeros, lattice010 = Four_Zeros, lattice011 = Four_Zeros;
    let lattice100 = Four_Zeros, lattice101 = Four_Zeros, lattice110 = Four_Zeros, lattice111 = Four_Zeros;
    // FIXME: Converting the input vectors to int indices will cause load-hit-stores (48 bytes)
    //        Converting the indexed noise values back to vectors will cause more (128 bytes)
    //        The noise table could store vectors if we chunked it into 2x2x2 blocks.
    //fltx4 xfrac = Four_Zeros, yfrac = Four_Zeros, zfrac = Four_Zeros;
    let xfrac = Four_Zeros, yfrac = Four_Zeros, zfrac = Four_Zeros;
    /*#define DOPASS(i)															\
        {	unsigned int xi = SubInt( x_idx, i );								\
            unsigned int yi = SubInt( y_idx, i );								\
            unsigned int zi = SubInt( z_idx, i );								\
            SubFloat( xfrac, i ) = (xi & 0xff)*(1.0/256.0);						\
            SubFloat( yfrac, i ) = (yi & 0xff)*(1.0/256.0);						\
            SubFloat( zfrac, i ) = (zi & 0xff)*(1.0/256.0);						\
            xi>>=8;																\
            yi>>=8;																\
            zi>>=8;																\
                                                                                \
            SubFloat( lattice000, i ) = GetLatticePointValue( xi,yi,zi );		\
            SubFloat( lattice001, i ) = GetLatticePointValue( xi,yi,zi+1 );		\
            SubFloat( lattice010, i ) = GetLatticePointValue( xi,yi+1,zi );		\
            SubFloat( lattice011, i ) = GetLatticePointValue( xi,yi+1,zi+1 );	\
            SubFloat( lattice100, i ) = GetLatticePointValue( xi+1,yi,zi );		\
            SubFloat( lattice101, i ) = GetLatticePointValue( xi+1,yi,zi+1 );	\
            SubFloat( lattice110, i ) = GetLatticePointValue( xi+1,yi+1,zi );	\
            SubFloat( lattice111, i ) = GetLatticePointValue( xi+1,yi+1,zi+1 );	\
        }*/
    function DOPASS(i) {
        /*unsigned int xi = SubInt( x_idx, i );
        unsigned int yi = SubInt( y_idx, i );
        unsigned int zi = SubInt( z_idx, i );*/
        let xi = x_idx;
        let yi = y_idx;
        let zi = z_idx;
        /*SubFloat( xfrac, i ) = (xi & 0xff)*(1.0/256.0);
        SubFloat( yfrac, i ) = (yi & 0xff)*(1.0/256.0);
        SubFloat( zfrac, i ) = (zi & 0xff)*(1.0/256.0);*/
        xfrac = (xi & 0xff) * INV_256;
        yfrac = (yi & 0xff) * INV_256;
        zfrac = (zi & 0xff) * INV_256;
        xi >>= 8;
        yi >>= 8;
        zi >>= 8;
        /*SubFloat( lattice000, i ) = GetLatticePointValue( xi,yi,zi );
        SubFloat( lattice001, i ) = GetLatticePointValue( xi,yi,zi+1 );
        SubFloat( lattice010, i ) = GetLatticePointValue( xi,yi+1,zi );
        SubFloat( lattice011, i ) = GetLatticePointValue( xi,yi+1,zi+1 );
        SubFloat( lattice100, i ) = GetLatticePointValue( xi+1,yi,zi );
        SubFloat( lattice101, i ) = GetLatticePointValue( xi+1,yi,zi+1 );
        SubFloat( lattice110, i ) = GetLatticePointValue( xi+1,yi+1,zi );
        SubFloat( lattice111, i ) = GetLatticePointValue( xi+1,yi+1,zi+1 );*/
        lattice000 = GetLatticePointValue(xi, yi, zi);
        lattice001 = GetLatticePointValue(xi, yi, zi + 1);
        lattice010 = GetLatticePointValue(xi, yi + 1, zi);
        lattice011 = GetLatticePointValue(xi, yi + 1, zi + 1);
        lattice100 = GetLatticePointValue(xi + 1, yi, zi);
        lattice101 = GetLatticePointValue(xi + 1, yi, zi + 1);
        lattice110 = GetLatticePointValue(xi + 1, yi + 1, zi);
        lattice111 = GetLatticePointValue(xi + 1, yi + 1, zi + 1);
    }
    DOPASS();
    /*DOPASS( 1 );
    DOPASS( 2 );
    DOPASS( 3 );*/
    // now, we have 8 lattice values for each of four points as m128s, and interpolant values for
    // each axis in m128 form in [xyz]frac. Perfom the trilinear interpolation as SIMD ops
    // first, do x interpolation
    /*fltx4 l2d00 = AddSIMD( lattice000, MulSIMD( xfrac, SubSIMD( lattice100, lattice000 ) ) );
    fltx4 l2d01 = AddSIMD( lattice001, MulSIMD( xfrac, SubSIMD( lattice101, lattice001 ) ) );
    fltx4 l2d10 = AddSIMD( lattice010, MulSIMD( xfrac, SubSIMD( lattice110, lattice010 ) ) );
    fltx4 l2d11 = AddSIMD( lattice011, MulSIMD( xfrac, SubSIMD( lattice111, lattice011 ) ) );*/
    const l2d00 = AddSIMD(lattice000, MulSIMD(xfrac, SubSIMD(lattice100, lattice000)));
    const l2d01 = AddSIMD(lattice001, MulSIMD(xfrac, SubSIMD(lattice101, lattice001)));
    const l2d10 = AddSIMD(lattice010, MulSIMD(xfrac, SubSIMD(lattice110, lattice010)));
    const l2d11 = AddSIMD(lattice011, MulSIMD(xfrac, SubSIMD(lattice111, lattice011)));
    // now, do y interpolation
    /*fltx4 l1d0 = AddSIMD( l2d00, MulSIMD( yfrac, SubSIMD( l2d10, l2d00 ) ) );
    fltx4 l1d1 = AddSIMD( l2d01, MulSIMD( yfrac, SubSIMD( l2d11, l2d01 ) ) );*/
    const l1d0 = AddSIMD(l2d00, MulSIMD(yfrac, SubSIMD(l2d10, l2d00)));
    const l1d1 = AddSIMD(l2d01, MulSIMD(yfrac, SubSIMD(l2d11, l2d01)));
    // final z interpolation
    //fltx4 rslt = AddSIMD( l1d0, MulSIMD( zfrac, SubSIMD( l1d1, l1d0 ) ) );
    const rslt = AddSIMD(l1d0, MulSIMD(zfrac, SubSIMD(l1d1, l1d0)));
    // map to 0..1
    return MulSIMD(Four_Twos, SubSIMD(rslt, Four_PointFives));
}

class VelocityNoise extends Source1ParticleOperator {
    static functionName = 'Velocity Noise';
    #randX = Math.random() * 1000;
    #randY = Math.random() * 1000;
    #randZ = Math.random() * 1000;
    constructor(system) {
        super(system);
        this.addParam('', PARAM_TYPE_INT, 0);
        this.addParam('Control Point Number', PARAM_TYPE_INT, 0);
        this.addParam('Time Noise Coordinate Scale', PARAM_TYPE_FLOAT, 1.0);
        this.addParam('Spatial Noise Coordinate Scale', PARAM_TYPE_FLOAT, 0.01);
        this.addParam('Time Coordinate Offset', PARAM_TYPE_FLOAT, 0.0);
        this.addParam('Spatial Coordinate Offset', PARAM_TYPE_VECTOR, vec3.create());
        this.addParam('Absolute Value', PARAM_TYPE_VECTOR, vec3.create());
        this.addParam('Invert Abs Value', PARAM_TYPE_VECTOR, vec3.create());
        this.addParam('output minimum', PARAM_TYPE_VECTOR, vec3.create());
        this.addParam('output maximum', PARAM_TYPE_VECTOR, vec3.fromValues(1, 1, 1));
        this.addParam('Apply Velocity in Local Space (0/1)', PARAM_TYPE_BOOL, false);
        //	DMXELEMENT_UNPACK_FIELD('Control Point Number','0',int,m_nControlPointNumber)
        //	DMXELEMENT_UNPACK_FIELD('Time Noise Coordinate Scale','1',float,m_flNoiseScale)
        //	DMXELEMENT_UNPACK_FIELD('Spatial Noise Coordinate Scale','0.01',float,m_flNoiseScaleLoc)
        //	DMXELEMENT_UNPACK_FIELD('Time Coordinate Offset','0', float, m_flOffset)
        //	DMXELEMENT_UNPACK_FIELD('Spatial Coordinate Offset','0 0 0', Vector, m_vecOffsetLoc)
        //	DMXELEMENT_UNPACK_FIELD('Absolute Value','0 0 0', Vector, m_vecAbsVal)
        //	DMXELEMENT_UNPACK_FIELD('Invert Abs Value','0 0 0', Vector, m_vecAbsValInv)
        //	DMXELEMENT_UNPACK_FIELD('output minimum','0 0 0', Vector, m_vecOutputMin)
        //	DMXELEMENT_UNPACK_FIELD('output maximum','1 1 1', Vector, m_vecOutputMax)
        //	DMXELEMENT_UNPACK_FIELD('Apply Velocity in Local Space (0/1)','0', bool, m_bLocalSpace)
    }
    doInit(particle, elapsedTime) {
        const m_nControlPointNumber = this.getParameter('Control Point Number');
        const m_flNoiseScale = this.getParameter('Time Noise Coordinate Scale');
        const m_flNoiseScaleLoc = this.getParameter('Spatial Noise Coordinate Scale');
        const m_flOffset = this.getParameter('Time Coordinate Offset');
        const m_vecOffsetLoc = this.getParameter('Spatial Coordinate Offset');
        const m_vecAbsVal = this.getParameter('Absolute Value');
        const m_vecAbsValInv = this.getParameter('Invert Abs Value');
        const m_vecOutputMin = this.getParameter('output minimum');
        const m_vecOutputMax = this.getParameter('output maximum');
        const m_bLocalSpace = this.getParameter('Apply Velocity in Local Space (0/1)');
        //	DMXELEMENT_UNPACK_FIELD('Control Point Number','0',int,m_nControlPointNumber)
        //	DMXELEMENT_UNPACK_FIELD('Time Noise Coordinate Scale','1',float,m_flNoiseScale)
        //	DMXELEMENT_UNPACK_FIELD('Spatial Noise Coordinate Scale','0.01',float,m_flNoiseScaleLoc)
        //	DMXELEMENT_UNPACK_FIELD('Time Coordinate Offset','0', float, m_flOffset)
        //	DMXELEMENT_UNPACK_FIELD('Spatial Coordinate Offset','0 0 0', Vector, m_vecOffsetLoc)
        //	DMXELEMENT_UNPACK_FIELD('Absolute Value','0 0 0', Vector, m_vecAbsVal)
        //	DMXELEMENT_UNPACK_FIELD('Invert Abs Value','0 0 0', Vector, m_vecAbsValInv)
        //	DMXELEMENT_UNPACK_FIELD('output minimum','0 0 0', Vector, m_vecOutputMin)
        //	DMXELEMENT_UNPACK_FIELD('output maximum','1 1 1', Vector, m_vecOutputMax)
        //	DMXELEMENT_UNPACK_FIELD('Apply Velocity in Local Space (0/1)','0', bool, m_bLocalSpace)
        let flAbsScaleX, flAbsScaleY, flAbsScaleZ;
        flAbsScaleX = 0.5;
        flAbsScaleY = 0.5;
        flAbsScaleZ = 0.5;
        // Set up single if check for absolute value inversion inside the loop
        const m_bNoiseAbs = (m_vecAbsValInv[0] != 0.0) || (m_vecAbsValInv[1] != 0.0) || (m_vecAbsValInv[2] != 0.0);
        // Set up values for more optimal absolute value calculations inside the loop
        if (m_vecAbsVal[0] != 0.0) {
            g_SIMD_clear_signmask;
            flAbsScaleX = 1.0;
        }
        if (m_vecAbsVal[1] != 0.0) {
            g_SIMD_clear_signmask;
            flAbsScaleY = 1.0;
        }
        if (m_vecAbsVal[2] != 0.0) {
            g_SIMD_clear_signmask;
            flAbsScaleZ = 1.0;
        }
        const ValueScaleX = (flAbsScaleX * (m_vecOutputMax[0] - m_vecOutputMin[0]));
        const ValueBaseX = (m_vecOutputMin[0] + ((1.0 - flAbsScaleX) * (m_vecOutputMax[0] - m_vecOutputMin[0])));
        const ValueScaleY = (flAbsScaleY * (m_vecOutputMax[1] - m_vecOutputMin[1]));
        const ValueBaseY = (m_vecOutputMin[1] + ((1.0 - flAbsScaleY) * (m_vecOutputMax[1] - m_vecOutputMin[1])));
        const ValueScaleZ = (flAbsScaleZ * (m_vecOutputMax[2] - m_vecOutputMin[2]));
        const ValueBaseZ = (m_vecOutputMin[2] + ((1.0 - flAbsScaleZ) * (m_vecOutputMax[2] - m_vecOutputMin[2])));
        const fl4ValueBaseX = ValueBaseX;
        const fl4ValueBaseY = ValueBaseY;
        const fl4ValueBaseZ = ValueBaseZ;
        const fl4ValueScaleX = ValueScaleX;
        const fl4ValueScaleY = ValueScaleY;
        const fl4ValueScaleZ = ValueScaleZ;
        const CoordScale = m_flNoiseScale;
        const CoordScaleLoc = m_flNoiseScaleLoc;
        const ofs_y = vec3.fromValues(100000.5, 300000.25, 9000000.75);
        const ofs_z = vec3.fromValues(110000.25, 310000.75, 9100000.5);
        /*size_t attr_stride;

        const FourVectors *xyz = pParticles->Get4VAttributePtr(PARTICLE_ATTRIBUTE_XYZ, &attr_stride);
        xyz += attr_stride * start_block;
        FourVectors *pxyz = pParticles->Get4VAttributePtrForWrite(PARTICLE_ATTRIBUTE_PREV_XYZ, &attr_stride);
        pxyz += attr_stride * start_block;
        const fltx4 *pCreationTime = pParticles->GetM128AttributePtr(PARTICLE_ATTRIBUTE_CREATION_TIME, &attr_stride);
        pCreationTime += attr_stride * start_block;*/
        // setup
        /*fltx4 fl4Offset = ReplicateX4(m_flOffset);*/
        vec3.clone(m_vecOffsetLoc); //TODO use it ?
        /*CParticleSIMDTransformation CPTransform;
        float flCreationTime = SubFloat(*pCreationTime, 0);
        pParticles->GetControlPointTransformAtTime(m_nControlPointNumber, flCreationTime, &CPTransform);*/
        //while(n_blocks--)
        {
            const fvCoordLoc = vec3.clone(particle.position);
            vec3.add(fvCoordLoc, fvCoordLoc, fvCoordLoc); //fvCoordLoc += fvOffsetLoc;
            const c = particle.cTime * 30 + m_flOffset; //vec3.add(vec3.create(), [particle.cTime, particle.cTime, particle.cTime], m_flOffset);
            const fvCoord = vec3.fromValues(c, c, c);
            //fvCoord[0] = AddSIMD(*pCreationTime, fl4Offset);
            //fvCoord[1] = AddSIMD(*pCreationTime, fl4Offset);
            //fvCoord[2] = AddSIMD(*pCreationTime, fl4Offset);
            vec3.scale(fvCoordLoc, fvCoordLoc, CoordScaleLoc); //fvCoordLoc *= CoordScaleLoc;
            vec3.scale(fvCoord, fvCoord, CoordScale * 0.01); //fvCoord *= CoordScale;
            vec3.add(fvCoord, fvCoord, fvCoordLoc); //fvCoord += fvCoordLoc;
            const fvCoord2 = vec3.clone(fvCoord);
            let fvOffsetTemp = vec3.clone(ofs_y);
            //fvOffsetTemp.DuplicateVector(ofs_y);
            vec3.add(fvCoord2, fvCoord2, fvOffsetTemp); //fvCoord2 +=	fvOffsetTemp;
            const fvCoord3 = vec3.clone(fvCoord);
            fvOffsetTemp = vec3.clone(ofs_z);
            //fvOffsetTemp.DuplicateVector(ofs_z);
            vec3.add(fvCoord3, fvCoord3, fvOffsetTemp); //fvCoord3 += fvOffsetTemp;
            let fl4NoiseX = NoiseSIMD(fvCoord[0], fvCoord[1], fvCoord[2]);
            let fl4NoiseY = NoiseSIMD(fvCoord2[0], fvCoord2[1], fvCoord2[2]);
            let fl4NoiseZ = NoiseSIMD(fvCoord3[0], fvCoord3[1], fvCoord3[2]);
            //console.log(fl4NoiseX/*, fl4NoiseY, fl4NoiseZ*/);
            //fl4NoiseX = fl4NoiseX & fl4AbsValX;//AndSIMD (fl4NoiseX, fl4AbsValX);
            //fl4NoiseY = fl4NoiseY & fl4AbsValY;//AndSIMD (fl4NoiseY, fl4AbsValY);
            //fl4NoiseZ = fl4NoiseZ & fl4AbsValZ;//AndSIMD (fl4NoiseZ, fl4AbsValZ);
            //fl4NoiseX = Math.random();
            //fl4NoiseY = Math.random();
            //fl4NoiseZ = Math.random();
            if (m_bNoiseAbs) {
                if (m_vecAbsValInv[0] != 0.0) {
                    fl4NoiseX = 1.0 - fl4NoiseX; //SubSIMD(Four_Ones, fl4NoiseX);
                }
                if (m_vecAbsValInv[1] != 0.0) {
                    fl4NoiseY = 1.0 - fl4NoiseY; //SubSIMD(Four_Ones, fl4NoiseY);
                }
                if (m_vecAbsValInv[2] != 0.0) {
                    fl4NoiseZ = 1.0 - fl4NoiseZ; //SubSIMD(Four_Ones, fl4NoiseZ);
                }
            }
            const fvOffset = vec3.create();
            fvOffset[0] = fl4ValueBaseX + fl4ValueScaleX * fl4NoiseX; //AddSIMD(fl4ValueBaseX, (MulSIMD(fl4ValueScaleX , fl4NoiseX)));
            fvOffset[1] = fl4ValueBaseY + fl4ValueScaleY * fl4NoiseY; //AddSIMD(fl4ValueBaseY, (MulSIMD(fl4ValueScaleY , fl4NoiseY)));
            fvOffset[2] = fl4ValueBaseZ + fl4ValueScaleZ * fl4NoiseZ; //AddSIMD(fl4ValueBaseZ, (MulSIMD(fl4ValueScaleZ , fl4NoiseZ)));
            //TODO fvOffset *= pParticles->m_flPreviousDt;
            if (m_bLocalSpace) {
                //CPTransform.VectorRotate(fvOffset);
                //TODO
                const cp = particle.system.getControlPoint(m_nControlPointNumber);
                if (cp) {
                    vec3.transformQuat(fvOffset, fvOffset, cp.getWorldQuaternion());
                    //vec3.add(randpos, randpos, cp.getOrigin());
                }
            }
            //console.log(fvOffset);
            vec3.add(particle.velocity, particle.velocity, fvOffset);
            vec3.scaleAndAdd(particle.prevPosition, particle.prevPosition, fvOffset, -elapsedTime);
            //vec3.scaleAndAdd(particle.velocity, particle.velocity, fvOffset, -10);
            //vec3.scaleAndAdd(particle.prevPosition, particle.prevPosition, fvOffset, -this.particleSystem.elapsedTime);
            //vec3.scaleAndAdd(particle.prevPosition, particle.position, fvOffset, 0.1);
            //vec3.scaleAndAdd(particle.prevPosition, particle.position, [0, 0, 1], 0.1);
            //particle.prevPosition = vec3.create();
        }
    }
    initMultipleOverride() {
        return true;
    }
}
Source1ParticleOperators.registerOperator(VelocityNoise);
/*

VelocityNoise.prototype.getNoise = function (particle, time) {
    //return NoiseSIMD(particle.position, particle.cTime);
    //return Math.random();
    return Math.cos(time * 5) * 0.5 + 0.5;
}
    */
// Clamp velocity to min/max values if set
/*VelocityNoise.prototype.clampVelocity = function(velocity) {
    const output_minimum = this.getParameter('output minimum');
    const output_maximum = this.getParameter('output maximum');

    if (output_minimum != null) {
        if (velocity.x < output_minimum.x) velocity.x = output_minimum.x;
        if (velocity.y < output_minimum.y) velocity.y = output_minimum.y;
        if (velocity.z < output_minimum.z) velocity.z = output_minimum.z;
    }

    if (output_maximum != null) {
        if (velocity.x > output_maximum.x) velocity.x = output_maximum.x;
        if (velocity.y > output_maximum.y) velocity.y = output_maximum.y;
        if (velocity.z > output_maximum.z) velocity.z = output_maximum.z;
    }
}*/
//TODO: place somewhere else
const g_SIMD_clear_signmask = 0x7fffffff;

const identityVec3 = vec3.create();
const tempVec3$b = vec3.create();
let VelocityRandom$1 = class VelocityRandom extends Source1ParticleOperator {
    static functionName = 'Velocity Random';
    constructor(system) {
        super(system);
        this.addParam('control_point_number', PARAM_TYPE_INT, 0);
        this.addParam('random_speed_min', PARAM_TYPE_FLOAT, 0);
        this.addParam('random_speed_max', PARAM_TYPE_FLOAT, 0);
        this.addParam('speed_in_local_coordinate_system_min', PARAM_TYPE_VECTOR, vec3.create());
        this.addParam('speed_in_local_coordinate_system_max', PARAM_TYPE_VECTOR, vec3.create());
        //	DMXELEMENT_UNPACK_FIELD('control_point_number', '0', int, m_nControlPointNumber)
        //	DMXELEMENT_UNPACK_FIELD('random_speed_min', '0', float, m_fSpeedMin)
        //	DMXELEMENT_UNPACK_FIELD('random_speed_max', '0', float, m_fSpeedMax)
        //	DMXELEMENT_UNPACK_FIELD('speed_in_local_coordinate_system_min', '0 0 0', Vector, m_LocalCoordinateSystemSpeedMin)
        //	DMXELEMENT_UNPACK_FIELD('speed_in_local_coordinate_system_max', '0 0 0', Vector, m_LocalCoordinateSystemSpeedMax)
    }
    doInit(particle, elapsedTime) {
        const speed_in_local_coordinate_system_min = this.getParameter('speed_in_local_coordinate_system_min');
        const speed_in_local_coordinate_system_max = this.getParameter('speed_in_local_coordinate_system_max');
        const random_speed_min = this.getParameter('random_speed_min');
        const random_speed_max = this.getParameter('random_speed_max');
        const m_nControlPointNumber = this.getParameter('control_point_number');
        const randomVector = vec3.create();
        const randomSpeed = (random_speed_max - random_speed_min) * Math.random() + random_speed_min;
        if (vec3.exactEquals(speed_in_local_coordinate_system_min, identityVec3) &&
            vec3.exactEquals(speed_in_local_coordinate_system_max, identityVec3)) {
            vec3.random(randomVector); //randomVector.randomizeUnit();
        }
        else {
            vec3RandomBox(randomVector, speed_in_local_coordinate_system_min, speed_in_local_coordinate_system_max); //randomVector.randomize(speed_in_local_coordinate_system_min, speed_in_local_coordinate_system_max);
        }
        if (randomSpeed != 0) {
            vec3.random(tempVec3$b, randomSpeed);
            vec3.add(randomVector, randomVector, tempVec3$b);
        }
        const cp = particle.system.getControlPoint(m_nControlPointNumber);
        if (cp) {
            vec3.transformQuat(randomVector, randomVector, cp.getWorldQuaternion());
        }
        //vec3.copy(particle.velocity, randomVector);
        //vec3.add(particle.velocity, particle.velocity, randomVector);
        vec3.scale(randomVector, randomVector, -elapsedTime);
        vec3.add(particle.prevPosition, particle.prevPosition, randomVector);
    }
    initMultipleOverride() {
        return true;
    }
};
Source1ParticleOperators.registerOperator(VelocityRandom$1);

class AlphaFadeAndDecay extends Source1ParticleOperator {
    static functionName = 'Alpha Fade and Decay';
    constructor(system) {
        super(system);
        this.addParam('start_alpha', PARAM_TYPE_FLOAT, 1.0);
        this.addParam('end_alpha', PARAM_TYPE_FLOAT, 0.0);
        this.addParam('start_fade_in_time', PARAM_TYPE_FLOAT, 0);
        this.addParam('end_fade_in_time', PARAM_TYPE_FLOAT, 0.5);
        this.addParam('start_fade_out_time', PARAM_TYPE_FLOAT, 0.5);
        this.addParam('end_fade_out_time', PARAM_TYPE_FLOAT, 1.0);
    }
    doOperate(particle, elapsedTime) {
        const start_alpha = this.getParameter('start_alpha');
        const end_alpha = this.getParameter('end_alpha');
        const m_flStartFadeInTime = this.getParameter('start_fade_in_time');
        const m_flEndFadeInTime = this.getParameter('end_fade_in_time');
        const m_flStartFadeOutTime = this.getParameter('start_fade_out_time');
        const m_flEndFadeOutTime = this.getParameter('end_fade_out_time');
        const proportionOfLife = particle.currentTime / particle.timeToLive;
        const fl4FadeInDuration = m_flEndFadeInTime - m_flStartFadeInTime;
        const fl4OOFadeInDuration = 1.0 / fl4FadeInDuration;
        const fl4FadeOutDuration = m_flEndFadeOutTime - m_flStartFadeOutTime;
        const fl4OOFadeOutDuration = 1.0 / fl4FadeOutDuration;
        let fl4Goal, fl4NewAlpha;
        switch (true) {
            case proportionOfLife <= m_flStartFadeInTime:
                //				alpha = start_alpha;
                break;
            case proportionOfLife < m_flEndFadeInTime:
                fl4Goal = particle.startAlpha * start_alpha;
                fl4NewAlpha = SimpleSplineRemapValWithDeltasClamped(proportionOfLife, m_flStartFadeInTime, fl4FadeInDuration, fl4OOFadeInDuration, fl4Goal, particle.startAlpha - fl4Goal);
                particle.alpha = fl4NewAlpha;
                break;
            case proportionOfLife < m_flStartFadeOutTime:
                break;
            case proportionOfLife < m_flEndFadeOutTime:
                fl4Goal = particle.startAlpha * end_alpha;
                fl4NewAlpha = SimpleSplineRemapValWithDeltasClamped(proportionOfLife, m_flStartFadeOutTime, fl4FadeOutDuration, fl4OOFadeOutDuration, particle.startAlpha, fl4Goal - particle.startAlpha);
                particle.alpha = fl4NewAlpha;
                break;
        }
        //alpha *= particle.startAlpha;
        //particle.alpha = alpha;
        if (particle.timeToLive < particle.currentTime) {
            particle.die();
        }
    }
}
Source1ParticleOperators.registerOperator(AlphaFadeAndDecay);

class AlphaFadeInRandom extends Source1ParticleOperator {
    static functionName = 'Alpha Fade In Random';
    constructor(system) {
        super(system);
        this.addParam('fade in time min', PARAM_TYPE_FLOAT, 0.25);
        this.addParam('fade in time max', PARAM_TYPE_FLOAT, 0.25);
        this.addParam('fade in time exponent', PARAM_TYPE_FLOAT, 1);
        this.addParam('proportional 0/1', PARAM_TYPE_BOOL, 1);
    }
    doOperate(particle, elapsedTime) {
        const proportional = this.getParameter('proportional 0/1');
        const fade_in_time_min = this.getParameter('fade in time min');
        const fade_in_time_max = this.getParameter('fade in time max');
        const m_flFadeInTimeExp = this.getParameter('fade in time exponent');
        //const fade_in_time = (fade_in_time_max - fade_in_time_min) * Math.random() + fade_in_time_min;
        const fade_in_time = (fade_in_time_max - fade_in_time_min) * Math.pow(ParticleRandomFloat(particle.id, particle.system.operatorRandomSampleOffset), m_flFadeInTimeExp) + fade_in_time_min;
        let time;
        if (proportional == 1 && particle.timeToLive) {
            time = particle.currentTime / particle.timeToLive;
        }
        else {
            time = particle.currentTime;
        }
        let d, d2;
        if (time < fade_in_time) {
            d = fade_in_time;
            if (d != 0) {
                d2 = particle.startAlpha;
                particle.alpha = d2 / d * (time);
            }
        }
    }
}
Source1ParticleOperators.registerOperator(AlphaFadeInRandom);

class AlphaFadeOutRandom extends Source1ParticleOperator {
    static functionName = 'Alpha Fade Out Random';
    constructor(system) {
        super(system);
        this.addParam('fade out time min', PARAM_TYPE_FLOAT, 0.25);
        this.addParam('fade out time max', PARAM_TYPE_FLOAT, 0.25);
        this.addParam('fade out time exponent', PARAM_TYPE_FLOAT, 1);
        this.addParam('proportional 0/1', PARAM_TYPE_BOOL, 1);
        this.addParam('fade bias', PARAM_TYPE_FLOAT, 0.5); //Neutral bias
    }
    doOperate(particle, elapsedTime) {
        const proportional = this.getParameter('proportional 0/1');
        const fade_out_time_min = this.getParameter('fade out time min');
        const fade_out_time_max = this.getParameter('fade out time max');
        this.getParameter('fade bias');
        const m_flFadeOutTimeExp = this.getParameter('fade in time exponent');
        const fade_out_time = (fade_out_time_max - fade_out_time_min) * Math.pow(ParticleRandomFloat(particle.id, particle.system.operatorRandomSampleOffset), m_flFadeOutTimeExp) + fade_out_time_min;
        let time;
        let start_fade_out_time;
        let lifeSpan;
        if (proportional == 1) {
            time = particle.currentTime / particle.timeToLive;
            start_fade_out_time = 1 - fade_out_time;
            lifeSpan = 1 - time;
        }
        else {
            time = particle.currentTime;
            start_fade_out_time = particle.timeToLive - fade_out_time;
            lifeSpan = particle.timeToLive - time;
        }
        let alpha = 0;
        switch (true) {
            case time > start_fade_out_time:
                const d = fade_out_time;
                if (d != 0) {
                    const d2 = particle.startAlpha;
                    alpha = d2 * (lifeSpan);
                }
                break;
            default:
                alpha = particle.startAlpha;
                break;
        }
        particle.alpha = alpha;
    }
}
Source1ParticleOperators.registerOperator(AlphaFadeOutRandom);

class ColorFade extends Source1ParticleOperator {
    static functionName = 'Color Fade';
    constructor(system) {
        super(system);
        this.addParam('color_fade', PARAM_TYPE_COLOR, WHITE);
        this.addParam('fade_start_time', PARAM_TYPE_FLOAT, 0);
        this.addParam('fade_end_time', PARAM_TYPE_FLOAT, 1);
        this.addParam('ease_in_and_out', PARAM_TYPE_BOOL, 1);
        //	DMXELEMENT_UNPACK_FIELD('color_fade', '255 255 255 255', Color, m_ColorFade)
        //	DMXELEMENT_UNPACK_FIELD('fade_start_time', '0', float, m_flFadeStartTime)
        //	DMXELEMENT_UNPACK_FIELD('fade_end_time', '1', float, m_flFadeEndTime)
        //	DMXELEMENT_UNPACK_FIELD('ease_in_and_out', '1', bool, m_bEaseInOut)
    }
    doOperate(particle, elapsedTime) {
        const color_fade = this.getParameter('color_fade');
        const fade_start_time = this.getParameter('fade_start_time');
        const fade_end_time = this.getParameter('fade_end_time');
        const m_bEaseInOut = this.getParameter('ease_in_and_out');
        if (fade_start_time == fade_end_time) {
            return;
        }
        const ooInRange = 1 / (fade_end_time - fade_start_time);
        const color = new ParticleColor().setColor(particle.initialColor);
        const flLifeTime = particle.currentTime / particle.timeToLive;
        //if (proportionOfLife>1)proportionOfLife=1;
        /*
        if (proportionOfLife<fade_start_time) {
            return;
        }
            */
        let T = (flLifeTime - fade_start_time) * ooInRange;
        T = clamp$1(T, 0, 1);
        if (m_bEaseInOut) {
            T = SimpleSpline(T);
        }
        particle.color.r = (color_fade.r - color.r) * T + color.r;
        particle.color.g = (color_fade.g - color.g) * T + color.g;
        particle.color.b = (color_fade.b - color.b) * T + color.b;
        /*
                    if (proportionOfLife < fade_end_time) {
                        const a = (proportionOfLife - fade_start_time) / (fade_end_time - fade_start_time);
                        particle.color.r = (color_fade.r - color.r) * a + color.r;
                        particle.color.g = (color_fade.g - color.g) * a + color.g;
                        particle.color.b = (color_fade.b - color.b) * a + color.b;

                        return;
                    }*/
    }
}
Source1ParticleOperators.registerOperator(ColorFade);

let LifespanDecay$1 = class LifespanDecay extends Source1ParticleOperator {
    static functionName = 'Lifespan Decay';
    doOperate(particle, elapsedTime) {
        if (particle.timeToLive < particle.currentTime) {
            particle.die();
        }
    }
};
Source1ParticleOperators.registerOperator(LifespanDecay$1);

const tempVec3$a = vec3.create();
const tempMat4 = mat4.create();
const IDENTITY_MAT4$2 = mat4.create();
let LockToBone$1 = class LockToBone extends Source1ParticleOperator {
    static functionName = 'Movement Lock to Bone';
    constructor(system) {
        super(system);
        this.addParam('control_point_number', PARAM_TYPE_INT, 0);
    }
    doOperate(particle, elapsedTime) {
        const controlPoint = particle.system.getControlPoint(this.getParameter('control_point_number'));
        if (controlPoint) {
            // TODO : Actually we should get the model parenting the control point
            const controllingModel = controlPoint.parentModel;
            if (controllingModel) {
                const bones = particle.bones;
                const initialVec = particle.initialVec;
                if (bones && initialVec) {
                    tempMat4[0] = 0;
                    tempMat4[1] = 0;
                    tempMat4[2] = 0;
                    tempMat4[4] = 0;
                    tempMat4[5] = 0;
                    tempMat4[6] = 0;
                    tempMat4[8] = 0;
                    tempMat4[9] = 0;
                    tempMat4[10] = 0;
                    tempMat4[12] = 0;
                    tempMat4[13] = 0;
                    tempMat4[14] = 0;
                    vec3.copy(tempVec3$a, initialVec);
                    for (const [bone, boneWeight] of bones) {
                        let boneMat;
                        if (bone) {
                            boneMat = mat4.fromRotationTranslationScale(mat4.create(), bone.worldQuat, bone.worldPos, bone.worldScale);
                        }
                        else {
                            boneMat = IDENTITY_MAT4$2;
                        }
                        if (boneWeight && boneMat) {
                            tempMat4[0] += boneWeight * boneMat[0];
                            tempMat4[1] += boneWeight * boneMat[1];
                            tempMat4[2] += boneWeight * boneMat[2];
                            tempMat4[4] += boneWeight * boneMat[4];
                            tempMat4[5] += boneWeight * boneMat[5];
                            tempMat4[6] += boneWeight * boneMat[6];
                            tempMat4[8] += boneWeight * boneMat[8];
                            tempMat4[9] += boneWeight * boneMat[9];
                            tempMat4[10] += boneWeight * boneMat[10];
                            tempMat4[12] += boneWeight * boneMat[12];
                            tempMat4[13] += boneWeight * boneMat[13];
                            tempMat4[14] += boneWeight * boneMat[14];
                        }
                    }
                    vec3.transformMat4(tempVec3$a, tempVec3$a, tempMat4);
                    if (particle.initialVecOffset) {
                        vec3.add(tempVec3$a, tempVec3$a, particle.initialVecOffset);
                    }
                    vec3.copy(particle.prevPosition, particle.position);
                    vec3.copy(particle.position, tempVec3$a);
                }
            }
        }
    }
};
Source1ParticleOperators.registerOperator(LockToBone$1);

const tempVec3$9 = vec3.create();
const tempVec3_2$2 = vec3.create();
const tempVec3_3 = vec3.create();
class MovementBasic extends Source1ParticleOperator {
    static functionName = 'Movement Basic';
    constructor(system) {
        super(system);
        this.addParam('drag', PARAM_TYPE_FLOAT, 0);
        this.addParam('gravity', PARAM_TYPE_VECTOR, vec3.create());
        this.addParam('max constraint passes', PARAM_TYPE_INT, 3);
    }
    doOperate(particle, elapsedTime) {
        const drag = this.getParameter('drag');
        const gravity = this.getParameter('gravity');
        this.getParameter('max constraint passes'); //TODO
        //ReplicateX4((pParticles->m_flDt / pParticles->m_flPreviousDt) * ExponentialDecay((1.0f-max(0.0,m_fDrag)), (1.0f/30.0f), pParticles->m_flDt));
        //fltx4 adj_dt = ReplicateX4((pParticles->m_flDt / pParticles->m_flPreviousDt) * ExponentialDecay((1.0f-max(0.0,m_fDrag)), (1.0f/30.0f), pParticles->m_flDt));
        const adj_dt = (elapsedTime / this.particleSystem.previousElapsedTime) * ExponentialDecay((1.0 - Math.max(0.0, drag)), (1.0 / 30.0), elapsedTime);
        /*if (particle.previousElapsedTime) {
            adj_dt *= (elapsedTime / particle.previousElapsedTime);
        }
        particle.previousElapsedTime = elapsedTime;*/
        const accumulatedForces = vec3.copy(tempVec3$9, gravity);
        //vec3.scale(accumulatedForces, accumulatedForces, 0.5);
        /*if (elapsedTime) {
            vec3.scale(accumulatedForces, accumulatedForces, 1/elapsedTime);
        }*/
        for (const force of this.particleSystem.forces.values()) {
            //const force = this.particleSystem.forces[j];
            force.forceParticle(particle, elapsedTime, accumulatedForces);
        }
        //elapsedTime *= 0.001;
        const accFactor = vec3.scale(tempVec3_2$2, accumulatedForces, elapsedTime * elapsedTime);
        const vecTemp = vec3.sub(tempVec3_3, particle.position, particle.prevPosition);
        vec3.scale(vecTemp, vecTemp, adj_dt);
        vec3.add(vecTemp, vecTemp, accFactor);
        vec3.copy(particle.prevPosition, particle.position);
        vec3.add(particle.position, particle.position, vecTemp);
        this.particleSystem.stepConstraints(particle);
    }
}
Source1ParticleOperators.registerOperator(MovementBasic);
Source1ParticleOperators.registerOperator('basic movement', MovementBasic);

class MovementLocktoControlPoint extends Source1ParticleOperator {
    static functionName = 'Movement Lock to Control Point';
    static once = false;
    constructor(system) {
        super(system);
        this.addParam('control_point_number', PARAM_TYPE_INT, 0);
        this.addParam('distance fade range', PARAM_TYPE_INT, 0);
        this.addParam('start_fadeout_min', PARAM_TYPE_FLOAT, 1);
        this.addParam('start_fadeout_max', PARAM_TYPE_FLOAT, 1);
        this.addParam('start_fadeout_exponent', PARAM_TYPE_FLOAT, 0);
        this.addParam('end_fadeout_min', PARAM_TYPE_FLOAT, 1);
        this.addParam('end_fadeout_max', PARAM_TYPE_FLOAT, 1);
        this.addParam('lock rotation', PARAM_TYPE_BOOL, false);
        /*'start_fadeout_min' 'float' '0.1000000015'
        'start_fadeout_max' 'float' '0.200000003'
        'start_fadeout_exponent' 'float' '1'
        'end_fadeout_min' 'float' '0.3000000119'
        'end_fadeout_max' 'float' '0.400000006'*/
    }
    doOperate(particle, elapsedTime) {
        if (!MovementLocktoControlPoint.once) {
            MovementLocktoControlPoint.once = true;
        }
        //return;
        if (particle.posLockedToCP == -1) {
            return;
        }
        this.getParameter('start_fadeout_min');
        this.getParameter('start_fadeout_max');
        const end_fadeout_min = this.getParameter('end_fadeout_min');
        const end_fadeout_max = this.getParameter('end_fadeout_max');
        const lockRotation = this.getParameter('lock rotation');
        const end_fadeout = (end_fadeout_max - end_fadeout_min) * Math.random() + end_fadeout_min;
        switch (true) {
            case end_fadeout == 1:
                break;
            case particle.proportionOfLife >= end_fadeout:
                particle.posLockedToCP = -1;
                break;
        }
        const cpNumber = this.getParameter('control_point_number');
        const distanceFadeRange = this.getParameter('distance fade range');
        const cp = this.particleSystem.getControlPoint(cpNumber);
        if (cp) {
            if (!particle.initialCPPosition) {
                particle.initialCPPosition = cp.getWorldPosition();
            }
            else {
                particle.initialCPPosition = vec3.clone(particle.cpPosition);
            }
            if (!particle.initialCPQuaternion) {
                particle.initialCPQuaternion = cp.getWorldQuaternion();
            }
            else {
                particle.initialCPQuaternion = quat.clone(particle.cpOrientation);
            }
            cp.getWorldPosition(particle.cpPosition);
            cp.getWorldQuaternion(particle.cpOrientation);
            const invertQuat = quat.invert(quat.create(), particle.initialCPQuaternion); //TODO: optimize
            const delta = vec3.subtract(vec3.create(), particle.cpPosition, particle.initialCPPosition); //TODO: optimize
            const deltaQuaternion = quat.mul(quat.create(), particle.cpOrientation, invertQuat);
            quat.normalize(deltaQuaternion, deltaQuaternion);
            const deltaL = vec3.length(delta);
            particle.deltaL = particle.deltaL || 0;
            particle.deltaL += deltaL;
            //console.log(deltaL);
            if (distanceFadeRange != 0 && particle.deltaL > distanceFadeRange) {
                particle.posLockedToCP = -1;
            }
            vec3.clone(particle.position);
            const delta2 = vec3.sub(vec3.create(), particle.position, particle.cpPosition);
            const delta3 = vec3.sub(vec3.create(), particle.prevPosition, particle.cpPosition);
            vec3.transformQuat(delta2, delta2, deltaQuaternion);
            vec3.transformQuat(delta3, delta3, deltaQuaternion);
            vec3.add(particle.position, particle.cpPosition, delta2);
            vec3.add(particle.prevPosition, particle.cpPosition, delta3);
            vec3.add(particle.position, particle.position, delta);
            vec3.add(particle.prevPosition, particle.prevPosition, delta);
            if (lockRotation) {
                cp.getWorldQuaternion(particle.cpOrientation);
                //TODO
            }
            else {
                vec4.zero(particle.cpOrientation);
            }
        }
        if (particle.PositionFromParentParticles) {
            particle.PositionFromParentParticles = false;
        }
    }
}
Source1ParticleOperators.registerOperator(MovementLocktoControlPoint);
//TODO: postion lock to controlpoint
//Source1ParticleOperators.registerOperator('postion lock to controlpoint', MovementLocktoControlPoint);
/*
Movement Lock to Controlpoint
Forces the position of a particle to that of some control point on the emitter.

start_fadeout_min
Bottom range of time to start fading out the lock (leave the particle behind).
start_fadeout_max
Top range of time to start fading out the lock (leave the particle behind).
end_fadeout_min
Bottom range of time to end fading out the lock. Particle will be fully disengaged from the control points movement at this point.
end_fadeout_max
Top range of time to end fading out the lock. Particle will be fully disengaged from the control points movement at this point.
start/end exponents
Bias on the selection within the range.
control point number
Which control point to lock to
fade distance
Particles will detach as they approach this distance
lock rotation
This will update a particle relative to a Control Point's rotation as well as position.
*/

const tempVec3$8 = vec3.create();
class MovementMaxVelocity extends Source1ParticleOperator {
    static functionName = 'Movement Max Velocity';
    constructor(system) {
        super(system);
        this.addParam('Maximum Velocity', PARAM_TYPE_FLOAT, 0);
    }
    doOperate(particle, elapsedTime) {
        const maxVelocity = this.getParameter('Maximum Velocity');
        const velocity = vec3.sub(tempVec3$8, particle.position, particle.prevPosition);
        let speed = vec3.length(velocity);
        vec3.normalize(velocity, velocity);
        const maxVelocityNormalized = maxVelocity * elapsedTime;
        speed = Math.min(maxVelocityNormalized, speed);
        vec3.scaleAndAdd(particle.position, particle.prevPosition, velocity, speed);
    }
}
Source1ParticleOperators.registerOperator(MovementMaxVelocity);

const tempVec3$7 = vec3.create();
let MovementRotateParticleAroundAxis$1 = class MovementRotateParticleAroundAxis extends Source1ParticleOperator {
    static functionName = 'Movement Rotate Particle Around Axis';
    once = true;
    constructor(system) {
        super(system);
        this.addParam('Rotation Axis', PARAM_TYPE_VECTOR, vec3.fromValues(0, 0, 1));
        this.addParam('Rotation Rate', PARAM_TYPE_FLOAT, 180);
        this.addParam('Control Point', PARAM_TYPE_INT, 0);
        this.addParam('Use Local Space', PARAM_TYPE_BOOL, 0);
        /*
        DMXELEMENT_UNPACK_FIELD( "Rotation Axis", "0 0 1", Vector, m_vecRotAxis )
        DMXELEMENT_UNPACK_FIELD( "Rotation Rate", "180", float, m_flRotRate )
        DMXELEMENT_UNPACK_FIELD( "Control Point", "0", int, m_nCP )
        DMXELEMENT_UNPACK_FIELD( "Use Local Space", "0", bool, m_bLocalSpace )*/
    }
    doOperate(particle, elapsedTime) {
        const axis = this.getParameter('Rotation Axis');
        const rate = this.getParameter('Rotation Rate');
        const useLocalSpace = this.getParameter('Use Local Space');
        const controlPointNumber = this.getParameter('Control Point');
        const modelView = mat4.create();
        mat4.identity(modelView);
        const q = quat.create(); //TODO: memory
        const cp = particle.system.getControlPoint(controlPointNumber);
        if (cp) {
            if (useLocalSpace == 1) {
                quat.copy(q, cp.getWorldQuaternion());
            }
            cp.getWorldPosition(tempVec3$7);
            vec3.sub(particle.position, particle.position, tempVec3$7);
            vec3.sub(particle.prevPosition, particle.prevPosition, tempVec3$7);
            const axis2 = vec3.clone(axis); //TODO: memory
            //axis2[1] = -axis2[1];
            //const tempQuat = quat.fromEuler(quat.create(), vec3.scale(vec3.create(), vec3.normalize(vec3.create(), axis), Math.HALF_PI));
            //quat.mul(tempQuat, tempQuat, q);
            //quat.fromEuler7(axis2, tempQuat);
            vec3.transformQuat(axis2, axis2, q);
            mat4.rotate(modelView, modelView, DEG_TO_RAD * (rate * elapsedTime), axis2);
            vec3.transformMat4(particle.position, particle.position, modelView);
            vec3.add(particle.position, particle.position, tempVec3$7);
            vec3.transformMat4(particle.prevPosition, particle.prevPosition, modelView);
            vec3.add(particle.prevPosition, particle.prevPosition, tempVec3$7);
        }
        else {
            mat4.rotate(modelView, modelView, DEG_TO_RAD * (rate * elapsedTime), axis);
            vec3.transformMat4(particle.position, particle.position, modelView);
        }
    }
};
Source1ParticleOperators.registerOperator(MovementRotateParticleAroundAxis$1);

const DEFAULT_ORIENTATION_OFFSET = 0;
const SPIN_STRENGTH = 1;
const orientTo2dDirectionTempVelocity = vec2.create();
//const orientTo2dDirectionTempVec3_1 = vec3.create();
class OrientTo2dDirection extends Source1ParticleOperator {
    static functionName = 'Rotation Orient to 2D Direction';
    #rotationOffset = DEFAULT_ORIENTATION_OFFSET;
    #spinStrength = SPIN_STRENGTH;
    paramChanged(name, param) {
        switch (name) {
            case 'Rotation Offset':
                this.#rotationOffset = param * DEG_TO_RAD + Math.PI /*Add PI right away*/; //TODO: convert to number
                break;
            case 'Spin Strength':
                this.#spinStrength = param; //TODO: convert to boolean
                break;
            default:
                super.paramChanged(name, param);
                break;
        }
    }
    doOperate(particle, elapsedTime) {
        particle.position;
        vec2.sub(orientTo2dDirectionTempVelocity, particle.position, particle.prevPosition);
        vec2.normalize(orientTo2dDirectionTempVelocity, orientTo2dDirectionTempVelocity);
        const currentRotation = particle.rotationRoll;
        const velocityRotation = Math.atan2(orientTo2dDirectionTempVelocity[1], orientTo2dDirectionTempVelocity[0]) + this.#rotationOffset;
        particle.rotationRoll = lerp(currentRotation, velocityRotation, this.#spinStrength);
    }
}
Source1ParticleOperators.registerOperator(OrientTo2dDirection);

let OscillateScalar$1 = class OscillateScalar extends Source1ParticleOperator {
    static functionName = 'Oscillate Scalar';
    constructor(system) {
        super(system);
        this.setNameId('Oscillate Scalar');
        this.addParam('oscillation field', PARAM_TYPE_INT, 7); //Alpha
        this.addParam('oscillation rate min', PARAM_TYPE_FLOAT, 0);
        this.addParam('oscillation rate max', PARAM_TYPE_FLOAT, 0);
        this.addParam('oscillation frequency min', PARAM_TYPE_FLOAT, 1);
        this.addParam('oscillation frequency max', PARAM_TYPE_FLOAT, 1);
        this.addParam('proportional 0/1', PARAM_TYPE_BOOL, true);
        this.addParam('start time min', PARAM_TYPE_FLOAT, 0);
        this.addParam('start time max', PARAM_TYPE_FLOAT, 0);
        this.addParam('end time min', PARAM_TYPE_FLOAT, 0);
        this.addParam('end time max', PARAM_TYPE_FLOAT, 0);
        this.addParam('start/end proportional', PARAM_TYPE_BOOL, true);
        this.addParam('oscillation multiplier', PARAM_TYPE_FLOAT, 2);
        this.addParam('oscillation start phase', PARAM_TYPE_FLOAT, 0.5);
        //	DMXELEMENT_UNPACK_FIELD_USERDATA('oscillation field', '7', int, m_nField, 'intchoice particlefield_scalar')
        //	DMXELEMENT_UNPACK_FIELD('oscillation rate min', '0', float, m_RateMin)
        //	DMXELEMENT_UNPACK_FIELD('oscillation rate max', '0', float, m_RateMax)
        //	DMXELEMENT_UNPACK_FIELD('oscillation frequency min', '1', float, m_FrequencyMin)
        //	DMXELEMENT_UNPACK_FIELD('oscillation frequency max', '1', float, m_FrequencyMax)
        //	DMXELEMENT_UNPACK_FIELD('proportional 0/1', '1', bool, m_bProportional)
        //	DMXELEMENT_UNPACK_FIELD('start time min', '0', float, m_flStartTime_min)
        //	DMXELEMENT_UNPACK_FIELD('start time max', '0', float, m_flStartTime_max)
        //	DMXELEMENT_UNPACK_FIELD('end time min', '1', float, m_flEndTime_min)
        //	DMXELEMENT_UNPACK_FIELD('end time max', '1', float, m_flEndTime_max)
        //	DMXELEMENT_UNPACK_FIELD('start/end proportional', '1', bool, m_bProportionalOp)
        //	DMXELEMENT_UNPACK_FIELD('oscillation multiplier', '2', float, m_flOscMult)
        //	DMXELEMENT_UNPACK_FIELD('oscillation start phase', '.5', float, m_flOscAdd)
    }
    doOperate(particle, elapsedTime) {
        const m_bProportional = this.getParameter('proportional 0/1');
        const m_bProportionalOp = this.getParameter('start/end proportional');
        const oscillationField = this.getParameter('oscillation field');
        const m_RateMin = this.getParameter('oscillation rate min');
        const m_RateMax = this.getParameter('oscillation rate max');
        const m_FrequencyMin = this.getParameter('oscillation frequency min');
        const m_FrequencyMax = this.getParameter('oscillation frequency max');
        this.getParameter('oscillation multiplier');
        const m_flStartTime_min = this.getParameter('start time min');
        const m_flStartTime_max = this.getParameter('start time max');
        const m_flEndTime_min = this.getParameter('end time min');
        const m_flEndTime_max = this.getParameter('end time max');
        const m_flOscMult = this.getParameter('oscillation multiplier');
        const m_flOscAdd = this.getParameter('oscillation start phase');
        const fl4StartTimeWidth = m_flStartTime_max - m_flStartTime_min;
        const fl4EndTimeWidth = m_flEndTime_max - m_flEndTime_min;
        const fl4FrequencyWidth = m_FrequencyMax - m_FrequencyMin;
        const fl4RateWidth = m_RateMax - m_RateMin;
        const fl4ScaleFactor = /*flStrength * */ elapsedTime;
        const fl4CosFactor = m_flOscMult * particle.currentTime + m_flOscAdd;
        if (particle.timeToLive) {
            let fl4LifeTime;
            if (m_bProportionalOp) {
                fl4LifeTime = particle.currentTime / particle.timeToLive;
            }
            else {
                fl4LifeTime = particle.currentTime;
            }
            let fl4StartTime = ParticleRandomFloat(particle.id, particle.system.operatorRandomSampleOffset + 11);
            fl4StartTime = m_flStartTime_min + fl4StartTimeWidth * fl4StartTime;
            let fl4EndTime = ParticleRandomFloat(particle.id, particle.system.operatorRandomSampleOffset + 12);
            fl4EndTime = m_flEndTime_min + fl4EndTimeWidth * fl4EndTime;
            if ((fl4LifeTime >= fl4StartTime) && (fl4LifeTime < fl4EndTime)) {
                let fl4Frequency = ParticleRandomFloat(particle.id, particle.system.operatorRandomSampleOffset);
                fl4Frequency = m_FrequencyMin + fl4FrequencyWidth * fl4Frequency;
                let fl4Rate = ParticleRandomFloat(particle.id, particle.system.operatorRandomSampleOffset + 1);
                fl4Rate = m_RateMin + fl4RateWidth * fl4Rate;
                let fl4Cos;
                if (m_bProportional) {
                    fl4LifeTime = (particle.currentTime - particle.cTime) / particle.timeToLive;
                    fl4Cos = ((m_flOscMult * (fl4LifeTime * fl4Frequency)) + m_flOscAdd);
                }
                else {
                    fl4Cos = fl4CosFactor * fl4Frequency;
                }
                const fl4OscMultiplier = fl4Rate * fl4ScaleFactor;
                let fl4OscVal = particle.getField(oscillationField) + fl4OscMultiplier * Math.sin(fl4Cos * Math.PI);
                if (oscillationField == 7) { //alpha
                    fl4OscVal = clamp$1(fl4OscVal, 0.0, 1.0);
                }
                particle.setField(oscillationField, fl4OscVal);
                //console.error(fl4OscVal);
            }
        }
    }
};
Source1ParticleOperators.registerOperator(OscillateScalar$1);

/*					'oscillation field' 'int' '0'
                    'oscillation field' 'int' '16'
                    'oscillation field' 'int' '3'
                    'oscillation field' 'int' '4'
                    'oscillation field' 'int' '7'*/
const tempVec3Freq = vec3.create();
const tempVec3Rate = vec3.create();
let OscillateVector$1 = class OscillateVector extends Source1ParticleOperator {
    static functionName = 'Oscillate Vector';
    constructor(system) {
        super(system);
        this.addParam('oscillation field', PARAM_TYPE_INT, 0);
        this.addParam('oscillation rate min', PARAM_TYPE_VECTOR3, vec3.create());
        this.addParam('oscillation rate max', PARAM_TYPE_VECTOR3, vec3.create());
        this.addParam('oscillation frequency min', PARAM_TYPE_VECTOR3, vec3.fromValues(1.0, 1.0, 1.0));
        this.addParam('oscillation frequency max', PARAM_TYPE_VECTOR3, vec3.fromValues(1.0, 1.0, 1.0));
        this.addParam('proportional 0/1', PARAM_TYPE_BOOL, 1);
        this.addParam('start time min', PARAM_TYPE_FLOAT, 0);
        this.addParam('start time max', PARAM_TYPE_FLOAT, 0);
        this.addParam('end time min', PARAM_TYPE_FLOAT, 1);
        this.addParam('end time max', PARAM_TYPE_FLOAT, 1);
        this.addParam('start/end proportional', PARAM_TYPE_BOOL, 1);
        this.addParam('oscillation multiplier', PARAM_TYPE_FLOAT, 2.0);
        this.addParam('oscillation start phase', PARAM_TYPE_FLOAT, 0.5);
    }
    doOperate(particle, elapsedTime) {
        const m_nField = this.getParameter('oscillation field');
        const m_RateMin = this.getParameter('oscillation rate min');
        const m_RateMax = this.getParameter('oscillation rate max');
        const m_FrequencyMin = this.getParameter('oscillation frequency min');
        const m_FrequencyMax = this.getParameter('oscillation frequency max');
        const m_bProportional = this.getParameter('proportional 0/1');
        const m_flStartTime_min = this.getParameter('start time min');
        const m_flStartTime_max = this.getParameter('start time max');
        const m_flEndTime_min = this.getParameter('end time min');
        const m_flEndTime_max = this.getParameter('end time max');
        const m_bProportionalOp = this.getParameter('start/end proportional');
        const m_flOscMult = this.getParameter('oscillation multiplier');
        const m_flOscAdd = this.getParameter('oscillation start phase');
        particle.cTime; //CM128AttributeIterator pCreationTime(PARTICLE_ATTRIBUTE_CREATION_TIME, pParticles);
        const pLifeDuration = particle.timeToLive; //CM128AttributeIterator pLifeDuration(PARTICLE_ATTRIBUTE_LIFE_DURATION, pParticles);
        //C4IAttributeIterator pParticleId (PARTICLE_ATTRIBUTE_PARTICLE_ID, pParticles);
        //C4VAttributeWriteIterator pOscField (m_nField, pParticles) ;
        const fl4CurTime = particle.currentTime;
        //const nRandomOffset = particle->OperatorRandomSampleOffset();
        const fvOscVal = vec3.create(); //todov3optimize
        const flStrength = 1;
        const fl4ScaleFactor = flStrength * elapsedTime;
        const fl4CosFactorMultiplier = m_flOscMult;
        const fl4CosFactorAdd = m_flOscAdd;
        const fl4CosFactor = fl4CosFactorMultiplier * fl4CurTime + fl4CosFactorAdd;
        const fl4CosFactorProp = fl4CosFactorMultiplier;
        const fl4StartTimeWidth = m_flStartTime_max - m_flStartTime_min;
        const fl4EndTimeWidth = m_flEndTime_max - m_flEndTime_min;
        const fvFrequencyMin = m_FrequencyMin;
        const fvFrequencyWidth = vec3.sub(vec3.create(), m_FrequencyMax, m_FrequencyMin); //todov3optimize
        const fvRateMin = m_RateMin;
        const fvRateWidth = vec3.sub(vec3.create(), m_RateMax, m_RateMin); //todov3optimize
        //int nCtr = pParticles->m_nPaddedActiveParticles;
        //do
        {
            const fl4LifeDuration = pLifeDuration;
            const fl4GoodMask = fl4LifeDuration > 0.0;
            let fl4LifeTime;
            if (m_bProportionalOp) {
                fl4LifeTime = particle.currentTime / particle.timeToLive;
            }
            else {
                fl4LifeTime = particle.currentTime;
            }
            //TODO: use random table
            //let fl4StartTime = Math.random();//pParticles->RandomFloat(*pParticleId, nRandomOffset + 11);
            let fl4StartTime = ParticleRandomFloat(particle.id, particle.system.operatorRandomSampleOffset + 11);
            fl4StartTime = m_flStartTime_min + fl4StartTimeWidth * fl4StartTime;
            //TODO: use random table
            //let fl4EndTime= Math.random();//pParticles->RandomFloat(*pParticleId, nRandomOffset + 12);
            let fl4EndTime = ParticleRandomFloat(particle.id, particle.system.operatorRandomSampleOffset + 12);
            fl4EndTime = m_flEndTime_min + fl4EndTimeWidth * fl4EndTime;
            if ((fl4LifeTime >= fl4StartTime) && (fl4LifeTime < fl4EndTime)) {
                //TODO: use random table
                //let fvFrequency = vec3.fromValues(Math.random(), Math.random(), Math.random());
                const fvFrequency = ParticleRandomVec3(tempVec3Freq, particle.id + particle.system.operatorRandomSampleOffset, 8, 12, 15);
                //fvFrequency[0] = pParticles->RandomFloat(*pParticleId, nRandomOffset + 8);
                //fvFrequency[1] = pParticles->RandomFloat(*pParticleId, nRandomOffset + 12);
                //fvFrequency[2] = pParticles->RandomFloat(*pParticleId, nRandomOffset + 15);
                vec3.mul(fvFrequency, fvFrequency, fvFrequencyWidth);
                vec3.add(fvFrequency, fvFrequency, fvFrequencyMin);
                //let fvRate = vec3.fromValues(Math.random(), Math.random(), Math.random());
                const fvRate = ParticleRandomVec3(tempVec3Rate, particle.id + particle.system.operatorRandomSampleOffset, 3, 7, 9);
                //fvRate[0] = pParticles->RandomFloat(*pParticleId, nRandomOffset + 3);
                //fvRate[1] = pParticles->RandomFloat(*pParticleId, nRandomOffset + 7);
                //fvRate[2] = pParticles->RandomFloat(*pParticleId, nRandomOffset + 9);
                //fvRate = AddSIMD(fvRateMin, MulSIMD(fvRateWidth, fvRate));
                vec3.mul(fvRate, fvRate, fvRateWidth);
                vec3.add(fvRate, fvRate, fvRateMin);
                const fvCos = vec3.create(); //todov3optimize
                if (m_bProportional) {
                    fl4LifeTime = particle.currentTime / particle.timeToLive;
                    fvCos[0] = fl4CosFactorProp * fvFrequency[0] * fl4LifeTime + fl4CosFactorAdd;
                    fvCos[1] = fl4CosFactorProp * fvFrequency[1] * fl4LifeTime + fl4CosFactorAdd;
                    fvCos[2] = fl4CosFactorProp * fvFrequency[2] * fl4LifeTime + fl4CosFactorAdd;
                }
                else {
                    vec3.scale(fvCos, fvFrequency, fl4CosFactor);
                }
                const fvOscMultiplier = vec3.create(); //todov3optimize
                vec3.scale(fvOscMultiplier, fvRate, fl4ScaleFactor);
                const fvOutput = vec3.create(); //TODO: perf//todov3optimize
                this.getInputValueAsVector(m_nField, particle, fvOutput); //*pOscField;
                fvOscVal[0] = AddSIMD(fvOutput[0], MulSIMD(fvOscMultiplier[0], SinEst01SIMD(fvCos[0])));
                fvOscVal[1] = AddSIMD(fvOutput[1], MulSIMD(fvOscMultiplier[1], SinEst01SIMD(fvCos[1])));
                fvOscVal[2] = AddSIMD(fvOutput[2], MulSIMD(fvOscMultiplier[2], SinEst01SIMD(fvCos[2])));
                const pOscField = vec3.create(); //todov3optimize
                if (m_nField == 6) {
                    pOscField[0] = MaskedAssign(fl4GoodMask, MaxSIMD(MinSIMD(fvOscVal[0], Four_Ones), Four_Zeros), fvOutput[0]);
                    pOscField[1] = MaskedAssign(fl4GoodMask, MaxSIMD(MinSIMD(fvOscVal[1], Four_Ones), Four_Zeros), fvOutput[1]);
                    pOscField[2] = MaskedAssign(fl4GoodMask, MaxSIMD(MinSIMD(fvOscVal[2], Four_Ones), Four_Zeros), fvOutput[2]);
                }
                else {
                    //pOscField[0] = MaskedAssign(fl4GoodMask, fvOscVal[0], fvOutput[0]);
                    //pOscField[1] = MaskedAssign(fl4GoodMask, fvOscVal[1], fvOutput[1]);
                    //pOscField[2] = MaskedAssign(fl4GoodMask, fvOscVal[2], fvOutput[2]);
                    pOscField[0] = fvOscVal[0];
                    pOscField[1] = fvOscVal[1];
                    pOscField[2] = fvOscVal[2];
                }
                this.setOutputValue(m_nField, pOscField, particle);
            }
            //++pCreationTime;
            //++pLifeDuration;
            //++pOscField;
            //++pParticleId;
            //} while (--nCtr);
        }
    }
};
Source1ParticleOperators.registerOperator(OscillateVector$1);

class RadiusScale extends Source1ParticleOperator {
    static functionName = 'Radius Scale';
    constructor(system) {
        super(system);
        this.addParam('radius_start_scale', PARAM_TYPE_FLOAT, 1);
        this.addParam('radius_end_scale', PARAM_TYPE_FLOAT, 1);
        this.addParam('start_time', PARAM_TYPE_FLOAT, 0);
        this.addParam('end_time', PARAM_TYPE_FLOAT, 1);
        this.addParam('scale_bias', PARAM_TYPE_FLOAT, 0.5); //Neutral bias
        this.addParam('ease_in_and_out', PARAM_TYPE_BOOL, 0); //Neutral bias
        /*DMXELEMENT_UNPACK_FIELD('start_time', '0', float, m_flStartTime)
        DMXELEMENT_UNPACK_FIELD('end_time', '1', float, m_flEndTime)
        DMXELEMENT_UNPACK_FIELD('radius_start_scale', '1', float, m_flStartScale)
        DMXELEMENT_UNPACK_FIELD('radius_end_scale', '1', float, m_flEndScale)
        DMXELEMENT_UNPACK_FIELD('ease_in_and_out', '0', bool, m_bEaseInAndOut)
        DMXELEMENT_UNPACK_FIELD('scale_bias', '0.5', float, m_flBias)*/
    }
    doOperate(particle, elapsedTime) {
        const radius_start_scale = this.getParameter('radius_start_scale');
        const radius_end_scale = this.getParameter('radius_end_scale');
        const start_time = this.getParameter('start_time');
        const end_time = this.getParameter('end_time');
        const scaleBias = this.getParameter('scale_bias');
        const easeInAndOut = this.getParameter('ease_in_and_out');
        const fl4OOTimeWidth = ReciprocalSIMD(SubSIMD(end_time, start_time));
        const biasParam = 1 / scaleBias - 2;
        const fl4LifeDuration = particle.timeToLive;
        let fl4GoodMask = CmpGtSIMD(fl4LifeDuration, 0);
        const fl4CurTime = this.particleSystem.currentTime;
        const fl4ScaleWidth = radius_end_scale - radius_start_scale;
        const fl4LifeTime = MulSIMD(SubSIMD(fl4CurTime, particle.cTime), ReciprocalEstSIMD(fl4LifeDuration)); // maybe need accurate div here?
        fl4GoodMask = AndSIMD(fl4GoodMask, CmpGeSIMD(fl4LifeTime, start_time));
        fl4GoodMask = AndSIMD(fl4GoodMask, CmpLtSIMD(fl4LifeTime, end_time));
        fl4GoodMask = (fl4LifeDuration > 0) && (fl4LifeTime >= start_time) && (fl4LifeTime < end_time);
        if (fl4GoodMask /* IsAnyNegative(fl4GoodMask) */) {
            let fl4FadeWindow = MulSIMD(SubSIMD(fl4LifeTime, start_time), fl4OOTimeWidth);
            if (easeInAndOut) {
                fl4FadeWindow = AddSIMD(radius_start_scale, MulSIMD(SimpleSpline(fl4FadeWindow), fl4ScaleWidth));
            }
            else {
                if (scaleBias != 0.5) {
                    fl4FadeWindow = AddSIMD(radius_start_scale, MulSIMD(BiasSIMD(fl4FadeWindow, biasParam), fl4ScaleWidth));
                }
                else {
                    fl4FadeWindow = AddSIMD(radius_start_scale, MulSIMD(fl4FadeWindow, fl4ScaleWidth));
                }
            }
            if (fl4GoodMask) {
                particle.radius = fl4FadeWindow * particle.initialRadius;
            }
        }
    }
}
Source1ParticleOperators.registerOperator(RadiusScale);

const a$1 = vec3.create();
class RemapCPSpeedToCP extends Source1ParticleOperator {
    static functionName = 'remap cp speed to cp';
    constructor(system) {
        super(system);
        this.addParam('operator strength scale control point', PARAM_TYPE_INT, 1);
        this.addParam('input control point', PARAM_TYPE_INT, 0);
        this.addParam('input minimum', PARAM_TYPE_FLOAT, 0);
        this.addParam('input maximum', PARAM_TYPE_FLOAT, 1);
        this.addParam('output minimum', PARAM_TYPE_FLOAT, 0);
        this.addParam('output maximum', PARAM_TYPE_FLOAT, 1);
        this.addParam('Output field 0-2 X/Y/Z', PARAM_TYPE_INT, 0); // X/Y/Z
        this.addParam('output control point', PARAM_TYPE_INT, 1);
    }
    doOperate(particle, elapsedTime) {
        const inputMinimum = this.getParameter('input minimum');
        const inputMaximum = this.getParameter('input maximum');
        const outputMinimum = this.getParameter('output minimum');
        const outputMaximum = this.getParameter('output maximum');
        const outputField = this.getParameter('Output field 0-2 X/Y/Z');
        const inCPNumber = this.getParameter('input control point');
        const outCPNumber = this.getParameter('output control point');
        const incp = this.particleSystem.getControlPoint(inCPNumber);
        const outcp = this.particleSystem.getControlPoint(outCPNumber);
        if (incp && outcp && (outputField == 0 || outputField == 1 || outputField == 2)) {
            vec3.length(incp.getWorldPosition(a$1));
            const position = outcp.position; //TODO optimize
            position[outputField] = RemapValClamped(200, inputMinimum, inputMaximum, outputMinimum, outputMaximum);
            outcp.position = position;
        }
    }
}
Source1ParticleOperators.registerOperator(RemapCPSpeedToCP);

const tempVec3$6 = vec3.create();
class RemapDistanceToControlPointToScalar extends Source1ParticleOperator {
    static functionName = 'Remap Distance to Control Point to Scalar';
    constructor(system) {
        super(system);
        this.addParam('control point', PARAM_TYPE_INT, 0);
        this.addParam('distance fade range', PARAM_TYPE_INT, 0);
        this.addParam('distance minimum', PARAM_TYPE_FLOAT, 0);
        this.addParam('distance maximum', PARAM_TYPE_FLOAT, 128);
        this.addParam('output minimum', PARAM_TYPE_FLOAT, 0);
        this.addParam('output maximum', PARAM_TYPE_FLOAT, 1);
        this.addParam('output field', PARAM_TYPE_INT, 1);
        this.addParam('output is scalar of initial random range', PARAM_TYPE_BOOL, 0);
        this.addParam('only active within specified distance', PARAM_TYPE_BOOL, 0);
    }
    doOperate(particle, elapsedTime) {
        const cpNumber = this.getParameter('control point');
        const dMin = this.getParameter('distance minimum');
        const dMax = this.getParameter('distance maximum');
        const oMin = this.getParameter('output minimum');
        const oMax = this.getParameter('output maximum');
        const field = this.getParameter('output field');
        const init = this.getParameter('output is scalar of initial random range');
        const active = this.getParameter('only active within specified distance');
        const cp = this.particleSystem.getControlPoint(cpNumber);
        if (cp) {
            const delta = vec3.subtract(tempVec3$6, cp.getWorldPosition(tempVec3$6), particle.position);
            const deltaL = vec3.length(delta);
            if (active && ((deltaL < dMin) || (deltaL > dMax))) {
                return;
            }
            const output = RemapValClamped(deltaL, dMin, dMax, oMin, oMax); //(deltaL-dMin)/(dMax-dMin) * (oMax-oMin) + oMin;
            const strength = this.getOperatorStrength();
            if (strength == 1) {
                particle.setField(field, output, init); //TODO
            }
            else {
                const value = particle.getField(field);
                particle.setField(field, lerp(value, output, strength), init); //TODO
            }
        }
    }
}
Source1ParticleOperators.registerOperator(RemapDistanceToControlPointToScalar);
/*
                    'id' 'elementid' '141980ed-af1c-4ffb-9890-b42e39fc0d28'
                    'name' 'string' 'Remap Distance to Control Point to Scalar'
                    'functionName' 'string' 'Remap Distance to Control Point to Scalar'
                    'operator start fadein' 'float' '0'
                    'operator end fadein' 'float' '0'
                    'operator start fadeout' 'float' '0'
                    'operator end fadeout' 'float' '0'
                    'operator fade oscillate' 'float' '0'
                    'distance minimum' 'float' '0'
                    'distance maximum' 'float' '200'
                    'output field' 'int' '1'
                    'output minimum' 'float' '1'
                    'output maximum' 'float' '0'
                    'control point' 'int' '0'
                    'ensure line of sight' 'bool' '0'
                    'LOS collision group' 'string' 'NONE'
                    'Maximum Trace Length' 'float' '-1'
                    'LOS Failure Scalar' 'float' '0'
                    'output is scalar of initial random range' 'bool' '1'
                    'only active within specified distance' 'bool' '0'
                    */

const tempVec3$5 = vec3.create();
class RemapDistanceToControlPointToVector extends Source1ParticleOperator {
    static functionName = 'Remap Distance to Control Point to Vector';
    constructor(system) {
        super(system);
        this.addParam('control point', PARAM_TYPE_INT, 0);
        //this.addParam('distance fade range', PARAM_TYPE_INT, 0);
        this.addParam('distance minimum', PARAM_TYPE_FLOAT, 0);
        this.addParam('distance maximum', PARAM_TYPE_FLOAT, 1);
        this.addParam('output minimum', PARAM_TYPE_VECTOR, vec3.fromValues(0, 0, 0));
        this.addParam('output maximum', PARAM_TYPE_VECTOR, vec3.fromValues(1, 1, 1));
        this.addParam('output field', PARAM_TYPE_INT, 1);
        //this.addParam('output is scalar of initial random range', PARAM_TYPE_BOOL, 0);
        this.addParam('only active within specified distance', PARAM_TYPE_BOOL, 0);
    }
    doOperate(particle, elapsedTime) {
        const cpNumber = this.getParameter('control point');
        const distanceMin = this.getParameter('distance minimum');
        const distanceMax = this.getParameter('distance maximum');
        const deltaDistance = distanceMax - distanceMin;
        const outputMin = this.getParameter('output minimum');
        const outputMax = this.getParameter('output maximum');
        const field = this.getParameter('output field');
        const activeDistance = this.getParameter('only active within specified distance');
        const cp = this.particleSystem.getControlPoint(cpNumber);
        if (cp == undefined) {
            return;
        }
        vec3.subtract(tempVec3$5, particle.cpPosition, particle.position);
        const deltaL = vec3.length(tempVec3$5);
        if (activeDistance && (deltaL < distanceMin || deltaL > distanceMax)) {
            // Outside distance window
            return;
        }
        vec3.lerp(tempVec3$5, outputMin, outputMax, (deltaL - distanceMin) / deltaDistance);
        particle.setField(field, tempVec3$5);
    }
}
Source1ParticleOperators.registerOperator(RemapDistanceToControlPointToVector);
/*
        "DmeParticleOperator"
        {
            "id" "elementid" "0d3d4ec1-b821-4970-a69d-57c97da97915"
            "name" "string" "Remap Distance to Control Point to Vector"
            "functionName" "string" "Remap Distance to Control Point to Vector"
            "operator start fadein" "float" "0"
            "operator end fadein" "float" "0"
            "operator start fadeout" "float" "0"
            "operator end fadeout" "float" "0"
            "operator fade oscillate" "float" "0"
            "distance minimum" "float" "0"
            "distance maximum" "float" "64"
            "output field" "int" "6"
            "output minimum" "vector3" "0 1 0"
            "output maximum" "vector3" "1.5 0 3"
            "control point" "int" "0"
            "only active within specified distance" "bool" "1"
            "local space CP" "int" "-1"
        }
    ]
                    */

class RemapScalar extends Source1ParticleOperator {
    static functionName = 'remap scalar';
    constructor(system) {
        super(system);
        this.addParam('input minimum', PARAM_TYPE_FLOAT, 0);
        this.addParam('input maximum', PARAM_TYPE_FLOAT, 1);
        this.addParam('output minimum', PARAM_TYPE_FLOAT, 0);
        this.addParam('output maximum', PARAM_TYPE_FLOAT, 1);
        this.addParam('input field', PARAM_TYPE_INT, 0);
        this.addParam('output field', PARAM_TYPE_INT, 0);
        this.addParam('output is scalar of initial random range', PARAM_TYPE_BOOL, 0);
    }
    doOperate(particle, elapsedTime) {
        const inputMinimum = this.getParameter('input minimum');
        const inputMaximum = this.getParameter('input maximum');
        const outputMinimum = this.getParameter('output minimum');
        const outputMaximum = this.getParameter('output maximum');
        const inputField = this.getParameter('input field');
        const outputField = this.getParameter('output field');
        const init = this.getParameter('output is scalar of initial random range');
        //const v = this.getInputValue(inputField, particle);
        const v = particle.getField(inputField, init);
        const d = (v - inputMinimum) / (inputMaximum - inputMinimum);
        const out = d * (outputMaximum - outputMinimum) + outputMinimum;
        this.setOutputValue(outputField, out, particle);
    }
}
Source1ParticleOperators.registerOperator(RemapScalar);

class RotationBasic extends Source1ParticleOperator {
    static functionName = 'Rotation Basic';
    doOperate(particle, elapsedTime) {
        particle.rotationRoll += particle.rotationSpeedRoll * elapsedTime;
    }
}
Source1ParticleOperators.registerOperator(RotationBasic);

/**
 * TODO
 */
class RotationSpinRoll extends Source1ParticleOperator {
    static functionName = 'Rotation Spin Roll';
    constructor(system) {
        super(system);
        this.addParam('spin_rate_degrees', PARAM_TYPE_INT, 0);
        this.addParam('spin_stop_time', PARAM_TYPE_FLOAT, 0);
        this.addParam('spin_rate_min', PARAM_TYPE_INT, 0);
        //DMXELEMENT_UNPACK_FIELD('spin_rate_degrees', '0', int, m_nSpinRateDegrees)
        //DMXELEMENT_UNPACK_FIELD('spin_stop_time', '0', float, m_fSpinRateStopTime)
        //DMXELEMENT_UNPACK_FIELD('spin_rate_min', '0', int, m_nSpinRateMinDegrees)
    }
    doOperate(particle, elapsedTime) {
        const m_nSpinRateDegrees = this.getParameter('spin_rate_degrees');
        const m_fSpinRateStopTime = this.getParameter('spin_stop_time');
        const m_nSpinRateMinDegrees = this.getParameter('spin_rate_min');
        const m_fSpinRateRadians = (m_nSpinRateDegrees) * DEG_TO_RAD;
        const m_fSpinRateMinRadians = (m_nSpinRateMinDegrees) * DEG_TO_RAD;
        const fCurSpinRate = m_fSpinRateRadians /* * flStrength*/; //TODO
        if (fCurSpinRate == 0.0) {
            return;
        }
        const dt = elapsedTime;
        let drot = dt * Math.abs(fCurSpinRate * TWO_PI);
        if (m_fSpinRateStopTime == 0.0) {
            drot = drot % TWO_PI; //fmod(drot, (float)(2.0f * M_PI));
        }
        if (fCurSpinRate < 0.0) {
            drot = -drot;
        }
        //fltx4 Rot_Add = ReplicateX4(drot);
        const Rot_Add = drot;
        //fltx4 Pi_2 = ReplicateX4(2.0*M_PI);
        //fltx4 nPi_2 = ReplicateX4(-2.0*M_PI);
        // FIXME: This is wrong
        const minSpeedRadians = dt * Math.abs(m_fSpinRateMinRadians * TWO_PI); //fltx4 minSpeedRadians = ReplicateX4(dt * fabs(m_fSpinRateMinRadians * 2.0f * M_PI));
        const now = this.particleSystem.currentTime;
        const SpinRateStopTime = m_fSpinRateStopTime;
        //CM128AttributeIterator pCreationTimeStamp(PARTICLE_ATTRIBUTE_CREATION_TIME, pParticles);
        //CM128AttributeIterator pLifeDuration(PARTICLE_ATTRIBUTE_LIFE_DURATION, pParticles);
        //CM128AttributeWriteIterator pRot(GetAttributeToSpin(), pParticles);
        // HACK: Rather than redo this, I'm simply remapping the stop time into the percentage of lifetime, rather than seconds
        const LifeSpan = particle.timeToLive;
        let SpinFadePerc = 0;
        let OOSpinFadeRate = 0;
        if (m_fSpinRateStopTime) {
            SpinFadePerc = LifeSpan * SpinRateStopTime;
            OOSpinFadeRate = 1.0 / SpinFadePerc;
        }
        const Age = now - particle.cTime;
        const RScale = Math.max(0, 1.0 - (Age * OOSpinFadeRate));
        // Cap the rotation at a minimum speed
        let deltaRot = Rot_Add * RScale;
        //fltx4 Tooslow = CmpLeSIMD(deltaRot, minSpeedRadians);
        //deltaRot = OrSIMD(AndSIMD(Tooslow, minSpeedRadians), AndNotSIMD(Tooslow, deltaRot));
        deltaRot = Math.max(minSpeedRadians, deltaRot);
        const NewRot = particle.rotationRoll + deltaRot;
        // now, cap at +/- 2*pi
        /*fltx4 Toobig =CmpGeSIMD(NewRot, Pi_2);
        fltx4 Toosmall = CmpLeSIMD(NewRot, nPi_2);

        NewRot = OrSIMD(AndSIMD(Toobig, SubSIMD(NewRot, Pi_2)),
        AndNotSIMD(Toobig, NewRot));

        NewRot = OrSIMD(AndSIMD(Toosmall, AddSIMD(NewRot, Pi_2)),
        AndNotSIMD(Toosmall, NewRot));*/
        //NewRot = Math.min(Math.max(-Math.TWO_PI, NewRot), Math.TWO_PI);
        particle.rotationRoll = NewRot;
        // Note: this should be PI / 180, but for some reason there is a bug in source engine
        //		particle.rotationRoll += spin_rate_degrees*elapsedTime * Math.PI * Math.PI / 90.0;
    }
}
Source1ParticleOperators.registerOperator(RotationSpinRoll);
Source1ParticleOperators.registerOperator('Rotation Spin', RotationSpinRoll);

class RotationSpinYaw extends Source1ParticleOperator {
    static functionName = 'Rotation Spin Yaw';
    constructor(system) {
        super(system);
        this.addParam('yaw_rate_degrees', PARAM_TYPE_FLOAT, 0);
    }
    doOperate(particle, elapsedTime) {
        const yaw_rate_degrees = this.getParameter('yaw_rate_degrees');
        particle.rotationYaw += yaw_rate_degrees * elapsedTime; //TODO
    }
}
Source1ParticleOperators.registerOperator(RotationSpinYaw);

const DEFAULT_SET_CP_ORIENTATION_FOR_PARTICLES = false; /* TODO: check default value*/
const setChildControlPointsFromParticlePositionsTempQuat = quat.create();
const setChildControlPointsFromParticlePositionsTempVec3 = vec3.create();
const setChildControlPointsFromParticlePositionsXUnitVec3 = vec3.fromValues(1, 0, 0);
class SetChildControlPointsFromParticlePositions extends Source1ParticleOperator {
    static functionName = 'Set child control points from particle positions';
    #setCpOrientation = DEFAULT_SET_CP_ORIENTATION_FOR_PARTICLES;
    constructor(system) {
        super(system);
        this.addParam('# of control points to set', PARAM_TYPE_INT, 1);
        this.addParam('First control point to set', PARAM_TYPE_INT, 0);
    }
    paramChanged(name, param) {
        switch (name) {
            case 'Set cp orientation for particles':
                this.#setCpOrientation = param; //TODO: convert to boolean
                break;
            default:
                super.paramChanged(name, param);
                break;
            /*
            Set cp radius for particles 1
            Set cp velocity for particles 1
            Set cp density for particles 1
            Set cp orientation for particles 1
            */
        }
    }
    doOperate(particle, elapsedTime) {
        const number = this.getParameter('# of control points to set');
        const first = this.getParameter('First control point to set');
        //const v = vec3.clone(particle.position);
        //v.add(particle.offsetPosition);
        //const v = vec3.add(vec3.create(), particle.position, particle.cpPosition);//v.add(particle.cpPosition);
        //TODO
        const v = vec3.create(); //TODO: optimize
        particle.getWorldPos(v);
        this.particleSystem.setChildControlPointPosition(first, first + number - 1, v);
        if (this.#setCpOrientation) {
            const b = vec3.sub(setChildControlPointsFromParticlePositionsTempVec3, particle.position, particle.prevPosition);
            setChildControlPointsFromParticlePositionsTempQuat[3] = Math.sqrt(vec3.sqrLen(setChildControlPointsFromParticlePositionsXUnitVec3) * vec3.sqrLen(b)) + vec3.dot(setChildControlPointsFromParticlePositionsXUnitVec3, b);
            vec3.cross(setChildControlPointsFromParticlePositionsTempQuat /*affect xyz*/, setChildControlPointsFromParticlePositionsXUnitVec3, setChildControlPointsFromParticlePositionsTempVec3);
            this.particleSystem.setChildControlPointOrientation(first, first + number - 1, setChildControlPointsFromParticlePositionsTempQuat);
        }
    }
}
Source1ParticleOperators.registerOperator(SetChildControlPointsFromParticlePositions);

const tempVec3$4 = vec3.create();
let SetControlPointPositions$1 = class SetControlPointPositions extends Source1ParticleOperator {
    static functionName = 'set control point positions';
    constructor(system) {
        super(system);
        this.addParam('Control Point to offset positions from', PARAM_TYPE_INT, 0);
        this.addParam('Set positions in world space', PARAM_TYPE_BOOL, false);
        this.addParam('Control Point to offset positions from', PARAM_TYPE_INT, 0);
        this.addParam('Control Point to offset positions from', PARAM_TYPE_INT, 0);
        this.addParam('Control Point to offset positions from', PARAM_TYPE_INT, 0);
        this.addParam('First Control Point Location', PARAM_TYPE_VECTOR3, vec3.fromValues(128, 0, 0));
        this.addParam('First Control Point Number', PARAM_TYPE_INT, 1);
        this.addParam('First Control Point Parent', PARAM_TYPE_INT, 0);
        this.addParam('Second Control Point Location', PARAM_TYPE_VECTOR3, vec3.fromValues(0, 128, 0));
        this.addParam('Second Control Point Number', PARAM_TYPE_INT, 2);
        this.addParam('Second Control Point Parent', PARAM_TYPE_INT, 0);
        this.addParam('Third Control Point Location', PARAM_TYPE_VECTOR3, vec3.fromValues(-128, 0, 0));
        this.addParam('Third Control Point Number', PARAM_TYPE_INT, 3);
        this.addParam('Third Control Point Parent', PARAM_TYPE_INT, 0);
        this.addParam('Fourth Control Point Location', PARAM_TYPE_VECTOR3, vec3.fromValues(0, -128, 0));
        this.addParam('Fourth Control Point Number', PARAM_TYPE_INT, 4);
        this.addParam('Fourth Control Point Parent', PARAM_TYPE_INT, 0);
    }
    doOperate(particle, elapsedTime) {
        const list = ['First', 'Second', 'Third', 'Fourth'];
        const useWorldLocation = this.getParameter('Set positions in world space');
        const headLocation = this.getParameter('Control Point to offset positions from');
        const vecControlPoint = this.particleSystem.getControlPointPosition(headLocation);
        for (let cpIndex = 0; cpIndex < 4; ++cpIndex) {
            const name = list[cpIndex];
            const cpNumber = this.getParameter(name + ' Control Point Number');
            if (cpNumber == headLocation) {
                continue;
            }
            const cpParent = this.getParameter(name + ' Control Point Parent');
            const cpLocation = this.getParameter(name + ' Control Point Location');
            if (!useWorldLocation) {
                const a = vec3.add(tempVec3$4, cpLocation, vecControlPoint);
                this.particleSystem.setControlPointPosition(cpNumber, a);
            }
            else {
                this.particleSystem.setControlPointPosition(cpNumber, cpLocation);
            }
            const controlPoint = this.particleSystem.getControlPoint(cpNumber);
            if (controlPoint) {
                controlPoint.setWorldQuaternion(quat.create());
            }
            this.particleSystem.setControlPointParent(cpNumber, cpParent);
        }
    }
};
Source1ParticleOperators.registerOperator(SetControlPointPositions$1);

const tempVec3_min = vec3.create();
const tempVec3_max = vec3.create();
class SetControlPointToParticlesCenter extends Source1ParticleOperator {
    static functionName = 'Set Control Point to Particles\' Center';
    constructor(system) {
        super(system);
        this.addParam('Control Point Number to Set', PARAM_TYPE_INT, 1);
        this.addParam('Center Offset', PARAM_TYPE_VECTOR3, vec3.fromValues(0, 0, 0));
    }
    doOperate(particle, elapsedTime) {
        const cpNumber = this.getParameter('Control Point Number to Set');
        const centerOffset = this.getParameter('Center Offset');
        //const v = vec3.add(tempVec3, particle.position, particle.cpPosition);
        this.particleSystem.getBounds(tempVec3_min, tempVec3_max);
        vec3.lerp(tempVec3_min, tempVec3_min, tempVec3_max, 0.5);
        vec3.add(tempVec3_min, tempVec3_min, centerOffset);
        this.particleSystem.setChildControlPointPosition(cpNumber, cpNumber, tempVec3_min);
    }
}
Source1ParticleOperators.registerOperator(SetControlPointToParticlesCenter);

const TEXTURE_WIDTH = 8;

const tempQuat$3 = quat.create();
const IDENTITY_QUAT = quat.create();
const vecDelta = vec3.create();
class RenderAnimatedSprites extends Source1ParticleOperator {
    static functionName = 'render_animated_sprites';
    #orientationType = 0 /*TODO: create enum*/;
    #texture;
    geometry;
    #maxParticles = 0; /*TODO: put in parent*/
    #imgData;
    constructor(system) {
        super(system);
        this.addParam('animation rate', PARAM_TYPE_FLOAT, 0.1);
        this.addParam('animation_fit_lifetime', PARAM_TYPE_BOOL, 0);
        this.addParam('orientation_type', PARAM_TYPE_INT, 0);
        this.addParam('orientation control point', PARAM_TYPE_INT, -1);
        this.addParam('second sequence animation rate', PARAM_TYPE_FLOAT, 0);
        this.addParam('use animation rate as FPS', PARAM_TYPE_BOOL, 0);
        this.addParam('Visibility Proxy Input Control Point Number', PARAM_TYPE_INT, -1);
        this.addParam('Visibility Camera Depth Bias', PARAM_TYPE_FLOAT, 0);
    }
    /*
    doRender(particleList, elapsedTime, material) {
        for (let i = 0; i < particleList.length; ++i) {
            this.renderAnimatedSprites(particleList[i], elapsedTime, material);
        }
    }
        */
    updateParticles(particleSystem, particleList, elapsedTime) {
        if (!this.geometry || !this.mesh || !this.particleSystem.material) {
            return;
        }
        const m_bFitCycleToLifetime = this.getParameter('animation_fit_lifetime');
        const rate = this.getParameter('animation rate');
        const useAnimRate = this.getParameter('use animation rate as FPS');
        this.geometry.count = particleList.length * 6;
        const maxParticles = this.#maxParticles;
        this.#setupParticlesTexture(particleList);
        this.mesh.setUniform('uMaxParticles', maxParticles); //TODOv3:optimize
        this.mesh.setUniform('uVisibilityCameraDepthBias', this.getParameter('Visibility Camera Depth Bias')); //TODOv3:optimize
        this.mesh.setVisible(Source1ParticleControler.visible);
        const orientationControlPointNumber = this.getParameter('orientation control point');
        const orientationControlPoint = this.particleSystem.getControlPoint(orientationControlPointNumber);
        if (orientationControlPoint) {
            this.mesh.setUniform('uOrientationControlPoint', orientationControlPoint.getWorldQuaternion(tempQuat$3));
        }
        else {
            this.mesh.setUniform('uOrientationControlPoint', IDENTITY_QUAT);
        }
        const uvs = this.geometry.attributes.get('aTextureCoord')._array;
        let index = 0;
        for (let i = 0; i < particleList.length; i++) {
            const particle = particleList[i];
            const sequence = particle.sequence;
            let flAgeScale;
            if (m_bFitCycleToLifetime) {
                const flLifetime = particle.timeToLive; //SubFloat(pLifeDuration[ nGroup * ld_stride ], nOffset);
                flAgeScale = (flLifetime > 0.0) ? (1.0 / flLifetime) * SEQUENCE_SAMPLE_COUNT : 0.0;
            }
            else {
                flAgeScale = rate * SEQUENCE_SAMPLE_COUNT;
                if (useAnimRate) {
                    //particle.frame+=elapsedTime*rate;
                    const frameSpan = this.particleSystem.material.getFrameSpan(sequence);
                    if (frameSpan !== null) {
                        flAgeScale = flAgeScale / frameSpan;
                    }
                }
            }
            let coords = this.particleSystem.material.getTexCoords(0, particle.currentTime, flAgeScale, sequence);
            if (coords) {
                //coords = coords.m_TextureCoordData[0];
                uvs[index++] = coords.uMin;
                uvs[index++] = coords.vMin;
                uvs[index++] = coords.uMax;
                uvs[index++] = coords.vMin;
                uvs[index++] = coords.uMin;
                uvs[index++] = coords.vMax;
                uvs[index++] = coords.uMax;
                uvs[index++] = coords.vMax;
                //uvs.push(0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0);
            }
            else {
                index += 8;
            }
        }
        this.geometry.attributes.get('aTextureCoord').dirty = true;
    }
    set maxParticles(maxParticles) {
        this.#maxParticles = Graphics$1.isWebGL2 ? maxParticles : ceilPowerOfTwo(maxParticles);
        this.#createParticlesArray();
        this.#initBuffers();
    }
    #initBuffers() {
        const geometry = this.geometry;
        if (!geometry || !this.mesh) {
            return;
        }
        const vertices = [];
        const uvs = [];
        const indices = [];
        const id = [];
        for (let i = 0; i < this.#maxParticles; i++) {
            const indiceBase = i * 4;
            if (this.#orientationType == 2 || this.#orientationType == 3) {
                indices.push(indiceBase, indiceBase + 1, indiceBase + 2, indiceBase + 2, indiceBase + 1, indiceBase + 3);
            }
            else {
                indices.push(indiceBase, indiceBase + 2, indiceBase + 1, indiceBase + 2, indiceBase + 3, indiceBase + 1);
            }
            vertices.push(-1.0, 1.0, 0.0, 1.0, 1.0, 0.0, -1.0, -1.0, 0.0, 1.0, -1.0, 0.0);
            uvs.push(0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0);
            id.push(i, i, i, i);
        }
        geometry.count = indices.length;
        geometry.setIndex(new Uint32BufferAttribute(indices, 1));
        geometry.setAttribute('aVertexPosition', new Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('aTextureCoord', new Float32BufferAttribute(uvs, 2));
        geometry.setAttribute('aParticleId', new Float32BufferAttribute(id, 1));
        this.mesh.setUniform('uMaxParticles', this.#maxParticles); //TODOv3:optimize
    }
    initRenderer() {
        this.geometry = new BufferGeometry();
        this.mesh = new Mesh({ geometry: this.geometry, material: this.particleSystem.material });
        this.mesh.serializable = false;
        this.mesh.hideInExplorer = true;
        this.mesh.setDefine('HARDWARE_PARTICLES');
        this.#createParticlesTexture();
        this.mesh.setUniform('uParticles', this.#texture);
        this.maxParticles = this.particleSystem.maxParticles;
        this.particleSystem.addChild(this.mesh);
        this.#orientationType = this.getParameter('orientation_type');
        this.setOrientationType(this.#orientationType);
        this.#initBuffers();
        /*
                switch (orientation) {
                    case 0: //always face camera
                        particleSystem.material.setDefine('PARTICLE_ORIENTATION_SCREEN_ALIGNED');
                        break;
                    case 1: //rotate around z
                        particleSystem.material.setDefine('SPRITE_ROTATE_AROUND_Z');
                        break;
                    case 2: //parallel to ground
                        particleSystem.material.setDefine('PARTICLE_ORIENTATION_WORLD_Z_ALIGNED');
                        //TODO
                        break;
                    case 3: //use normal
                    default:
                        //glCanvas.setUniform1f('uFaceCamera', -1.0);
                        break;
                }*/
    }
    #createParticlesArray() {
        this.#imgData = new Float32Array(this.#maxParticles * 4 * TEXTURE_WIDTH);
    }
    #createParticlesTexture() {
        this.#texture = TextureManager.createTexture();
        this.#texture.addUser(this);
        const gl = Graphics$1.glContext; //TODO
        gl.bindTexture(GL_TEXTURE_2D, this.#texture.texture);
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        gl.bindTexture(GL_TEXTURE_2D, null);
    }
    #updateParticlesTexture() {
        const gl = Graphics$1.glContext;
        gl.bindTexture(GL_TEXTURE_2D, this.#texture.texture);
        if (Graphics$1.isWebGL2) {
            gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA32F, TEXTURE_WIDTH, this.#maxParticles, 0, GL_RGBA, GL_FLOAT, this.#imgData);
        }
        else {
            gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, TEXTURE_WIDTH, this.#maxParticles, 0, GL_RGBA, GL_FLOAT, this.#imgData);
        }
        gl.bindTexture(GL_TEXTURE_2D, null);
    }
    #setupParticlesTexture(particleList) {
        const a = this.#imgData;
        let index = 0;
        for (const particle of particleList) { //TODOv3
            vec3.subtract(vecDelta, particle.prevPosition, particle.position);
            /*let pose = bone.boneMat;
            for (let k = 0; k < 16; ++k) {
                a[index++] = pose[k];
            }*/
            a[index++] = particle.position[0];
            a[index++] = particle.position[1];
            a[index++] = particle.position[2];
            index++;
            a[index++] = particle.color.r;
            a[index++] = particle.color.g;
            a[index++] = particle.color.b;
            a[index++] = particle.alpha * particle.alpha2;
            a[index++] = particle.radius;
            index++;
            a[index++] = particle.rotationRoll;
            a[index++] = particle.rotationYaw * DEG_TO_RAD;
            // Vec delta
            a[index++] = vecDelta[0];
            a[index++] = vecDelta[1];
            a[index++] = vecDelta[2];
            index++;
            // normal
            index += 4;
            // renderScreenVelocityRotate
            a[index++] = particle.renderScreenVelocityRotate ? 1 : 0;
            a[index++] = particle.m_flRotateRate;
            a[index++] = particle.m_flForward;
            index++;
            // free for now
            index += 8;
        }
        this.#updateParticlesTexture();
    }
    dispose() {
        this.mesh?.dispose();
        this.#texture?.removeUser(this);
    }
}
Source1ParticleOperators.registerOperator(RenderAnimatedSprites);

const tempVec2$1 = vec2.create();
class RenderRope extends Source1ParticleOperator {
    static functionName = 'render rope';
    #maxParticles = 0;
    texture;
    geometry;
    imgData;
    constructor(system) {
        super(system);
        this.addParam('subdivision_count', PARAM_TYPE_INT, 3);
        this.addParam('texel_size', PARAM_TYPE_FLOAT, 4.0);
        this.addParam('texture_scroll_rate', PARAM_TYPE_FLOAT, 0.0);
    }
    /*
    doRender(particleList, elapsedTime, material) {
        for (let i = 0; i < particleList.length; ++i) {
            this.renderAnimatedSprites(particleList[i], elapsedTime, material);
        }
    }
        */
    updateParticles(particleSystem, particleList, elapsedTime) {
        if (!this.geometry || !this.mesh || !this.particleSystem.material) {
            return;
        }
        this.getParameter('subdivision_count');
        const m_flTexelSizeInUnits = this.getParameter('texel_size');
        const m_flTextureScrollRate = this.getParameter('texture_scroll_rate');
        const m_flTextureScale = 1.0 / (this.particleSystem.material.getColorMapSize(tempVec2$1)[1] * m_flTexelSizeInUnits);
        const flTexOffset = m_flTextureScrollRate * particleSystem.currentTime;
        const geometry = this.geometry;
        const segments = [];
        let ropeLength = 0.0;
        let previousSegment = null;
        for (let i = 0, l = particleList.length; i < l; i++) {
            //for (let i = 0, l = (particleList.length - 1) * subdivCount + 1; i < l; i++) {
            const particle = particleList[i];
            const segment = new BeamSegment(particle.position, [particle.color.r, particle.color.g, particle.color.b, particle.alpha], 0.0, particle.radius);
            if (previousSegment) {
                ropeLength += segment.distanceTo(previousSegment);
            }
            segment.texCoordY = (ropeLength + flTexOffset) * m_flTextureScale;
            segments.push(segment);
            previousSegment = segment;
        }
        geometry.segments = segments;
    }
    set maxParticles(maxParticles) {
        this.#maxParticles = maxParticles;
        this.#createParticlesArray();
        //this._initBuffers();
    }
    initRenderer() {
        this.geometry = new BeamBufferGeometry();
        this.mesh = new Mesh({ geometry: this.geometry, material: this.particleSystem.material });
        this.mesh.serializable = false;
        this.mesh.hideInExplorer = true;
        this.mesh.setDefine('IS_ROPE');
        this.mesh.setDefine('USE_VERTEX_COLOR');
        this.#createParticlesTexture();
        this.mesh.setUniform('uParticles', this.texture);
        this.maxParticles = this.particleSystem.maxParticles;
        this.particleSystem.addChild(this.mesh);
        this.setOrientationType(this.getParameter('orientation_type')); //TODO: remove orientation_type : only for RenderAnimatedSprites
        this.particleSystem.material.renderFace(RenderFace.Both);
        /*
                switch (orientation) {
                    case 0: //always face camera
                        particleSystem.material.setDefine('PARTICLE_ORIENTATION_SCREEN_ALIGNED');
                        break;
                    case 1: //rotate around z
                        particleSystem.material.setDefine('SPRITE_ROTATE_AROUND_Z');
                        break;
                    case 2: //parallel to ground
                        particleSystem.material.setDefine('PARTICLE_ORIENTATION_WORLD_Z_ALIGNED');
                        //TODO
                        break;
                    case 3: //use normal
                    default:
                        //glCanvas.setUniform1f('uFaceCamera', -1.0);
                        break;
                }*/
    }
    #createParticlesArray() {
        this.imgData = new Float32Array(this.#maxParticles * 4 * TEXTURE_WIDTH);
    }
    #createParticlesTexture() {
        this.texture = TextureManager.createTexture();
        this.texture.addUser(this);
        const gl = Graphics$1.glContext; //TODO
        gl.bindTexture(GL_TEXTURE_2D, this.texture.texture);
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        gl.bindTexture(GL_TEXTURE_2D, null);
    }
    #updateParticlesTexture() {
        const gl = Graphics$1.glContext;
        gl.bindTexture(GL_TEXTURE_2D, this.texture.texture);
        if (Graphics$1.isWebGL2) {
            gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA32F, TEXTURE_WIDTH, this.#maxParticles, 0, GL_RGBA, GL_FLOAT, this.imgData);
        }
        else {
            gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, TEXTURE_WIDTH, this.#maxParticles, 0, GL_RGBA, GL_FLOAT, this.imgData);
        }
        gl.bindTexture(GL_TEXTURE_2D, null);
    }
    #setupParticlesTexture(particleList) {
        const a = this.imgData;
        let index = 0;
        for (const particle of particleList) { //TODOv3
            /*let pose = bone.boneMat;
            for (let k = 0; k < 16; ++k) {
                a[index++] = pose[k];
            }*/
            a[index++] = particle.position[0];
            a[index++] = particle.position[1];
            a[index++] = particle.position[2];
            index++;
            a[index++] = particle.color.r;
            a[index++] = particle.color.g;
            a[index++] = particle.color.b;
            a[index++] = particle.alpha;
            a[index++] = particle.radius;
            index++;
            a[index++] = particle.rotationRoll;
            a[index++] = particle.rotationYaw * DEG_TO_RAD;
            index++;
            index++;
            index++;
            index++;
            index += 16;
        }
        this.#updateParticlesTexture();
    }
    dispose() {
        this.mesh?.dispose();
        this.texture?.removeUser(this);
    }
}
Source1ParticleOperators.registerOperator(RenderRope);

// Note: this operator doesn't render anything, it simply orientate the particle for other renderers
class RenderScreenVelocityRotate extends Source1ParticleOperator {
    static functionName = 'render_screen_velocity_rotate';
    isScreenVelocityRotate = true;
    constructor(system) {
        super(system);
        this.addParam('rotate_rate(dps)', PARAM_TYPE_FLOAT, 0.0);
        this.addParam('forward_angle', PARAM_TYPE_FLOAT, -90.0);
    }
    /*
        doRender(particleList, elapsedTime, material) {
            for (let i = 0; i < particleList.length; ++i) {
                this.renderAnimatedSprites(particleList[i], elapsedTime, material);
            }
        }
    */
    updateParticles(particleSystem, particleList, elapsedTime) {
        const m_flRotateRate = this.getParameter('rotate_rate(dps)') * DEG_TO_RAD;
        const m_flForward = this.getParameter('forward_angle') * DEG_TO_RAD;
        for (let i = 0; i < particleList.length; i++) {
            const particle = particleList[i];
            particle.renderScreenVelocityRotate = true;
            particle.m_flRotateRate = m_flRotateRate;
            particle.m_flForward = m_flForward;
        }
    }
    initRenderer() {
        // Nothing to do
    }
}
Source1ParticleOperators.registerOperator(RenderScreenVelocityRotate);

class RenderSpriteTrail extends Source1ParticleOperator {
    static functionName = 'render_sprite_trail';
    texture;
    geometry;
    imgData;
    constructor(system) {
        super(system);
        this.addParam('animation rate', PARAM_TYPE_FLOAT, 0.1);
        this.addParam('length fade in time', PARAM_TYPE_FLOAT, 0.0);
        this.addParam('max length', PARAM_TYPE_FLOAT, 2000.0);
        this.addParam('min length', PARAM_TYPE_FLOAT, 0.0);
        //	DMXELEMENT_UNPACK_FIELD('animation rate', '.1', float, m_flAnimationRate)
        //	DMXELEMENT_UNPACK_FIELD('length fade in time', '0', float, m_flLengthFadeInTime)
        //	DMXELEMENT_UNPACK_FIELD('max length', '2000', float, m_flMaxLength)
        //	DMXELEMENT_UNPACK_FIELD('min length', '0', float, m_flMinLength)
    }
    /*
    doRender(particleList, elapsedTime, material) {
        for (let i = 0; i < particleList.length; ++i) {
            this.renderSpriteTrail(particleList[i], elapsedTime, material);
        }
    }*/
    updateParticles(particleSystem, particleList, elapsedTime) {
        if (!this.geometry || !this.mesh || !this.particleSystem.material) {
            return;
        }
        const rate = this.getParameter('animation rate') ?? 30;
        this.geometry.count = particleList.length * 6;
        const maxParticles = Graphics$1.isWebGL2 ? particleSystem.maxParticles : ceilPowerOfTwo(particleSystem.maxParticles);
        this.#setupParticlesTexture(particleList, maxParticles, elapsedTime);
        this.mesh.setUniform('uMaxParticles', maxParticles); //TODOv3:optimize
        this.mesh.setVisible(Source1ParticleControler.visible);
        let index = 0;
        for (const particle of particleList) {
            let coords = this.particleSystem.material.getTexCoords(0, particle.currentTime, rate * SEQUENCE_SAMPLE_COUNT, particle.sequence);
            if (coords) {
                const uvs = this.geometry.attributes.get('aTextureCoord')._array;
                //coords = coords.m_TextureCoordData[0];
                /*
                const uMin = coords.m_fLeft_U0;
                const vMin = coords.m_fTop_V0;
                const uMax = coords.m_fRight_U0;
                const vMax = coords.m_fBottom_V0;
                */
                uvs[index++] = coords.uMin;
                uvs[index++] = coords.vMin;
                uvs[index++] = coords.uMax;
                uvs[index++] = coords.vMin;
                uvs[index++] = coords.uMin;
                uvs[index++] = coords.vMax;
                uvs[index++] = coords.uMax;
                uvs[index++] = coords.vMax;
            }
            else {
                index += 8;
            }
        }
        this.geometry.attributes.get('aTextureCoord').dirty = true;
    }
    initRenderer() {
        const maxParticles = Graphics$1.isWebGL2 ? this.particleSystem.maxParticles : ceilPowerOfTwo(this.particleSystem.maxParticles);
        this.createParticlesArray(maxParticles);
        this.#createParticlesTexture();
        const vertices = [];
        const uvs = [];
        const indices = [];
        const id = [];
        for (let i = 0; i < maxParticles; i++) {
            const indiceBase = i * 4;
            indices.push(indiceBase, indiceBase + 2, indiceBase + 1, indiceBase + 2, indiceBase + 3, indiceBase + 1);
            vertices.push(-1.0, 1.0, 0.0, 1.0, 1.0, 0.0, -1.0, -1.0, 0.0, 1.0, -1.0, 0.0);
            uvs.push(0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0);
            id.push(i, i, i, i);
        }
        const vertexPosition = new Float32BufferAttribute(vertices, 3);
        const textureCoord = new Float32BufferAttribute(uvs, 2);
        const particleId = new Float32BufferAttribute(id, 1);
        const geometry = new BufferGeometry();
        geometry.setIndex(new Uint32BufferAttribute(indices, 1));
        geometry.setAttribute('aVertexPosition', vertexPosition);
        geometry.setAttribute('aTextureCoord', textureCoord);
        geometry.setAttribute('aParticleId', particleId);
        geometry.count = indices.length;
        this.mesh = new Mesh({ geometry: geometry, material: this.particleSystem.material });
        this.mesh.serializable = false;
        this.mesh.hideInExplorer = true;
        this.mesh.setDefine('HARDWARE_PARTICLES');
        this.mesh.setUniform('uParticles', this.texture);
        this.mesh.setUniform('uMaxParticles', maxParticles); //TODOv3:optimize
        this.particleSystem.addChild(this.mesh);
        this.geometry = geometry;
        this.particleSystem.material.setDefine('RENDER_SPRITE_TRAIL');
        //particleSystem.material.setDefine('PARTICLE_ORIENTATION_SCREEN_ALIGNED');
        this.setOrientationType(0);
    }
    createParticlesArray(maxParticles) {
        this.imgData = new Float32Array(maxParticles * 4 * TEXTURE_WIDTH);
    }
    #createParticlesTexture() {
        this.texture = TextureManager.createTexture();
        this.texture.addUser(this);
        const gl = Graphics$1.glContext; //TODO
        gl.bindTexture(GL_TEXTURE_2D, this.texture.texture);
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        gl.bindTexture(GL_TEXTURE_2D, null);
    }
    #updateParticlesTexture(maxParticles, pixels) {
        const gl = Graphics$1.glContext;
        gl.bindTexture(GL_TEXTURE_2D, this.texture.texture);
        if (Graphics$1.isWebGL2) {
            gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA32F, TEXTURE_WIDTH, maxParticles, 0, GL_RGBA, GL_FLOAT, pixels);
        }
        else {
            gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, TEXTURE_WIDTH, maxParticles, 0, GL_RGBA, GL_FLOAT, pixels);
        }
        gl.bindTexture(GL_TEXTURE_2D, null);
    }
    #setupParticlesTexture(particleList, maxParticles, elapsedTime) {
        const m_flMaxLength = this.getParameter('max length');
        const m_flMinLength = this.getParameter('min length');
        const m_flLengthFadeInTime = this.getParameter('length fade in time');
        this.getParameter('animation rate') ?? 30;
        this.getParameter('animation_fit_lifetime') ?? 0;
        /*
                if (fit) {
                    rate = material.sequenceLength / particle.timeToLive;
                }
                    */
        const a = new Float32Array(maxParticles * 4 * TEXTURE_WIDTH);
        let index = 0;
        for (const particle of particleList) {
            const flAge = particle.currentTime;
            const flLengthScale = (flAge >= m_flLengthFadeInTime) ? 1.0 : (flAge / m_flLengthFadeInTime);
            const vecDelta = vec3.subtract(vec3.create(), particle.prevPosition, particle.position); //TODOv3: optimize
            const flMag = vec3.length(vecDelta);
            vec3.normalize(vecDelta, vecDelta);
            const flOODt = (elapsedTime != 0.0) ? (1.0 / elapsedTime) : 1.0;
            let flLength = flLengthScale * flMag * flOODt * particle.trailLength;
            if (flLength <= 0.0) {
                return;
            }
            flLength = clamp$1(flLength, m_flMinLength, m_flMaxLength);
            //vec3.scale(vecDelta, vecDelta, flLength * 0.5);TODOv3
            //const vTangentY = vec3.cross(vec3.create(), vDirToBeam, vecDelta);
            let rad = particle.radius;
            if (flLength < rad) {
                rad = flLength;
            }
            a[index++] = particle.position[0];
            a[index++] = particle.position[1];
            a[index++] = particle.position[2];
            index++;
            a[index++] = particle.color.r;
            a[index++] = particle.color.g;
            a[index++] = particle.color.b;
            a[index++] = particle.alpha;
            a[index++] = rad;
            index++;
            a[index++] = particle.rotationRoll;
            a[index++] = particle.rotationYaw * DEG_TO_RAD;
            a[index++] = vecDelta[0];
            a[index++] = vecDelta[1];
            a[index++] = vecDelta[2];
            a[index++] = flLength;
            index += 16;
        }
        this.#updateParticlesTexture(maxParticles, a);
    }
    /*
    setupParticlesTexture1(particleList, maxParticles, elapsedTime) {
        const m_flMaxLength = this.getParameter('max length');
        const m_flMinLength = this.getParameter('min length');
        const m_flLengthFadeInTime = this.getParameter('length fade in time');
        const rate = this.getParameter('animation rate') || 30;
        const fit = this.getParameter('animation_fit_lifetime') || 0;
        /*
                if (fit) {
                    rate = material.sequenceLength / particle.timeToLive;
                }
        * /

        const a = new Float32Array(maxParticles * 4 * TEXTURE_WIDTH);
        let index = 0;

        for (const particle of particleList) {
            const flAge = particle.currentTime;
            const flLengthScale = (flAge >= m_flLengthFadeInTime) ? 1.0 : (flAge / m_flLengthFadeInTime);
            const vecDelta = vec3.subtract(vec3.create(), particle.prevPosition, particle.position);//TODOv3: optimize
            const flMag = vec3.length(vecDelta);
            vec3.normalize(vecDelta, vecDelta);
            const flOODt = (elapsedTime != 0.0) ? (1.0 / elapsedTime) : 1.0;
            let flLength = flLengthScale * flMag * flOODt * particle.trailLength;
            if (flLength <= 0.0) {
                return;
            }

            flLength = clamp(flLength, m_flMinLength, m_flMaxLength);
            //vec3.scale(vecDelta, vecDelta, flLength * 0.5);TODOv3

            //const vTangentY = vec3.cross(vec3.create(), vDirToBeam, vecDelta);
            let rad = particle.radius;
            if (flLength < rad) {
                rad = flLength;
            }

            a[index++] = particle.position[0];
            a[index++] = particle.position[1];
            a[index++] = particle.position[2];
            index++;
            a[index++] = particle.color.r;
            a[index++] = particle.color.g;
            a[index++] = particle.color.b;
            a[index++] = particle.alpha;
            a[index++] = rad;
            index++;
            a[index++] = particle.rotationRoll;
            a[index++] = particle.rotationYaw * DEG_TO_RAD;
            a[index++] = vecDelta[0];
            a[index++] = vecDelta[1];
            a[index++] = vecDelta[2];
            a[index++] = flLength;
            index += 16;
        }

        this.#updateParticlesTexture(maxParticles, a);
    }
    */
    dispose() {
        this.mesh?.dispose();
        this.texture?.removeUser(this);
    }
}
Source1ParticleOperators.registerOperator(RenderSpriteTrail);

var source1_blend_pixel_fog_const = `
vec3 BlendPixelFogConst( const vec3 vShaderColor, float pixelFogFactor, const vec3 vFogColor, float fPixelFogType )
{
	pixelFogFactor = clamp( pixelFogFactor, 0.0, 1.0);
	vec3 fRangeResult = mix( vShaderColor.rgb, vFogColor.rgb, pixelFogFactor * pixelFogFactor ); //squaring the factor will get the middle range mixing closer to hardware fog
	vec3 fHeightResult = mix( vShaderColor.rgb, vFogColor.rgb, pixelFogFactor);
	return mix( fRangeResult, fHeightResult, fPixelFogType );
}
`;

var source1_blend_tint = `
#ifdef BLEND_TINT_BY_BASE_ALPHA
	vec3 tintedColor = albedo * g_DiffuseModulation.rgb;
	tintedColor = mix(tintedColor, g_DiffuseModulation.rgb, uBlendTintColorOverBase);
	albedo = mix(albedo, tintedColor, texelColor.a);
#else
	albedo = albedo * g_DiffuseModulation.rgb;
#endif
`;

var source1_colormap_alpha = `
#ifdef IS_TRANSLUCENT
	#if !defined(BASE_ALPHA_ENV_MAP_MASK) && !defined(SELF_ILLUM) && !defined(BLEND_TINT_BY_BASE_ALPHA) && !defined(USE_COLOR_ALPHA_AS_PHONG_MASK)
		alpha *= texelColor.a;
	#endif
#endif
`;

var source1_compute_particle_position = `
vec4 q;
vec3 a;
#ifndef PARTICLE_ORIENTATION
	#define PARTICLE_ORIENTATION 3
#endif
#ifndef USE_PARTICLE_YAW
	#define USE_PARTICLE_YAW 1
#endif

#define PARTICLE_ORIENTATION_SCREEN_ALIGNED 0
#define PARTICLE_ORIENTATION_SCREEN_Z_ALIGNED 1
#define PARTICLE_ORIENTATION_WORLD_Z_ALIGNED 2
#define PARTICLE_ORIENTATION_ALIGN_TO_PARTICLE_NORMAL 3
#define PARTICLE_ORIENTATION_SCREENALIGN_TO_PARTICLE_NORMAL 4
#define PARTICLE_ORIENTATION_FULL_3AXIS_ROTATION 5

	particle p = getParticle(int(aParticleId));
	vTextureCoord.xy = aTextureCoord;
	vColor = p.color;

	vec3 aVertexPosition3 = aVertexPosition;


	//vec4 test = vec4(aVertexPosition3 + vecDelta, 1.0);// * p.radius * rotationMatrix(vec3(0.0, 1.0, 0.0), -p.roll * 1.0);
	vec4 test = vec4(aVertexPosition3, 1.0) * p.radius * rotationMatrix(vec3(0.0, .0, 1.0), -p.roll * 1.0);
	vec4 vertexPositionModelSpace = vec4(p.center.xyz + test.xyz, 1.0);
	//vertexPositionModelSpace *= rotationMatrix(vec3(0.0, 1.0, 0.0), -p.roll * 100.0);

	vec4 vertexPositionCameraSpace;// = uModelViewMatrix * vertexPositionModelSpace;


#ifdef RENDER_SPRITE_TRAIL
	vec3 vecDelta = p.vecDelta.xyz;
	//vecDelta = vec3(1.0, 1.0, 0.0);
	vec3 aVertexPosition2;

	a = cross(vec3(1.0, 0.0, 0.0), vecDelta);
	q.xyz = a;
	q.w = 1.0 + dot(vec3(1.0, 0.0, 0.0), vecDelta);

	aVertexPosition2 = vec3_transformQuat(aVertexPosition3 * vec3(p.vecDelta.w, 0.0, p.radius), normalize(q));

	vertexPositionModelSpace = vec4(p.center + aVertexPosition2 + vecDelta * p.vecDelta.w * 0.0, 1.0);


	vec3 test2 = vec3_transformQuat(vec3(0.0, 0.0, 1.0), normalize(q));
	test2 = normalize(test2);


	aVertexPosition2 = vec3_transformQuat(aVertexPosition3 * vec3(p.vecDelta.w * 0.5, p.radius * 0.5, 0.0), normalize(q));
	vec3 eyeDir = p.center - uCameraPosition;
	q.xyz = vecDelta;
	q.w = 1.0 + dot(eyeDir, a);

#endif


#if PARTICLE_ORIENTATION == PARTICLE_ORIENTATION_SCREEN_ALIGNED
#ifdef RENDER_SPRITE_TRAIL
	//A + dot(AP,AB) / dot(AB,AB) * AB
	vec3 A =  p.center;
	vec3 B =  A + vecDelta;
	vec3 P =  uCameraPosition;
	vec3 AP = P-A;
	vec3 AB = B-A;

	vec3 projPoint = A + dot(AP,AB) / dot(AB,AB) * AB;


	vec3 vDirToBeam = normalize(projPoint - uCameraPosition);
	vec3 vTangentY = normalize(cross(vDirToBeam, vecDelta));
	vTangentY = test2;
	vertexPositionModelSpace = vec4(aVertexPosition2 + vecDelta * p.vecDelta.w * 0.5, 1.0);


	A = -vDirToBeam;
	B = normalize(vecDelta);
	mat3 M  = mat3(
1.0-B.x*B.x,-B.y*B.x,-B.z*B.x,
-B.x*B.y,1.0-B.y*B.y,-B.z*B.y,
-B.x*B.z,-B.y*B.z,1.0-B.z*B.z
	    );
	vec3 C = M * A;//B * (A * B / length(B)) / length(B);

	q.xyz = cross(vTangentY, C);
	q.w = 1.0 + dot(vTangentY, C);
	vertexPositionModelSpace = vec4_transformQuat(vertexPositionModelSpace, normalize(q));
	vertexPositionModelSpace.xyz += p.center;


	//vertexPositionModelSpace.xyz = vertexPositionModelSpace.xyz + vTangentY * p.radius * 0.5;


	vertexPositionCameraSpace = uModelViewMatrix * vertexPositionModelSpace;
	gl_Position = uProjectionMatrix * vertexPositionCameraSpace;
#else
	mat4 lookAt = rotationMatrix(vec3(0.0, 1.0, 0.0), p.yaw);
	mat4 lookAt2 = rotationMatrix(vec3(0.0, 0.0, 1.0), -p.roll);
	lookAt = lookAt * lookAt2;
	gl_Position = uProjectionMatrix * (uModelViewMatrix * vec4(p.center, 1.0) + lookAt * vec4(aVertexPosition.xy * p.radius, 0.0, 0.0));

#endif
#else
	vertexPositionCameraSpace = uModelViewMatrix * vertexPositionModelSpace;
	gl_Position = uProjectionMatrix * vertexPositionCameraSpace;
#endif

#if PARTICLE_ORIENTATION == PARTICLE_ORIENTATION_SCREENALIGN_TO_PARTICLE_NORMAL
	mat4 lookAt = rotationMatrix(vec3(0.0, 1.0, 0.0), p.yaw);
	mat4 lookAt2 = rotationMatrix(vec3(0.0, 0.0, 1.0), -p.roll);
	lookAt = lookAt * lookAt2;
	gl_Position = uProjectionMatrix * (uModelViewMatrix * vec4(p.center, 1.0) + lookAt * vec4(aVertexPosition.xy * p.radius, 0.0, 0.0));
#endif

#if PARTICLE_ORIENTATION == PARTICLE_ORIENTATION_SCREENALIGN_TO_PARTICLE_NORMAL
	vertexPositionCameraSpace = uModelViewMatrix * vertexPositionModelSpace;
	gl_Position = uProjectionMatrix * vertexPositionCameraSpace;
#endif

#if PARTICLE_ORIENTATION == PARTICLE_ORIENTATION_SCREEN_Z_ALIGNED
	mat4 lookAt = rotationMatrix(vec3(0.0, 1.0, 0.0), -p.yaw);
	mat4 lookAt2 = rotationMatrix(vec3(0.0, 0.0, 1.0), -p.roll);
	lookAt = lookAt * lookAt2;
	gl_Position = uProjectionMatrix * (uModelViewMatrix * vec4(p.center, 1.0) + lookAt * vec4(aVertexPosition.xy * p.radius, 0.0, 0.0));
#endif

#if PARTICLE_ORIENTATION == PARTICLE_ORIENTATION_WORLD_Z_ALIGNED
	mat4 yawMatrix = rotationMatrix(vec3(0.0, 1.0, 0.0), p.yaw);

	#ifdef IS_SPRITE_CARD_MATERIAL
		mat4 rollMatrix = rotationMatrix(vec3(0.0, 0.0, 1.0), HALF_PI - p.roll);
	#else
		mat4 rollMatrix = rotationMatrix(vec3(0.0, 0.0, 1.0), p.roll);
	#endif
	mat4 lookAt;

	mat4 cpMat = mat4FromQuat(uOrientationControlPoint);

	#if USE_PARTICLE_YAW == 1
		lookAt = cpMat * yawMatrix * rollMatrix;
	#else
		lookAt = cpMat * rollMatrix;
	#endif

	#ifndef IS_SPRITE_CARD_MATERIAL
		gl_Position = uProjectionMatrix * (uModelViewMatrix * (vec4(p.center, 1.0) + lookAt * vec4(vec2(1.0, -1.0) * aVertexPosition.xy * p.radius, 0.0, 0.0)));
	#else
		gl_Position = uProjectionMatrix * (uModelViewMatrix * (vec4(p.center, 1.0) + lookAt * vec4(aVertexPosition.xy * p.radius, 0.0, 0.0)));
	#endif
#endif

#ifdef SOURCE1_PARTICLES
	#if PARTICLE_ORIENTATION == PARTICLE_ORIENTATION_ALIGN_TO_PARTICLE_NORMAL
		mat4 lookAt = rotationMatrix(vec3(0.0, 1.0, 0.0), -p.yaw);
		mat4 lookAt2 = rotationMatrix(vec3(0.0, 0.0, 1.0), -p.roll);
		lookAt = lookAt * lookAt2;
		gl_Position = uProjectionMatrix * (uModelViewMatrix * vec4(p.center, 1.0) + lookAt * vec4(aVertexPosition.xy * p.radius, 0.0, 0.0));
	#endif
#else //SOURCE2
	#if PARTICLE_ORIENTATION == PARTICLE_ORIENTATION_ALIGN_TO_PARTICLE_NORMAL
		vec3 particleNormal = normalize(p.normal);//not sure we have to normalize
		mat4 lookAt = rotationMatrix(particleNormal, p.roll);
		vec4 pos;

		vec3 vTrialVector = vec3( 0.0, 0.0, 1.0 );
		if ( abs( particleNormal.z ) > 0.9 )
		{
			vTrialVector = float3( 1, 0, 0 );
		}
		vec3 up = normalize( cross( particleNormal, vTrialVector ) );
		vec3 right = cross( particleNormal, up );

	    pos.xyz = aVertexPosition.x * p.radius * right;
	    pos.xyz += aVertexPosition.y * p.radius * up;
		pos = lookAt * pos;
		pos += vec4(p.center, 1.0);
		gl_Position = uProjectionMatrix * (uModelViewMatrix * pos);
	#endif
#endif
`;

var source1_compute_selfillum = `
#if defined(USE_SELF_ILLUM) && COLOR_MAP_ALPHA_BITS > 0
	#ifdef USE_SELF_ILLUM_ENVMAPMASK_ALPHA
		#ifdef USE_CUBE_MAP
			vec3 selfIllumComponent = uSelfIllumTint * albedo;
			float Adj_Alpha = 1. * cubeMapColor.a;
			diffuse = max(0., 1. - Adj_Alpha) * diffuse + Adj_Alpha * selfIllumComponent;
		#endif
	#else
		#ifdef USE_SELF_ILLUM_MASK_MAP
			vec3 selfIllumMask = texture2D(uSelfIllumMaskMap, vTextureCoord.xy).rgb;
		#else
			vec3 selfIllumMask = texelColor.aaa;
		#endif

		#if !defined(SKIP_SELF_ILLUM_FRESNEL) && defined(USE_SELF_ILLUM_FRESNEL)
			vec3 worldVertToEyeVectorXYZ_tangentSpaceVertToEyeVectorZ = normalize(uCameraPosition - vVertexPositionWorldSpace.xyz);
			vec3 vVertexNormal = normalize(vVertexNormalWorldSpace.xyz);

			float flSelfIllumFresnel = (
										pow(
											saturate(
												dot(vVertexNormal, normalize(worldVertToEyeVectorXYZ_tangentSpaceVertToEyeVectorZ))
											), uSelfIllumScaleBiasExpBrightness.z
										) * uSelfIllumScaleBiasExpBrightness.x) + uSelfIllumScaleBiasExpBrightness.y;
			diffuse = mix(diffuse, albedo * uSelfIllumTint * uSelfIllumScaleBiasExpBrightness.w, selfIllumMask * saturate(flSelfIllumFresnel));
		#else
			// Not sure why I need to multiply by g_DiffuseModulation.rgb, but it works better
			diffuse = mix(diffuse, albedo * uSelfIllumTint * g_DiffuseModulation.rgb, selfIllumMask);
		#endif
	#endif
#endif
`;

var source1_compute_sheen = `
vec3 sheenMapColor = vec3(1.0);

#ifdef USE_SHEEN_MASK_MAP
	vec2 sheenMaskCoords = vec2(0.0);
	if (g_flSheenDirection == 0.0) {
		sheenMaskCoords.x = vVertexPositionModelSpace.z;
		sheenMaskCoords.y = vVertexPositionModelSpace.y;
	} else if (g_flSheenDirection == 1.0) {
		sheenMaskCoords.x = vVertexPositionModelSpace.z;
		sheenMaskCoords.y = vVertexPositionModelSpace.x;
	} else {
		sheenMaskCoords.x = vVertexPositionModelSpace.y;
		sheenMaskCoords.y = vVertexPositionModelSpace.x;
	}

	sheenMaskCoords = (sheenMaskCoords - g_vPackedConst6.zw) / g_vPackedConst6.xy;

	sheenMapColor *= texture2D(sheenMaskMap, sheenMaskCoords).rgb;
#endif


	//vec3 sheenMapTint = texture2D(sheenMapMask, (sheenMaskCoord - vec2(sheenMapMaskOffsetX)) / sheenMapMaskScaleX).rgb;
#ifdef USE_SHEEN_MAP
	sheenMapColor *= vec4(textureCube(sheenMap, reflectDir)).rgb;
	sheenMapColor *= g_cCloakColorTint.rgb;

	gl_FragColor.rgb += sheenMapColor * 3.0;
#endif


#ifdef USE_SHEEN_MASK_MAP
	//albedo = abs(vec3(sheenMaskCoords.xy, 0.0));
#endif
`;

var source1_declare_gamma_functions = `
#ifndef SKIP_GAMMA_TO_LINEAR
	float GammaToLinear(const float gamma) {
		return pow(gamma, 2.2);
	}
	vec3 GammaToLinear(const vec3 gamma) {
		return pow(gamma, vec3(2.2));
	}
	vec4 GammaToLinear(const vec4 gamma) {
		return vec4(pow(gamma.rgb, vec3(2.2)), gamma.a);
	}
#else
	float GammaToLinear(const float gamma) {
		return gamma;
	}
	vec3 GammaToLinear(const vec3 gamma) {
		return gamma;
	}
	vec4 GammaToLinear(const vec4 gamma) {
		return gamma;
	}
#endif
`;

var source1_declare_particle_position = `
vec4 vec4_transformQuat(vec4 a, vec4 q) {
	vec4 ret;
	float qx = q.x;
	float qy = q.y;
	float qz = q.z;
	float qw = q.w;

	float x = a.x;
	float y = a.y;
	float z = a.z;

	// calculate quat * vec
	float ix = qw * x + qy * z - qz * y;
	float iy = qw * y + qz * x - qx * z;
	float iz = qw * z + qx * y - qy * x;
	float iw = -qx * x - qy * y - qz * z;

	// calculate result * inverse quat
	ret.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
	ret.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
	ret.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
	ret.w = a.w;
	return ret;
}
`;

var source1_declare_phong = `
//TODO: set a vec2 for these two ?
uniform float uPhongExponent;
uniform float uPhongExponentFactor;
uniform float uPhongBoost;
`;

var source1_declare_selfillum = `
#ifdef USE_SELF_ILLUM
	uniform vec3 uSelfIllumTint;

	#ifdef USE_SELF_ILLUM_MASK_MAP
		uniform sampler2D uSelfIllumMaskMap;
	#endif

	#ifndef SKIP_SELF_ILLUM_FRESNEL
		#ifdef USE_SELF_ILLUM_FRESNEL
			uniform vec4 uSelfIllumScaleBiasExpBrightness;
		#endif
	#endif
#endif
`;

var source1_declare_sheen = `
#ifdef USE_SHEEN_MAP
	uniform samplerCube sheenMap;
#endif
#ifdef USE_SHEEN_MASK_MAP
	uniform sampler2D sheenMaskMap;
#endif

uniform vec4 g_vPackedConst6;
uniform vec4 g_vPackedConst7;
uniform vec3 g_cCloakColorTint;

#define g_flSheenMapMaskScaleX g_vPackedConst6.x // Default = 1.0f
#define g_flSheenMapMaskScaleY g_vPackedConst6.y // Default = 1.0f
#define g_flSheenMapMaskOffsetX g_vPackedConst6.z // Default = 0.0f
#define g_flSheenMapMaskOffsetY g_vPackedConst6.w // Default = 0.0f

#define g_flSheenDirection		g_vPackedConst7.x // 0,1,2 -> XYZ
#define g_flEffectIndex			g_vPackedConst7.y // W
`;

var source1_final_output_const = `
#include source1_blend_pixel_fog_const

vec4 FinalOutputConst( const vec4 vShaderColor, float pixelFogFactor, float fPixelFogType, const int iTONEMAP_SCALE_TYPE, float fWriteDepthToDestAlpha, const float flProjZ )
{
	vec4 result = vShaderColor;
	if( iTONEMAP_SCALE_TYPE == TONEMAP_SCALE_LINEAR )
	{
		result.rgb *= LINEAR_LIGHT_SCALE;
	}
	else if( iTONEMAP_SCALE_TYPE == TONEMAP_SCALE_GAMMA )
	{
		result.rgb *= GAMMA_LIGHT_SCALE;
	}

	result.a = mix( result.a, DepthToDestAlpha( flProjZ ), fWriteDepthToDestAlpha );

	result.rgb = BlendPixelFogConst( result.rgb, pixelFogFactor, g_LinearFogColor.rgb, fPixelFogType );
	result.rgb = SRGBOutput( result.rgb ); //SRGB in pixel shader conversion

	return result;
}
`;

var source1_fragment_common = `

const vec4 g_LinearFogColor = vec4(0.0, 0.0, 0.0, 1.0 / 192.0);
#define OO_DESTALPHA_DEPTH_RANGE (g_LinearFogColor.w)

#define HDR_INPUT_MAP_SCALE 16.0

#define TONEMAP_SCALE_NONE 0
#define TONEMAP_SCALE_LINEAR 1
#define TONEMAP_SCALE_GAMMA 2


#define LINEAR_LIGHT_SCALE 1.0
#define LIGHT_MAP_SCALE 1.0
#define ENV_MAP_SCALE 1.0
#define GAMMA_LIGHT_SCALE pow(1.0, 1.0 / 2.2);

//sampler1D GammaTableSampler : register( s15 );
uniform sampler2D gammaTableMap;

vec3 SRGBOutput( const vec3 vShaderColor )
{
	return vShaderColor;//TODOv3: remove me
	//On ps2b capable hardware we always have the linear->gamma conversion table texture in sampler s15.
	vec3 result;
	result.r = texture2D( gammaTableMap, vec2(vShaderColor.r, 0.5)).r;
	result.g = texture2D( gammaTableMap, vec2(vShaderColor.g, 0.5)).r;
	result.b = texture2D( gammaTableMap, vec2(vShaderColor.b, 0.5)).r;
	return result;
}

float SoftParticleDepth( float flDepth )
{
	return flDepth * OO_DESTALPHA_DEPTH_RANGE;
}
float DepthToDestAlpha( const float flProjZ )
{
	return SoftParticleDepth( flProjZ );
}


float3 CalcReflectionVectorUnnormalized( float3 normal, float3 eyeVector )
{
	// FIXME: might be better of normalizing with a normalizing cube map and
	// get rid of the dot( normal, normal )
	// compute reflection vector r = 2 * ((n dot v)/(n dot n)) n - v
	//  multiply all values through by N.N.  uniformly scaling reflection vector won't affect result
	//  since it is used in a cubemap lookup
	return (2.0*(dot( normal, eyeVector ))*normal) - (dot( normal, normal )*eyeVector);
}


// Traditional fresnel term approximation
float Fresnel( const float3 vNormal, const float3 vEyeDir )
{
	float fresnel = 1.0-saturate( dot( vNormal, vEyeDir ) );				// 1-(N.V) for Fresnel term
	return fresnel * fresnel;											// Square for a more subtle look
}

// Traditional fresnel term approximation which uses 4th power (square twice)
float Fresnel4( const float3 vNormal, const float3 vEyeDir )
{
	float fresnel = 1.0-saturate( dot( vNormal, vEyeDir ) );				// 1-(N.V) for Fresnel term
	fresnel = fresnel * fresnel;										// Square
	return fresnel * fresnel;											// Square again for a more subtle look
}

float Fresnel( const float3 vNormal, const float3 vEyeDir, float3 vRanges )
{
	float result, f = Fresnel( vNormal, vEyeDir );			// Traditional Fresnel

	if ( f > 0.5 )
		result = lerp( vRanges.y, vRanges.z, (2.0*f)-1.0 );		// Blend between mid and high values
	else
		result = lerp( vRanges.x, vRanges.y, 2.0*f );			// Blend between low and mid values
	return result;
}
`;

var source1_varying_character = `
#include varying_standard
`;

var source1_varying_customweapon = `
#include varying_standard
`;

var source1_varying_eyerefract = `
#include varying_standard
`;

var source1_varying_refract = `
#include varying_standard
varying vec4 vDetailTextureCoord;
`;

var source1_varying_sprite = `
#include varying_standard
varying vec4 vColor;
`;

var source1_varying_spritecard = `
#include varying_standard
varying vec4 vColor;
`;

var source1_varying_unlit_generic = `
#include varying_standard
varying vec4 vColor;
`;

var source1_varying_unlittwotexture = `
#include varying_standard

varying vec4 vColor;
`;

var source1_varying_vertexlit_generic = `
#include varying_standard
varying vec4 vDetailTextureCoord;
`;

var source1_varying_weapondecal = `
varying vec4 vVertexPositionWorldSpace;
varying vec4 vVertexPositionCameraSpace;

varying vec3 vVertexNormalWorldSpace;
varying vec3 vVertexNormalCameraSpace;
varying vec3 vVertexTangentWorldSpace;
varying vec3 vVertexTangentCameraSpace;
varying vec3 vVertexBitangentWorldSpace;
varying vec3 vVertexBitangentCameraSpace;

varying vec4 vTextureCoord;
`;

var source1_varying_worldvertextransition = `
#include varying_standard
varying vec2 vLightCoord;
varying float vVertexAlpha;
varying float vEyeDistance;
`;

Includes['source1_blend_pixel_fog_const'] = source1_blend_pixel_fog_const;
Includes['source1_blend_tint'] = source1_blend_tint;
Includes['source1_colormap_alpha'] = source1_colormap_alpha;
Includes['source1_compute_particle_position'] = source1_compute_particle_position;
Includes['source1_compute_selfillum'] = source1_compute_selfillum;
Includes['source1_compute_sheen'] = source1_compute_sheen;
Includes['source1_declare_gamma_functions'] = source1_declare_gamma_functions;
Includes['source1_declare_particle_position'] = source1_declare_particle_position;
Includes['source1_declare_phong'] = source1_declare_phong;
Includes['source1_declare_selfillum'] = source1_declare_selfillum;
Includes['source1_declare_sheen'] = source1_declare_sheen;
Includes['source1_final_output_const'] = source1_final_output_const;
Includes['source1_fragment_common'] = source1_fragment_common;
Includes['source1_varying_character'] = source1_varying_character;
Includes['source1_varying_customweapon'] = source1_varying_customweapon;
Includes['source1_varying_eyerefract'] = source1_varying_eyerefract;
Includes['source1_varying_refract'] = source1_varying_refract;
Includes['source1_varying_sprite'] = source1_varying_sprite;
Includes['source1_varying_spritecard'] = source1_varying_spritecard;
Includes['source1_varying_unlit_generic'] = source1_varying_unlit_generic;
Includes['source1_varying_unlittwotexture'] = source1_varying_unlittwotexture;
Includes['source1_varying_vertexlit_generic'] = source1_varying_vertexlit_generic;
Includes['source1_varying_weapondecal'] = source1_varying_weapondecal;
Includes['source1_varying_worldvertextransition'] = source1_varying_worldvertextransition;

var source1_character_fs = `
#include source1_fragment_common
#include declare_camera_position
const vec4 defaultNormalTexel = vec4(0.5, 0.5, 1.0, 1.0);

uniform vec3 phongfresnelranges;

#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_phong_exponent_map
#include declare_fragment_mask_map
#include declare_fragment_alpha_test
#include source1_declare_phong
#include source1_declare_sheen
#include source1_declare_selfillum
#include declare_fragment_cube_map

uniform vec4 g_ShaderControls;
#define g_fPixelFogType					g_ShaderControls.x
#define g_fWriteDepthToAlpha			g_ShaderControls.y
#define g_fWriteWaterFogToDestAlpha		g_ShaderControls.z
#define g_fVertexAlpha					g_ShaderControls.w

uniform vec4 g_DiffuseModulation;
uniform vec3 uCubeMapTint;
uniform float uBlendTintColorOverBase;

#include source1_final_output_const

#include declare_lights

#include source1_varying_character

#define uBaseMapAlphaPhongMask 0//TODO: set proper uniform
void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map
	#include compute_fragment_normal_map
	#include compute_fragment_phong_exponent_map
	#include compute_fragment_mask1_map
	#include compute_fragment_mask2_map

	#include compute_fragment_normal

	float phongMask = 0.0;
	#ifdef USE_NORMAL_MAP
		vec3 tangentSpaceNormal = mix(2.0 * texelNormal.xyz - 1.0, vec3(0, 0, 1), float(uBaseMapAlphaPhongMask));
		#ifdef USE_COLOR_ALPHA_AS_PHONG_MASK
			phongMask = texelColor.a;
		#else
			phongMask = texelNormal.a;
		#endif
	#else
		vec3 tangentSpaceNormal = mix(2.0 * defaultNormalTexel.xyz - 1.0, vec3(0, 0, 1), float(uBaseMapAlphaPhongMask));
		#ifdef USE_COLOR_ALPHA_AS_PHONG_MASK
			phongMask = texelColor.a;
		#endif
	#endif
	//float phongMask = mix(texelNormal.a, texelColor.a, float(uBaseMapAlphaPhongMask));
	fragmentNormalCameraSpace = normalize(TBNMatrixCameraSpace * tangentSpaceNormal);

	diffuseColor *= texelColor;
	#include compute_fragment_alpha_test

	vec3 albedo = texelColor.rgb;
	#include source1_blend_tint
	#include compute_fragment_cube_map

	float alpha = g_DiffuseModulation.a;
	#include source1_colormap_alpha


	alpha = alpha;//lerp(alpha, alpha * vVertexColor.a, g_fVertexAlpha);



	float fogFactor = 0.0;
	//gl_FragColor = FinalOutputConst(vec4(albedo, alpha), fogFactor, g_fPixelFogType, TONEMAP_SCALE_LINEAR, g_fWriteDepthToAlpha, worldPos_projPosZ.w );
	//gl_FragColor = FinalOutputConst( float4( result.rgb, alpha ), fogFactor, g_fPixelFogType, TONEMAP_SCALE_LINEAR, g_fWriteDepthToAlpha, i.worldPos_projPosZ.w );

	if (gl_FragCoord.x < 400.) {
		//gl_FragColor = vec4(texelColor.rgb, 1.);
	}
	/*if (length(floor((gl_FragCoord.xy + vec2(15.0)) / 30.0) * 30.0 - gl_FragCoord.xy) > 10.0) {
		discard;
	}*/
#ifndef IS_TRANSLUCENT
	gl_FragColor.a = 1.0;
#endif

#ifdef USE_SHEEN_MAP
	//gl_FragColor.rgb = texture2D(sheenMaskMap, vTextureCoord).rgb;
#endif


/* TEST SHADING BEGIN*/
	#include compute_lights_setup_vars



	BlinnPhongMaterial material;
	material.diffuseColor = albedo;//diffuseColor.rgb;//vec3(1.0);//diffuseColor.rgb;
	material.specularColor = vec3(phongMask);
#ifdef USE_PHONG_EXPONENT_MAP
	#ifdef USE_PHONG_ALBEDO_TINT
		material.specularColor = mix(vec3(1.0), texelColor.rgb, texelPhongExponent.g) * phongMask;
	#endif
	material.specularShininess = texelPhongExponent.r * uPhongExponentFactor;
#else
	material.specularShininess = uPhongExponent;
#endif
	material.specularStrength = uPhongBoost;
#ifdef SOURCE1_SPECULAR_STRENGTH
	material.specularStrength *= float(SOURCE1_SPECULAR_STRENGTH);
#endif

#if NUM_POINT_LIGHTS > 0
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		computePointLightIrradiance(uPointLights[i], geometry, directLight);
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( uAmbientLight );

	irradiance += getLightProbeIrradiance( lightProbe, geometry );

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );

		}

	#endif

#endif

#if defined( RE_IndirectDiffuse )

	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );

#endif

#if defined( RE_IndirectSpecular )

	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );

#endif

/* TEST SHADING END*/

/* TEST SHADING BEGIN*/
#ifdef USE_PHONG_SHADING
	gl_FragColor.rgb = (reflectedLight.directSpecular + reflectedLight.directDiffuse + reflectedLight.indirectDiffuse);
#else
	gl_FragColor.rgb = (reflectedLight.directDiffuse + reflectedLight.indirectDiffuse);
#endif
gl_FragColor.a = alpha;

/* TEST SHADING END*/


#ifdef USE_CUBE_MAP
	#if defined(USE_NORMAL_MAP) && defined(USE_NORMAL_ALPHA_AS_ENVMAP_MASK)
		gl_FragColor.rgb += cubeMapColor.rgb * uCubeMapTint.rgb * texelNormal.a;
	#else
		gl_FragColor.rgb += cubeMapColor.rgb * uCubeMapTint.rgb * texelColor.a;
	#endif
#endif


	//gl_FragColor = texelMask1;

	#include source1_compute_selfillum
	#include source1_compute_sheen
	#include compute_fragment_standard
	#include compute_fragment_render_mode
}
`;

var source1_character_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning

#include source1_varying_character

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection

	vec4 vProjPos = uViewProjectionMatrix * vertexPositionWorldSpace;
	//o.projPos = vProjPos;
	vProjPos.z = dot(vertexPositionWorldSpace, uViewProjectionMatrix[2] );
	//worldPos_projPosZ = vec4(vertexPositionWorldSpace.xyz, vProjPos.z );
}
`;

var source1_customweapon_fs = `
#define PAINT_STYLE_NONE 0
#define PAINT_STYLE_SOLID 1
#define PAINT_STYLE_HYDROGRAPHIC 2
#define PAINT_STYLE_SPRAY 3
#define PAINT_STYLE_ANODIZED 4
#define PAINT_STYLE_ANODIZED_MULTI 5
#define PAINT_STYLE_ANODIZED_AIR 6
#define PAINT_STYLE_CUSTOM 7
#define PAINT_STYLE_ANTIQUED 8
#define PAINT_STYLE_GUNSMITH 9

#ifndef PAINT_STYLE
	#define PAINT_STYLE 0
#endif
#ifndef EXPONENTMODE
	#define EXPONENTMODE 0
#endif
#ifndef PREVIEW
	#define PREVIEW 1
#endif
#ifndef CHEAPMODE
	#define CHEAPMODE 0
#endif
#ifndef PHONGALBEDOFACTORMODE
	#define PHONGALBEDOFACTORMODE 0
#endif
#ifndef PREVIEWPHONGALBEDOTINT
	#define PREVIEWPHONGALBEDOTINT 1
#endif
#include source1_fragment_common
#include declare_camera_position
const vec4 defaultNormalTexel = vec4(0.5, 0.5, 1.0, 1.0);

uniform vec3 phongfresnelranges;

#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_exponent_map
#include declare_fragment_alpha_test
#include declare_fragment_mask_map
#include source1_declare_phong
#include source1_declare_sheen
#include source1_declare_selfillum
#include declare_fragment_cube_map
#ifdef USE_PATTERN_MAP
	uniform sampler2D patternMap;
#endif
#include declare_fragment_ao_map
#ifdef USE_SCRATCHES_MAP
	uniform sampler2D scratchesMap;
#endif
#ifdef USE_GRUNGE_MAP
	uniform sampler2D grungeMap;
#endif
#ifdef USE_SURFACE_MAP
	uniform sampler2D surfaceMap;
#endif
#ifdef USE_POS_MAP
	uniform sampler2D posMap;
#endif

#if ((PAINT_STYLE == PAINT_STYLE_SPRAY) || (PAINT_STYLE == PAINT_STYLE_ANODIZED_AIR))
	uniform vec4 g_patternTexCoordTransform[2];
#endif


uniform vec4 g_ShaderControls;
#define g_fPixelFogType					g_ShaderControls.x
#define g_fWriteDepthToAlpha			g_ShaderControls.y
#define g_fWriteWaterFogToDestAlpha		g_ShaderControls.z
#define g_fVertexAlpha					g_ShaderControls.w

uniform vec4 g_DiffuseModulation;
uniform vec3 uCubeMapTint;
uniform float uBlendTintColorOverBase;
uniform float uWearProgress;
#define g_flWearAmt uWearProgress//TODO: manually replace

#include source1_final_output_const

#include declare_lights

/*********/
//customization

uniform vec3 uCamoColor0;
uniform vec3 uCamoColor1;
uniform vec3 uCamoColor2;
uniform vec3 uCamoColor3;
#define g_cCamo0 uCamoColor0
#define g_cCamo1 uCamoColor1
#define g_cCamo2 uCamoColor2
#define g_cCamo3 uCamoColor3
/*********/
/*vec4 triplanarPatternColor(vec3 posColor) {
	vec4 color;
	float mXY = abs(normalVector.z);
	float mXZ = abs(normalVector.y);
	float mYZ = abs(normalVector.x);


	float total = mXY + mXZ + mYZ;
	mXY /= total;
	mXZ /= total;
	mYZ /= total;

	vec2 scale = vec2(1.0/16.0);
	vec2 t1 = v.xy * scale + uPatternOffset;
	vec2 t2 = v.xz * scale + uPatternOffset;
	vec2 t3 = v.yz * scale + uPatternOffset;

	vec2 c1,c2,c3;

	c1.s = t1.s*cos(uPatternRotate)-t1.t*sin(uPatternRotate);
	c1.t = t1.t*cos(uPatternRotate)+t1.s*sin(uPatternRotate);
	c2.s = t2.s*cos(uPatternRotate)-t2.t*sin(uPatternRotate);
	c2.t = t2.t*cos(uPatternRotate)+t2.s*sin(uPatternRotate);
	c3.s = t3.s*cos(uPatternRotate)-t3.t*sin(uPatternRotate);
	c3.t = t3.t*cos(uPatternRotate)+t3.s*sin(uPatternRotate);

	vec4 cXY = texture2D(detailMap, c1);
	vec4 cXZ = texture2D(detailMap, c2);
	vec4 cYZ = texture2D(detailMap, c3);

	color = cXY*mXY + cXZ*mXZ + cYZ*mYZ;
	return cYZ * (abs(mYZ)+abs(mXZ)) + cXY * mXY;//side good
	return color;
}*/

#define		 g_flBlendYPow			7.0
#define		 g_flBlendZPow			7.0
#define		 g_flAnodizedBaseExponent 0.004
#define		 g_flAnodizedBasePhongIntensity 1.0
#define		 g_cAnodizedBase		vec3(0.05)

#define		 g_flPhongAlbedoFactor	 1.0//g_fvPhongSettings_wear.x//TODO
#define		 g_flPaintExponent		 1.0//g_fvPhongSettings_wear.y
#define		 g_flPaintPhongIntensity 1.0//g_fvPhongSettings_wear.z

uniform vec4 g_PreviewPhongBoosts;
#define  g_PreviewPhongAlbedoBoost	1.0//	g_PreviewPhongBoosts.x//TODO
#define  g_PreviewPhongBoost		1.0//	g_PreviewPhongBoosts.y
#define  g_PreviewPatternScale		g_PreviewPhongBoosts.z

#include source1_varying_customweapon

#define uBaseMapAlphaPhongMask 0//TODO: set proper uniform

void main(void) {
	float4 cOut = vec4(0.0, 0.0, 0.0, 1.0);
	#include compute_fragment_ao_map
#define fvAoSrc texelAo//TODO: manually replace
	float flCavity = texelAo.r;
	float flPaintBlend = fvAoSrc.a;

	#ifdef USE_SCRATCHES_MAP
		vec4 texelScratches = texture2D(scratchesMap, vTexture2Coord.xy);
	#else
		vec4 texelScratches = vec4(1.0);
	#endif
#define flPaintWear	texelScratches.g//TODO: manually replace

	#ifdef USE_PATTERN_MAP
		vec4 texelPattern = texture2D(patternMap, vTextureCoord.zw);
	#else
		vec4 texelPattern = vec4(1.0);
	#endif
#define fvPattern texelPattern//TODO: manually replace

	#include compute_fragment_mask1_map
#define fvMasks texelMask1//TODO: manually replace

	#include compute_fragment_exponent_map
#define cExp texelExponent//TODO: manually replace
#define cOrigExp texelExponent//TODO: manually replace

	#if (PAINT_STYLE != PAINT_STYLE_ANTIQUED)
		flPaintBlend += flPaintWear * flCavity;
		flPaintBlend *= g_flWearAmt * 6.0 + 1.0;
		#if ((PAINT_STYLE == PAINT_STYLE_HYDROGRAPHIC) || (PAINT_STYLE == PAINT_STYLE_ANODIZED_MULTI) || (PAINT_STYLE == PAINT_STYLE_CUSTOM) || (PAINT_STYLE == PAINT_STYLE_GUNSMITH)) // Paint patterns and durability
			float flCuttableArea = 1.0;
			#if ((PAINT_STYLE == PAINT_STYLE_HYDROGRAPHIC) || (PAINT_STYLE == PAINT_STYLE_ANODIZED_MULTI))
				flCuttableArea = 1.0 - saturate(fvMasks.g + fvMasks.b);
			#endif
			// cut through
			flPaintBlend += smoothstep(0.5, 0.6, fvPattern.a) * smoothstep(1.0, 0.9, fvPattern.a);
			#if (PAINT_STYLE == PAINT_STYLE_ANODIZED_MULTI)
				// rescale the alpha to represent exponent in the range of 0-255 and let the cutout mask area fall off the top end
				fvPattern.a = saturate(fvPattern.a * 2.0);
			#elif (PAINT_STYLE == PAINT_STYLE_GUNSMITH)
				flPaintBlend *= max (1.0 - flCuttableArea, smoothstep(0.0, 0.5, fvPattern.a));
				// rescale the alpha to represent exponent in the range of 0-255 and let the cutout mask area fall off the top end
				fvPattern.a = lerp(fvPattern.a, saturate(fvPattern.a * 2.0), fvMasks.r);
				// indestructible paint
			#else
				// indestructible paint
				flPaintBlend *= max (1.0 - flCuttableArea, smoothstep(0.0, 0.5, fvPattern.a));
			#endif
		#endif//#if ((PAINT_STYLE == PAINT_STYLE_HYDROGRAPHIC) || (PAINT_STYLE == PAINT_STYLE_ANODIZED_MULTI) || (PAINT_STYLE == PAINT_STYLE_CUSTOM) || (PAINT_STYLE == PAINT_STYLE_GUNSMITH))
		#if (((EXPONENTMODE == 1) || (PREVIEW == 1)) && ((PAINT_STYLE == PAINT_STYLE_ANODIZED) || (PAINT_STYLE == PAINT_STYLE_ANODIZED_MULTI) || (PAINT_STYLE == PAINT_STYLE_ANODIZED_AIR )))
			float flPaintExpBlend = smoothstep( 0.99, 1.0, flPaintBlend );
		#else
			float flPaintExpBlend = flPaintBlend;
		#endif
	#elif ((EXPONENTMODE == 1) || (PREVIEW == 1))
		float flPaintExpBlend = flPaintBlend;
	#endif//#if (PAINT_STYLE != 8)

	#if ( ( PAINT_STYLE == PAINT_STYLE_HYDROGRAPHIC ) || ( PAINT_STYLE == PAINT_STYLE_SPRAY ) ) // paint wears off in layers
		vec3 fvPaintEdges = vec3(1.0);
		float3 spread = vec3(0.06) * g_flWearAmt; // spread of partially worn paint increases as the gun becomes more worn
		spread.y *= 2.0;
		spread.z *= 3.0;

		fvPaintEdges.x = smoothstep ( 0.58, 0.56 - spread.x, flPaintBlend );
		fvPaintEdges.y = smoothstep ( 0.56 - spread.x, 0.54 - spread.y, flPaintBlend );
		fvPaintEdges.z = smoothstep ( 0.54 - spread.y, 0.52 - spread.z, flPaintBlend );
	#endif

	#if ( ( PAINT_STYLE != 8 ) && ( PAINT_STYLE != 9 ) )
		flPaintBlend = smoothstep( 0.58, 0.68, flPaintBlend );
	#elif ( PAINT_STYLE == PAINT_STYLE_GUNSMITH )
		flPaintBlend = lerp( smoothstep( 0.58, 0.68, flPaintBlend ), flPaintBlend, fvMasks.r );
	#endif

	#if ( ( PAINT_STYLE == PAINT_STYLE_ANODIZED ) || ( PAINT_STYLE == PAINT_STYLE_ANODIZED_MULTI ) || ( PAINT_STYLE == PAINT_STYLE_ANODIZED_AIR ) ) // Anodized paint scratches through uncolored base coat
		float flPaintEdges = smoothstep ( 0.0, 0.01, flPaintBlend );
	#endif


	// ------------------------------------------------------------------------------------------------------
	// Exponent texture
	// ------------------------------------------------------------------------------------------------------
	#if ( ( EXPONENTMODE == 1 ) || ( PREVIEW == 1 ) )
		//float4 cExp = tex2D( ExponentSampler, i.vBaseUV_PatternUV.xy );
		#if ( ( PREVIEW == 1 ) && ( PREVIEWPHONGALBEDOTINT == 0 ) )
			cExp.g = 0.0;
		#endif
		float4 cPaintExp = cExp;

		#if ( ( PAINT_STYLE == PAINT_STYLE_ANODIZED ) || ( PAINT_STYLE == PAINT_STYLE_ANODIZED_MULTI ) || ( PAINT_STYLE == PAINT_STYLE_ANODIZED_AIR ) || ( PAINT_STYLE == PAINT_STYLE_ANTIQUED ) || ( PAINT_STYLE == PAINT_STYLE_GUNSMITH ) ) // Anodized/metallic
			#if ( PAINT_STYLE == PAINT_STYLE_ANTIQUED )
				flPaintBlend = 1.0 - step( flPaintExpBlend, 0.996 ) * fvMasks.r;
			#elif ( PAINT_STYLE == PAINT_STYLE_GUNSMITH )
				flPaintBlend = lerp( flPaintBlend, 1.0 - step( flPaintExpBlend, 0.996 ), fvMasks.r );
			#else
				flPaintBlend = saturate( 1.0 + flPaintExpBlend - fvMasks.r );
			#endif

			// exponent
			#if ( PAINT_STYLE == PAINT_STYLE_ANODIZED_MULTI )
				float flPatternExponentBlend = max( max( fvMasks.g, fvMasks.b ), flPaintBlend );
				cPaintExp.r = lerp( fvPattern.a, cExp.r, flPatternExponentBlend );
			#elif ( PAINT_STYLE == PAINT_STYLE_GUNSMITH )
				cPaintExp.r = lerp( g_flPaintExponent, fvPattern.a, fvMasks.r );
				cPaintExp.r = lerp( cPaintExp.r, cExp.r, flPaintBlend );
			#else
				cPaintExp.r = lerp( g_flPaintExponent, cExp.r, flPaintBlend );
			#endif

			// phongalbedo
			#if ( PAINT_STYLE == PAINT_STYLE_GUNSMITH )
				cPaintExp.g = saturate( fvMasks.r + flPaintBlend * cExp.g );
			#else
				cPaintExp.g = lerp ( 1.0, cExp.g, flPaintBlend );
			#endif

			cPaintExp.a = 1.0;
		#else // Everything else not anodized
			cPaintExp = lerp ( float4( g_flPaintExponent, 0.0, 0.0, 1.0 ), cExp, flPaintBlend );
			cPaintExp.a = 1.0;
		#endif

		#if ( PREVIEW == 0 )
			cOut = cPaintExp;
		#endif
	#endif


	// ------------------------------------------------------------------------------------------------------
	// Diffuse texture
	// ------------------------------------------------------------------------------------------------------
	#if ( ( EXPONENTMODE == 0 ) || ( PREVIEW == 1 ) )
		#include compute_fragment_color_map
		#ifndef USE_COLOR_MAP//TODO: probably not the best way to do that. We should remove all texelColor if no colorMap
			vec4 texelColor = vec4(1.0);
		#endif
#define cBase texelColor
		//float4 cBase = tex2D( BaseSampler, i.vBaseUV_PatternUV.xy );

		float3 cPaint = g_cCamo0;

		// ambient occlusion
		float flAo = fvAoSrc.g;

		// apply grunge to paint only in creases
		//float4 cGrunge = tex2D( GrungeSampler, i.vWearUV_GrungeUV.zw );
		#ifdef USE_GRUNGE_MAP
			vec4 texelGrunge = texture2D(grungeMap, vTexture2Coord.zw);
		#else
			vec4 texelGrunge = vec4(0.0);
		#endif
#define cGrunge texelGrunge//TODO: manually replace
		#if ( ( PAINT_STYLE == PAINT_STYLE_ANTIQUED ) || ( PAINT_STYLE == PAINT_STYLE_GUNSMITH ) )
			float flGrunge = cGrunge.r * cGrunge.g * cGrunge.b;
		#endif
		cGrunge = lerp( vec4(1.0), cGrunge, ( pow( ( 1.0 - flCavity ), 4.0 ) * 0.25 + 0.75 * g_flWearAmt ) );

		// ------------------------------------------------------------------------------------------------------
		// Solid style
		// ------------------------------------------------------------------------------------------------------
		#if ( PAINT_STYLE == PAINT_STYLE_SOLID )
			// apply color in solid blocks using masking from the part kit MasksSampler
			cPaint = lerp( cPaint, g_cCamo1, fvMasks.r );
			cPaint = lerp( cPaint, g_cCamo2, fvMasks.g );
			cPaint = lerp( cPaint, g_cCamo3, fvMasks.b );
		#endif

		// ------------------------------------------------------------------------------------------------------
		// Hydrographic/anodized multicolored style
		// ------------------------------------------------------------------------------------------------------
		#if ( ( PAINT_STYLE == PAINT_STYLE_HYDROGRAPHIC ) || ( PAINT_STYLE == PAINT_STYLE_ANODIZED_MULTI ) )
			// create camo using pattern
			cPaint = lerp( lerp( lerp( g_cCamo0, g_cCamo1, fvPattern.r ), g_cCamo2, fvPattern.g ), g_cCamo3, fvPattern.b );

			// apply any masking from the last two masks from MasksSampler, allowing some areas to be solid color
			cPaint = lerp( cPaint, g_cCamo2, fvMasks.g );
			cPaint = lerp( cPaint, g_cCamo3, fvMasks.b );
		#endif

		// ------------------------------------------------------------------------------------------------------
		// Spraypaint/anodized airbrushed style
		// ------------------------------------------------------------------------------------------------------
		#if ( ( PAINT_STYLE == PAINT_STYLE_SPRAY ) || ( PAINT_STYLE == PAINT_STYLE_ANODIZED_AIR ) )
			// apply spraypaint via box map based on mesh's object-space position as stored in the position pmap
			//float4 fvNormalSrc = tex2D( NormalsSampler, i.vBaseUV_PatternUV.xy );
			#ifdef USE_SURFACE_MAP
				vec4 texelSurface = texture2D(surfaceMap, vTextureCoord.xy);
			#else
				vec4 texelSurface = vec4(1.0);//this is probably wrong. we should never enter here anyway
			#endif
#define fvNormalSrc texelSurface//TODO: manually replace

			float2 fvPosCoord = float2( vTextureCoord.x, 1.0 - vTextureCoord.y );

			float4 fvPos = float4( 0.0, 0.0, 0.0, 0.0 );

			#if ( CHEAPMODE == 0 ) // if supersampling is not disabled
				//super sampling of position map
				float2 offsets[17];
				offsets[ 0] = float2( -0.00107234 ,-0.00400203 );
				offsets[ 1] = float2( 0.00195312, -0.00338291 ),
				offsets[ 2] = float2( 0.00400203, -0.00107234 ),
				offsets[ 3] = float2( -0.000714896, -0.00266802 ),
				offsets[ 4] = float2( 0.000976565, -0.00169146 ),
				offsets[ 5] = float2( 0.00266802, -0.000714896 );
				offsets[ 6] = float2( -0.00338291, -0.00195312 );
				offsets[ 7] = float2( -0.00169146, -0.000976565 );
				offsets[ 8] = float2( 0.0, 0.0 );
				offsets[ 9] = float2( 0.00169146, 0.000976565 );
				offsets[10] = float2( 0.00338291, 0.00195312 );
				offsets[11] = float2( -0.00266802, 0.000714896 );
				offsets[12] = float2( -0.000976565, 0.00169146 );
				offsets[13] = float2( 0.000714896, 0.00266802 );
				offsets[14] = float2( -0.00400203, 0.00107234 );
				offsets[15] = float2( -0.00195312, 0.00338291 );
				offsets[16] = float2( 0.00107234, 0.00400203 );
				for ( int k = 0; k < 17; k++ )
				{
					#ifdef USE_POS_MAP
						//fvPos += tex2D( OSPosSampler, fvPosCoord + offsets[k] ) * 0.05882353;
						fvPos += texture2D( posMap, fvPosCoord + offsets[k] ) * 0.05882353;// 1/17
					#endif

				}
			#else
				fvPos = texture2D( posMap, fvPosCoord );
			#endif

			//extract integer HDR values out from the RGBA vtf
			//developer.valvesoftware.com/wiki/Valve_Texture_Format#HDR_compression
			fvPos.rgb = (fvPos.rgb * (fvPos.a * 16.0) );

			float3 fvNormal = normalize( fvNormalSrc.xyz * 2.0 - 1.0 );

			// Project the mask in object-space x, y and z
			float2 flCoord;


			#if ( PREVIEW == 1 )

				// apply the preview pattern scale to only the scale portion of the pattern transform.

				mat2 tempMatrix = mat2(g_PreviewPatternScale, 0, 0, g_PreviewPatternScale);
				mat2 tempMatrix2 = mat2(g_patternTexCoordTransform[0].xy, g_patternTexCoordTransform[1].xy);
				tempMatrix = tempMatrix * tempMatrix2;

				flCoord.x = dot( fvPos.yz, tempMatrix[0] ) + g_patternTexCoordTransform[0].w;
				flCoord.y = dot( fvPos.yz, tempMatrix[1] ) + g_patternTexCoordTransform[1].w;
				//float3 fvTexX = tex2D( PatternSampler, flCoord ).rgb;
				float3 fvTexX = texture2D( patternMap, flCoord ).rgb;

				flCoord.x = dot( fvPos.xz, tempMatrix[0] ) + g_patternTexCoordTransform[0].w;
				flCoord.y = dot( fvPos.xz, tempMatrix[1] ) + g_patternTexCoordTransform[1].w;
				//float3 fvTexY = tex2D( PatternSampler, flCoord ).rgb;
				float3 fvTexY = texture2D( patternMap, flCoord ).rgb;

				flCoord.x = dot( fvPos.yx, tempMatrix[0] ) + g_patternTexCoordTransform[0].w;
				flCoord.y = dot( fvPos.yx, tempMatrix[1] ) + g_patternTexCoordTransform[1].w;
				//float3 fvTexZ = tex2D( PatternSampler, flCoord ).rgb;
				float3 fvTexZ = texture2D( patternMap, flCoord ).rgb;

			#else

				flCoord.x = dot( fvPos.yz, g_patternTexCoordTransform[0].xy ) + g_patternTexCoordTransform[0].w;
				flCoord.y = dot( fvPos.yz, g_patternTexCoordTransform[1].xy ) + g_patternTexCoordTransform[1].w;
				//float3 fvTexX = tex2D( PatternSampler, flCoord ).rgb;
				float3 fvTexX = texture2D( patternMap, flCoord ).rgb;

				flCoord.x = dot( fvPos.xz, g_patternTexCoordTransform[0].xy ) + g_patternTexCoordTransform[0].w;
				flCoord.y = dot( fvPos.xz, g_patternTexCoordTransform[1].xy ) + g_patternTexCoordTransform[1].w;
				//float3 fvTexY = tex2D( PatternSampler, flCoord ).rgb;
				float3 fvTexY = texture2D( patternMap, flCoord ).rgb;

				flCoord.x = dot( fvPos.yx, g_patternTexCoordTransform[0].xy ) + g_patternTexCoordTransform[0].w;
				flCoord.y = dot( fvPos.yx, g_patternTexCoordTransform[1].xy ) + g_patternTexCoordTransform[1].w;
				//float3 fvTexZ = tex2D( PatternSampler, flCoord ).rgb;
				float3 fvTexZ = texture2D( patternMap, flCoord ).rgb;

			#endif



			// smooth blend the three projections across the object-space surface normals
			float yBlend = abs( dot( fvNormal.xyz, float3( 0.0, 1.0, 0.0 ) ) );
			yBlend = pow( yBlend, g_flBlendYPow );

			float zBlend = abs( dot( fvNormal.xyz, float3( 0.0, 0.0, 1.0 ) ) );
			zBlend = pow( zBlend, g_flBlendZPow );

			float3 fvPatternMask = lerp( lerp( fvTexX, fvTexY, yBlend ), fvTexZ, zBlend );

			#if ( PAINT_STYLE == PAINT_STYLE_SPRAY )// paint wears off in layers
				fvPatternMask.xyz *= fvPaintEdges.xyz;
			#endif

			cPaint = lerp( lerp( lerp( g_cCamo0, g_cCamo1, fvPatternMask.r ), g_cCamo2, fvPatternMask.g ), g_cCamo3, fvPatternMask.b );
			#if ( PAINT_STYLE == PAINT_STYLE_ANODIZED_AIR )
				// apply any masking from the last two masks from MasksSampler, allowing some areas to be solid color
				cPaint = lerp( cPaint, g_cCamo2, fvMasks.g );
				cPaint = lerp( cPaint, g_cCamo3, fvMasks.b );
			#endif
		#endif

		// ------------------------------------------------------------------------------------------------------
		// Anodized style
		// ------------------------------------------------------------------------------------------------------
		#if ( PAINT_STYLE == PAINT_STYLE_ANODIZED )
			cPaint.rgb = g_cCamo0.rgb;
		#endif

		#if ( ( PAINT_STYLE == PAINT_STYLE_ANODIZED ) || ( PAINT_STYLE == PAINT_STYLE_ANODIZED_MULTI ) || ( PAINT_STYLE == PAINT_STYLE_ANODIZED_AIR ) )
			// chipped edges of anodized dye
			cPaint = lerp( cPaint, g_cAnodizedBase, flPaintEdges );
			cGrunge.rgb = lerp( cGrunge.rgb, float3( 1.0, 1.0, 1.0 ), flPaintEdges );

			// anodize only in areas specified by the masks texture
			flPaintBlend = saturate( 1.0 + flPaintBlend - fvMasks.r );
		#endif

		// ------------------------------------------------------------------------------------------------------
		// Custom painted style
		// ------------------------------------------------------------------------------------------------------
		#if ( PAINT_STYLE == PAINT_STYLE_CUSTOM )
			cPaint = fvPattern.rgb;
		#endif
		// ------------------------------------------------------------------------------------------------------
		// Antiqued or Gunsmith style
		// ------------------------------------------------------------------------------------------------------

		#if ( PAINT_STYLE == PAINT_STYLE_ANTIQUED )
			//float4 fvPattern = tex2D( PatternSampler, i.vBaseUV_PatternUV.zw );
		#endif

		#if ( ( PAINT_STYLE == PAINT_STYLE_ANTIQUED ) || ( PAINT_STYLE == PAINT_STYLE_GUNSMITH ) )
			float flPatinaBlend = flPaintWear * flAo * flCavity * flCavity;
			flPatinaBlend = smoothstep( 0.1, 0.2, flPatinaBlend * g_flWearAmt );

			float flOilRubBlend = saturate( flCavity * flAo - g_flWearAmt * 0.1 ) - flGrunge;
			flOilRubBlend = smoothstep( 0.0, 0.15, flOilRubBlend + 0.08 );

			float3 cPatina = lerp( g_cCamo1, g_cCamo2, g_flWearAmt );
			float3 cOilRubColor = lerp( g_cCamo1, g_cCamo3, pow( g_flWearAmt, 0.5 ) );
			cPatina = lerp( cOilRubColor, cPatina, flOilRubBlend ) * fvPattern.rgb;

			float3 vLumCoefficients = vec3(0.3, 0.59, 0.11);//TODO: set const
			float fPatternLum = dot( fvPattern.rgb, vLumCoefficients );

			float3 cScratches = g_cCamo0 * fPatternLum;

			cPatina = lerp( cPatina, cScratches, flPatinaBlend );

			#if ( PAINT_STYLE == PAINT_STYLE_ANTIQUED )
				cPaint = cPatina;
				flPaintBlend = 1.0 - fvMasks.r;
			#elif ( PAINT_STYLE == PAINT_STYLE_GUNSMITH )
				cPaint = lerp ( fvPattern.rgb, cPatina, fvMasks.r );
				flPaintBlend = flPaintBlend * ( 1.0 - fvMasks.r );
			#endif
		#endif

		// ------------------------------------------------------------------------------------------------------
		// All paints
		// ------------------------------------------------------------------------------------------------------

		float3 cModulation = fvAoSrc.bbb;//TODO: not sure was float3 cModulation = fvAoSrc.b;
		cPaint.rgb *= cGrunge.rgb;

		// On very dark paints, increase the modulation slightly by adding
		float3 lumCoefficients = vec3(0.3, 0.59, 0.11);//TODO: set const
		float flModulationLum = dot( cPaint.rgb, lumCoefficients );
		flModulationLum = 1.0 - smoothstep( 0.08, 0.15, flModulationLum );

		#if ( ( PAINT_STYLE == PAINT_STYLE_SOLID ) || ( PAINT_STYLE == PAINT_STYLE_HYDROGRAPHIC ) || ( PAINT_STYLE == PAINT_STYLE_SPRAY ) || ( PAINT_STYLE == PAINT_STYLE_CUSTOM ) )
			flModulationLum *= 0.03;
			cModulation = cModulation.rgb * ( cPaint.rgb + flModulationLum ) * 0.5;
		#elif ( PAINT_STYLE == PAINT_STYLE_GUNSMITH )
			flModulationLum *= lerp( 0.03, 0.005, fvMasks.r );
			cModulation = cModulation.rgb * ( cPaint.rgb + flModulationLum ) * lerp( 0.5, 2.0, fvMasks.r );
		#else
			flModulationLum *= 0.005;
			cModulation = cModulation.rgb * ( cPaint.rgb + flModulationLum ) * 2.0;
		#endif


		cPaint = saturate( cPaint + cModulation );

		cPaint.rgb *= flAo;

		cOut.rgb = lerp( cPaint, cBase.rgb, flPaintBlend );

		// ------------------------------------------------------------------------------------------------------
		// Specular Intensity Mask
		// ------------------------------------------------------------------------------------------------------
		#if ( PAINT_STYLE == PAINT_STYLE_GUNSMITH )
			#if ( PHONGALBEDOFACTORMODE == 1 )
				float flSpecMask = lerp( g_flPaintPhongIntensity, 1.0, fvMasks.r ) * flAo * cGrunge.a;
			#else
				float flSpecMask = lerp( g_flPaintPhongIntensity, g_flPhongAlbedoFactor, fvMasks.r ) * flAo * cGrunge.a;
			#endif
		#else
			float flSpecMask = g_flPaintPhongIntensity * flAo * cGrunge.a;
		#endif
		#if ( ( PAINT_STYLE == PAINT_STYLE_ANODIZED ) || ( PAINT_STYLE == PAINT_STYLE_ANODIZED_MULTI ) || ( PAINT_STYLE == PAINT_STYLE_ANODIZED_AIR ) || ( PAINT_STYLE == PAINT_STYLE_ANTIQUED ) || ( PAINT_STYLE == PAINT_STYLE_GUNSMITH ) )// anodized/metallic
			// phongalbedoboost must be increased in the material for the anodized look, so in areas that are
			// already using phongalbedo the specular intensity must be reduced in order to retain approximately
			// the same intensity as the originally authored texture
			float flInvPaintBlend = 1.0 - flPaintBlend;

			//float4 cOrigExp = tex2D( ExponentSampler, i.vBaseUV_PatternUV.xy );
			#if ( ( PREVIEW == 1 ) && ( PREVIEWPHONGALBEDOTINT == 0 ) )
				cOrigExp.g = 0.0;
			#endif
			#if ( PAINT_STYLE == PAINT_STYLE_ANTIQUED )
				flSpecMask *= lerp( flOilRubBlend * ( 1.0 - flPatinaBlend * g_flWearAmt ), 1.0, flPatinaBlend );
			#elif ( PAINT_STYLE == PAINT_STYLE_GUNSMITH )
				float flPaintSpecBlend = smoothstep( 0.9, 1.0, flPaintBlend ) * fvMasks.r;
				flSpecMask *= lerp(  smoothstep( 0.01, 0.0, flPaintBlend ), lerp( flOilRubBlend * ( 1.0 - flPatinaBlend * g_flWearAmt ), 1.0, flPatinaBlend ), fvMasks.r );
				flSpecMask = lerp( flSpecMask, cBase.a, flPaintSpecBlend );
				flPaintSpecBlend = smoothstep( 0.9, 1.0, flPaintBlend ) * ( 1.0 - fvMasks.r );
			#else
				flSpecMask *= lerp( g_flPaintPhongIntensity, g_flAnodizedBasePhongIntensity, flPaintEdges );
			#endif

			float flPhongAlbedoBlend = flPaintBlend;

			float flAdjustedBase = 1.0;
			#if ( PHONGALBEDOFACTORMODE == 1 )
				flAdjustedBase = lerp( 1.0, g_flPhongAlbedoFactor, cOrigExp.g * flPhongAlbedoBlend );
				cOut.a = lerp( flSpecMask, cBase.a * flAdjustedBase, flPaintBlend );
			#else
				cOut.a = lerp( flSpecMask * g_flPhongAlbedoFactor, cBase.a, flPhongAlbedoBlend );
			#endif

			#if ( PAINT_STYLE == PAINT_STYLE_GUNSMITH )
				cOut.a = lerp( flSpecMask, cBase.a * flAdjustedBase, flPaintSpecBlend );
			#endif

		#else // everything else
			float flPaintSpecBlend = smoothstep( 0.9, 1.0, flPaintBlend );
			flSpecMask *= smoothstep( 0.01, 0.0, flPaintBlend );
			cOut.a = lerp( flSpecMask, cBase.a, flPaintSpecBlend );
		#endif


	#endif

















	vec4 diffuseColor = vec4(1.0);
	//#include compute_fragment_color_map
	#ifndef USE_COLOR_MAP//TODO: probably not the best way to do that. We should remove all texelColor if no colorMap
		//vec4 texelColor = vec4(1.0);
	#endif
	#include compute_fragment_normal_map
	#include compute_fragment_phong_exponent_map

	#include compute_fragment_normal

	/*#ifdef USE_POS_MAP
		vec4 texelPos = texture2D(posMap, vTextureCoord.xy);
		texelPos.rgb *= texelPos.a * 16.0;//HDR decompression
	#else
		vec4 texelPos = vec4(0.0);
	#endif*/

	vec4 paintColor = texelPattern;

	float phongMask = 0.0;
	#ifdef USE_NORMAL_MAP
		vec3 tangentSpaceNormal = mix(2.0 * texelNormal.xyz - 1.0, vec3(0, 0, 1), float(uBaseMapAlphaPhongMask));
		#ifdef USE_COLOR_ALPHA_AS_PHONG_MASK
			phongMask = texelColor.a;
		#else
			phongMask = texelNormal.a;
		#endif
	#else
		vec3 tangentSpaceNormal = mix(2.0 * defaultNormalTexel.xyz - 1.0, vec3(0, 0, 1), float(uBaseMapAlphaPhongMask));
		#ifdef USE_COLOR_ALPHA_AS_PHONG_MASK
			phongMask = texelColor.a;
		#endif
	#endif
	//float phongMask = mix(texelNormal.a, texelColor.a, float(uBaseMapAlphaPhongMask));
	fragmentNormalCameraSpace = normalize(TBNMatrixCameraSpace * tangentSpaceNormal);

	//diffuseColor *= texelColor;
	#include compute_fragment_alpha_test

	vec3 albedo = vec3(1.0);//texelColor.rgb;
	#include source1_blend_tint
	#include compute_fragment_cube_map

	float alpha = g_DiffuseModulation.a;
	#include source1_colormap_alpha


	alpha = alpha;//lerp(alpha, alpha * vVertexColor.a, g_fVertexAlpha);



	float fogFactor = 0.0;

	if (length(mod(gl_FragCoord.xy, vec2(2.0))) < 1.0) {
	//	discard;
	}
	//gl_FragColor = vec4(albedo, alpha);
	//gl_FragColor.rgb = g_DiffuseModulation.rgb;
#ifndef IS_TRANSLUCENT
	gl_FragColor.a = 1.0;
#endif

#ifdef USE_SHEEN_MAP
	//gl_FragColor.rgb = texture2D(sheenMaskMap, vTextureCoord).rgb;
#endif


/* TEST SHADING BEGIN*/
	#include compute_lights_setup_vars



	BlinnPhongMaterial material;
	material.diffuseColor = albedo;//diffuseColor.rgb;//vec3(1.0);//diffuseColor.rgb;
	material.specularColor = vec3(phongMask);
#ifdef USE_PHONG_EXPONENT_MAP
	#ifdef USE_PHONG_ALBEDO_TINT
		material.specularColor = mix(vec3(1.0), texelColor.rgb, texelPhongExponent.g) * phongMask;
	#endif
	material.specularShininess = texelPhongExponent.r * uPhongExponentFactor;
#else
	material.specularShininess = uPhongExponent;
#endif
	material.specularStrength = uPhongBoost;
#ifdef SOURCE1_SPECULAR_STRENGTH
	material.specularStrength *= float(SOURCE1_SPECULAR_STRENGTH);
#endif

#if NUM_POINT_LIGHTS > 0
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		computePointLightIrradiance(uPointLights[i], geometry, directLight);
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( uAmbientLight );

	irradiance += getLightProbeIrradiance( lightProbe, geometry );

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );

		}

	#endif

#endif

#if defined( RE_IndirectDiffuse )

	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );

#endif

#if defined( RE_IndirectSpecular )

	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );

#endif

/* TEST SHADING END*/

/* TEST SHADING BEGIN*/
#ifdef USE_PHONG_SHADING
	gl_FragColor.rgb = (reflectedLight.directSpecular + reflectedLight.directDiffuse + reflectedLight.indirectDiffuse);
#else
	gl_FragColor.rgb = (reflectedLight.directDiffuse + reflectedLight.indirectDiffuse);
#endif
gl_FragColor.a = alpha;

//gl_FragColor.rgb = vec3(phongMask);
/* TEST SHADING END*/




#ifdef USE_CUBE_MAP
	#if defined(USE_NORMAL_MAP) && defined(USE_NORMAL_ALPHA_AS_ENVMAP_MASK)
		gl_FragColor.rgb += cubeMapColor.rgb * uCubeMapTint.rgb * texelNormal.a;
	#else
		gl_FragColor.rgb += cubeMapColor.rgb * uCubeMapTint.rgb * texelColor.a;
	#endif
#endif

#if PAINT_STYLE == PAINT_STYLE_ANODIZED_AIR
	//gl_FragColor.rgb = vec3(1.0);
	/*patternColor = triplanarPatternColor(vPatternCoord2);
	float mask0 = max((1.0 - length(patternColor.rgb)) * texelMask1.r, 0.0);
	if (length(texelMask1.rgb) != texelMask1.r) {
		patternColor = vec4(0.0);
		mask0 = 0.0;
	}

	float mask1 = clamp(							patternColor.r, 0.0, 1.0);
	float mask2 = max(texelMask1.g, patternColor.g);
	float mask3 = max(texelMask1.b, patternColor.b);

	vec3 color0 = mask0 * uColor0;
	vec3 color1 = mask1 * uColor1;
	vec3 color2 = mask2 * uColor2;
	vec3 color3 = mask3 * uColor3;
	paintColor.rgb = vec3(color0 + color1 + color2 + color3) * 2.0;
	paintColor.a = texelMask1.r;
*/
#endif


	gl_FragColor.rgb = texelPattern.rgb;
	gl_FragColor.rgb = vec3(cOut);
	#include source1_compute_selfillum
	#include source1_compute_sheen
	#include compute_fragment_standard
	#include compute_fragment_render_mode

	//gl_FragColor.rgb = texture2D(scratchesMap, vTexture2Coord.xy).rgb;
	//gl_FragColor.rgb = texture2D(grungeMap, vTexture2Coord.zw).rgb;
	//gl_FragColor.rgb = texelAo.aaa;
}
`;

var source1_customweapon_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning

uniform vec4 g_patternTexCoordTransform[2];
uniform vec4 g_wearTexCoordTransform[2];
uniform vec4 g_grungeTexCoordTransform[2];

#include source1_varying_customweapon

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	vTextureCoord.xy = mod(vTextureCoord.xy, 1.0);

	vTextureCoord.z = dot(vTextureCoord.xy, g_patternTexCoordTransform[0].xy) + g_patternTexCoordTransform[0].w;
	vTextureCoord.w = dot(vTextureCoord.xy, g_patternTexCoordTransform[1].xy) + g_patternTexCoordTransform[1].w;
	vTexture2Coord.x = dot(aTextureCoord, g_wearTexCoordTransform[0].xy) + g_wearTexCoordTransform[0].w;
	vTexture2Coord.y = dot(aTextureCoord, g_wearTexCoordTransform[1].xy) + g_wearTexCoordTransform[1].w;
	vTexture2Coord.z = dot(aTextureCoord, g_grungeTexCoordTransform[0].xy) + g_grungeTexCoordTransform[0].w;
	vTexture2Coord.w = dot(aTextureCoord, g_grungeTexCoordTransform[1].xy) + g_grungeTexCoordTransform[1].w;
}
`;

var source1_eyerefract_fs = `
#include declare_lights
#include declare_shadow_mapping

uniform vec3 phongfresnelranges;

#include declare_fragment_color_map
#include declare_fragment_alpha_test

uniform sampler2D corneaMap;

/*const vec4 g_vIrisProjectionU = vec4(0, 1, 0, 0);
const vec4 g_vIrisProjectionV = vec4(0, 0, 1, 0);*/


uniform vec3 uEyeOrigin;
uniform vec4 uIrisProjectionU;
uniform vec4 uIrisProjectionV;
/********************************************/
varying vec4 vWorldPosition_ProjPosZ;
varying vec4 vTangentViewVector;

varying vec3 vWorldNormal;
varying vec3 vWorldTangent;
varying vec3 vWorldBinormal;

#define g_flEyeballRadius	5.51
//#define g_bRaytraceSphere	1.0
#define g_flParallaxStrength 0.25
/********************************************/

#include source1_varying_eyerefract

void main(void) {
	vec4 diffuseColor = vec4(1.0);
	//#include compute_fragment_color_map_mod1

	#ifdef USE_COLOR_MAP
		vec4 texelColor = texture2D(colorMap, mod(vTextureCoord.xy, 1.0));
	diffuseColor *= texelColor;
	#endif
	#include compute_fragment_alpha_test
		//texelColor.a = 1.0;
		//gl_FragColor = texelColor;
#ifndef IS_TRANSLUCENT
	gl_FragColor.a = 1.0;
#endif
	//gl_FragColor = vec4(vTextureCoord/2.0, 0.0, 1.0);



/********************************************/
	vec3 vWorldPosition = vWorldPosition_ProjPosZ.xyz;
	vec2 vCorneaUv; // Note: Cornea texture is a cropped version of the iris texture
	vCorneaUv.x = dot( uIrisProjectionU, vec4( vWorldPosition, 1.0 ) );
	vCorneaUv.y = dot( uIrisProjectionV, vec4( vWorldPosition, 1.0 ) );
	vec2 vSphereUv = ( vCorneaUv.xy * 0.5 ) + 0.25;

	vec4 corneaColor = texture2D(corneaMap, mod(vCorneaUv, 1.0));
	float fIrisOffset = corneaColor.b;

	vec2 vParallaxVector = ( vTangentViewVector.xy * fIrisOffset * g_flParallaxStrength ) / ( 1.0 - vTangentViewVector.z ); // Note: 0.25 is a magic number
	vParallaxVector = ( vTangentViewVector.xy* g_flParallaxStrength) / ( 1.0 - vTangentViewVector.z );
	vParallaxVector.x = -vParallaxVector.x; //Need to flip x...not sure why.
	vParallaxVector = vec2(0.0);

	vec2 vIrisUv = vSphereUv.xy - vParallaxVector.xy;
#ifdef USE_COLOR_MAP
	vec4 cIrisColor = texture2D(colorMap, vIrisUv);//tex2D( g_tIrisSampler, vIrisUv.xy );
#else
	vec4 cIrisColor = vec4(1.0);
#endif
	cIrisColor = pow(cIrisColor, vec4(1./2.2));
	cIrisColor.a = 1.0;
	gl_FragColor = cIrisColor;
	//gl_FragColor = vec4(abs(normalize(vCorneaUv.xy)),0.0 , 1.0);
	//gl_FragColor = vec4(abs(normalize(vParallaxVector.xy)), 0.0, 1.0);
	//gl_FragColor = vec4(abs(normalize(vWorldPosition.xyz)), 1.0);
	//gl_FragColor = vec4(abs(normalize(vTangentViewVector.xyz)), 1.0);
	//gl_FragColor = vec4(((1.0 - abs(vTangentViewVector).z)), 0.0, 0.0, 1.0);
	//gl_FragColor = vec4(abs(normalize(vIrisUv)), 0.0, 1.0);
	//gl_FragColor = texture2D(colorMap, mod(vTextureCoord, 1.0));gl_FragColor.a = 1.0;
	//gl_FragColor = vec4(abs(normalize(uEyeOrigin)), 1.0);
	//gl_FragColor = vec4(abs(normalize(uEyeOrigin)), 1.0);
	//gl_FragColor = vec4(length(vWorldPosition_ProjPosZ .xyz - uEyeOrigin) / 100.0, 0.0, 0.0, 1.0);
	//gl_FragColor = vec4(normalize(abs(vWorldPosition_ProjPosZ.xyz - uEyeOrigin)), 1.0);

	//gl_FragColor = vec4(abs(vWorldPosition_ProjPosZ.x) / 50.0, 0.0, 0.0, 1.0);
	//gl_FragColor = vec4(normalize(abs(vWorldNormal)), 1.0);
	//gl_FragColor = vec4(normalize(abs(vWorldTangent)), 1.0);
	//gl_FragColor = vec4(normalize(abs(vWorldBinormal)), 1.0);
/********************************************/
	#include compute_fragment_standard

#ifdef SKIP_PROJECTION
#ifdef USE_COLOR_MAP
	gl_FragColor = texture2D(colorMap, mod(vTextureCoord.xy, 1.0));
#else
	vec4 gl_FragColor = vec4(1.0);
#endif
	gl_FragColor.a = 1.;
#endif
	#include compute_fragment_render_mode
}
`;

var source1_eyerefract_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_camera_position
#include declare_vertex_uv
#include declare_vertex_skinning

uniform vec3 uEyeOrigin;
uniform vec4 uIrisProjectionU;
uniform vec4 uIrisProjectionV;

/********************************************/
varying vec4 vWorldPosition_ProjPosZ;
varying vec4 vTangentViewVector;
varying vec3 vWorldNormal;
varying vec3 vWorldTangent;
varying vec3 vWorldBinormal;



vec3 Vec3WorldToTangent( vec3 iWorldVector, vec3 iWorldNormal, vec3 iWorldTangent, vec3 iWorldBinormal )
{
	vec3 vTangentVector;
	vTangentVector.x = dot( iWorldVector.xyz, iWorldTangent.xyz );
	vTangentVector.y = dot( iWorldVector.xyz, iWorldBinormal.xyz );
	vTangentVector.z = dot( iWorldVector.xyz, iWorldNormal.xyz );
	return vTangentVector.xyz; // Return without normalizing
}
vec3 Vec3WorldToTangentNormalized( vec3 iWorldVector, vec3 iWorldNormal, vec3 iWorldTangent, vec3 iWorldBinormal )
{
	return normalize( Vec3WorldToTangent( iWorldVector, iWorldNormal, iWorldTangent, iWorldBinormal ) );
}
//const vec4 g_vIrisProjectionU = vec4(0, 1, 0, 0);
//const vec4 g_vIrisProjectionV = vec4(0, 0, 1, 0);

/********************************************/

#include source1_varying_eyerefract

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection


/********************************************/
	vWorldPosition_ProjPosZ.xyz = vertexPositionWorldSpace.xyz;

	mat4 cViewProj = uProjectionMatrix * uViewMatrix;
	vec4 vProjPos = cViewProj * vertexPositionWorldSpace;//mul( vec4( vertexPositionWorldSpace, 1.0 ), cViewProj );
	//o.projPos = vProjPos;
	//vProjPos.z = dot(vertexPositionWorldSpace, cViewProjZ );
	//o.vWorldPosition_ProjPosZ.w = vProjPos.z;

	vec3 vEyeSocketUpVector = normalize( -uIrisProjectionV.xyz );
	vec3 vEyeSocketLeftVector = normalize( -uIrisProjectionU.xyz );

	//vEyeSocketUpVector = -vec3(0.0, 1.0, 0.0);
	//vEyeSocketLeftVector = -vec3(0.0, 0.0, 1.0);

	vWorldNormal = normalize( vertexPositionWorldSpace.xyz - uEyeOrigin.xyz );
	vWorldTangent = normalize( cross( vEyeSocketUpVector.xyz, vWorldNormal.xyz ) );
	vWorldBinormal = normalize( cross( vWorldNormal.xyz, vWorldTangent.xyz ) );

	vec3 vWorldViewVector = normalize (vertexPositionWorldSpace.xyz - uCameraPosition);
	vTangentViewVector.xyz = Vec3WorldToTangentNormalized(vWorldViewVector, vWorldNormal, vWorldTangent, vWorldBinormal);
	//vTangentViewVector.xyz = vWorldViewVector;
	//vTangentViewVector.xyz = vertexPositionWorldSpace.xyz;
	//vTangentViewVector.xyz = vWorldBinormal;

/********************************************/
}
`;

var source1_lightmappedgeneric_fs = `
#define FLAT_SHADING
const vec4 defaultNormalTexel = vec4(0.5, 0.5, 1.0, 1.0);
#include declare_lights
#include declare_shadow_mapping

uniform vec3 phongfresnelranges;

#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_alpha_test

#include varying_standard

void main(void) {
	vec4 diffuseColor = vec4(1.0);

	vec3 lightmapColor1 = vec3(1.0, 1.0, 1.0);
	vec3 lightmapColor2 = vec3(1.0, 1.0, 1.0);
	vec3 lightmapColor3 = vec3(1.0, 1.0, 1.0);
	vec3 diffuseLighting = vec3(1.0);

	#include compute_fragment_color_map
	#include compute_fragment_normal_map
	#include compute_fragment_alpha_test

	#include compute_fragment_normal

	vec3 albedo = texelColor.rgb;

	#ifdef USE_SSBUMP
		vec3 tangentSpaceNormal = texelNormal.xyz;

		diffuseLighting = texelNormal.x * lightmapColor1 +
						  texelNormal.y * lightmapColor2 +
						  texelNormal.z * lightmapColor3;
	#else
		#ifdef USE_NORMAL_MAP
			vec3 tangentSpaceNormal = 2.0 * texelNormal.xyz - 1.0;
		#else
			vec3 tangentSpaceNormal = 2.0 * defaultNormalTexel.xyz - 1.0;
		#endif
	#endif

	fragmentNormalCameraSpace = normalize(TBNMatrixCameraSpace * tangentSpaceNormal);
	#include compute_lights_setup_vars
	BlinnPhongMaterial material;
	material.diffuseColor = texelColor.rgb * diffuseLighting;
	material.specularColor = vec3(1.0);//specular;
	material.specularShininess = 5.0;//shininess;
	material.specularStrength = 1.0;//specularStrength;

	#include compute_fragment_lights

	/*gl_FragColor = textureColor;*/
	gl_FragColor.a = 1.0;
#ifdef USE_PHONG_SHADING
	gl_FragColor.rgb = (reflectedLight.directSpecular + reflectedLight.directDiffuse + reflectedLight.indirectDiffuse);
#else
	gl_FragColor.rgb = (reflectedLight.directDiffuse + reflectedLight.indirectDiffuse * 0.0/*TODO*/);
#endif


#ifdef SKIP_LIGHTING
	gl_FragColor.rgb = albedo;
#endif
	#include compute_fragment_standard
}
`;

var source1_lightmappedgeneric_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_shadow_mapping

#include varying_standard

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_shadow_mapping
	#include compute_vertex_standard
}
`;

var source1_refract_fs = `

#include source1_varying_refract
void main(void) {
	discard;
}
`;

var source1_refract_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_detail_uv
#include declare_vertex_skinning
#include declare_shadow_mapping
#include declare_log_depth

#include source1_varying_refract

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex_detail_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_shadow_mapping
	#include compute_vertex_standard

	vVertexPositionModelSpace = vertexPositionModelSpace;
	#include compute_vertex_log_depth
}
`;

var source1_sprite_fs = `
uniform sampler2D colorMap;
uniform float uAddSelf;
uniform float uOverbrightFactor;
#include declare_fragment_alpha_test

#include source1_varying_sprite

void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map
	diffuseColor *= texelColor;
	#include compute_fragment_alpha_test
	//vec4 textureColor = texture2D(colorMap, vTextureCoord.xy);
	//gl_FragColor = textureColor * (vColor + vec4(uAddSelf));
	//gl_FragColor = texelColor * (vColor + vec4(uAddSelf)) * texelColor.a;
	vec4 blended_rgb = texelColor;
	//blended_rgb.rgb *= uOverbrightFactor;
	#ifdef ADD_SELF
		blended_rgb.a *= vColor.a;
		blended_rgb.rgb *= blended_rgb.a;
		blended_rgb.rgb += uOverbrightFactor * uAddSelf * vColor.a * blended_rgb.rgb;
		blended_rgb.rgb *= vColor.rgb;
	#else
		blended_rgb *= vColor;
	#endif
	gl_FragColor = blended_rgb;
#ifdef IS_ROPE
	//gl_FragColor = vec4(1.0);
#endif
	#include compute_fragment_standard
}`;

var source1_sprite_vs = `
//#version 300 es

attribute float aParticleId;
#include declare_attributes

#include declare_matrix_uniforms

//uniform float uFaceCamera;
uniform vec3 uCameraPosition;

#include source_declare_particle

#include source1_declare_gamma_functions

#include source1_varying_sprite

void main(void) {
#ifdef HARDWARE_PARTICLES
	#define SOURCE1_PARTICLES
	#include source1_compute_particle_position
	vColor = p.color;
	vColor = GammaToLinear(p.color);
	vColor = p.color;
#else
	#ifdef USE_VERTEX_COLOR
		vColor = aVertexColor;
	#endif
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
#endif
}
`;

var source1_spritecard_fs = `
#include source1_declare_gamma_functions

uniform sampler2D colorMap;
uniform float uAddSelf;
uniform float uOverbrightFactor;
#include declare_fragment_alpha_test

#include source1_varying_spritecard

void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map
	diffuseColor *= texelColor;
	#include compute_fragment_alpha_test
	//vec4 textureColor = texture2D(colorMap, vTextureCoord.xy);
	//gl_FragColor = textureColor * (vColor + vec4(uAddSelf));
	//gl_FragColor = texelColor * (vColor + vec4(uAddSelf)) * texelColor.a;
	vec4 blended_rgb = texelColor;
	blended_rgb.rgb *= uOverbrightFactor;
	//blended_rgb = pow(blended_rgb, vec4(2.2));
	#ifdef ADD_SELF
		blended_rgb.a *= vColor.a;
		blended_rgb.rgb *= blended_rgb.a;
		blended_rgb.rgb += uOverbrightFactor * uAddSelf * vColor.a * blended_rgb.rgb;
		blended_rgb.rgb *= vColor.rgb * vColor.a;
	#else
		blended_rgb *= vColor;
	#endif
	gl_FragColor = blended_rgb;
#ifdef IS_ROPE
	//gl_FragColor = vec4(1.0);
#endif
	#include compute_fragment_standard
}`;

var source1_spritecard_vs = `
//#version 300 es

attribute float aParticleId;
#include declare_attributes

#include declare_matrix_uniforms

//uniform float uFaceCamera;
uniform vec3 uCameraPosition;

#include source_declare_particle

#include source1_declare_gamma_functions

#include source1_varying_spritecard

void main(void) {
#ifdef HARDWARE_PARTICLES
	#define SOURCE1_PARTICLES
	#include source1_compute_particle_position
	vColor = GammaToLinear(p.color);
	vColor = p.color;
#else
	#ifdef USE_VERTEX_COLOR
		vColor = aVertexColor;
	#else
		vColor = vec4(1.0);
	#endif
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
#endif



}
`;

var source1_unlitgeneric_fs = `
#include source1_declare_gamma_functions

uniform sampler2D colorMap;
uniform float uAddSelf;
#include declare_fragment_alpha_test

#include declare_lights
#include declare_shadow_mapping

#include source1_varying_unlit_generic

void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map
	diffuseColor *= texelColor;
	#include compute_fragment_alpha_test
	//vec4 textureColor = texture2D(colorMap, vTextureCoord.xy);
	//gl_FragColor = textureColor * (vColor + vec4(uAddSelf));
	//gl_FragColor = texelColor * (vColor + vec4(uAddSelf)) * texelColor.a;
	#if defined(USE_VERTEX_COLOR) || defined(HARDWARE_PARTICLES)
		gl_FragColor = texelColor * vColor;
	#else
		gl_FragColor = texelColor;
	#endif
	//gl_FragColor = vColor;
	#include compute_fragment_standard
}
`;

var source1_unlitgeneric_vs = `
//#version 300 es

attribute float aParticleId;
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning

uniform float uFaceCamera;
uniform vec3 uCameraPosition;

#include source_declare_particle

#include source1_varying_unlit_generic

void main(void) {
#ifdef HARDWARE_PARTICLES
	#define SOURCE1_PARTICLES
	#include source1_compute_particle_position
	vColor = p.color;
#else
	#ifdef USE_VERTEX_COLOR
		vColor = aVertexColor;
	#endif
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
#endif
}
`;

var source1_unlittwotexture_fs = `

uniform sampler2D colorMap;
uniform sampler2D color2Map;

#include source1_varying_unlittwotexture

/*unlittwotexture.fs*/
void main(void) {
		vec4 textureColor = texture2D(colorMap, vTextureCoord.xy);
		vec4 texture2Color = texture2D(color2Map, vTexture2Coord.xy);
		gl_FragColor = textureColor * vColor * textureColor.a;
		//gl_FragColor = vColor;
		//gl_FragColor = vec4(uAddSelf);
		//gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
		//gl_FragColor = vec4(vTextureCoord, 0.0, 1.0);
		gl_FragColor = textureColor * textureColor.a + texture2Color * texture2Color.a;
		//gl_FragColor = texture2Color * texture2Color.a;
		//gl_FragColor = vec4(vTexture2Coord, 0.0, 1.0);
		//gl_FragColor = vec4(vTexture2Coord, 0.0, 1.0);
		gl_FragColor = textureColor * textureColor.a * texture2Color * texture2Color.a;
	#include compute_fragment_standard
}
`;

var source1_unlittwotexture_vs = `
//#version 300 es

#ifdef HARDWARE_PARTICLES
attribute float aParticleId;
#endif
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning

uniform float uFaceCamera;
uniform vec3 uCameraPosition;

//uniform mat4 uTextureTransform;
uniform mat4 uTexture2Transform;

#include source_declare_particle

#include source1_varying_unlittwotexture

/*unlittwotexture.vs*/
void main(void) {
#ifdef HARDWARE_PARTICLES
	particle p = getParticle(int(aParticleId));
	vColor = p.color;
#else
	vColor = vec4(1.0);
#endif
	//vTextureCoord = aTextureCoord;

#ifdef USE_TEXTURE_TRANSFORM
	vTextureCoord.xy = (uTextureTransform * vec4(aTextureCoord, 1.0, 1.0)).st;
	vTexture2Coord.xy = (uTexture2Transform * vec4(aTextureCoord, 1.0, 1.0)).st;
#endif

#ifdef PARTICLE_ORIENTATION_WORLD_Z_ALIGNED
	//vec3 aVertexPosition3 = aVertexPosition.xyz;
#else
	//vec3 aVertexPosition3 = aVertexPosition.xyz;
#endif
	vec3 aVertexPosition3 = aVertexPosition;
#ifdef HARDWARE_PARTICLES
	vec4 vertexPositionCameraSpace;
	vec4 test = vec4(aVertexPosition3, 1.0) * p.radius * rotationMatrix(vec3(0.0, .0, 1.0), -p.roll * 1.0);
	vec4 vertexPositionModelSpace = vec4(p.center.xyz + test.xyz, 1.0);
	if(uFaceCamera == 10.0) {//face camera
		mat4 lookAt = rotationMatrix(vec3(0.0, 1.0, 0.0), p.yaw);
		mat4 lookAt2 = rotationMatrix(vec3(0.0, 0.0, 1.0), -p.roll);
		lookAt = lookAt * lookAt2;
		vertexPositionCameraSpace = (uModelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0) + lookAt * vec4(aVertexPosition.x*p.radius, aVertexPosition.y*p.radius, 0.0, 0.0));
		vertexPositionCameraSpace = uModelViewMatrix * vertexPositionModelSpace;
	}

	if(uFaceCamera == 11.0) {
		mat4 lookAt = rotationMatrix(vec3(0.0, 0.0, 1.0), -p.roll);
		vec3 eyeDir = aVertexPosition - uCameraPosition;
		eyeDir.x = 0.0;
		eyeDir = normalize(eyeDir);
		vertexPositionCameraSpace = (uModelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0) + vec4(aVertexPosition.x*p.radius, aVertexPosition.y*p.radius*eyeDir.y, 0.0, 0.0));
	}

	if(uFaceCamera == 10.0) {
		mat4 lookAt = rotationMatrix(vec3(0.0, 0.0, 1.0), -p.roll);
		vec3 eyeDir = aVertexPosition - uCameraPosition;
		eyeDir.x = 0.0;
		eyeDir = normalize(eyeDir);
		vertexPositionCameraSpace = (uModelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0) + vec4(aVertexPosition.x*p.radius, aVertexPosition.y*p.radius*eyeDir.y, 0.0, 0.0));
		vertexPositionCameraSpace = uModelViewMatrix * vec4(vertexPositionModelSpace.x, vertexPositionModelSpace.y, vertexPositionModelSpace.z , 1.0);
		vertexPositionCameraSpace = (uModelViewMatrix * vec4(vertexPositionModelSpace.x, vertexPositionModelSpace.y*eyeDir.y, vertexPositionModelSpace.z, 1.0));
	}

	if(uFaceCamera == 1000.0) {
		mat4 lookAt = rotationMatrix(vec3(0.0, 1.0, 0.0), p.yaw);
		mat4 lookAt2 = rotationMatrix(vec3(0.0, 0.0, 1.0), -p.roll);
		vec3 eyeDir = aVertexPosition - uCameraPosition;
		eyeDir.x = 0.0;
		eyeDir = normalize(eyeDir);
		lookAt = lookAt * lookAt2;
		vertexPositionCameraSpace = (uModelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0) + lookAt * vec4(aVertexPosition.x*p.radius, aVertexPosition.y*p.radius, 0.0, 0.0));
		vertexPositionCameraSpace = lookAt * (uModelViewMatrix * vec4(vertexPositionModelSpace.x, vertexPositionModelSpace.y*eyeDir.y, vertexPositionModelSpace.z, 1.0));
	}

#else
	/*#ifdef HARDWARE_SKINNING
		mat4 skinMat = accumulateSkinMat();
		vec4 vertexPositionModelSpace = skinMat * vec4(aVertexPosition, 1.0);
	#else
		vec4 vertexPositionModelSpace = vec4(aVertexPosition, 1.0);
	#endif*/
	#include compute_vertex_uv
	#include compute_vertex_uv2
	#include compute_vertex
	#include compute_vertex_skinning
	//#include compute_vertex_projection
#endif
	//vertexPositionModelSpace *= rotationMatrix(vec3(0.0, 1.0, 0.0), -p.roll * 100.0);

	// = uModelViewMatrix * vertexPositionModelSpace;




#ifdef RENDER_SPRITE_TRAIL
	vec3 vecDelta = p.vecDelta.xyz;
	//vecDelta = vec3(1.0, 1.0, 0.0);
	vec3 aVertexPosition2;

	vec4 q;
	vec3 a = cross(vec3(1.0, 0.0, 0.0), vecDelta);
	q.xyz = a;
	q.w = /*length(vecDelta)*/1.0 + dot(vec3(1.0, 0.0, 0.0), vecDelta);

	aVertexPosition2 = vec3_transformQuat(aVertexPosition3 * vec3(p.vecDelta.w, 0.0, p.radius), normalize(q));
/*
	vec3 test2 = vec3(1.0, 0.0, 0.0);
	vec3 eyeDir = aVertexPosition2 - uCameraPosition;
	q.xyz = cross(test2, eyeDir);
	q.w = length(eyeDir) + dot(test2, vecDelta);
	aVertexPosition2.xyz = vec3_transformQuat(aVertexPosition2.xyz, normalize(q));*/
	vertexPositionModelSpace = vec4(p.center + aVertexPosition2 + vecDelta * p.vecDelta.w, 1.0);

#endif


#ifdef PARTICLE_ORIENTATION_SCREEN_ALIGNED
#ifdef RENDER_SPRITE_TRAIL
#else
	mat4 lookAt = rotationMatrix(vec3(0.0, 1.0, 0.0), p.yaw);
	mat4 lookAt2 = rotationMatrix(vec3(0.0, 0.0, 1.0), -p.roll);
	lookAt = lookAt * lookAt2;
	gl_Position = uProjectionMatrix * (uModelViewMatrix * vec4(p.center, 1.0) + lookAt * vec4(aVertexPosition.x*p.radius, aVertexPosition.y*p.radius, 0.0, 0.0));

#endif
#else
	//vertexPositionCameraSpace = uModelViewMatrix * vertexPositionModelSpace;
	//gl_Position = uProjectionMatrix * vertexPositionCameraSpace;
#endif

#ifdef HARDWARE_PARTICLES
	vertexPositionModelSpace = vec4(aVertexPosition, 1.0);
	vertexPositionCameraSpace = uModelViewMatrix * vertexPositionModelSpace;
	gl_Position = uProjectionMatrix * vertexPositionCameraSpace;
#else
#include compute_vertex_projection
#endif


}
`;

var source1_vertexlitgeneric_fs = `
#include source1_fragment_common
#include declare_camera_position
const vec4 defaultNormalTexel = vec4(0.5, 0.5, 1.0, 1.0);

uniform vec3 phongfresnelranges;

#include declare_fragment_color_map
#include declare_fragment_detail_map
#include declare_fragment_normal_map
#include declare_fragment_phong_exponent_map
#include declare_fragment_alpha_test
#include source1_declare_phong
#include source1_declare_sheen
#include source1_declare_selfillum
#include declare_fragment_cube_map

uniform vec4 g_ShaderControls;
#define g_fPixelFogType					g_ShaderControls.x
#define g_fWriteDepthToAlpha			g_ShaderControls.y
#define g_fWriteWaterFogToDestAlpha		g_ShaderControls.z
#define g_fVertexAlpha					g_ShaderControls.w

uniform vec4 g_DiffuseModulation;
uniform vec3 uCubeMapTint;
uniform float uBlendTintColorOverBase;
uniform float uDetailBlendFactor;

#include source1_final_output_const

#include declare_lights
#include declare_shadow_mapping
#include declare_log_depth

#include source1_varying_vertexlit_generic

#define uBaseMapAlphaPhongMask 0//TODO: set proper uniform
void main(void) {
	#ifdef NO_DRAW
		discard;
	#endif

	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map
	#include compute_fragment_detail_map
	#include compute_fragment_normal_map
	#include compute_fragment_phong_exponent_map

	#include compute_fragment_normal

	float phongMask = 1.0;
	#ifdef USE_NORMAL_MAP
		vec3 tangentSpaceNormal = mix(2.0 * texelNormal.xyz - 1.0, vec3(0, 0, 1), float(uBaseMapAlphaPhongMask));
		#ifdef USE_COLOR_ALPHA_AS_PHONG_MASK
			phongMask = texelColor.a;
		#else
			phongMask = texelNormal.a;
		#endif
	#else
		vec3 tangentSpaceNormal = mix(2.0 * defaultNormalTexel.xyz - 1.0, vec3(0, 0, 1), float(uBaseMapAlphaPhongMask));
		#ifdef USE_COLOR_ALPHA_AS_PHONG_MASK
			phongMask = texelColor.a;
		#endif
	#endif
	//float phongMask = mix(texelNormal.a, texelColor.a, float(uBaseMapAlphaPhongMask));
	fragmentNormalCameraSpace = normalize(TBNMatrixCameraSpace * tangentSpaceNormal);

	diffuseColor *= texelColor;
	#include compute_fragment_alpha_test

	vec3 albedo = texelColor.rgb;
	#include source1_blend_tint
	#include compute_fragment_cube_map

	float alpha = g_DiffuseModulation.a;
	#include source1_colormap_alpha


	alpha = alpha;//lerp(alpha, alpha * vVertexColor.a, g_fVertexAlpha);



	float fogFactor = 0.0;
	//gl_FragColor = FinalOutputConst(vec4(albedo, alpha), fogFactor, g_fPixelFogType, TONEMAP_SCALE_LINEAR, g_fWriteDepthToAlpha, worldPos_projPosZ.w );
	//gl_FragColor = FinalOutputConst( float4( result.rgb, alpha ), fogFactor, g_fPixelFogType, TONEMAP_SCALE_LINEAR, g_fWriteDepthToAlpha, i.worldPos_projPosZ.w );

	if (gl_FragCoord.x < 400.) {
		//gl_FragColor = vec4(texelColor.rgb, 1.);
	}
	/*if (length(floor((gl_FragCoord.xy + vec2(15.0)) / 30.0) * 30.0 - gl_FragCoord.xy) > 10.0) {
		discard;
	}*/
	if (length(mod(gl_FragCoord.xy, vec2(2.0))) < 1.0) {
	//	discard;
	}
	//gl_FragColor = vec4(albedo, alpha);
	//gl_FragColor.rgb = g_DiffuseModulation.rgb;


#ifdef USE_SHEEN_MAP
	//gl_FragColor.rgb = texture2D(sheenMaskMap, vTextureCoord).rgb;
#endif



	#if defined(USE_DETAIL_MAP) && defined(DETAIL_BLEND_MODE)
		#if (DETAIL_BLEND_MODE == 0)
		//TODO
		#elif (DETAIL_BLEND_MODE == 1)
			gl_FragColor.rgb += texelDetail.rgb * uDetailBlendFactor;
		#elif (DETAIL_BLEND_MODE == 2)
		//TODO
		#elif (DETAIL_BLEND_MODE == 3) // TCOMBINE_FADE
			albedo = mix(albedo, texelDetail.rgb, uDetailBlendFactor);
		#endif
	#endif


/* TEST SHADING BEGIN*/
	#include compute_lights_setup_vars



	BlinnPhongMaterial material;
	material.diffuseColor = albedo;//diffuseColor.rgb;//vec3(1.0);//diffuseColor.rgb;
	material.specularColor = vec3(phongMask);
#ifdef USE_PHONG_EXPONENT_MAP
	#ifdef USE_PHONG_ALBEDO_TINT
		material.specularColor = mix(vec3(1.0), texelColor.rgb, texelPhongExponent.g);
	#endif
	material.specularShininess = texelPhongExponent.r * uPhongExponentFactor;
#else
	material.specularShininess = uPhongBoost * uPhongExponent;
#endif
	material.specularStrength = phongMask;
#ifdef SOURCE1_SPECULAR_STRENGTH
	material.specularStrength *= float(SOURCE1_SPECULAR_STRENGTH);
#endif

#include compute_fragment_lights

/* TEST SHADING END*/

/* TEST SHADING BEGIN*/

vec3 diffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
#include source1_compute_selfillum


#ifdef USE_PHONG_SHADING
	gl_FragColor.rgb = (reflectedLight.directSpecular + diffuse);
#else
	gl_FragColor.rgb = (diffuse);
#endif
gl_FragColor.a = alpha;

//gl_FragColor.rgb = vec3(phongMask);
/* TEST SHADING END*/
//gl_FragColor.rgb = texelPhongExponent.rgb;
//gl_FragColor.rgb = material.specularColor;
//gl_FragColor.rgb = vec3(texelColor.a);


#ifdef USE_CUBE_MAP
	#if defined(USE_NORMAL_MAP) && defined(USE_NORMAL_ALPHA_AS_ENVMAP_MASK)
		gl_FragColor.rgb += cubeMapColor.rgb * uCubeMapTint.rgb * texelNormal.a;
	#else
		gl_FragColor.rgb += cubeMapColor.rgb * uCubeMapTint.rgb * texelColor.a;
	#endif
#endif




/*


	computePointLightIrradiance(uPointLights[0], geometry, directLight);
	RE_Direct( directLight, geometry, material, reflectedLight );
		float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
		irradiance = dotNL * directLight.color;

	vec3 halfDir = normalize( directLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( directLight.direction, halfDir ) );
	vec3 F = F_Schlick( material.specularColor, dotLH );
	float D = D_BlinnPhong( material.specularShininess, dotNH );

	float D_BlinnPhong = RECIPROCAL_PI * ( material.specularShininess * 0.5 + 1.0 ) * pow( dotNH + 0.1, material.specularShininess );


gl_FragColor.rgb = 0.5 + 0.5 * vec3(D_BlinnPhong);
*/
#ifdef SKIP_LIGHTING
	gl_FragColor.rgb = albedo;
#endif

	#include source1_compute_sheen
	#include compute_fragment_standard
	#include compute_fragment_log_depth

	#if defined(USE_DETAIL_MAP) && defined(DETAIL_BLEND_MODE)
		#if (DETAIL_BLEND_MODE == 5)
		//TODO
		#elif (DETAIL_BLEND_MODE == 6)
			float f = uDetailBlendFactor - 0.5;
			float fMult = (f >= 0.0) ? 1.0 / uDetailBlendFactor : 4.0 * uDetailBlendFactor;
			float fAdd = (f >= 0.0) ? 1.0-fMult : -0.5*fMult;
			gl_FragColor.rgb += saturate(fMult * texelDetail.rgb + fAdd);
		#endif
	#endif

	#include compute_fragment_render_mode
}
`;

var source1_vertexlitgeneric_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_detail_uv
#include declare_vertex_skinning
#include declare_shadow_mapping
#include declare_log_depth

#include source1_varying_vertexlit_generic

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex_detail_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_shadow_mapping
	#include compute_vertex_standard

	vVertexPositionModelSpace = vertexPositionModelSpace;
	#include compute_vertex_log_depth
}
`;

var source1_water_fs = `
uniform vec3 phongfresnelranges;

uniform sampler2D colorMap;
#ifdef ALPHA_TEST
uniform float uAlphaTestReference;
#endif

varying vec2 vTextureCoord;
void main(void) {
		vec4 textureColor = texture2D(colorMap, vTextureCoord);
#ifdef ALPHA_TEST
		if (textureColor.a < uAlphaTestReference) {
			discard;
		}
#endif

		gl_FragColor = textureColor;
		gl_FragColor = vec4(0.5, 0.5, 1.0, 0.5);
		/*if (length(mod(gl_FragCoord.xy, vec2(2.0))) > 1.0) {
			discard;
		}*/
	#include compute_fragment_standard
}
`;

var source1_water_vs = `
attribute vec3 aVertexPosition;
attribute vec3 aVertexNormal;
attribute vec2 aTextureCoord;

uniform mat4 uModelMatrix;
uniform mat4 uViewMatrix;
uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat3 uNormalMatrix;

uniform mat4 uTextureTransform;

varying vec2 vTextureCoord;

void main(void) {
	vTextureCoord = (uTextureTransform * vec4(aTextureCoord, 1.0, 1.0)).st;
	vec4 vertexPositionModelSpace = vec4(aVertexPosition, 1.0);

	vec4 vertexPositionCameraSpace = uModelViewMatrix * vertexPositionModelSpace;

	gl_Position = uProjectionMatrix * vertexPositionCameraSpace;
}
`;

var source1_weapondecal_fs = `
#ifndef DESATBASETINT
	#define DESATBASETINT 0
#endif
#ifndef ALPHAMASK
	#define ALPHAMASK 0
#endif
#ifndef THIRDPERSON
	#define THIRDPERSON 0
#endif
#ifndef HIGHLIGHT
	#define HIGHLIGHT 0
#endif
#ifndef PHONG
	#define PHONG 0
#endif
#ifndef USE_CUBE_MAP
	#define USE_CUBE_MAP 0
#endif
#ifndef PEEL
	#define PEEL 0
#endif
#ifndef CASCADED_SHADOW_MAPPING
	#define CASCADED_SHADOW_MAPPING 0
#endif
#ifndef DYN_CSM_ENABLED
	#define DYN_CSM_ENABLED 0
#endif
#ifndef NUM_LIGHTS
	#define NUM_LIGHTS 0
#endif

#if ( DESATBASETINT == 1 )
	const float3 g_desat = vec3(0.299, 0.587, 0.114);
#endif
#if (HIGHLIGHT > 0)
	#define			TAU									6.28318
	#define			ONE_OVER_SIXTEEN					0.0625
	#define			CSTRIKE_BLUE						float3( 0.204, 0.266, 0.343 )
#endif
#define			g_flScratchwidth					0.02



#include source1_fragment_common
#include declare_camera_position
#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_phong_exponent_map
#if (THIRDPERSON == 0)
	#include declare_fragment_ao_map
	uniform sampler2D scratchesMap;
	uniform sampler2D grungeMap;
#endif

#if (DECALSTYLE == 3) // hologram
	uniform sampler2D holoMaskMap;
	uniform sampler2D holoSpectrumMap;
#endif


#include declare_fragment_cube_map

uniform vec3 uCubeMapTint;


uniform vec4 uWearParams;//g_fvConstRegister0
#define			g_flWearAmt							uWearParams.x
#define			g_flWearWidth						uWearParams.y
#define			g_flWearRemapped					uWearParams.z
#define			g_flUnWearStrength					uWearParams.w

uniform vec4 uPhongParams;//g_fvConstRegister1
#define			g_flPhongExponent					uPhongParams.x
#define			g_flPhongBoost						uPhongParams.y
#define			g_flPhongAlbedoBoost				uPhongParams.z
#define			g_flGrungeScale						uPhongParams.w

uniform vec4 uPhongFresnel;//g_fvConstRegister2
#define			g_fvPhongFresnelRanges				uPhongFresnel.xyz
#define			g_bPhongAlbedoTint					uPhongFresnel.w



uniform vec3 uColorTint;//m_nColorTint
uniform vec3 uColorTint2;//m_nColorTint2
uniform vec3 uColorTint3;//m_nColorTint3
uniform vec3 uColorTint4;//m_nColorTint4


uniform float uTintLerpBase;
#define			g_flTintLerpBase uTintLerpBase//g_fvConstRegister13

#if (HIGHLIGHT > 0) || (PEEL == 1)
	uniform vec2 uHighlight;//m_nHighlight, m_nHighlightCycle
	#define			g_flHighlightAmount					uHighlight.x
	#define			g_flHighlightCycle					uHighlight.y
#endif


#include source1_varying_weapondecal

void main(void) {
	#ifdef USE_COLOR_MAP
		float4 cOut = texture2D(colorMap, vTextureCoord.zw);
	#else
		float4 cOut = vec4(1.0);
	#endif

	#if ( DESATBASETINT == 1 )
		cOut.rgb = lerp( vec3(dot(g_desat.rgb, cOut.rgb)), cOut.rgb, g_flTintLerpBase );
	#endif

	#if ( ALPHAMASK == 1 )
		cOut.a = step( 0.1, cOut.a );
		cOut.rgb = vec3(cOut.a);
		cOut.a = 1.0;
		gl_FragColor = cOut;
		return;
	#endif

	#if ( THIRDPERSON == 1 )
		//clip off any pixels outside 0-1 UV space to prevent smearing edge pixels on lower mips
		//clip( (saturate( vTextureCoord.z ) != vTextureCoord.z) ? -1 : 1 );
		if ((saturate( vTextureCoord.z ) != vTextureCoord.z)) {
			discard;
		}
		//clip( (saturate( vTextureCoord.w ) != vTextureCoord.w) ? -1 : 1 );
		if ((saturate( vTextureCoord.w ) != vTextureCoord.w)) {
			discard;
		}
	#endif

	//alpha values above 0.1 locally decrease wear to retain important areas of the sticker
	float flUnWearImportance = g_flUnWearStrength * ( 1.0 - cOut.a );

	//semi-on/off alpha
	cOut.a = step( 0.1, cOut.a );
	#if (HIGHLIGHT == 0) && (PEEL == 0)
		//clip( cOut.a - 0.001 );
		if (cOut.a < 0.001) {
			discard;
		}
	#endif

	#if (DECALSTYLE != 2) // non-color-replace logos can still be color tinted by the first color tint value

		#if (DESATBASETINT == 1)
			cOut.rgb = lerp( cOut.rgb * (uColorTint / 255.0), cOut.rgb, cOut.g * g_flTintLerpBase );
		#else
			cOut.rgb *= (uColorTint / 255.0);
		#endif

	#endif

	#if (PHONG == 1)
		// default to numerically defined specular values
		float4 fvSpecularExponent = float4( g_flPhongExponent, g_bPhongAlbedoTint, 0.0, 1.0 );
		#ifdef USE_PHONG_EXPONENT_MAP
			// override the existing specular exponent values with values from the exponent map
			fvSpecularExponent.xy = tex2D( phongExponentMap, vTextureCoord.xy ).xy;
		#endif
	#endif

	//float3 vWorldPos = i.worldPos;
#define vWorldPos vVertexPositionWorldSpace.xyz
	float3 vEyeDir = normalize( uCameraPosition - vWorldPos );

	#if ( (DECALSTYLE == 4) || ( DECALSTYLE == 5 ) )// foil emboss uses normal map
		float4 vNormalTexel = tex2D(normalMap, vTextureCoord.zw * vec2(1.0, -1.0));//I don't know why we have to inverse y axis
		float3 vTangentSpaceNormal = 2.0 * vNormalTexel.xyz - 1.0;

		vec3 fragmentNormalWorldSpace = normalize(vVertexNormalWorldSpace.xyz);
		vec3 fragmentTangentWorldSpace = normalize(vVertexTangentWorldSpace.xyz);
		vec3 fragmentBitangentWorldSpace = normalize(vVertexBitangentWorldSpace.xyz);
		mat3 TBNMatrixWorldSpace = mat3(fragmentTangentWorldSpace, fragmentBitangentWorldSpace, fragmentNormalWorldSpace);


		float3 vWorldNormal = normalize( (TBNMatrixWorldSpace/* (float3x3)i.tangentSpaceTranspose*/ * vTangentSpaceNormal ) );
		#if ( DECALSTYLE == 5)
			// flatten the normal for anisotropic spec to reduce aliasing
			float3 vSpecNormal = normalize( (TBNMatrixWorldSpace/* (float3x3)i.tangentSpaceTranspose*/ * lerp( vTangentSpaceNormal, float3( 0.0, 0.0, 1.0 ), 0.95 ) ) );
		#endif
	#else
		float3 vWorldNormal = normalize ( vVertexNormalWorldSpace.xyz );
	#endif

	#if (DECALSTYLE == 2) // color-replace logo
		cOut.rgb = lerp( lerp( lerp( (uColorTint / 255.0), (uColorTint2 / 255.0), cOut.r ), (uColorTint3 / 255.0), cOut.g ), (uColorTint4 / 255.0), cOut.b );
	#endif

	#if (DECALSTYLE == 3) // hologram
		float3 fvHoloMask = tex2D( holoMaskMap, vTextureCoord.zw ).rgb;

		#if (NUM_LIGHTS > 0)
			float2 fvSpectrumUV = float2( fvHoloMask.g + dot( vEyeDir, vWorldNormal ), fvHoloMask.b );
			float3 fvlightdir0 = normalize(cLightInfo[0].pos.xyz - vWorldPos);
			fvSpectrumUV.x += dot( vEyeDir, fvlightdir0 );
		#else
			float2 fvSpectrumUV = float2( fvHoloMask.g + dot( vEyeDir + vWorldNormal, float3( 0, 1, 0 ) ), fvHoloMask.b );
		#endif

		float3 fvHoloSpectrumSrc = tex2D( holoSpectrumMap, fvSpectrumUV ).rgb;
		cOut.rgb = lerp( cOut.rgb, fvHoloSpectrumSrc, fvHoloMask.r );
	#endif

	// lighting
	#if ( (CASCADED_SHADOW_MAPPING == 1) && (DYN_CSM_ENABLED == 1) )
		float flCSMShadow = CSMComputeShadowing( vWorldPos );
	#else
		float flCSMShadow = 1.0;
	#endif

	//float3 linearColor = PixelShaderDoLighting( vWorldPos, vWorldNormal, float3( 0.1, 0.1, 0.1), false, true, i.lightAtten, g_cAmbientCube, NormalizeSampler, NUM_LIGHTS, cLightInfo, false, false, NULL, flCSMShadow );//TODO
	vec3 linearColor = vec3(1.0);

	#ifdef USE_CUBE_MAP
		float3 vReflect = CalcReflectionVectorUnnormalized( vWorldNormal, vEyeDir );
		float3 envMapColor = ENV_MAP_SCALE * texCUBE( cubeMap, vReflect ).rgb * uCubeMapTint;
		// TODO: envmap fresnel
		#if (DECALSTYLE == 4)
			envMapColor *= cOut.rgb * linearColor.rgb;
		#endif
	#endif

	#if (PHONG == 1)
		float3 specularLighting, rimLighting;
		float fFresnelRanges = Fresnel( vWorldNormal, vEyeDir, g_fvPhongFresnelRanges );
		#if ( DECALSTYLE == 5)
			float3 vTangentS = float3( i.tangentSpaceTranspose[0][0], i.tangentSpaceTranspose[1][0], i.tangentSpaceTranspose[2][0] );
			vTangentS = normalize( mul( (float3x3)i.tangentSpaceTranspose, vTangentS ) );
			float3 vTangentT = float3( i.tangentSpaceTranspose[0][1], i.tangentSpaceTranspose[1][1], i.tangentSpaceTranspose[2][1] );
			vTangentT = normalize( mul( (float3x3)i.tangentSpaceTranspose, vTangentT ) );

			vTangentS = normalize( cross( vSpecNormal, vTangentT ) );
			vTangentT = normalize( cross( vSpecNormal, vTangentS ) );

			float4 vAnisoDirSample = tex2D( AnisoDirSampler, vTextureCoord.zw );
			float2 vAnisoDir = vAnisoDirSample.yx * 2.0 - 1.0;

			//PixelShaderDoAnisotropicSpecularLighting( vWorldPos, vWorldNormal, vTangentS, vTangentT, fvSpecularExponent.r * 255.0, vEyeDir, i.lightAtten, NUM_LIGHTS, cLightInfo, fFresnelRanges, vAnisoDir, 1.0, specularLighting );
			//TODO

			rimLighting = 0.0;

			specularLighting *= vAnisoDirSample.a;
		#else
			//PixelShaderDoSpecularLighting( vWorldPos, vWorldNormal, fvSpecularExponent.r * 255.0, vEyeDir, i.lightAtten, NUM_LIGHTS, cLightInfo, false, NULL, fFresnelRanges, false, 1.0, 1.0, specularLighting, rimLighting );
			//TODO
		#endif

		specularLighting *= max( vec3(g_flPhongBoost), fvSpecularExponent.g * g_flPhongAlbedoBoost ) * cOut.rgb ;
		//specularLighting *= lerp( g_flPhongBoost.xxx, g_flPhongAlbedoBoost * cOut.rgb, fvSpecularExponent.g );
		//specularLighting *= g_flPhongBoost;

		#if ( DECALSTYLE != 5 )
			specularLighting *= cOut.a * fFresnelRanges; // specular mask
		#endif
	#endif

	#if ( THIRDPERSON == 0 )

		//sample ao
		#ifdef USE_AO_MAP
			float4 fvAOSrc = tex2D( aoMap, vTextureCoord.xy );
		#else
			float4 fvAOSrc = vec4(1.0);
		#endif

		//apply scratches and grunge

		//sample cavity and ao
		float4 fvScratchesSrc = tex2D( scratchesMap, vTextureCoord.xy * 0.5 );
		float4 fvGrungeSrc = tex2D( grungeMap, vTextureCoord.zw * g_flGrungeScale );
		float cavity = 1.0 - fvAOSrc.r * fvAOSrc.g * fvScratchesSrc.g;

		//apply uniform grunge
		cOut.rgb = lerp( cOut.rgb, cOut.rgb * fvGrungeSrc.rgb, g_flWearAmt * 0.7 );

		float flLocalRemappedWear = g_flWearRemapped - flUnWearImportance;

		float alphaWearPoint = saturate( flLocalRemappedWear - g_flWearWidth );

		//fast wear vertical threshold
		//float flFastWearThresholdValue = step( g_flFastWearThreshold, vTextureCoord.w ) * g_flWearAmt * 2.0;
		//alphaWearPoint += flFastWearThresholdValue;
		//flLocalRemappedWear += flFastWearThresholdValue;

		#if (DECALSTYLE == 4)
			//foil embossed labels have hard wear edges
			cOut.a *= step( alphaWearPoint + g_flScratchwidth, cavity );
		#else
			cOut.a *= smoothstep( alphaWearPoint - g_flScratchwidth, alphaWearPoint + g_flScratchwidth, cavity );
		#endif

		#if ( DECALSTYLE == 1 || DECALSTYLE == 3 ) //paper-backed or holographic (which is also paper-backed)
			// wear down color to white paper backing
			float colorWear = smoothstep( flLocalRemappedWear - g_flScratchwidth, flLocalRemappedWear + g_flScratchwidth, cavity );
			cOut.rgb = lerp( fvGrungeSrc.rgb, cOut.rgb, colorWear );
		#endif

		#if ( ( DECALSTYLE != 4 ) && ( DECALSTYLE != 5 ) ) //foil stickers don't lose their shine
			// wear down spec and envmap
			#if (PHONG == 1 || defined(USE_CUBE_MAP))
				float specWearPoint = saturate( flLocalRemappedWear + g_flWearWidth );
				float specWear = smoothstep( specWearPoint - g_flScratchwidth, specWearPoint + g_flScratchwidth, cavity );
				#if (PHONG == 1)
					specularLighting *= specWear;
				#endif
				#ifdef USE_CUBE_MAP
					envMapColor *= specWear;
				#endif
			#endif
		#endif

	#endif //THIRDPERSON == 0

	#if ( DECALSTYLE == 5 ) // color burn lighting for extra saturation
		cOut.rgb = lerp( cOut.rgb * cOut.rgb * cOut.rgb, cOut.rgb, linearColor );
	#endif

	#if (PHONG == 1)
		cOut.rgb += specularLighting;
	#endif

	// apply lighting
	cOut.rgb *= linearColor;

	#ifdef USE_CUBE_MAP
		cOut.rgb += envMapColor;
	#endif

	#if ( THIRDPERSON == 0 )
		//secondary blurred ao
		cOut.rgb *= lerp( 1.0, fvAOSrc.b, g_flWearAmt * 0.35 );

		//apply AO
		cOut.rgb *= fvAOSrc.g;
	#endif //THIRDPERSON == 0

	#if ( HIGHLIGHT > 0 )
		// cheap highlighting base pass
		float flModdedCycle = fmod( 0.5 * vTextureCoord.x + vTextureCoord.y + g_flHighlightCycle, 1.5 );
		flModdedCycle = smoothstep( 0.2, 0.6, abs( flModdedCycle - 0.5 ) );

		#ifdef USE_CUBE_MAP
			vReflect.r += flModdedCycle;
			float3 envMapColorSelect = texCUBE( cubeMap, vReflect ).rgb * HDR_INPUT_MAP_SCALE;
			float3 selectionColor = max( 4.0*envMapColorSelect.rgb, CSTRIKE_BLUE );
		#else
			float3 selectionColor = max( 4.0*cOut.rgb, CSTRIKE_BLUE );
		#endif

		cOut.rgb = lerp( cOut.rgb, selectionColor, flModdedCycle * g_flHighlightAmount );

	#endif

	#if ( HIGHLIGHT == 2)

		//also do expensive edge detection
		float flEdgeAlphaDetect = 0.0;

		float2 offsets[16] = {
			float2( 1.0, 0.0 ),
			float2( 0.9211, 0.3894 ),
			float2( 0.6967, 0.7174 ),
			float2( 0.3624, 0.932 ),
			float2( -0.0292, 0.9996 ),
			float2( -0.4161, 0.9093 ),
			float2( -0.7374, 0.6755 ),
			float2( -0.9422, 0.335 ),
			float2( -0.9983, -0.0584 ),
			float2( -0.8968, -0.4425 ),
			float2( -0.6536, -0.7568 ),
			float2( -0.3073, -0.9516 ),
			float2( 0.0875, -0.9962 ),
			float2( 0.4685, -0.8835 ),
			float2( 0.7756, -0.6313 ),
			float2( 0.9602, -0.2794 ),
		};

		for ( int k = 0; k < 16; k++ )
		{
			float flAlphaTap = tex2D( BaseSampler, vTextureCoord.zw + offsets[k] * 0.015 ).a;
			flEdgeAlphaDetect += step( 0.1, flAlphaTap );
		}

		flEdgeAlphaDetect = step( abs( (flEdgeAlphaDetect * ONE_OVER_SIXTEEN) - 0.5 ), 0.499 );

		cOut = lerp( cOut, float4(selectionColor, 1), flEdgeAlphaDetect * g_flHighlightAmount );

	#endif

	#if ( PEEL == 1 )
		//sticker peeling application effect in 2D
		float invHighlight = 1.0 - g_flHighlightAmount;
		float distort = pow( (invHighlight - vTextureCoord.x), 0.3 ) * 0.3;

		float2 backingUV = float2(invHighlight + (invHighlight - vTextureCoord.x), vTextureCoord.y );

		//fake vertical parallax
		float flParallaxY = dot( float3(0,0,1), vWorldNormal );
		backingUV.y += (flParallaxY * distort );

		#ifdef USE_COLOR_MAP
			float4 flBackingSample = tex2D( colorMap, backingUV );
		#else
			float4 flBackingSample = vec4(1.0);
		#endif

		//desaturate backing sample
		flBackingSample.rgb = vec3(dot( flBackingSample.rgb, float3(0.299,0.587,0.114) ));

		distort = smoothstep( 0.01, 0.2, distort);
		flBackingSample.rgb = lerp( flBackingSample.rgb, vec3(0.5), vec3(0.2) ) * distort;
		flBackingSample.a = step( 0.1, flBackingSample.a );

		//if ( flBackingSample.a > 0 && vTextureCoord.x < invHighlight )
		//{
		//	cOut.rgb = flBackingSample.rgb;
		//	float edgeFade = smoothstep( 0.0, 0.2, min( vTextureCoord.x, vTextureCoord.y ) );
		//	cOut.a = max( cOut.a, edgeFade );
		//}
		//becomes:
		cOut = lerp( cOut,
			   float4( flBackingSample.rgb, max( cOut.a, smoothstep( 0.0, 0.2, min( vTextureCoord.x, vTextureCoord.y ) ) ) ),
			   step( vTextureCoord.x, invHighlight ) * flBackingSample.a );

		//if ( vTextureCoord.x > invHighlight )
		//{
		//	cOut.rgb = 0;
		//	cOut.a *= (1.0 - distort) * 0.8;
		//}
		//becomes:
		cOut = lerp( cOut, float4( 0, 0, 0, cOut.a * (1.0 - distort) * 0.8 ), step( invHighlight, vTextureCoord.x ) );

	#endif

	//return FinalOutput( cOut, 0, PIXEL_FOG_TYPE_NONE, TONEMAP_SCALE_LINEAR );
	#ifdef USE_COLOR_MAP
		//cOut = texture2D(colorMap, vTextureCoord.xy);
	#endif
	gl_FragColor = cOut;



	/*#if (USE_CUBE_MAP == 1)
		vReflect = CalcReflectionVectorUnnormalized( vWorldNormal, vEyeDir );
		envMapColor = texCUBE( cubeMap, vEyeDir ).rgb;
		gl_FragColor.rgb = envMapColor;
		gl_FragColor.a = 1.0;
	#endif*/
	//#include source1_compute_selfillum
	#include compute_fragment_standard
}
`;

var source1_weapondecal_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning

uniform vec4 g_patternTexCoordTransform[2];
uniform vec4 g_wearTexCoordTransform[2];
uniform vec4 g_grungeTexCoordTransform[2];

#include source1_varying_weapondecal

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection


	vTextureCoord.z = dot(aTextureCoord, g_patternTexCoordTransform[0].xy) + g_patternTexCoordTransform[0].w;
	vTextureCoord.w = dot(aTextureCoord, g_patternTexCoordTransform[1].xy) + g_patternTexCoordTransform[1].w;


	#if (MIRROR == 0)
		vTextureCoord.z = dot(aTextureCoord, g_patternTexCoordTransform[0].xy) + g_patternTexCoordTransform[0].w;
		vTextureCoord.w = dot(aTextureCoord, g_patternTexCoordTransform[1].xy) + g_patternTexCoordTransform[1].w;
	#else
		float2 flippedTexCoord = float2( 1.0f - aTextureCoord.x, aTextureCoord.y );
		vTextureCoord.z = dot(flippedTexCoord, g_patternTexCoordTransform[0].xy) + g_patternTexCoordTransform[0].w;
		vTextureCoord.w = dot(flippedTexCoord, g_patternTexCoordTransform[1].xy) + g_patternTexCoordTransform[1].w;
	#endif

}
`;

var source1_worldvertextransition_fs = `
#include declare_lights
#include declare_shadow_mapping
uniform sampler2D colorMap;
uniform sampler2D color2Map;
uniform sampler2D blendModulateMap;
uniform sampler2D lightMap;
/*uniform sampler2D normalMap;
uniform samplerCube cubeMap;*/

uniform vec3 uColor;
uniform vec3 uEnvMapTint;
uniform float uAlpha;
uniform bool uAlphaTest;
uniform float uUseCubeMap;
uniform float uUseEnvMapMask;
uniform float blendTintByBaseAlpha;
uniform float blendTintColorOverBase;
uniform float uBaseAlphaEnvMapMask;
uniform float uNormalMapAlphaEnvMapMask;
uniform float uEnvMapIntensity;
uniform float uMaskEnvByMetalness;
uniform bool uUseLighting;


uniform vec3 uAmbientColor;

const vec4 c1 = vec4(3.0, -2.0, 0.5, 0.5);

#include source1_varying_worldvertextransition

/* worldvertextransition.fs */
void main(void) {
	#include compute_fragment_color_map


	#include compute_fragment_normal

	vec4 texture2Color = texture2D(color2Map, vTextureCoord.xy);
		vec4 blendModulateColor = texture2D(blendModulateMap, vec2(mod(vTextureCoord.s, 1.0), mod(vTextureCoord.t, 1.0)));/*TODO: transform*/
	if(uAlphaTest && (texelColor.a <= 0.5)) {
		discard;
	}
		float vVertexAlpha2;

	#ifdef USE_BLEND_MODULATE_MAP
			vVertexAlpha2 = vVertexAlpha - blendModulateColor.g;
			vVertexAlpha2 = clamp(vVertexAlpha2 + c1.a, 0.0, 1.0);
		float vVertexAlpha3 =	c1.g * vVertexAlpha2 + c1.r;
			vVertexAlpha3 = vVertexAlpha3 * vVertexAlpha2;
			vVertexAlpha2 = vVertexAlpha3 * vVertexAlpha2;
	#else
		vVertexAlpha2 = vVertexAlpha;
	#endif

	#ifdef USE_COLOR_MAP
		#ifdef USE_COLOR2_MAP
			gl_FragColor = mix(texelColor, texture2Color, vVertexAlpha2);
		#else
			gl_FragColor = texelColor;
		#endif
	#else
		#ifdef USE_COLOR2_MAP
			gl_FragColor = texture2Color;
		#else
			gl_FragColor = vec4(1.0);
		#endif
	#endif
#ifdef USE_LIGHTING
#ifdef UNDEFINED
	gl_FragColor *= max( 1.0 - vEyeDistance / 1000.0, 0.1);
#endif
#endif
/*
	#include compute_lights_setup_vars
	BlinnPhongMaterial material;
	material.diffuseColor = texelColor.rgb;
	material.specularColor = vec3(1.0);//specular;
	material.specularShininess = 5.0;//shininess;
	material.specularStrength = 1.0;//specularStrength;

	#include compute_fragment_lights

	gl_FragColor.a = 1.0;
	#ifdef USE_PHONG_SHADING
		gl_FragColor.rgb = (reflectedLight.directSpecular + reflectedLight.directDiffuse + reflectedLight.indirectDiffuse);
	#else
		gl_FragColor.rgb = (reflectedLight.directDiffuse + reflectedLight.indirectDiffuse);
	#endif
*/
	#include compute_fragment_standard
}


/*
; STATIC: "DETAIL" "0..1"
; STATIC: "BLENDMODULATETEXTURE" "0..1"
ps.1.4

def c1, 3.0, -2.0, 0.5, 0.5

texld	r0, t0
texld	r1, t1
texld	r2, t2
#if DETAIL
texld	r3, t3 ; detail
#endif
#if BLENDMODULATETEXTURE
texld	r4, t4 ; detail
#endif

#if BLEND_MODULATETEXTURE
sub r5.a, v0.a, r4.g
add_sat r5.a, r5.a, c1.a
mad	r6.a, c1.g, r5.a, c1.r
mul r6.a, r6.a, r5.a
mul r5.a, r6.a, r5.a
#else
mov_sat r5.a, v0.a
#endif
lrp r0, r5.a, r1, r0

mul r0, r0, r2
#if DETAIL
mul_x2 r0.rgb, r0, r3
#endif
mul_x2 r0.rgb, c0, r0 ; * 2 * (overbrightFactor/2)
*/
`;

var source1_worldvertextransition_vs = `
#include declare_attributes
attribute float aVertexAlpha;
attribute vec2 aLightCoord;

#include declare_matrix_uniforms
#include declare_vertex_uv

uniform vec4 uTextureCoordOffsetU;
uniform vec4 uTextureCoordOffsetV;

#include source1_varying_worldvertextransition

/* worldvertextransition.vs */
void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_shadow_mapping
	#include compute_vertex_standard
	vVertexAlpha = aVertexAlpha;
}
`;

Shaders['source1_character.fs'] = source1_character_fs;
Shaders['source1_character.vs'] = source1_character_vs;
Shaders['source1_customweapon.fs'] = source1_customweapon_fs;
Shaders['source1_customweapon.vs'] = source1_customweapon_vs;
Shaders['source1_eyerefract.fs'] = source1_eyerefract_fs;
Shaders['source1_eyerefract.vs'] = source1_eyerefract_vs;
Shaders['source1_lightmappedgeneric.fs'] = source1_lightmappedgeneric_fs;
Shaders['source1_lightmappedgeneric.vs'] = source1_lightmappedgeneric_vs;
Shaders['source1_refract.fs'] = source1_refract_fs;
Shaders['source1_refract.vs'] = source1_refract_vs;
Shaders['source1_sprite.fs'] = source1_sprite_fs;
Shaders['source1_sprite.vs'] = source1_sprite_vs;
Shaders['source1_spritecard.fs'] = source1_spritecard_fs;
Shaders['source1_spritecard.vs'] = source1_spritecard_vs;
Shaders['source1_unlitgeneric.fs'] = source1_unlitgeneric_fs;
Shaders['source1_unlitgeneric.vs'] = source1_unlitgeneric_vs;
Shaders['source1_unlittwotexture.fs'] = source1_unlittwotexture_fs;
Shaders['source1_unlittwotexture.vs'] = source1_unlittwotexture_vs;
Shaders['source1_vertexlitgeneric.fs'] = source1_vertexlitgeneric_fs;
Shaders['source1_vertexlitgeneric.vs'] = source1_vertexlitgeneric_vs;
Shaders['source1_water.fs'] = source1_water_fs;
Shaders['source1_water.vs'] = source1_water_vs;
Shaders['source1_weapondecal.fs'] = source1_weapondecal_fs;
Shaders['source1_weapondecal.vs'] = source1_weapondecal_vs;
Shaders['source1_worldvertextransition.fs'] = source1_worldvertextransition_fs;
Shaders['source1_worldvertextransition.vs'] = source1_worldvertextransition_vs;

// TODO: remove me when particle are finished
const messagePerOperator$1 = new Set();
const Source2ParticleOperators = new Map;
function RegisterSource2ParticleOperator(operatorName, operator) {
    Source2ParticleOperators.set(operatorName, operator);
}
function GetSource2ParticleOperator(operatorName) {
    const operator = Source2ParticleOperators.get(operatorName);
    if (operator) {
        return operator;
    }
    if (!messagePerOperator$1.has(operatorName)) {
        console.error('do operator ', operatorName);
        messagePerOperator$1.add(operatorName);
    }
    return null;
}

class Source2Snapshot {
    particleCount = 0;
    attributes = {};
    file = null;
    setParticleCount(particleCount) {
        this.particleCount = particleCount;
    }
}

const Source2SnapshotLoader = new (function () {
    class Source2SnapshotLoader {
        async load(repository, filename) {
            filename = filename.replace(/\.vsnap_c/, '').replace(/\.vsnap/, '');
            const snapFile = await new Source2FileLoader(true).load(repository, filename + '.vsnap_c');
            if (snapFile) {
                return this.#loadSnapshot(snapFile);
            }
            else {
                return null;
            }
        }
        #loadSnapshot(snapFile) {
            const snapShot = new Source2Snapshot();
            snapShot.file = snapFile;
            const dataBlock = snapFile.getBlockByType('DATA');
            const snapBlock = snapFile.getBlockByType('SNAP');
            if (dataBlock && snapBlock) {
                const particleCount = dataBlock.getKeyValueAsNumber('num_particles') ?? 0;
                snapShot.setParticleCount(particleCount);
                const snapshotAttributes = dataBlock.getKeyValueAsElementArray('attributes') ?? [];
                const snapshotStringList = dataBlock.getKeyValueAsStringArray('string_list') ?? [];
                const reader = new BinaryReader(snapBlock.datas);
                let attributeValue;
                let bones;
                let weights;
                for (const snapshotAttribute of snapshotAttributes) {
                    const dataOffset = snapshotAttribute.getSubValueAsNumber('data_offset');
                    if (dataOffset === null) {
                        continue;
                    }
                    reader.seek(dataOffset);
                    const attributeType = snapshotAttribute.getSubValueAsString('type');
                    switch (attributeType) {
                        case 'float3':
                        case 'vector':
                            attributeValue = [];
                            for (let i = 0; i < particleCount; ++i) {
                                attributeValue.push(reader.getVector3());
                            }
                            break;
                        case 'skinning':
                            attributeValue = [];
                            for (let i = 0; i < particleCount; ++i) {
                                const skinning = Object.create(null) /*TODO: create type*/;
                                bones = [];
                                weights = [];
                                for (let i = 0; i < 4; ++i) {
                                    bones.push(snapshotStringList[reader.getUint16()]);
                                }
                                for (let i = 0; i < 4; ++i) {
                                    weights.push(reader.getFloat32());
                                }
                                skinning.bones = bones;
                                skinning.weights = weights;
                                attributeValue.push(skinning);
                            }
                            break;
                        case 'string':
                            attributeValue = [];
                            for (let i = 0; i < particleCount; ++i) {
                                attributeValue.push(snapshotStringList[reader.getUint32()]);
                            }
                            break;
                        case 'float':
                            attributeValue = [];
                            for (let i = 0; i < particleCount; ++i) {
                                attributeValue.push(reader.getFloat32());
                            }
                            break;
                        default:
                            attributeValue = null;
                            console.error('Unknown snapshot attribute type', attributeType, snapshotAttribute, snapFile, particleCount);
                    }
                    const name = snapshotAttribute.getSubValueAsString('name');
                    if (name) {
                        snapShot.attributes[name] = attributeValue;
                    }
                }
            }
            return snapShot;
        }
    }
    return Source2SnapshotLoader;
}());

const PARTICLE_FIELD_POSITION = 0;
const PARTICLE_FIELD_POSITION_PREVIOUS = 2;
const PARTICLE_FIELD_RADIUS = 3;
const PARTICLE_FIELD_ROTATION_ROLL = 4;
const PARTICLE_FIELD_ROTATION_ROLL_SPEED = 5;
const PARTICLE_FIELD_COLOR = 6;
const PARTICLE_FIELD_ALPHA = 7;
const PARTICLE_FIELD_SEQUENCE_NUMBER = 9;
const PARTICLE_FIELD_TRAIL_LENGTH = 10;
const PARTICLE_FIELD_YAW = 12;
const PARTICLE_FIELD_HITBOX_OFFSET_POSITION = 15;
const PARTICLE_FIELD_SCRATCH_VECTOR = 17;
const PARTICLE_FIELD_SCRATCH_FLOAT = 18;
const PARTICLE_FIELD_PITCH = 20;
const PARTICLE_FIELD_GLOW_RGB = 22;
const PARTICLE_FIELD_GLOW_ALPHA = 23;
const ATTRIBUTES_WHICH_ARE_ANGLES = 1 << PARTICLE_FIELD_ROTATION_ROLL | 1 << PARTICLE_FIELD_ROTATION_ROLL_SPEED | 1 << PARTICLE_FIELD_YAW | 1 << PARTICLE_FIELD_PITCH;
const ATTRIBUTES_WHICH_ARE_0_TO_1 = 1 << PARTICLE_FIELD_ALPHA;

const DEFAULT_PARTICLE_NORMAL = vec3.fromValues(0, 0, 1);
class Source2Particle {
    id;
    isAlive = false;
    position = vec3.create();
    quaternion = quat.create();
    prevPosition = vec3.create();
    cpPosition = vec3.create();
    velocity = vec3.create();
    color = vec4.create();
    initialColor = vec4.create();
    normal = vec3.create();
    scratchVec = vec3.create(); //?
    scratch = 0;
    hitboxOffsetPosition = vec3.create(); //?
    glowRGB = vec3.create();
    uMin = 0;
    uMax = 1;
    vMin = 0;
    vMax = 1;
    cTime = 0;
    context = new Map();
    system;
    currentTime = 0;
    timeToLive = 0;
    initialTimeToLive = 0;
    proportionOfLife = 0;
    trail = []; //TODO: remove ?
    modelName = '';
    u = 0; //TODO: remove ?
    v = 0; //TODO: remove ?
    radius = 0;
    initialRadius = 0;
    rotationRoll = 0;
    initialRoll = 0;
    rotationSpeedRoll = 0;
    rotationYaw = 0;
    startAlpha = 0;
    alpha = 0;
    glowAlpha = 0;
    sequence = 0;
    initialSequence = 0;
    sequence2 = 0;
    frame = 0;
    PositionFromParentParticles = false;
    posLockedToCP = false;
    rotLockedToCP = false;
    trailLength = 0.1;
    MovementRigidAttachToCP = false;
    previousElapsedTime = 0;
    skinning;
    initialSkinnedPosition;
    initialSkinnedNormal;
    snapHitbox;
    snapHitboxOffset;
    bones;
    initialVec;
    static consoleAlphaAlternate = false;
    static consolePitch = false;
    constructor(id, system) {
        //this.name = 'Particle ' + id;
        //this.id = id;
        //this.cpPosition = vec3.create();
        //this.cpOrientation = quat.create();
        //this.cpOrientationInvert = quat.create();
        //this.cpPreviousTransform = mat4.create();//TODO: set this per particle list, not per particle
        //this.offsetPosition = vec3.create();
        this.system = system;
        this.reset(id);
        /*
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_XYZ, 0.0f, 0.0f, 0.0f);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_PREV_XYZ, 0.0f, 0.0f, 0.0f);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_LIFE_DURATION, 1.0f);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_RADIUS, pDef->m_flConstantRadius);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_ROTATION, pDef->m_flConstantRotation);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_ROTATION_SPEED, pDef->m_flConstantRotationSpeed);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_TINT_RGB,
                pDef->m_ConstantColor.r() / 255.0f, pDef->m_ConstantColor.g() / 255.0f,
                pDef->m_ConstantColor.g() / 255.0f);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_ALPHA, pDef->m_ConstantColor.a() / 255.0f);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_CREATION_TIME, 0.0f);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_SEQUENCE_NUMBER, pDef->m_nConstantSequenceNumber);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_SEQUENCE_NUMBER1, pDef->m_nConstantSequenceNumber1);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_TRAIL_LENGTH, 0.1f);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_PARTICLE_ID, 0);
            SetAttributeToConstant(PARTICLE_ATTRIBUTE_YAW, 0);*/
    }
    step(elapsedTime) {
        this.currentTime += elapsedTime;
        if (this.timeToLive) {
            this.proportionOfLife = this.currentTime / this.timeToLive;
        }
    }
    start() {
        this.isAlive = true;
        this.currentTime = 0;
        this.proportionOfLife = 0;
        this.trail = [];
    }
    die() {
        this.isAlive = false;
        this.modelName = '';
    }
    reset(id) {
        this.id = id;
        //this.firstRender = true;
        this.currentTime = 0;
        this.proportionOfLife = 0;
        this.timeToLive = 1;
        vec3.zero(this.position);
        vec3.zero(this.prevPosition);
        //vec3.zero(this.cpPosition);
        //vec4.zero(this.cpOrientation);
        //vec3.zero(this.offsetPosition);
        vec3.zero(this.velocity);
        vec4.set(this.color, 1, 1, 1, 1);
        vec4.set(this.initialColor, 1, 1, 1, 1);
        vec3.copy(this.normal, DEFAULT_PARTICLE_NORMAL);
        vec3.zero(this.scratchVec);
        this.scratch = 0;
        this.u = 0;
        this.v = 0;
        this.radius = 5;
        this.initialRadius = 5;
        this.rotationRoll = 0;
        this.initialRoll = 0;
        this.rotationSpeedRoll = 0;
        this.rotationYaw = 0;
        this.startAlpha = 1;
        this.alpha = this.startAlpha;
        this.glowAlpha = 1;
        // sequence number for animated textures
        this.sequence = 0;
        this.sequence2 = 0;
        this.frame = 0;
        this.PositionFromParentParticles = false;
        this.posLockedToCP = false;
        this.rotLockedToCP = false;
        this.trailLength = 0.1;
        this.MovementRigidAttachToCP = false;
        this.context.clear();
        //this.initialCPPosition = null;
        //this.initialCPQuaternion = null;
        //mat4.identity(this.cpPreviousTransform);
    }
    setInitialField(field /*TODO: create a field enum*/, value, mulInitial = false) {
        this.setField(field, value, mulInitial, true);
    }
    setField(field = 0, value, mulInitial = false, setInitial = false, additive = false) {
        // TODO: create setScalarfield / setvectorfield
        if (isNaN(field)) {
            return;
        }
        //console.log('Field ' + field + ' ' + value);
        switch (field) {
            case 0: // Position
                if (additive) {
                    vec3.add(this.position, this.position, value);
                }
                else {
                    vec3.copy(this.position, value);
                }
                if (setInitial) {
                    vec3.copy(this.prevPosition, this.position);
                }
                break;
            case 1: // Time to live
                //if (mulInitial) {value*=this.initialSequence;}
                //this.sequence = Math.round(value);
                if (mulInitial) {
                    value += this.initialTimeToLive;
                }
                this.timeToLive = value;
                //console.log(value);
                break;
            case 2: // Previous position
                vec3.copy(this.prevPosition, value);
                break;
            //case 2: vector position ?
            case 3:
                if (mulInitial) {
                    value *= this.initialRadius;
                }
                this.radius = value;
                if (setInitial) {
                    this.initialRadius = value;
                }
                break;
            case 4: //roll
                //value*=57.3;
                if (value instanceof Float32Array) {
                    value = value[0];
                }
                if (mulInitial) {
                    value += this.initialRoll;
                }
                this.rotationRoll = value; //TODO
                break;
            case 5:
                this.rotationSpeedRoll = value * DEG_TO_RAD;
                break;
            case 6: // Color
                if (mulInitial) {
                    value[0] *= this.initialColor[0];
                    value[1] *= this.initialColor[1];
                    value[2] *= this.initialColor[2];
                }
                if (additive) {
                    vec3.add(this.color, this.color, value);
                }
                else {
                    vec3.copy(this.color, value);
                }
                //this.color.setColor({r:value[0], g:value[1], b:value[2]});
                this.color[0] = clamp$1(this.color[0], 0.0, 1.0);
                this.color[1] = clamp$1(this.color[1], 0.0, 1.0);
                this.color[2] = clamp$1(this.color[2], 0.0, 1.0);
                //vec3.copy(this.color, this.color[);
                if (setInitial) {
                    vec3.copy(this.initialColor, value);
                    //this.initialColor.setColor({r:value[0], g:value[1], b:value[2]});
                }
                break;
            case 7: // Alpha
                if (mulInitial) {
                    value *= this.startAlpha;
                }
                if (setInitial) {
                    this.startAlpha = value;
                }
                this.alpha = value;
                break;
            //case 8: // creation time
            case PARTICLE_FIELD_SEQUENCE_NUMBER:
                this.sequence = value << 0;
                break;
            case PARTICLE_FIELD_TRAIL_LENGTH:
                this.trailLength = value;
                break;
            case 12: // yaw
                if (value instanceof Float32Array) {
                    value = value[0];
                }
                this.rotationYaw = value; //TODO
                break;
            case PARTICLE_FIELD_HITBOX_OFFSET_POSITION:
                vec3.copy(this.hitboxOffsetPosition, value);
                break;
            case 16:
                if (!Source2Particle.consoleAlphaAlternate) {
                    console.warn('alpha alternate code me');
                    Source2Particle.consoleAlphaAlternate = true;
                }
                break;
            case PARTICLE_FIELD_SCRATCH_VECTOR:
                vec3.copy(this.scratchVec, value);
                break;
            case PARTICLE_FIELD_SCRATCH_FLOAT:
                this.scratch = value;
                break;
            case 20:
                if (!Source2Particle.consolePitch) {
                    console.warn('pitch code me');
                    Source2Particle.consolePitch = true;
                }
                break;
            case 21:
                //TODO
                vec3.copy(this.normal, value);
                break;
            case PARTICLE_FIELD_GLOW_RGB:
                vec3.copy(this.glowRGB, value);
                break;
            case PARTICLE_FIELD_GLOW_ALPHA:
                this.glowAlpha = value;
                break;
        }
    }
    /**
    * TODO
    */
    /*
    // required
    DEFPARTICLE_ATTRIBUTE(XYZ, 0);

    // particle lifetime (duration) of particle as a float.
    DEFPARTICLE_ATTRIBUTE(LIFE_DURATION, 1);

    // prev coordinates for verlet integration
    DEFPARTICLE_ATTRIBUTE(PREV_XYZ, 2);

    // radius of particle
    DEFPARTICLE_ATTRIBUTE(RADIUS, 3);

    // rotation angle of particle
    DEFPARTICLE_ATTRIBUTE(ROTATION, 4);

    // rotation speed of particle
    DEFPARTICLE_ATTRIBUTE(ROTATION_SPEED, 5);

    // tint of particle
    DEFPARTICLE_ATTRIBUTE(TINT_RGB, 6);

    // alpha tint of particle
    DEFPARTICLE_ATTRIBUTE(ALPHA, 7);

    // creation time stamp (relative to particle system creation)
    DEFPARTICLE_ATTRIBUTE(CREATION_TIME, 8);

    // sequnece # (which animation sequence number this particle uses)
    DEFPARTICLE_ATTRIBUTE(SEQUENCE_NUMBER, 9);

    // length of the trail
    DEFPARTICLE_ATTRIBUTE(TRAIL_LENGTH, 10);

    // unique particle identifier
    DEFPARTICLE_ATTRIBUTE(PARTICLE_ID, 11);

    // unique rotation around up vector
    DEFPARTICLE_ATTRIBUTE(YAW, 12);

    // second sequnece # (which animation sequence number this particle uses)
    DEFPARTICLE_ATTRIBUTE(SEQUENCE_NUMBER1, 13);

    // hit box index
    DEFPARTICLE_ATTRIBUTE(HITBOX_INDEX, 14);

    DEFPARTICLE_ATTRIBUTE(HITBOX_RELATIVE_XYZ, 15);
    */
    getScalarField(field = 0, initial = false) {
        switch (field) {
            case 1: // Time to live
                return initial ? this.initialTimeToLive : this.timeToLive;
            case 3:
                return this.radius;
            case 4:
                return this.rotationRoll;
            case 5:
                return this.rotationSpeedRoll;
            case 7:
                return this.alpha;
            case 8: //creation time
                return this.cTime;
            case PARTICLE_FIELD_SEQUENCE_NUMBER:
                return this.sequence;
            case PARTICLE_FIELD_TRAIL_LENGTH:
                return this.trailLength;
            case 12: //yaw
                return this.rotationYaw;
            case 16:
                if (!Source2Particle.consoleAlphaAlternate) {
                    console.warn('alpha alternate code me');
                    Source2Particle.consoleAlphaAlternate = true;
                }
                break;
            case PARTICLE_FIELD_SCRATCH_FLOAT:
                return this.scratch;
            case 20:
                if (!Source2Particle.consolePitch) {
                    console.warn('pitch code me');
                    Source2Particle.consolePitch = true;
                }
                break;
        }
        return 0;
    }
    getVectorField(out, field = 0, initial = false) {
        switch (field) {
            case PARTICLE_FIELD_POSITION:
                vec3.copy(out, this.position);
                break;
            case PARTICLE_FIELD_POSITION_PREVIOUS:
                vec3.copy(out, this.prevPosition);
                break;
            case PARTICLE_FIELD_COLOR:
                vec3.copy(out, this.color);
                break;
            case PARTICLE_FIELD_HITBOX_OFFSET_POSITION:
                vec3.copy(out, this.hitboxOffsetPosition);
                break;
            case PARTICLE_FIELD_SCRATCH_VECTOR:
                vec3.copy(out, this.scratchVec);
                break;
            case 21:
                vec3.copy(out, this.normal);
                break;
            case PARTICLE_FIELD_GLOW_RGB:
                vec3.copy(out, this.glowRGB);
                break;
        }
        return out;
    }
    /**
     * @deprecated Please use getScalarField instead.
     */
    getField(field = 0, initial = false) {
        // TODO: create getScalarField / getVectorField
        switch (field) {
            case PARTICLE_FIELD_POSITION:
                return this.position;
            case 1: // Time to live
                return initial ? this.initialTimeToLive : this.timeToLive;
            case PARTICLE_FIELD_POSITION_PREVIOUS:
                return this.prevPosition;
            case 3:
                return this.radius;
            case 4:
                return this.rotationRoll;
            case 5:
                return this.rotationSpeedRoll;
            case PARTICLE_FIELD_COLOR:
                return this.color;
            case 7:
                return this.alpha;
            case 8: //creation time
                return this.cTime;
            case PARTICLE_FIELD_SEQUENCE_NUMBER:
                return this.sequence;
            case PARTICLE_FIELD_TRAIL_LENGTH:
                return this.trailLength;
            case 12: //yaw
                return this.rotationYaw;
            case PARTICLE_FIELD_HITBOX_OFFSET_POSITION:
                return this.hitboxOffsetPosition;
            case 16:
                if (!Source2Particle.consoleAlphaAlternate) {
                    console.warn('alpha alternate code me');
                    Source2Particle.consoleAlphaAlternate = true;
                }
                break;
            case PARTICLE_FIELD_SCRATCH_VECTOR:
                return this.scratchVec;
            case PARTICLE_FIELD_SCRATCH_FLOAT:
                return this.scratch;
            case 20:
                if (!Source2Particle.consolePitch) {
                    console.warn('pitch code me');
                    Source2Particle.consolePitch = true;
                }
                break;
            case 21:
                return this.normal;
            case PARTICLE_FIELD_GLOW_RGB:
                return this.glowRGB;
        }
        return 0;
    }
    /**
    * TODO
    */
    setInitialSequence(sequence) {
        this.sequence = sequence;
        this.initialSequence = sequence;
    }
    /**
    * TODO
    */
    setInitialRadius(radius) {
        this.radius = radius;
        this.initialRadius = radius;
    }
    /**
    * TODO
    */
    setInitialTTL(timeToLive) {
        this.timeToLive = timeToLive;
        this.initialTimeToLive = timeToLive;
    }
    /**
    * TODO
    */
    setInitialColor(color) {
        this.color = color;
        this.initialColor = color;
    }
    /**
    * Set particle initial rotation roll.
    * @param {Number} roll Initial rotation roll.
    */
    setInitialRoll(roll) {
        this.rotationRoll = roll;
        this.initialRoll = roll;
    }
    /**
    * Get particle world position
    * @param {vec3|null} The receiving vector. Created if null.
    * @return {vec3} The world position.
    */
    getWorldPos(worldPos = vec3.create()) {
        //vec3.transformQuat(worldPos, this.position, this.cpOrientation);
        //vec3.transformQuat(worldPos, this.position, quat.create());
        //vec3.transformQuat(worldPos, this.position, this.system.currentOrientation);
        //vec3.transformQuat(worldPos, this.position, this.cpOrientation);
        //if (this.initialCPPosition) {
        //vec3.add(worldPos, worldPos, this.cpPosition);
        //}
        vec3.copy(worldPos, this.position);
        return worldPos;
    }
    /**
    * Get particle world position
    * @param {vec3|null} The receiving vector. Created if null.
    * @return {vec3} The world position.
    */
    getLocalPos(worldPos = vec3.create()) {
        //worldPos = worldPos || vec3.create();
        //vec3.transformQuat(worldPos, this.position, this.cpOrientation);
        vec3.transformQuat(worldPos, this.position, quat.create());
        //vec3.add(worldPos, worldPos, this.cpPosition);
        return worldPos;
    }
}
/* FIELDS
0:velocity ??
1: TTL
3:radius
4:roll
5:roll speed ??
6: color
7: alpha
8:current time
10:scale
12:yaw???
//-----------------------------------------------------------------------------
// Particle attributes
//-----------------------------------------------------------------------------
#define MAX_PARTICLE_ATTRIBUTES 32

#define DEFPARTICLE_ATTRIBUTE(name, bit)						\
    const int PARTICLE_ATTRIBUTE_##name##_MASK = (1 << bit);	\
    const int PARTICLE_ATTRIBUTE_##name = bit;

// required
DEFPARTICLE_ATTRIBUTE(XYZ, 0);

// particle lifetime (duration) of particle as a float.
DEFPARTICLE_ATTRIBUTE(LIFE_DURATION, 1);

// prev coordinates for verlet integration
DEFPARTICLE_ATTRIBUTE(PREV_XYZ, 2);

// radius of particle
DEFPARTICLE_ATTRIBUTE(RADIUS, 3);

// rotation angle of particle
DEFPARTICLE_ATTRIBUTE(ROTATION, 4);

// rotation speed of particle
DEFPARTICLE_ATTRIBUTE(ROTATION_SPEED, 5);

// tint of particle
DEFPARTICLE_ATTRIBUTE(TINT_RGB, 6);

// alpha tint of particle
DEFPARTICLE_ATTRIBUTE(ALPHA, 7);

// creation time stamp (relative to particle system creation)
DEFPARTICLE_ATTRIBUTE(CREATION_TIME, 8);

// sequnece # (which animation sequence number this particle uses)
DEFPARTICLE_ATTRIBUTE(SEQUENCE_NUMBER, 9);

// length of the trail
DEFPARTICLE_ATTRIBUTE(TRAIL_LENGTH, 10);

// unique particle identifier
DEFPARTICLE_ATTRIBUTE(PARTICLE_ID, 11);

// unique rotation around up vector
DEFPARTICLE_ATTRIBUTE(YAW, 12);

// second sequnece # (which animation sequence number this particle uses)
DEFPARTICLE_ATTRIBUTE(SEQUENCE_NUMBER1, 13);

// hit box index
DEFPARTICLE_ATTRIBUTE(HITBOX_INDEX, 14);

DEFPARTICLE_ATTRIBUTE(HITBOX_RELATIVE_XYZ, 15);

*/
/**
 * TODO
 */

var OperatorParamType;
(function (OperatorParamType) {
    OperatorParamType[OperatorParamType["Null"] = 0] = "Null";
    OperatorParamType[OperatorParamType["Element"] = 1] = "Element";
    OperatorParamType[OperatorParamType["Bool"] = 2] = "Bool";
    OperatorParamType[OperatorParamType["Number"] = 3] = "Number";
    OperatorParamType[OperatorParamType["BigInt"] = 4] = "BigInt";
    OperatorParamType[OperatorParamType["String"] = 5] = "String";
    OperatorParamType[OperatorParamType["Array"] = 6] = "Array";
})(OperatorParamType || (OperatorParamType = {}));
class OperatorParam {
    isOperatorParam = true;
    #value;
    #type;
    #name;
    constructor(name, type, value) {
        this.#name = name;
        this.#type = type;
        this.#value = value;
    }
    getName() {
        return this.#name;
    }
    getType() {
        return this.#type;
    }
    getValueAsBool() {
        if (this.#type != OperatorParamType.Bool) {
            return null;
        }
        return this.#value;
    }
    getValueAsNumber() {
        if (this.#type == OperatorParamType.Number) {
            return this.#value;
        }
        if (this.#type == OperatorParamType.Element) {
            //return this.#value as number;
            const type = this.#value.get('m_nType')?.getValueAsString();
            switch (type) {
                case 'PF_TYPE_LITERAL' /*TODO: create a string constant*/:
                    return this.#value.get('m_flLiteralValue')?.getValueAsNumber() ?? null;
                default:
                    console.error('unknown number type, maybe use getParamScalarValue instead', type, this);
            }
        }
        return null;
    }
    getValueAsString() {
        if (this.#type != OperatorParamType.String) {
            return null;
        }
        return this.#value;
    }
    getValueAsArray() {
        if (this.#type != OperatorParamType.Array) {
            return null;
        }
        return this.#value;
    }
    getValueAsVec2(out) {
        if (this.#type != OperatorParamType.Array) {
            return null;
        }
        const value = this.#value; //TODO: check the actual type
        for (let i = 0; i < 2; i++) {
            // TODO: check len
            out[i] = value[i] ?? 0;
        }
        return out;
    }
    getValueAsVec3(out) {
        if (this.#type != OperatorParamType.Array) {
            return null;
        }
        const value = this.#value; //TODO: check the actual type
        for (let i = 0; i < 3; i++) {
            // TODO: check len
            out[i] = value[i] ?? 0;
        }
        return out;
    }
    getValueAsVec4(out) {
        if (this.#type != OperatorParamType.Array) {
            return null;
        }
        const value = this.#value; //TODO: check the actual type
        for (let i = 0; i < 4; i++) {
            // TODO: check len
            out[i] = value[i] ?? 0;
        }
        return out;
    }
    getSubValue(name) {
        if (this.#type != OperatorParamType.Element) {
            return null;
        }
        return this.#value.get(name) ?? null;
    }
    getSubValueAsBool(name) {
        return this.getSubValue(name)?.getValueAsBool() ?? null;
    }
    getSubValueAsNumber(name) {
        return this.getSubValue(name)?.getValueAsNumber() ?? null;
    }
    getSubValueAsString(name) {
        return this.getSubValue(name)?.getValueAsString() ?? null;
    }
    getSubValueAsArray(name) {
        return this.getSubValue(name)?.getValueAsArray() ?? null;
    }
    getSubValueAsVec2(name, out) {
        return this.getSubValue(name)?.getValueAsVec2(out) ?? null;
    }
    getSubValueAsVec3(name, out) {
        return this.getSubValue(name)?.getValueAsVec3(out) ?? null;
    }
    static fromKv3(name, kv3) {
        if (kv3.isKv3Element) {
            return this.#fromKv3Element(name, kv3);
        }
        if (kv3.isKv3Value) {
            return this.#fromKv3Value(name, kv3);
        }
        if (kv3 === null) {
            new OperatorParam(name, OperatorParamType.Null, null);
        }
        throw 'fix me';
    }
    static #fromKv3Element(name, element) {
        const operatorParam = new OperatorParam(name, OperatorParamType.Element, new Map);
        for (const [name, property] of element.getProperties()) {
            operatorParam.#value.set(name, this.fromKv3(name, property));
        }
        return operatorParam;
    }
    static #fromKv3Value(name, kv3) {
        //const operatorParam = new OperatorParam();
        let type;
        let value;
        if (kv3.isArray()) {
            type = OperatorParamType.Array;
            value = [];
            if (kv3.getSubType() == Kv3Type.Element) {
                for (const sub of kv3.getValue()) {
                    value.push(this.fromKv3('', sub));
                }
            }
            else {
                // TODO: control subtype
                for (const sub of kv3.getValue()) {
                    value.push(sub);
                }
            }
            //export type Kv3ValueType = null | boolean | bigint | number | string | Uint8Array | Float32Array | Kv3ValueType[] | Kv3Element | Kv3Value;
        }
        else {
            switch (kv3.getType()) {
                case Kv3Type.Resource:
                case Kv3Type.String:
                    type = OperatorParamType.String;
                    value = kv3.getValue();
                    break;
                case Kv3Type.Double:
                case Kv3Type.Float:
                case Kv3Type.Int32:
                case Kv3Type.IntZero:
                case Kv3Type.IntOne:
                case Kv3Type.DoubleZero:
                case Kv3Type.DoubleOne:
                    type = OperatorParamType.Number;
                    value = kv3.getValue();
                    break;
                case Kv3Type.True:
                case Kv3Type.False:
                case Kv3Type.Bool:
                    type = OperatorParamType.Bool;
                    value = kv3.getValue();
                    break;
                default:
                    throw 'fix me, missing type';
            }
        }
        return new OperatorParam(name, type, value);
    }
}

var Source2ParticleSetMethod;
(function (Source2ParticleSetMethod) {
    Source2ParticleSetMethod["SetValue"] = "PARTICLE_SET_VALUE";
    Source2ParticleSetMethod["ScaleInitial"] = "PARTICLE_SET_SCALE_INITIAL_VALUE";
    Source2ParticleSetMethod["AddInitial"] = "PARTICLE_SET_ADD_TO_INITIAL_VALUE";
    Source2ParticleSetMethod["RampCurrent"] = "PARTICLE_SET_RAMP_CURRENT_VALUE";
    Source2ParticleSetMethod["ScaleCurrent"] = "PARTICLE_SET_SCALE_CURRENT_VALUE";
    Source2ParticleSetMethod["AddCurrent"] = "PARTICLE_SET_ADD_TO_CURRENT_VALUE";
    Source2ParticleSetMethod["Default"] = "PARTICLE_SET_VALUE";
    // TODO: find m_nSetMethod
})(Source2ParticleSetMethod || (Source2ParticleSetMethod = {}));
function stringToSetMethod(setMethod) {
    switch (setMethod) {
        case Source2ParticleSetMethod.SetValue:
            return Source2ParticleSetMethod.SetValue;
        case Source2ParticleSetMethod.ScaleInitial:
            return Source2ParticleSetMethod.ScaleInitial;
        case Source2ParticleSetMethod.AddInitial:
            return Source2ParticleSetMethod.AddInitial;
        case Source2ParticleSetMethod.RampCurrent:
            return Source2ParticleSetMethod.RampCurrent;
        case Source2ParticleSetMethod.ScaleCurrent:
            return Source2ParticleSetMethod.ScaleCurrent;
        case Source2ParticleSetMethod.AddCurrent:
            return Source2ParticleSetMethod.AddCurrent;
        default:
            console.error('unsupported set method', setMethod);
    }
}
var Source2ParticleSelection;
(function (Source2ParticleSelection) {
    Source2ParticleSelection["First"] = "PARTICLE_SELECTION_FIRST";
    Source2ParticleSelection["Last"] = "PARTICLE_SELECTION_LAST";
    Source2ParticleSelection["Number"] = "PARTICLE_SELECTION_NUMBER";
})(Source2ParticleSelection || (Source2ParticleSelection = {}));
function stringToParticleSelection(selection) {
    switch (selection) {
        case Source2ParticleSelection.First:
            return Source2ParticleSelection.First;
        case Source2ParticleSelection.Last:
            return Source2ParticleSelection.Last;
        case Source2ParticleSelection.Number:
            return Source2ParticleSelection.Number;
        default:
            console.error('unsupported particle selection', selection);
    }
}
var Source2PinBreakType;
(function (Source2PinBreakType) {
    Source2PinBreakType["None"] = "PARTICLE_PIN_DISTANCE_NONE";
    Source2PinBreakType["Neighbor"] = "PARTICLE_PIN_DISTANCE_NEIGHBOR";
    Source2PinBreakType["Farthest"] = "PARTICLE_PIN_DISTANCE_FARTHEST";
    Source2PinBreakType["First"] = "PARTICLE_PIN_DISTANCE_FIRST";
    Source2PinBreakType["Last"] = "PARTICLE_PIN_DISTANCE_LAST";
    Source2PinBreakType["Center"] = "PARTICLE_PIN_DISTANCE_CENTER";
    Source2PinBreakType["Cp"] = "PARTICLE_PIN_DISTANCE_CP";
    Source2PinBreakType["CpPair"] = "PARTICLE_PIN_DISTANCE_CP_PAIR_EITHER";
    Source2PinBreakType["Speed"] = "PARTICLE_PIN_SPEED";
    Source2PinBreakType["CollectionAge"] = "PARTICLE_PIN_COLLECTION_AGE";
    Source2PinBreakType["FloatValue"] = "PARTICLE_PIN_FLOAT_VALUE";
})(Source2PinBreakType || (Source2PinBreakType = {}));
function stringToPinBreakType(breakType) {
    switch (breakType) {
        case Source2PinBreakType.None:
            return Source2PinBreakType.None;
        case Source2PinBreakType.Neighbor:
            return Source2PinBreakType.Neighbor;
        case Source2PinBreakType.Farthest:
            return Source2PinBreakType.Farthest;
        case Source2PinBreakType.First:
            return Source2PinBreakType.First;
        case Source2PinBreakType.Last:
            return Source2PinBreakType.Last;
        case Source2PinBreakType.Center:
            return Source2PinBreakType.Center;
        case Source2PinBreakType.Cp:
            return Source2PinBreakType.Cp;
        case Source2PinBreakType.CpPair:
            return Source2PinBreakType.CpPair;
        case Source2PinBreakType.Speed:
            return Source2PinBreakType.Speed;
        case Source2PinBreakType.CollectionAge:
            return Source2PinBreakType.CollectionAge;
        case Source2PinBreakType.FloatValue:
            return Source2PinBreakType.FloatValue;
        default:
            console.error('unsupported pin break type', breakType);
    }
}
var Source2ParticleTintBlendMode;
(function (Source2ParticleTintBlendMode) {
    Source2ParticleTintBlendMode["Replace"] = "PARTICLEBLEND_REPLACE";
    Source2ParticleTintBlendMode["Overlay"] = "PARTICLEBLEND_OVERLAY";
    Source2ParticleTintBlendMode["Darken"] = "PARTICLEBLEND_DARKEN";
    Source2ParticleTintBlendMode["Lighten"] = "PARTICLEBLEND_LIGHTEN";
    Source2ParticleTintBlendMode["Multiply"] = "PARTICLEBLEND_MULTIPLY";
})(Source2ParticleTintBlendMode || (Source2ParticleTintBlendMode = {}));
function stringToTintBlendMode(blend) {
    switch (blend) {
        case Source2ParticleTintBlendMode.Replace:
            return Source2ParticleTintBlendMode.Replace;
        case Source2ParticleTintBlendMode.Overlay:
            return Source2ParticleTintBlendMode.Overlay;
        case Source2ParticleTintBlendMode.Darken:
            return Source2ParticleTintBlendMode.Darken;
        case Source2ParticleTintBlendMode.Lighten:
            return Source2ParticleTintBlendMode.Lighten;
        case Source2ParticleTintBlendMode.Multiply:
            return Source2ParticleTintBlendMode.Multiply;
        default:
            console.error('unsupported tint blend mode', blend);
    }
}
var Source2ParticleScalarField;
(function (Source2ParticleScalarField) {
    Source2ParticleScalarField[Source2ParticleScalarField["LifeDuration"] = 1] = "LifeDuration";
    Source2ParticleScalarField[Source2ParticleScalarField["Radius"] = 3] = "Radius";
    Source2ParticleScalarField[Source2ParticleScalarField["Roll"] = 4] = "Roll";
    Source2ParticleScalarField[Source2ParticleScalarField["RollSpeed"] = 5] = "RollSpeed";
    Source2ParticleScalarField[Source2ParticleScalarField["Alpha"] = 7] = "Alpha";
    Source2ParticleScalarField[Source2ParticleScalarField["CreationTime"] = 8] = "CreationTime";
    Source2ParticleScalarField[Source2ParticleScalarField["SequenceNumber"] = 9] = "SequenceNumber";
    Source2ParticleScalarField[Source2ParticleScalarField["TrailLength"] = 10] = "TrailLength";
    Source2ParticleScalarField[Source2ParticleScalarField["ParticleId"] = 11] = "ParticleId";
    Source2ParticleScalarField[Source2ParticleScalarField["Yaw"] = 12] = "Yaw";
    Source2ParticleScalarField[Source2ParticleScalarField["SequenceNumber2"] = 13] = "SequenceNumber2";
    Source2ParticleScalarField[Source2ParticleScalarField["HitboxIndex"] = 14] = "HitboxIndex";
    Source2ParticleScalarField[Source2ParticleScalarField["AlphaAlternate"] = 16] = "AlphaAlternate";
    Source2ParticleScalarField[Source2ParticleScalarField["ScratchFloat"] = 18] = "ScratchFloat";
    Source2ParticleScalarField[Source2ParticleScalarField["Disabled"] = 19] = "Disabled";
    Source2ParticleScalarField[Source2ParticleScalarField["Pitch"] = 20] = "Pitch";
    Source2ParticleScalarField[Source2ParticleScalarField["GlowAlpha"] = 23] = "GlowAlpha";
    Source2ParticleScalarField[Source2ParticleScalarField["ScratchFloat2"] = 26] = "ScratchFloat2";
    Source2ParticleScalarField[Source2ParticleScalarField["ScratchFloat3"] = 27] = "ScratchFloat3";
    Source2ParticleScalarField[Source2ParticleScalarField["BoneIndice"] = 31] = "BoneIndice";
    Source2ParticleScalarField[Source2ParticleScalarField["ParentParticleIndex"] = 33] = "ParentParticleIndex";
    Source2ParticleScalarField[Source2ParticleScalarField["ForceScale"] = 34] = "ForceScale";
    Source2ParticleScalarField[Source2ParticleScalarField["ManualAnimationFrame"] = 38] = "ManualAnimationFrame";
    Source2ParticleScalarField[Source2ParticleScalarField["ShaderExtraData1"] = 39] = "ShaderExtraData1";
    Source2ParticleScalarField[Source2ParticleScalarField["ShaderExtraData2"] = 40] = "ShaderExtraData2";
    Source2ParticleScalarField[Source2ParticleScalarField["BoxFlags"] = 44] = "BoxFlags";
    Source2ParticleScalarField[Source2ParticleScalarField["UserEventStates"] = 45] = "UserEventStates";
    Source2ParticleScalarField[Source2ParticleScalarField["ParentParticleId"] = 46] = "ParentParticleId";
    Source2ParticleScalarField[Source2ParticleScalarField["Default"] = 3] = "Default";
})(Source2ParticleScalarField || (Source2ParticleScalarField = {}));
var Source2ParticleVectorField;
(function (Source2ParticleVectorField) {
    Source2ParticleVectorField[Source2ParticleVectorField["Position"] = 0] = "Position";
    Source2ParticleVectorField[Source2ParticleVectorField["PreviousPosition"] = 2] = "PreviousPosition";
    Source2ParticleVectorField[Source2ParticleVectorField["Color"] = 6] = "Color";
    Source2ParticleVectorField[Source2ParticleVectorField["HitboxOffsetPosition"] = 15] = "HitboxOffsetPosition";
    Source2ParticleVectorField[Source2ParticleVectorField["ScratchVector"] = 17] = "ScratchVector";
    Source2ParticleVectorField[Source2ParticleVectorField["Disabled"] = 19] = "Disabled";
    Source2ParticleVectorField[Source2ParticleVectorField["Normal"] = 21] = "Normal";
    Source2ParticleVectorField[Source2ParticleVectorField["GlowRgb"] = 22] = "GlowRgb";
    Source2ParticleVectorField[Source2ParticleVectorField["ScratchVector2"] = 30] = "ScratchVector2";
    Source2ParticleVectorField[Source2ParticleVectorField["BoneWeights"] = 32] = "BoneWeights";
    Source2ParticleVectorField[Source2ParticleVectorField["BoxMins"] = 41] = "BoxMins";
    Source2ParticleVectorField[Source2ParticleVectorField["BoxMaxs"] = 42] = "BoxMaxs";
    Source2ParticleVectorField[Source2ParticleVectorField["BoxAngles"] = 43] = "BoxAngles";
    Source2ParticleVectorField[Source2ParticleVectorField["Default"] = 0] = "Default";
})(Source2ParticleVectorField || (Source2ParticleVectorField = {}));
var Source2ParticleEndCapState;
(function (Source2ParticleEndCapState) {
    Source2ParticleEndCapState["AlwaysEnabled"] = "PARTICLE_ENDCAP_ALWAYS_ON";
    Source2ParticleEndCapState["DisabledDuringEndCap"] = "PARTICLE_ENDCAP_ENDCAP_OFF";
    Source2ParticleEndCapState["EnabledDuringEndCap"] = "PARTICLE_ENDCAP_ENDCAP_ON";
})(Source2ParticleEndCapState || (Source2ParticleEndCapState = {}));
var Source2ParticleRotationSetType;
(function (Source2ParticleRotationSetType) {
    Source2ParticleRotationSetType["None"] = "PARTICLE_ROTATION_LOCK_NONE";
    Source2ParticleRotationSetType["SetRotations"] = "PARTICLE_ROTATION_LOCK_ROTATIONS";
    Source2ParticleRotationSetType["SetNormal"] = "PARTICLE_ROTATION_LOCK_NORMAL";
})(Source2ParticleRotationSetType || (Source2ParticleRotationSetType = {}));
function stringToRotationSetType(rotationSetType) {
    switch (rotationSetType) {
        case Source2ParticleRotationSetType.None:
            return Source2ParticleRotationSetType.None;
        case Source2ParticleRotationSetType.SetRotations:
            return Source2ParticleRotationSetType.SetRotations;
        case Source2ParticleRotationSetType.SetNormal:
            return Source2ParticleRotationSetType.SetNormal;
        default:
            console.error('unsupported rotationSetType', rotationSetType);
    }
}
var Source2ParticleSnapshotReadType;
(function (Source2ParticleSnapshotReadType) {
    Source2ParticleSnapshotReadType["Increment"] = "SNAPSHOT_INDEX_INCREMENT";
    Source2ParticleSnapshotReadType["Direct"] = "SNAPSHOT_INDEX_DIRECT";
    Source2ParticleSnapshotReadType["Default"] = "SNAPSHOT_INDEX_INCREMENT";
})(Source2ParticleSnapshotReadType || (Source2ParticleSnapshotReadType = {}));
function stringToSnapshotReadType(snapshotReadType) {
    switch (snapshotReadType) {
        case Source2ParticleSnapshotReadType.Increment:
            return Source2ParticleSnapshotReadType.Increment;
        case Source2ParticleSnapshotReadType.Direct:
            return Source2ParticleSnapshotReadType.Direct;
        default:
            console.error('unsupported snapshotReadType', snapshotReadType);
    }
}
var Source2ParticleModelType;
(function (Source2ParticleModelType) {
    Source2ParticleModelType["ControlPoint"] = "PM_TYPE_CONTROL_POINT";
    Source2ParticleModelType["Model"] = "PM_TYPE_NAMED_VALUE_MODEL";
    Source2ParticleModelType["Entity"] = "PM_TYPE_NAMED_VALUE_EHANDLE";
    Source2ParticleModelType["Default"] = "PM_TYPE_CONTROL_POINT";
})(Source2ParticleModelType || (Source2ParticleModelType = {}));
function stringToModelType(modelType) {
    switch (modelType) {
        case Source2ParticleModelType.ControlPoint:
            return Source2ParticleModelType.ControlPoint;
        case Source2ParticleModelType.Model:
            return Source2ParticleModelType.Model;
        case Source2ParticleModelType.Entity:
            return Source2ParticleModelType.Entity;
        default:
            console.error('unsupported modelType', modelType);
    }
}
var Source2ParticleTransformType;
(function (Source2ParticleTransformType) {
    Source2ParticleTransformType["Invalid"] = "PT_TYPE_INVALID";
    Source2ParticleTransformType["NamedValue"] = "PT_TYPE_NAMED_VALUE";
    Source2ParticleTransformType["ControlPoint"] = "PT_TYPE_CONTROL_POINT";
    Source2ParticleTransformType["ControlPointRange"] = "PT_TYPE_CONTROL_POINT_RANGE";
    Source2ParticleTransformType["Default"] = "PT_TYPE_CONTROL_POINT";
})(Source2ParticleTransformType || (Source2ParticleTransformType = {}));
function stringToTransformType(transformType) {
    switch (transformType) {
        case Source2ParticleTransformType.Invalid:
            return Source2ParticleTransformType.Invalid;
        case Source2ParticleTransformType.NamedValue:
            return Source2ParticleTransformType.NamedValue;
        case Source2ParticleTransformType.ControlPoint:
            return Source2ParticleTransformType.ControlPoint;
        case Source2ParticleTransformType.ControlPointRange:
            return Source2ParticleTransformType.ControlPointRange;
        default:
            console.error('unsupported transformType', transformType);
    }
}
var Source2ParticleCpField;
(function (Source2ParticleCpField) {
    Source2ParticleCpField[Source2ParticleCpField["Disabled"] = -1] = "Disabled";
    Source2ParticleCpField[Source2ParticleCpField["X"] = 0] = "X";
    Source2ParticleCpField[Source2ParticleCpField["Y"] = 1] = "Y";
    Source2ParticleCpField[Source2ParticleCpField["Z"] = 2] = "Z";
    Source2ParticleCpField[Source2ParticleCpField["Default"] = 0] = "Default";
})(Source2ParticleCpField || (Source2ParticleCpField = {}));

const COLOR_SCALE = 1 / 255;
function vec3Lerp(out, a, b, t) {
    const ax = Number(a[0]);
    const ay = Number(a[1]);
    const az = Number(a[2]);
    out[0] = ax + t * (Number(b[0]) - ax);
    out[1] = ay + t * (Number(b[1]) - ay);
    out[2] = az + t * (Number(b[2]) - az);
    return out;
}
const operatorTempVec2_0 = vec2.create();
const operatorTempVec2_1 = vec2.create();
const operatorTempVec3_0 = vec3.create();
const operatorTempVec3_1 = vec3.create();
const DEFAULT_OP_STRENGTH = 1; // TODO: check default value
const DEFAULT_OP_START_FADE_IN_TIME = 0; // TODO: check default value
const DEFAULT_OP_END_FADE_IN_TIME = 0; // TODO: check default value
const DEFAULT_OP_START_FADE_OUT_TIME = 0; // TODO: check default value
const DEFAULT_OP_END_FADE_OUT_TIME = 0; // TODO: check default value
const DEFAULT_OP_FADE_OSCILLATE_PERIOD = 0; // TODO: check default value
const DEFAULT_FIELD_INPUT$1 = -1; // TODO: check default value
const DEFAULT_SCALE_CP = -1; // TODO: check default value
const DEFAULT_CONTROL_POINT_NUMBER = 0; // TODO: check default value
const DEFAULT_SET_METHOD$5 = Source2ParticleSetMethod.SetValue; // TODO: check default value
const DEFAULT_ASSOCIATED_EMITTER_INDEX = -1; // disabled
class Operator {
    static PVEC_TYPE_PARTICLE_VECTOR = false;
    #parameters = new Map();
    system;
    opStartFadeInTime = DEFAULT_OP_START_FADE_IN_TIME;
    opEndFadeInTime = DEFAULT_OP_END_FADE_IN_TIME;
    opStartFadeOutTime = DEFAULT_OP_START_FADE_OUT_TIME;
    opEndFadeOutTime = DEFAULT_OP_END_FADE_OUT_TIME;
    opFadeOscillatePeriod = DEFAULT_OP_FADE_OSCILLATE_PERIOD;
    #normalizePerLiving = false;
    disableOperator = false;
    controlPointNumber = DEFAULT_CONTROL_POINT_NUMBER;
    #fieldInput = DEFAULT_FIELD_INPUT$1;
    fieldOutput = -1;
    scaleCp = DEFAULT_SCALE_CP;
    mesh;
    endCapState;
    currentTime = 0;
    operateAllParticlesRemoveme = false;
    setMethod = DEFAULT_SET_METHOD$5;
    //protected opStrength = DEFAULT_OP_STRENGTH;
    associatedEmitterIndex = DEFAULT_ASSOCIATED_EMITTER_INDEX;
    constructor(system) {
        this.system = system;
    }
    setParam(paramName, param) {
        /*
        if (value instanceof Kv3Array) {
            const arr = [];
            for (const v of value.values) {
                if (typeof v == 'bigint') {
                    arr.push(Number(v));
                } else {
                    arr.push(v);
                }
            }
            this.#parameters[paramName] = arr;
        } else {
            if (typeof value == 'bigint') {
                this.#parameters[paramName] = Number(value);
            } else {
                this.#parameters[paramName] = value;
            }
        }
        */
        this.#parameters.set(paramName, param);
        this._paramChanged(paramName, param);
    }
    getParamScalarValue(paramName, particle) {
        const parameter = this.#parameters.get(paramName);
        if (parameter) {
            return this.#getParamScalarValue(parameter, particle);
        }
        return null;
    }
    #getParamScalarValue(parameter, particle) {
        let inputValue;
        const type = parameter.getSubValueAsString('m_nType');
        if (type) {
            switch (type) {
                case 'PF_TYPE_LITERAL':
                    return parameter.getSubValueAsNumber('m_flLiteralValue') ?? 0;
                case 'PF_TYPE_PARTICLE_AGE':
                    return particle?.currentTime ?? null; // TODO: not sure if this is the actual value
                case 'PF_TYPE_PARTICLE_NUMBER_NORMALIZED':
                    if (this.#normalizePerLiving) {
                        const max = this.system.livingParticles.length;
                        inputValue = (particle?.id ?? 0) % max / max;
                    }
                    else {
                        inputValue = (particle?.id ?? 0) / this.system.maxParticles;
                    }
                    return this.#getParamScalarValue2(parameter, inputValue);
                case 'PF_TYPE_PARTICLE_NUMBER':
                    inputValue = particle?.id ?? 0;
                    return this.#getParamScalarValue2(parameter, inputValue);
                case 'PF_TYPE_PARTICLE_AGE_NORMALIZED':
                    return this.#getParamScalarValue2(parameter, particle?.proportionOfLife ?? 0);
                case 'PF_TYPE_RANDOM_BIASED':
                    //TODO: use m_nBiasType (PF_BIAS_TYPE_EXPONENTIAL ...)
                    return RemapValClampedBias(Math.random(), 0, 1, parameter.getSubValueAsNumber('m_flRandomMin') ?? 0, parameter.getSubValueAsNumber('m_flRandomMax') ?? 1, 0.5 /*parameter.m_flBiasParameter*/); //TODO: use another bias function bias varies from -1 to 1
                case 'PF_TYPE_RANDOM_UNIFORM':
                    // TODO: user m_nRandomMode (PF_RANDOM_MODE_CONSTANT ...)
                    return RandomFloat(parameter.getSubValueAsNumber('m_flRandomMin') ?? 0, parameter.getSubValueAsNumber('m_flRandomMax') ?? 1);
                case 'PF_TYPE_COLLECTION_AGE':
                    return this.#getParamScalarValue2(parameter, this.system.currentTime);
                case 'PF_TYPE_PARTICLE_NOISE':
                    return this.#getParamScalarValue2(parameter, RandomFloat(parameter.getSubValueAsNumber('m_flNoiseOutputMin') ?? 0, parameter.getSubValueAsNumber('m_flNoiseOutputMax') ?? 1));
                case 'PF_TYPE_CONTROL_POINT_COMPONENT':
                    const cp = this.system.getControlPoint(parameter.getSubValueAsNumber('m_nControlPoint') ?? 0);
                    if (cp) {
                        return cp.getPosition(operatorTempVec3_0)[parameter.getSubValueAsNumber('m_nVectorComponent') ?? 0] ?? 0;
                    }
                    return 0;
                case 'PF_TYPE_PARTICLE_FLOAT':
                    // TODO: use m_nMapType (PF_MAP_TYPE_REMAP...)
                    return inputValue = RemapValClamped(particle?.getField(parameter.getSubValueAsNumber('m_nScalarAttribute') ?? 0) ?? 0, parameter.getSubValueAsNumber('m_flInput0') ?? 0, parameter.getSubValueAsNumber('m_flInput1') ?? 1, parameter.getSubValueAsNumber('m_flOutput0') ?? 0, parameter.getSubValueAsNumber('m_flOutput1') ?? 1);
                case 'PF_TYPE_CONTROL_POINT_SPEED':
                    // TODO: code me
                    return null;
                default:
                    console.error('#getParamScalarValue unknown type', parameter);
                    throw 'Code me';
            }
        }
        else {
            return parameter.getValueAsNumber();
        }
    }
    #getParamScalarValue2 /*TODO: rename to MapType*/(parameter, inputValue) {
        const mapType = parameter.getSubValueAsString('m_nMapType');
        if (!mapType) {
            return 0;
        }
        switch (mapType) {
            case 'PF_MAP_TYPE_DIRECT':
                return inputValue;
            case 'PF_MAP_TYPE_CURVE':
                return this.#getParamScalarValueCurve(parameter, inputValue);
            case 'PF_MAP_TYPE_MULT':
                console.error('do this getParamScalarValue2');
                return inputValue * (parameter.getSubValueAsNumber('m_flMultFactor') ?? 1 /* TODO: check default value*/);
            case 'PF_MAP_TYPE_REMAP':
                return inputValue; //TODO
            default:
                console.error('Unknown map type : ', mapType, parameter);
                return 0;
        }
    }
    #getParamScalarValueCurve(parameter, inputValue) {
        const curve = parameter.getSubValue('m_Curve');
        if (!curve) {
            return 0;
        }
        const domainMins = curve?.getSubValueAsVec2('m_vDomainMins', operatorTempVec2_0);
        const domainMaxs = curve?.getSubValueAsVec2('m_vDomainMaxs', operatorTempVec2_1);
        if (!domainMins || !domainMaxs) {
            return 0;
        }
        const inputMin = domainMins[0];
        const inputMax = domainMaxs[0];
        domainMins[1];
        domainMaxs[1];
        //let modeClamped = parameter.m_nInputMode == "PF_INPUT_MODE_CLAMPED" ? true : false;
        // TODO: use params m_spline, m_tangents, see for instance particles/units/heroes/hero_dawnbreaker/dawnbreaker_ambient_hair.vpcf_c
        if (parameter.getSubValueAsString('m_nInputMode') == 'PF_INPUT_MODE_CLAMPED') {
            inputValue = clamp$1(inputValue, inputMin, inputMax);
        }
        else {
            //"PF_INPUT_MODE_LOOPED"
            //Note : the loop goes from 0 to inputMax, not inputMin to inputMax
            inputValue = inputMax !== 0 ? inputValue % inputMax : inputMin;
        }
        return this.#getCurveValue(curve, inputValue);
    }
    #getCurveValue(curve /*TODO: improve type*/, x) {
        //TODO: do a real curve
        const spline = curve.getSubValueAsArray('m_spline');
        if (!spline) {
            return 0;
        }
        let previousKey = spline[0];
        if (!previousKey || !previousKey.isOperatorParam) {
            return 0;
        }
        let key = previousKey;
        if (x < (previousKey.getSubValueAsNumber('x') ?? 0)) {
            return previousKey.getSubValueAsNumber('y') ?? 0;
        }
        let index = 0;
        while (key = spline[++index]) {
            const keyX = key.getSubValueAsNumber('x') ?? 0;
            const keyY = key.getSubValueAsNumber('y') ?? 0;
            const previousKeyX = previousKey.getSubValueAsNumber('x') ?? 0;
            const previousKeyY = previousKey.getSubValueAsNumber('y') ?? 0;
            if (x < keyX) {
                return lerp(previousKeyY, keyY, (x - previousKeyX) / (keyX - previousKeyX));
            }
            previousKey = key;
        }
        return previousKey.getSubValueAsNumber('y') ?? 0;
        //export function lerp(min, max, v) {
    }
    getParamVectorValue(out /*not sure about vec4. maybe vec3 ?*/, paramName, particle) {
        const parameter = this.#parameters.get(paramName);
        if (!parameter) {
            return undefined;
        }
        const type = parameter.getSubValueAsString('m_nType');
        if (type) {
            switch (type) {
                case 'PVEC_TYPE_LITERAL':
                    //console.error('do this param', paramName, parameter);
                    //return parameter.m_vLiteralValue;
                    parameter.getSubValueAsVec3('m_vLiteralValue', out);
                    break;
                case 'PVEC_TYPE_LITERAL_COLOR':
                    return parameter.getValueAsVec3(out);
                case 'PVEC_TYPE_PARTICLE_VECTOR':
                    if (!Operator.PVEC_TYPE_PARTICLE_VECTOR) {
                        Operator.PVEC_TYPE_PARTICLE_VECTOR = true;
                        throw 'Code me';
                    }
                    break;
                case 'PVEC_TYPE_FLOAT_INTERP_GRADIENT':
                    return this.#getParamVectorValueFloatInterpGradient(out, parameter, particle);
                case 'PVEC_TYPE_FLOAT_COMPONENTS':
                    console.error('fix me: PVEC_TYPE_FLOAT_COMPONENTS', parameter);
                    const componentX = parameter.getSubValue('m_FloatComponentX');
                    const componentY = parameter.getSubValue('m_FloatComponentX');
                    const componentZ = parameter.getSubValue('m_FloatComponentX');
                    if (componentX && componentY && componentZ) {
                        out[0] = this.#getParamScalarValue(componentX, particle) ?? 0 /* TODO: check default value*/;
                        out[1] = this.#getParamScalarValue(componentY, particle) ?? 0 /* TODO: check default value*/;
                        out[2] = this.#getParamScalarValue(componentZ, particle) ?? 0 /* TODO: check default value*/;
                    }
                    break;
                case 'PVEC_TYPE_RANDOM_UNIFORM_OFFSET':
                    if (parameter.getSubValueAsVec3('m_vRandomMin', operatorTempVec3_0) &&
                        parameter.getSubValueAsVec3('m_vRandomMax', operatorTempVec3_1)) {
                        vec3RandomBox(out, operatorTempVec3_0, operatorTempVec3_1);
                    }
                    break;
                case 'PVEC_TYPE_CP_VALUE':
                    const cp = this.system.getControlPoint(parameter.getSubValueAsNumber('m_nControlPoint') ?? DEFAULT_CONTROL_POINT_NUMBER);
                    if (cp) {
                        vec3.copy(out, cp.currentWorldPosition);
                        if (parameter.getSubValueAsVec3('m_vCPValueScale', operatorTempVec3_0)) {
                            vec3.mul(out, out, operatorTempVec3_0);
                        }
                    }
                    break;
                case 'PVEC_TYPE_RANDOM_UNIFORM':
                    //TODO
                    break;
                default:
                    console.error('getParamVectorValue unknown type', type, parameter);
                    throw 'Code me';
            }
        }
        else {
            const value = parameter.getValueAsArray();
            if (value) {
                for (let i = 0; i < 4; i++) {
                    out[i] = value[i] ?? 0;
                }
                return out;
            }
            else {
                console.error('value is not an array, investigate');
                return null;
            }
        }
    }
    #getParamVectorValueFloatInterpGradient(out, parameter, particle) {
        const interpInput0 = parameter.getSubValueAsNumber('m_flInterpInput0');
        const interpInput1 = parameter.getSubValueAsNumber('m_flInterpInput1');
        const floatInterp = parameter.getSubValue('m_FloatInterp');
        if (!floatInterp || interpInput0 === null || interpInput1 === null) {
            return null;
        }
        let inputValue = this.#getParamScalarValue(floatInterp, particle);
        if (inputValue === null) {
            return null;
        }
        inputValue = RemapValClamped(inputValue, interpInput0, interpInput1, 0.0, 1.0);
        const gradient = parameter.getSubValue('m_Gradient');
        if (!gradient) {
            return null;
        }
        const stops = gradient.getSubValueAsArray('m_Stops');
        if (!stops || stops.length == 0) {
            return null;
        }
        //m_Color
        let previousStop = stops[0];
        let stop = previousStop;
        if (inputValue < (previousStop.getSubValueAsNumber('m_flPosition') ?? 0)) {
            if (previousStop.getSubValueAsVec3('m_Color', out)) {
                return vec4.scale(out, out, COLOR_SCALE);
            }
        }
        let index = 0;
        while (stop = stops[++index]) {
            // TODO: optimize
            const previousStopColor = previousStop.getSubValueAsVec3('m_Color', operatorTempVec3_0);
            if (!previousStopColor) {
                return null;
            }
            const previousStopPosition = previousStop.getSubValueAsNumber('m_flPosition');
            if (previousStopPosition === null) {
                return null;
            }
            const stopColor = stop.getSubValueAsVec3('m_Color', operatorTempVec3_1);
            if (!stopColor) {
                return null;
            }
            const stopPosition = stop.getSubValueAsNumber('m_flPosition');
            if (stopPosition === null) {
                return null;
            }
            if (inputValue < (previousStop.getSubValueAsNumber('m_flPosition') ?? 0)) {
                vec3Lerp(out, previousStopColor, stopColor, (inputValue - previousStopPosition) / (stopPosition - previousStopPosition));
                return vec4.scale(out, out, COLOR_SCALE);
            }
            previousStop = stop;
        }
        if (previousStop.getSubValueAsVec3('m_Color', out)) {
            return out;
        }
        return null;
    }
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_bDisableOperator':
                this.disableOperator = param.getValueAsBool() ?? false;
                break;
            case 'm_nOpEndCapState':
                const endCapState = param.getValueAsString();
                if (endCapState === null) {
                    console.error('wrong type for', paramName, param);
                }
                //TODO: do it properly
                if (endCapState == 'PARTICLE_ENDCAP_ENDCAP_ON') {
                    this.disableOperator = true;
                }
                else {
                    if (endCapState == 'PARTICLE_ENDCAP_ENDCAP_OFF') {
                        this.disableOperator = false;
                    }
                    else {
                        console.error('unknown value', paramName, param);
                    }
                }
                break;
            case 'm_flOpStartFadeInTime':
                this.opStartFadeInTime = param.getValueAsNumber() ?? DEFAULT_OP_START_FADE_IN_TIME;
                break;
            case 'm_flOpEndFadeInTime':
                this.opEndFadeInTime = param.getValueAsNumber() ?? DEFAULT_OP_END_FADE_IN_TIME;
                break;
            case 'm_flOpStartFadeOutTime':
                this.opStartFadeOutTime = param.getValueAsNumber() ?? DEFAULT_OP_START_FADE_OUT_TIME;
                break;
            case 'm_flOpEndFadeOutTime':
                this.opEndFadeOutTime = param.getValueAsNumber() ?? DEFAULT_OP_END_FADE_OUT_TIME;
                break;
            case 'm_flOpFadeOscillatePeriod':
                this.opFadeOscillatePeriod = param.getValueAsNumber() ?? DEFAULT_OP_FADE_OSCILLATE_PERIOD;
                break;
            case 'm_nControlPointNumber':
                this.controlPointNumber = param.getValueAsNumber() ?? DEFAULT_CONTROL_POINT_NUMBER;
                break;
            case 'm_nOrientationType':
                this.setOrientationType(param.getValueAsString() ?? ''); //TODO: default value ?
                break;
            case 'm_nFieldInput':
                console.error('do this param', paramName, param);
                this.#fieldInput = param.getValueAsNumber() ?? DEFAULT_FIELD_INPUT$1;
                break;
            case 'm_nOutputField':
                this.fieldOutput = param.getValueAsNumber() ?? -1;
                break;
            case 'm_nOpScaleCP':
                console.error('do this param', paramName, param);
                this.scaleCp = param.getValueAsNumber() ?? DEFAULT_SCALE_CP;
                break;
            case 'm_flOpStrength':
                //this.opStrength = param.getValueAsNumber() ?? DEFAULT_OP_STRENGTH;
                // used in operateParticle
                break;
            case 'm_Notes':
                console.info(this.constructor.name, 'notes:', param.getValueAsString());
                //this.opStrength = param.getValueAsNumber() ?? DEFAULT_OP_STRENGTH;
                // used in operateParticle
                break;
            case 'm_nSetMethod':
                this.setMethod = stringToSetMethod(param.getValueAsString()) ?? DEFAULT_SET_METHOD$5;
                break;
            case 'm_nAssociatedEmitterIndex':
                this.associatedEmitterIndex = param.getValueAsNumber() ?? DEFAULT_ASSOCIATED_EMITTER_INDEX;
                break;
            /*
        case 'm_flAlphaScale':
            throw 'do m_fSpeedRandExp';
            //handled in operator
            break;
            */
            default:
                console.warn(this.constructor.name + ' : unknown parameter : ' + paramName, param);
        }
    }
    initializeParticle(particles, elapsedTime) {
        if (!particles || this.disableOperator) {
            return;
        }
        let strength = 1; // TODO: use m_flOpStrength?
        // TODO: use checkIfOperatorShouldRun
        if (this.scaleCp) {
            strength = this.system.getControlPoint(this.scaleCp).currentWorldPosition[0];
        }
        this.doInit(particles, elapsedTime, strength);
    }
    operateParticle(particle, elapsedTime) {
        if (this.disableOperator) {
            return;
        }
        if (this.endCapState != 1) {
            let strength = this.getParamScalarValue('m_flOpStrength') ?? DEFAULT_OP_STRENGTH;
            // TODO: use checkIfOperatorShouldRun
            if (this.scaleCp) {
                strength = this.system.getControlPoint(this.scaleCp).currentWorldPosition[0];
            }
            this.doOperate(particle, elapsedTime, strength);
        }
    }
    forceParticle(particle, elapsedTime, accumulatedForces) {
        if (!particle || this.disableOperator) {
            return;
        }
        this.doForce(particle, elapsedTime, accumulatedForces, 1 /*TODO: compute actual strengh*/);
    }
    constraintParticle(particle) {
        if (!particle || this.disableOperator) {
            return;
        }
        this.applyConstraint(particle);
    }
    renderParticle(particleList, elapsedTime, material) {
        if (!particleList) {
            return;
        }
        this.doRender(particleList, elapsedTime, material);
    }
    #checkIfOperatorShouldRun() {
        // use opFadeOscillatePeriod
        const strength = this.fadeInOut();
        return strength > 0;
    }
    fadeInOut() {
        if (this.currentTime < this.opStartFadeInTime) {
            return 0;
        }
        if (this.opEndFadeOutTime && this.currentTime > this.opEndFadeOutTime) {
            return 0;
        }
        if (this.currentTime < this.opEndFadeInTime) {
            return (this.currentTime - this.opStartFadeInTime) / (this.opEndFadeInTime - this.opStartFadeInTime);
        }
        if (this.currentTime < this.opStartFadeOutTime) {
            return 1;
        }
        if (this.currentTime < this.opEndFadeOutTime) {
            return (this.currentTime - this.opStartFadeOutTime) / (this.opEndFadeOutTime - this.opStartFadeOutTime);
        }
        return 1;
    }
    setParameter(name, type, value) {
        if (name == '' || name == undefined) {
            return this;
        }
        if (name == 'operator end cap state') {
            this.endCapState = value;
        }
        if (!this.#parameters.has(name)) {
            this.#parameters.set(name, new OperatorParam(name, type, value));
        }
        //this.#parameters[name].type = type;
        //this.#parameters[name].value = value;
        //this.propertyChanged(parameter);
        return this;
    }
    getParameter(name) {
        return this.#parameters.get(name) ?? null;
    }
    getParameters() {
        return this.#parameters;
    }
    setParameters(parameters) {
        for (const i in parameters) {
            const pair = parameters[i];
            this.setParameter(pair[0], pair[1], pair[2]);
        }
        return this;
    }
    doNothing() {
    }
    reset() {
    }
    getOperatorFade() {
        if (!this.system) {
            return 0;
        }
        let start_fadein = this.getParameter('operator start fadein')?.getValueAsNumber() ?? 0 /* TODO: check default value*/;
        let end_fadein = this.getParameter('operator end fadein')?.getValueAsNumber() ?? 0 /* TODO: check default value*/;
        let start_fadeout = this.getParameter('operator start fadeout')?.getValueAsNumber() ?? 0 /* TODO: check default value*/;
        let end_fadeout = this.getParameter('operator end fadeout')?.getValueAsNumber() ?? 0 /* TODO: check default value*/;
        const fade_oscillate = this.getParameter('operator fade oscillate')?.getValueAsNumber() ?? 0 /* TODO: check default value*/;
        if (start_fadein == 0 && end_fadein == 0 && start_fadeout == 0 && end_fadeout == 0) {
            // if all parms at 0, return 1
            return 1;
        }
        let currentTime = this.system.currentTime;
        //	console.log(currentTime);
        if (fade_oscillate != 0) {
            currentTime = currentTime % fade_oscillate;
            start_fadein *= fade_oscillate;
            end_fadein *= fade_oscillate;
            start_fadeout *= fade_oscillate;
            end_fadeout *= fade_oscillate;
        }
        //	console.log(currentTime%fade_oscillate);
        switch (true) {
            case currentTime < start_fadein:
                return 0;
            case currentTime < end_fadein:
                return (currentTime - start_fadein) / (end_fadein - start_fadein);
            case currentTime < start_fadeout:
                return 1;
            case currentTime < end_fadeout:
                return 1 - (currentTime - start_fadeout) / (end_fadeout - start_fadeout);
            default:
                return 0;
        }
    }
    getInputValue(inputField, particle) {
        let input;
        switch (inputField) {
            case 0: //creation time
                input = vec3.clone(particle.position);
                break;
            case 8: //creation time
                input = particle.cTime;
                break;
        }
        return input;
    }
    getInputValueAsVector(inputField, particle, v) {
        switch (inputField) {
            case 0: //creation time
                vec3.copy(v, particle.position);
                break;
            case 4:
                v[0] = particle.rotationRoll;
                v[1] = particle.rotationRoll;
                v[2] = particle.rotationRoll;
                break;
            case 8: //creation time
                v[0] = particle.cTime;
                v[1] = particle.cTime;
                v[2] = particle.cTime;
                break;
        }
    }
    setOutputValue(outputField, value, particle) {
        particle.setInitialField(outputField, value /*TODO*/);
    }
    initMultipleOverride() {
        return false;
    }
    isPreEmission() {
        return false;
    }
    setOrientationType(orientationType) {
        //TODO: finish this
        switch (orientationType) {
            case 'PARTICLE_ORIENTATION_SCREEN_ALIGNED':
            case 0n:
            case 0:
                this.mesh?.setDefine('PARTICLE_ORIENTATION', PARTICLE_ORIENTATION_SCREEN_ALIGNED);
                break;
            case 'PARTICLE_ORIENTATION_SCREEN_Z_ALIGNED':
            case 1n:
            case 1:
                this.mesh?.setDefine('PARTICLE_ORIENTATION', PARTICLE_ORIENTATION_SCREEN_Z_ALIGNED);
                break;
            case 'PARTICLE_ORIENTATION_WORLD_Z_ALIGNED':
            case 2n:
            case 2:
                this.mesh?.setDefine('PARTICLE_ORIENTATION', PARTICLE_ORIENTATION_WORLD_Z_ALIGNED);
                break;
            case 'PARTICLE_ORIENTATION_ALIGN_TO_PARTICLE_NORMAL':
            case 3n:
            case 3:
                this.mesh?.setDefine('PARTICLE_ORIENTATION', PARTICLE_ORIENTATION_ALIGN_TO_PARTICLE_NORMAL);
                break;
            case 'PARTICLE_ORIENTATION_SCREENALIGN_TO_PARTICLE_NORMAL':
            case 4n:
            case 4:
                this.mesh?.setDefine('PARTICLE_ORIENTATION', PARTICLE_ORIENTATION_SCREENALIGN_TO_PARTICLE_NORMAL);
                break;
            case 'PARTICLE_ORIENTATION_FULL_3AXIS_ROTATION':
            case 5n:
            case 5:
                this.mesh?.setDefine('PARTICLE_ORIENTATION', PARTICLE_ORIENTATION_FULL_3AXIS_ROTATION);
                break;
            default:
                console.error('Unknown orientationType ', orientationType);
        }
    }
    init() {
        //This function is called after parameters are set
    }
    dispose() {
    }
    doInit(particle, elapsedTime, strength) { }
    doEmit(elapsedTime) { }
    doOperate(particle, elapsedTime, strength) { }
    doForce(particle, elapsedTime, accumulatedForces, strength) { }
    applyConstraint(particle) { }
    doRender(particle, elapsedTime, material) { }
    initRenderer(particleSystem) { }
    updateParticles(particleSystem, particleList, elapsedTime) { }
}

const DEFAULT_EMITTER_INDEX = -1;
const DEFAULT_EMISSION_DURATION$1 = 0;
const DEFAULT_START_TIME$2 = 0;
class Emitter extends Operator {
    emitterIndex = DEFAULT_EMITTER_INDEX;
    emissionDuration = DEFAULT_EMISSION_DURATION$1;
    startTime = DEFAULT_START_TIME$2;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_nEmitterIndex':
                this.emitterIndex = param.getValueAsNumber() ?? DEFAULT_EMITTER_INDEX;
                break;
            case 'm_flEmissionDuration':
                this.emissionDuration = param.getValueAsNumber() ?? DEFAULT_EMISSION_DURATION$1;
                break;
            case 'm_flStartTime':
                this.startTime = param.getValueAsNumber() ?? DEFAULT_START_TIME$2;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    emitParticle(creationTime, elapsedTime) {
        if (!this.system || this.disableOperator) {
            return;
        }
        return this.system.createParticle(this.emitterIndex, creationTime, elapsedTime);
    }
}

const DEFAULT_CONTROL_POINT_SCALE = vec3.fromValues(1, 1, 1);
const SOURCE2_DEFAULT_RADIUS = 5; // TODO: check default value
const vec$8 = vec3.create();
const DEFAULT_MAX_PARTICLES$1 = 1000;
const DEFAULT_GROUP_ID = 0;
class Source2ParticleSystem extends Entity {
    isParticleSystem = true;
    isSource2ParticleSystem = true;
    fileName;
    repository;
    #parentModel;
    animable = true;
    resetable = true;
    speed = 1;
    isRunning = false;
    startAfterDelay = 0;
    preEmissionOperators = [];
    emitters = [];
    initializers = [];
    operators = [];
    forces = [];
    constraints = [];
    renderers = [];
    #controlPoints = [];
    childSystems = [];
    livingParticles = [];
    poolParticles = [];
    minBounds = vec3.create();
    maxBounds = vec3.create();
    particleCount = 0;
    // particle to emit when the system starts
    initialParticles = 0;
    disabled = false;
    baseProperties;
    firstStep = false;
    currentTime = 0;
    elapsedTime = 0;
    previousElapsedTime = 0;
    maxParticles = 0;
    currentParticles = 0;
    resetDelay = 0;
    parentSystem = null;
    isBounded = false;
    endCap = false;
    groupId = DEFAULT_GROUP_ID;
    constructor(repository, fileName, name) {
        super({ name: name });
        this.fileName = fileName;
        this.repository = repository;
        this.setMaxParticles(DEFAULT_MAX_PARTICLES$1);
        //Add first control point
        //this.getControlPoint(0);
        this.baseProperties = { color: vec4.fromValues(1.0, 1.0, 1.0, 1.0), radius: SOURCE2_DEFAULT_RADIUS, lifespan: 1, sequenceNumber: 0, snapshotControlPoint: 0, snapshot: '', rotationSpeedRoll: 0, controlPointConfigurations: [] };
    }
    async init(snapshotModifiers) {
        await this.#initSnapshot(snapshotModifiers);
        for (const child of this.childSystems) {
            this.addChild(child);
        }
        for (const renderer of this.renderers) {
            renderer.initRenderer(this);
        }
    }
    async #initSnapshot(snapshotModifiers) {
        //TODO : we should add a snapshotmanager to avoid loading the same file multiple time
        let snapshotFile = this.baseProperties.snapshot;
        if (snapshotModifiers?.has(snapshotFile)) {
            snapshotFile = snapshotModifiers.get(snapshotFile);
        }
        if (snapshotFile) {
            const snapshot = await Source2SnapshotLoader.load(this.repository, snapshotFile);
            console.debug(snapshot);
            const cp = this.getControlPoint(this.baseProperties.snapshotControlPoint);
            if (cp && snapshot) {
                //TODO : what happens when this controlPoint is inherited and has already a snapshot ?
                cp.snapshot = snapshot;
            }
        }
    }
    start() {
        if (this.disabled)
            return;
        if (this.isRunning)
            return;
        Source2ParticleManager.setActive(this);
        this.firstStep = true;
        this.#reset();
        this.#startChildren();
        this.isRunning = true;
    }
    #startChildren() {
        for (const child of this.childSystems) {
            child.start();
        }
    }
    stop() {
        this.stopChildren();
        this.isRunning = false;
        for (let i = 0; i < this.livingParticles.length; ++i) {
            const particle = this.livingParticles[i];
            this.poolParticles.push(particle);
            this.livingParticles.splice(i, 1);
            --i;
        }
    }
    stopChildren() {
        for (const child of this.childSystems) {
            child.stop();
        }
    }
    do(action, params) {
        switch (action) {
            case 'reset':
                this.reset();
                break;
        }
    }
    reset() {
        this.stop();
        this.start();
    }
    #reset() {
        this.currentTime = 0;
        this.elapsedTime = 0.05;
        this.previousElapsedTime = 0.05;
        this.particleCount = 0;
        this.#resetChilds();
        this.#resetEmitters();
        //TODO: reset some operators
    }
    #resetChilds() {
        for (const child of this.childSystems) {
            child.#reset();
        }
    }
    #resetEmitters() {
        for (const emitter of this.emitters) {
            emitter.reset();
        }
    }
    #preEmission() {
        for (const operator of this.preEmissionOperators) {
            operator.operateParticle(null, this.elapsedTime);
        }
    }
    step(elapsedTime) {
        if (!this.isPlaying()) {
            elapsedTime = 0.0000001;
        }
        if (!this.isRunning)
            return;
        if (this.firstStep) {
            elapsedTime = 0.05;
        }
        this.previousElapsedTime = this.elapsedTime;
        this.elapsedTime = elapsedTime * this.speed;
        this.#preEmission();
        this.#stepControlPoint();
        if (this.firstStep) {
            this.firstStep = false;
            this.#emitInitialParticles(elapsedTime);
        }
        this.#stepEmitters();
        this.#stepOperators();
        this.currentTime += this.elapsedTime;
        this.#stepRenderers(elapsedTime);
        this.#stepChildren(elapsedTime);
        this.#recomputeBounds();
    }
    #emitInitialParticles(elapsedTime) {
        for (let i = 0; i < this.initialParticles; ++i) {
            this.createParticle(DEFAULT_EMITTER_INDEX, 0, elapsedTime);
        }
    }
    #stepControlPoint() {
        for (const cp of this.#controlPoints) {
            //const cp = this.controlPoints[i];
            if (cp) { // There can be empty values in controlPoints
                cp.step();
            }
            /*if (i == 0) {
                if (cp.attachmentProp) {
                    const atta = cp.attachmentProp;
                    if (atta) {
                        this.setOrientation(atta.getWorldQuat());
                    }
                }
            }*/
        }
        /*if (this.parentSystem) {
            this.setOrientation(this.parentSystem.getWorldQuaternion());
        }*/
    }
    #stepEmitters() {
        for (const emitter of this.emitters) {
            emitter.doEmit(this.elapsedTime);
        }
    }
    #stepOperators() {
        for (let i = 0; i < this.livingParticles.length; ++i) {
            const particle = this.livingParticles[i];
            particle.step(this.elapsedTime);
            for (const operator of this.operators) {
                //const operator = this.operators[j];
                if (operator.operateAllParticlesRemoveme) {
                    if (i == 0) { //do it only once
                        operator.operateParticle(this.livingParticles, this.elapsedTime);
                    }
                }
                else {
                    operator.operateParticle(particle, this.elapsedTime);
                }
                // break the loop if the particle is dead
                if (!particle.isAlive)
                    break;
            }
            if (!particle.isAlive) {
                this.poolParticles.push(particle);
                this.livingParticles.splice(i, 1);
                --i;
            }
        }
    }
    #stepRenderers(elapsedTime) {
        //TODOv3: multiple passes
        for (const renderer of this.renderers) {
            if (!renderer.disableOperator) {
                renderer.updateParticles(this, this.livingParticles, elapsedTime);
            }
        }
    }
    #stepChildren(elapsedTime) {
        for (const child of this.childSystems) {
            if (!child.endCap) {
                child.step(elapsedTime);
            }
        }
    }
    createParticle(emitterIndex, creationTime, elapsedTime) {
        if (this.livingParticles.length < this.maxParticles) {
            // first try to get one from the pool
            if (this.poolParticles.length > 0) {
                const particle = this.poolParticles.pop();
                //init the particle to its initial state;
                particle.reset(++this.particleCount);
                particle.cTime = creationTime;
                this.#initControlPoint(particle);
                this.#startParticle(particle, elapsedTime);
                return particle;
            }
            const particle = new Source2Particle(/*'Particle ' + */ ++this.particleCount, this);
            particle.cTime = creationTime;
            this.#initControlPoint(particle);
            this.#startParticle(particle, elapsedTime);
            ++this.currentParticles;
            return particle;
        }
    }
    #startParticle(particle, elapsedTime) {
        this.resetDelay = 0;
        this.livingParticles.push(particle);
        this.#preInitParticle(particle);
        particle.previousElapsedTime = elapsedTime;
        particle.start();
        // Init modifiers in a 2nd loop
        for (const initializer of this.initializers) {
            if (!initializer.initMultipleOverride()) {
                initializer.initializeParticle(particle, elapsedTime);
            }
        }
        for (const initializer of this.initializers) {
            if (initializer.initMultipleOverride()) {
                initializer.initializeParticle(particle, elapsedTime);
            }
        }
    }
    #preInitParticle(particle) {
        particle.setInitialRadius(this.baseProperties.radius);
        vec4.copy(particle.color, this.baseProperties.color);
        vec4.copy(particle.initialColor, particle.color);
        particle.startAlpha = this.baseProperties.color[3];
        particle.alpha = this.baseProperties.color[3];
        particle.setInitialTTL(this.baseProperties.lifespan);
        particle.sequence = this.baseProperties.sequenceNumber;
        particle.rotationSpeedRoll = this.baseProperties.rotationSpeedRoll;
    }
    #initControlPoint(particle) {
        this.getWorldPosition(particle.cpPosition);
    }
    getWorldPosition(vec = vec3.create()) {
        return vec3.zero(vec);
    }
    getWorldQuaternion(q = quat.create()) {
        return quat.identity(q);
    }
    getControlPoint(controlPointId) {
        const parentSystem = this.parentSystem;
        if (parentSystem) {
            return this.#controlPoints[controlPointId] ?? parentSystem.getControlPoint(controlPointId); //TODO: remove recursion
        }
        let controlPoint = this.#controlPoints[controlPointId];
        if (controlPoint === undefined) {
            controlPoint = this.#createControlPoint(controlPointId);
        }
        return controlPoint;
    }
    getControlPointForScale(controlPointId) {
        const parentSystem = this.parentSystem;
        if (parentSystem) {
            return this.#controlPoints[controlPointId] ?? parentSystem.getControlPoint(controlPointId);
        }
        let controlPoint = this.#controlPoints[controlPointId];
        if (controlPoint === undefined) {
            controlPoint = this.#createControlPoint(controlPointId);
            controlPoint.position = DEFAULT_CONTROL_POINT_SCALE;
        }
        return controlPoint;
    }
    getOwnControlPoint(controlPointId) {
        //return this.getControlPoint(controlPointId);
        return this.#controlPoints[controlPointId] ?? this.#createControlPoint(controlPointId);
    }
    #createControlPoint(controlPointId) {
        const controlPoint = new ControlPoint();
        controlPoint.name = String(controlPointId);
        this.addChild(controlPoint);
        this.#controlPoints[controlPointId] = controlPoint;
        vec3.set(controlPoint.fVector, 0, 1, 0);
        vec3.set(controlPoint.uVector, 0, 0, 1);
        vec3.set(controlPoint.rVector, 1, 0, 0);
        return controlPoint;
    }
    getControlPointPosition(cpId) {
        const cp = this.getControlPoint(cpId);
        if (cp) {
            return cp.getWorldPosition(vec$8);
        }
        return vec3.create();
    }
    setControlPointPosition(cpId, position) {
        const cp = this.getControlPoint(cpId);
        if (cp) {
            cp.position = position;
        }
    }
    setMaxParticles(max) {
        this.maxParticles = Math.max(Math.min(max, HARD_MAX_PARTICLES), 1);
    }
    stepConstraints(particle) {
        //TODOv3: multiple passes
        for (const constraint of this.constraints) {
            constraint.constraintParticle(particle);
        }
    }
    #recomputeBounds() {
        const minBounds = this.minBounds;
        const maxBounds = this.maxBounds;
        vec3.set(minBounds, Infinity, Infinity, Infinity);
        vec3.set(maxBounds, -Infinity, -Infinity, -Infinity);
        this.isBounded = false;
        for (const particle of this.livingParticles) {
            vec3.min(minBounds, minBounds, particle.position);
            vec3.max(maxBounds, maxBounds, particle.position);
            this.isBounded = true;
        }
    }
    getBounds(minBounds, maxBounds) {
        vec3.copy(minBounds, this.minBounds);
        vec3.copy(maxBounds, this.maxBounds);
    }
    getBoundsCenter(center) {
        if (this.isBounded) {
            vec3.add(center, this.minBounds, this.maxBounds);
            vec3.scale(center, center, 0.5);
        }
        else {
            vec3.zero(center);
        }
    }
    parentChanged(parent) {
        if (parent?.isSource2ParticleSystem) {
            this.parentSystem = parent;
        }
        else {
            parent?.addChild(this.getControlPoint(0));
            this.setParentModel(parent ?? undefined);
        }
    }
    setParentModel(model) {
        if (!model?.isSource2ModelInstance) {
            return;
        }
        this.#parentModel = model;
        this.getControlPoint(0).model = model;
        if (this.baseProperties.controlPointConfigurations) {
            for (const controlPointConfiguration of this.baseProperties.controlPointConfigurations) {
                /*if (controlPointConfiguration.m_name == 'point_follow')*/ {
                    const drivers = controlPointConfiguration.drivers;
                    if (drivers) {
                        let i = 0;
                        for (const driver of drivers) {
                            const attachmentName = driver.attachmentName;
                            if (attachmentName) {
                                let attachmentInstance = model?.getAttachment(attachmentName);
                                if (driver.entityName == 'parent') {
                                    attachmentInstance = model?.parent?.getAttachment?.(attachmentName) ?? attachmentInstance;
                                }
                                if (attachmentInstance) {
                                    const cp = this.getOwnControlPoint(driver.controlPoint ?? i);
                                    attachmentInstance.addChild(cp);
                                    cp.step();
                                }
                            }
                            ++i;
                        }
                    }
                }
            }
        }
    }
    getParentModel() {
        // TODO: remove recursion
        if (this.parentSystem) {
            return this.parentSystem.getParentModel();
        }
        return this.#parentModel;
    }
    getParticle(index) {
        if (index == undefined) {
            index = Math.floor(Math.random() * this.livingParticles.length);
        }
        if (index >= this.livingParticles.length) {
            index = Math.floor(Math.random() * this.poolParticles.length);
            return this.poolParticles[index];
        }
        return this.livingParticles[index];
    }
    dispose() {
        super.dispose();
        this.#controlPoints.forEach(element => element.dispose());
        this.operators.forEach(element => element.dispose());
        this.renderers.forEach(element => element.dispose());
        this.childSystems.forEach(element => element.dispose());
        this.#controlPoints.length = 0;
    }
    buildContextMenu() {
        const startStop = this.isRunning ? { i18n: '#stop', f: () => this.stop() } : { i18n: '#start', f: () => this.start() };
        return Object.assign(super.buildContextMenu(), {
            Source2ParticleSystem_1: null,
            startStop: startStop,
            reset: { i18n: '#reset', f: () => this.reset() },
        });
    }
    static getEntityName() {
        return 'Source 2 particle system';
    }
}
Source2ParticleSystem.prototype.isParticleSystem = true;
Source2ParticleSystem.prototype.isSource2ParticleSystem = true;

const CParticleSystemDefinition = 'CParticleSystemDefinition';
const DEFAULT_INITIAL_PARTICLES = 0;
// TODO: remove me when particle are finished
const messagePerOperator = new Set();
function valueToControlPointConfigurationDrivers(value) {
    const ret = [];
    if (value) {
        for (const configuration of value) {
            ret.push({
                attachmentName: configuration.getValueAsString('m_attachmentName'),
                entityName: configuration.getValueAsString('m_entityName'),
                attachType: configuration.getValueAsString('m_iAttachType'),
                controlPoint: configuration.getValueAsNumber('m_iControlPoint'),
            });
        }
    }
    return ret;
}
function valueToControlPointConfigurations(value) {
    const ret = [];
    if (value) {
        for (const configuration of value) {
            ret.push({
                name: configuration.getValueAsString('m_name') ?? '',
                drivers: valueToControlPointConfigurationDrivers(configuration.getValueAsElementArray('m_drivers')),
            });
        }
    }
    return ret;
}
function initProperties(system, systemDefinition) {
    //const keys = Object.keys(systemDefinition);
    for (const [key, value] of systemDefinition.getProperties()) {
        //const value = systemDefinition[key];
        switch (key) {
            case 'm_nMaxParticles':
                system.setMaxParticles(systemDefinition.getValueAsNumber(key) ?? DEFAULT_MAX_PARTICLES$1);
                break;
            case 'm_ConstantColor':
                //vec4.set(system.baseProperties.color, Number(value[0]) / 255.0, Number(value[1]) / 255.0, Number(value[2]) / 255.0, Number(value[3]) / 255.0);
                const constantColor = systemDefinition.getValueAsNumberArray(key);
                if (constantColor && constantColor.length >= 4) {
                    vec4.set(system.baseProperties.color, constantColor[0] / 255.0, constantColor[1] / 255.0, constantColor[2] / 255.0, constantColor[3] / 255.0);
                }
                break;
            case 'm_flConstantLifespan':
                system.baseProperties.lifespan = systemDefinition.getValueAsNumber(key) ?? 0; // TODO: check default value
                break;
            case 'm_flConstantRadius':
                system.baseProperties.radius = systemDefinition.getValueAsNumber(key) ?? SOURCE2_DEFAULT_RADIUS; // TODO: check default value
                break;
            case 'm_nConstantSequenceNumber':
                system.baseProperties.sequenceNumber = systemDefinition.getValueAsNumber(key) ?? 0; // TODO: check default value
                break;
            case 'm_controlPointConfigurations':
                system.baseProperties.controlPointConfigurations = valueToControlPointConfigurations(systemDefinition.getValueAsElementArray(key)); // TODO: check default value
                break;
            case 'm_hSnapshot':
                system.baseProperties.snapshot = systemDefinition.getValueAsResource(key) ?? ''; // TODO: check default value
                break;
            case 'm_nSnapshotControlPoint':
                system.baseProperties.snapshotControlPoint = systemDefinition.getValueAsNumber(key) ?? 0; // TODO: check default value
                break;
            case 'm_nInitialParticles':
                system.initialParticles = systemDefinition.getValueAsNumber(key) ?? DEFAULT_INITIAL_PARTICLES;
                break;
            case 'm_flConstantRotationSpeed':
                system.baseProperties.rotationSpeedRoll = systemDefinition.getValueAsNumber(key) ?? 0; // TODO: check default value
                break;
            case 'm_nGroupID':
                system.groupId = systemDefinition.getValueAsNumber(key) ?? DEFAULT_GROUP_ID;
                break;
        }
    }
}
function initOperators(system, systemArray, kv3Array) {
    if (!kv3Array) {
        return;
    }
    const properties = kv3Array;
    if (properties) {
        for (const property of properties) {
            const operatorClassName = property.getValueAsString('_class');
            if (operatorClassName) {
                const operatorClass = GetSource2ParticleOperator(operatorClassName);
                if (operatorClass) {
                    const operator = new operatorClass(system);
                    if (operator.isPreEmission()) {
                        system.preEmissionOperators.push(operator);
                    }
                    else {
                        systemArray.push(operator);
                    }
                    for (const [name, value] of property.getProperties()) {
                        if (value && name != '_class') {
                            operator.setParam(name, OperatorParam.fromKv3(name, value) /*property.getValue(name)*/);
                        }
                    }
                    operator.init();
                }
                else {
                    if (!messagePerOperator.has(operatorClassName)) {
                        console.error('Unknown operator : ' + operatorClassName, property, system.name);
                        messagePerOperator.add(operatorClassName);
                    }
                }
            }
        }
    }
}
async function initChildren(repository, systemArray, kv3Array, snapshotModifiers) {
    const promises = [];
    if (kv3Array) {
        const properties = kv3Array;
        if (properties) {
            for (let childIndex = 0; childIndex < properties.length; ++childIndex) {
                const property = properties[childIndex];
                const m_ChildRef = property.getValueAsResource('m_ChildRef');
                const m_flDelay = property.getValueAsNumber('m_flDelay') ?? 0;
                if (m_ChildRef) {
                    const p = new Promise(async (resolve) => {
                        const system = await Source2ParticleManager.getSystem(repository, m_ChildRef, snapshotModifiers);
                        system.disabled = property.getValueAsBool('m_bDisableChild') ?? false;
                        if (system) {
                            system.endCap = property.getValueAsBool('m_bEndCap') ?? false;
                            system.startAfterDelay = m_flDelay;
                            systemArray[childIndex] = system;
                            resolve(true);
                        }
                        else {
                            resolve(false);
                        }
                    });
                    promises.push(p);
                }
            }
        }
    }
    await Promise.allSettled(promises);
}
const Source2ParticleLoader = new (function () {
    class Source2ParticleLoader {
        load(repository, path) {
            const promise = new Promise(resolve => {
                path = path.replace(/\.vpcf_c/, '');
                const vpcfPromise = new Source2FileLoader().load(repository, path + '.vpcf_c');
                vpcfPromise.then((source2File) => {
                    resolve(source2File);
                });
            });
            return promise;
        }
        async getSystem(repository, vpcf, snapshotModifiers) {
            const fileName = vpcf.fileName;
            const result = /[ \w-]+?(?=\.)/.exec(fileName);
            const system = new Source2ParticleSystem(repository, fileName, result ? result[0] : fileName);
            //const systemDefinition = vpcf.getBlockStruct('DATA', '');
            if (vpcf.getBlockStructAsString('DATA', '_class') == CParticleSystemDefinition) {
                initOperators(system, system.preEmissionOperators, vpcf.getBlockStructAsElementArray('DATA', 'm_PreEmissionOperators'));
                initOperators(system, system.emitters, vpcf.getBlockStructAsElementArray('DATA', 'm_Emitters'));
                initOperators(system, system.initializers, vpcf.getBlockStructAsElementArray('DATA', 'm_Initializers'));
                initOperators(system, system.operators, vpcf.getBlockStructAsElementArray('DATA', 'm_Operators'));
                initOperators(system, system.renderers, vpcf.getBlockStructAsElementArray('DATA', 'm_Renderers'));
                initOperators(system, system.forces, vpcf.getBlockStructAsElementArray('DATA', 'm_ForceGenerators'));
                initOperators(system, system.constraints, vpcf.getBlockStructAsElementArray('DATA', 'm_Constraints'));
                await initChildren(repository, system.childSystems, vpcf.getBlockStructAsElementArray('DATA', 'm_Children'), snapshotModifiers);
                const dataKv = vpcf.getBlockKeyValues('DATA');
                if (dataKv) {
                    initProperties(system, dataKv);
                }
            }
            await system.init(snapshotModifiers);
            return system;
        }
    }
    return Source2ParticleLoader;
}());
registerLoader('Source2ParticleLoader', Source2ParticleLoader);

const Source2TextureLoader = new (function () {
    class Source2TextureLoader {
        async load(repository, path) {
            path = path.replace(/\.vtex_c/, '');
            return await new Source2FileLoader(true).load(repository, path + '.vtex_c');
        }
    }
    return Source2TextureLoader;
}());

class Source2TextureManagerClass {
    #vtexList = new Map2();
    #texturesList = new Map();
    #loadingTexturesList = new Map();
    #defaultTexture;
    WEBGL_compressed_texture_s3tc;
    EXT_texture_compression_bptc;
    EXT_texture_compression_rgtc;
    constructor() {
        Graphics$1.ready.then(() => {
            this.#defaultTexture = TextureManager.createCheckerTexture(new Color(0.5, 0.75, 1));
            this.#defaultTexture.addUser(this);
            //this._missingTexture = TextureManager.createCheckerTexture();
            this.WEBGL_compressed_texture_s3tc = Graphics$1.getExtension('WEBGL_compressed_texture_s3tc');
            this.EXT_texture_compression_bptc = Graphics$1.getExtension('EXT_texture_compression_bptc');
            this.EXT_texture_compression_rgtc = Graphics$1.getExtension('EXT_texture_compression_rgtc');
        });
        setInterval(() => this.#cleanup(), TEXTURE_CLEANUP_DELAY);
    }
    async getTexture(repository, path, frame) {
        frame = Math.floor(frame);
        const texture = await this.#getTexture(repository, path);
        return texture ? texture.getFrame(frame) ?? null : this.#defaultTexture; //TODOv3
    }
    async getVtex(repository, path) {
        // TODO: fix that concurent calls of the same texture will load it multiple times
        let vtex = this.#vtexList.get(repository, path);
        if (vtex !== undefined) {
            return vtex;
        }
        vtex = await Source2TextureLoader.load(repository, path);
        if (vtex) {
            this.#vtexList.set(repository, path, vtex);
        }
        return vtex;
    }
    async getTextureSheet(repository, path) {
        const texture = await this.#getTexture(repository, path);
        return texture.properties.get('sprite_sheet') ?? null;
    }
    async #getTexture(repository, path) {
        path = path.replace(/\.vtex_c$/, '').replace(/\.vtex$/, '');
        path = path + '.vtex_c';
        const fullPath = repository + path;
        if (this.#loadingTexturesList.has(fullPath)) {
            await this.#loadingTexturesList.get(fullPath);
        }
        if (!this.#texturesList.has(fullPath)) {
            const animatedTexture = new AnimatedTexture();
            const promise = new Promise(async (resolve) => {
                const vtex = await this.getVtex(repository, path);
                animatedTexture.properties.set('vtex', vtex);
                const texture = TextureManager.createTexture(); //TODOv3: add params
                if (vtex) {
                    this.#initTexture(texture, vtex);
                    if (vtex.spriteSheet) {
                        animatedTexture.properties.set('sprite_sheet', vtex.spriteSheet);
                    }
                }
                animatedTexture.addFrame(0, texture);
                resolve(animatedTexture);
            });
            this.#loadingTexturesList.set(fullPath, promise);
            await promise;
            this.setTexture(fullPath, animatedTexture);
            this.#loadingTexturesList.delete(fullPath);
        }
        return this.#texturesList.get(fullPath);
    }
    setTexture(path, texture) {
        this.#texturesList.set(path, texture);
    }
    #initTexture(texture, vtexFile) {
        const imageData = vtexFile.blocks.DATA.imageData;
        const imageFormat = vtexFile.getImageFormat();
        if (imageData) {
            if (vtexFile.isCubeTexture()) {
                this.#initCubeTexture(texture.texture, imageFormat, vtexFile.getWidth(), vtexFile.getHeight(), imageData);
            }
            else {
                this.#initFlatTexture(texture.texture, imageFormat, vtexFile.getWidth(), vtexFile.getHeight(), imageData);
                /*if (imageFormat & TEXTURE_FORMAT_COMPRESSED_S3TC) {
                    this.fillTextureDxt(texture, vtexFile.getWidth(), vtexFile.getHeight(), vtexFile.getDxtLevel(), imageData[0]);
                } else {
                    this.fillTexture(texture, vtexFile.getWidth(), vtexFile.getHeight(), imageData[0]);
                }*/
            }
            //Graphics.glContext.bindTexture(GL_TEXTURE_2D, null);
        }
        if (vtexFile.decodeNormalizeNormals()) {
            texture.defines.set('NORMALIZE_NORMALS', 'NORMALIZE_NORMALS');
        }
    }
    #initCubeTexture(texture, imageFormat, width, height, imageData) {
        const glContext = Graphics$1.glContext;
        glContext.bindTexture(GL_TEXTURE_CUBE_MAP, texture);
        switch (formatCompression(imageFormat)) {
            case TextureCompressionMethod.Uncompressed:
                this.fillTexture(imageFormat, width, height, imageData[0], GL_TEXTURE_CUBE_MAP_POSITIVE_X);
                this.fillTexture(imageFormat, width, height, imageData[1], GL_TEXTURE_CUBE_MAP_NEGATIVE_X);
                this.fillTexture(imageFormat, width, height, imageData[2], GL_TEXTURE_CUBE_MAP_POSITIVE_Y);
                this.fillTexture(imageFormat, width, height, imageData[3], GL_TEXTURE_CUBE_MAP_NEGATIVE_Y);
                this.fillTexture(imageFormat, width, height, imageData[4], GL_TEXTURE_CUBE_MAP_POSITIVE_Z);
                this.fillTexture(imageFormat, width, height, imageData[5], GL_TEXTURE_CUBE_MAP_NEGATIVE_Z);
                break;
            case TextureCompressionMethod.St3c:
                this.fillTextureDxt(texture, imageFormat, width, height, imageData[0], GL_TEXTURE_CUBE_MAP_POSITIVE_X);
                this.fillTextureDxt(texture, imageFormat, width, height, imageData[1], GL_TEXTURE_CUBE_MAP_NEGATIVE_X);
                this.fillTextureDxt(texture, imageFormat, width, height, imageData[2], GL_TEXTURE_CUBE_MAP_POSITIVE_Y);
                this.fillTextureDxt(texture, imageFormat, width, height, imageData[3], GL_TEXTURE_CUBE_MAP_NEGATIVE_Y);
                this.fillTextureDxt(texture, imageFormat, width, height, imageData[4], GL_TEXTURE_CUBE_MAP_POSITIVE_Z);
                this.fillTextureDxt(texture, imageFormat, width, height, imageData[5], GL_TEXTURE_CUBE_MAP_NEGATIVE_Z);
                break;
            case TextureCompressionMethod.Bptc:
                throw 'TODO';
            case TextureCompressionMethod.Rgtc:
                throw 'TODO';
        }
        glContext.texParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glContext.texParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        //glContext.texParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, clampS ? GL_CLAMP_TO_EDGE : GL_REPEAT);
        //glContext.texParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, clampT ? GL_CLAMP_TO_EDGE : GL_REPEAT);
        glContext.bindTexture(GL_TEXTURE_CUBE_MAP, null);
    }
    #initFlatTexture(texture, imageFormat, width, height, imageData) {
        const glContext = Graphics$1.glContext;
        glContext.bindTexture(GL_TEXTURE_2D, texture);
        switch (formatCompression(imageFormat)) {
            case TextureCompressionMethod.Uncompressed:
                this.fillTexture(imageFormat, width, height, imageData[0], GL_TEXTURE_2D);
                break;
            case TextureCompressionMethod.St3c:
                this.fillTextureDxt(texture, imageFormat, width, height, imageData[0], GL_TEXTURE_2D);
                break;
            case TextureCompressionMethod.Bptc:
                this.#fillTextureBptc(texture, width, height, imageData[0]);
                break;
            case TextureCompressionMethod.Rgtc:
                this.#fillTextureRgtc(texture, width, height, imageData[0]);
                break;
        }
        //glContext.bindTexture(GL_TEXTURE_2D, texture);
        glContext.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glContext.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glContext.bindTexture(GL_TEXTURE_2D, null);
    }
    fillTexture(imageFormat, width, height, datas, target) {
        const gl = Graphics$1.glContext;
        gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, false);
        switch (imageFormat) {
            case ImageFormat.RGBA:
            case ImageFormat.BGRA8888:
                gl.texImage2D(target, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, datas); //TODO: params
                break;
            case ImageFormat.R8:
                gl.texImage2D(target, 0, GL_R8, width, height, 0, GL_RED, GL_UNSIGNED_BYTE, datas); //TODO: params
                break;
        }
        gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, false);
    }
    fillTextureDxt(texture, imageFormat, width, height, datas, target) {
        const gl = Graphics$1.glContext;
        const s3tc = this.WEBGL_compressed_texture_s3tc; //gl.getExtension("WEBGL_compressed_texture_s3tc");//TODO: store it
        gl.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        if (s3tc) {
            gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, true);
            let dxtFormat = 0;
            switch (imageFormat) {
                case ImageFormat.Bc1:
                    dxtFormat = s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    break;
                case ImageFormat.Bc2:
                    dxtFormat = s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    break;
                case ImageFormat.Bc3:
                    dxtFormat = s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                    break;
            }
            //gl.bindTexture(target, texture);
            gl.compressedTexImage2D(target, 0, dxtFormat, width, height, 0, datas);
        }
        else {
            /*gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, false);
            var dxtflag = dxtLevel == 1 ? (1 << 0) : (1 << 2);
            var uncompressedData = decompress(datas, width, height, dxtflag);
            gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, uncompressedData);//TODO: params*/
            gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, false);
            const uncompressedData = new Uint8Array(width * height * 4);
            Detex.decode(imageFormat, width, height, datas, uncompressedData).then(() => {
                // TODO: fix target in the 3 lines below
                gl.bindTexture(GL_TEXTURE_2D, texture);
                gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, uncompressedData); //TODO: params
                gl.bindTexture(GL_TEXTURE_2D, null);
            });
        }
        gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, false);
    }
    #fillTextureBptc(texture, width, height, datas) {
        const gl = Graphics$1.glContext;
        const bptc = this.EXT_texture_compression_bptc;
        gl.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        gl.bindTexture(GL_TEXTURE_2D, texture);
        if (bptc) {
            gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, true);
            const bptcFormat = bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT; //COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;
            gl.compressedTexImage2D(GL_TEXTURE_2D, 0, bptcFormat, width, height, 0, datas);
        }
        else {
            gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, false);
            const uncompressedData = new Uint8Array(width * height * 4);
            Detex.decodeBC7(width, height, datas, uncompressedData).then(() => {
                gl.bindTexture(GL_TEXTURE_2D, texture);
                gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, uncompressedData); //TODO: params
                gl.bindTexture(GL_TEXTURE_2D, null);
            });
        }
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        Graphics$1.getGLError('texParameteri');
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        Graphics$1.getGLError('texParameteri');
        //gl.texParameteri(GL_TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        //gl.texParameteri(GL_TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        //gl.bindTexture(GL_TEXTURE_2D, null);
        gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, false);
    }
    #fillTextureRgtc(texture, width, height, datas) {
        const gl = Graphics$1.glContext;
        const rgtc = this.EXT_texture_compression_rgtc;
        gl.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        gl.bindTexture(GL_TEXTURE_2D, texture);
        if (rgtc) {
            gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, true);
            const bptcFormat = rgtc.COMPRESSED_RED_RGTC1_EXT; //COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;
            gl.compressedTexImage2D(GL_TEXTURE_2D, 0, bptcFormat, width, height, 0, datas);
        }
        else {
            gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, false);
            const uncompressedData = new Uint8Array(width * height * 4);
            Detex.decodeBC4(width, height, datas, uncompressedData).then(() => {
                gl.bindTexture(GL_TEXTURE_2D, texture);
                gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, uncompressedData); //TODO: params
                gl.bindTexture(GL_TEXTURE_2D, null);
            });
        }
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        //gl.texParameteri(GL_TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        //gl.texParameteri(GL_TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, false);
    }
    #cleanup() {
        for (const [texturePath, texture] of this.#texturesList) {
            if (texture.hasOnlyUser(this)) {
                texture.removeUser(this);
                this.#texturesList.delete(texturePath);
            }
        }
    }
}
const Source2TextureManager = new Source2TextureManagerClass();

/**
 * DynamicExpression
 */
let stack;
const HASH_SEED = 0x31415926;
const hashes = new Map();
hashes.set(murmurhash2_32_gc('time', HASH_SEED), 'time');
function getAttribute(hash, renderAttributes) {
    let stringValue = hashes.get(hash);
    if (!stringValue) {
        for (let renderAttribute of renderAttributes) {
            renderAttribute = renderAttribute.toLowerCase();
            hashes.set(murmurhash2_32_gc(renderAttribute, HASH_SEED), renderAttribute);
        }
        stringValue = hashes.get(hash);
    }
    return stringValue;
}
function executeDynamicExpression(byteCode, renderAttributes) {
    let pointer = -1;
    const storage = new Map();
    stack = [];
    let storeAddress;
    let location;
    while (pointer < byteCode.length) {
        ++pointer;
        const opcode = byteCode[pointer];
        switch (opcode) {
            case 0: // stop
                return stack.pop();
            case 2: // goto
                location = getlocation(byteCode, pointer + 1);
                if ((location >= 0) && (location < byteCode.length)) {
                    pointer = location - 1;
                }
                else {
                    //TODO: error message
                    return;
                }
                break;
            case 4: // ?
                const conditionalValue = stack.pop();
                // Only the first value is tested
                location = conditionalValue[0] ? getlocation(byteCode, pointer + 1) : getlocation(byteCode, pointer + 3);
                if ((location >= 0) && (location < byteCode.length)) {
                    pointer = location - 1;
                }
                else {
                    //TODO: error message
                    return;
                }
                break;
            case 6: // function
                const functionCode = getlocation(byteCode, pointer + 1);
                if (functionCode >= 0) {
                    processFunction(functionCode);
                    pointer += 2;
                }
                else {
                    //TODO: error message
                    return;
                }
                break;
            case 7: // float32
                stack.push(getFloat32(byteCode, pointer + 1));
                pointer += 4;
                break;
            case 8: // save
                storeAddress = getByte(byteCode, pointer + 1);
                if (storeAddress >= 0) {
                    storage.set(storeAddress, stack.pop());
                    pointer += 1;
                }
                else {
                    //TODO: error message
                    return;
                }
                break;
            case 9: // restore
                storeAddress = getByte(byteCode, pointer + 1);
                if (storeAddress >= 0) {
                    stack.push(storage.get(storeAddress));
                    pointer += 1;
                }
                else {
                    //TODO: error message
                    return;
                }
                break;
            case 12:
                not();
                break;
            case 13: // ==
                equality();
                break;
            case 14: // !=
                inequality();
                break;
            case 15: // >
                greater();
                break;
            case 16: // >=
                greaterEqual();
                break;
            case 17: // <
                less();
                break;
            case 18: // <=
                lessEqual();
                break;
            case 19: // +
                add();
                break;
            case 20: // -
                subtract();
                break;
            case 21: // *
                multiply();
                break;
            case 22: // /
                divide();
                break;
            case 23: // %
                modulo();
                break;
            case 24: // negate
                negation();
                break;
            case 25: // get value
                const hash = (byteCode[pointer + 1] + (byteCode[pointer + 2] << 8) + (byteCode[pointer + 3] << 16) + (byteCode[pointer + 4] << 24)) >>> 0;
                let stringValue = getAttribute(hash, renderAttributes);
                if (stringValue) {
                    let value = 0;
                    if (stringValue === 'time') {
                        value = performance.now() * 0.001;
                    }
                    stack.push(vec4.fromValues(value, value, value, value));
                }
                pointer += 4;
                break;
            //see m_renderAttributesUsed
            //time : 0: 25 1: 204 2: 133 3: 68 4: 150 5: 0
            //$gemcolor: 0: 25 1: 230 2: 22 3: 70 4: 81 5: 0
            //a: 0: 25 1: 225 2: 113 3: 207 4: 30 5: 0
            //b: 0: 25 1: 42 2: 183 3: 253 4: 183 5: 0
            //B: 0: 25 1: 42 2: 183 3: 253 4: 183 5: 0
            //$a: 0: 25 1: 96 2: 46 3: 222 4: 5 5: 0
            //??? 0: 25 1: 252 2: 99 3: 114 4: 40 5: 0 ==> $PA_ARCANA_DETAIL1SCALE
            //$gem 0: 25 1: 150 2: 173 3: 217 4: 104 5: 0
            case 30:
                swizzle(getByte(byteCode, ++pointer));
                break;
            case 31: // exist
                stack.push(vec4.fromValues(0, 0, 0, 0)); //TODO get an external var
                pointer += 4;
                break;
        }
    }
}
function processFunction(functionCode) {
    let a, b, c, d;
    switch (functionCode) {
        case 0: // sin
            sin();
            break;
        case 1: // cos
            cos();
            break;
        case 2: // tan
            tan();
            break;
        case 3: // frac
            frac();
            break;
        case 4: // floor
            floor();
            break;
        case 5: // ceil
            ceil();
            break;
        case 6: // saturate
            saturate();
            break;
        case 7: // clamp
            a = stack.pop();
            b = stack.pop();
            c = stack.pop();
            a[0] = clamp$1(c[0], b[0], a[0]);
            a[1] = clamp$1(c[1], b[1], a[1]);
            a[2] = clamp$1(c[2], b[2], a[2]);
            a[3] = clamp$1(c[3], b[3], a[3]);
            stack.push(a);
            break;
        case 8: // lerp
            const factor = stack.pop();
            const second = stack.pop();
            const first = stack.pop();
            first[0] = first[0] + factor[0] * (second[0] - first[0]);
            first[1] = first[1] + factor[1] * (second[1] - first[1]);
            first[2] = first[2] + factor[2] * (second[2] - first[2]);
            first[3] = first[3] + factor[3] * (second[3] - first[3]);
            stack.push(first);
            break;
        case 9: // dot4
            dot4();
            break;
        case 10: // dot3
            dot3();
            break;
        case 11: // dot2
            dot2();
            break;
        case 12: // log
            log();
            break;
        case 13: // log2
            log2();
            break;
        case 14: // log10
            log10();
            break;
        case 15: // exp
            exp();
            break;
        case 16: // exp2
            exp2();
            break;
        case 17: // sqrt
            sqrt();
            break;
        case 18: // rsqrt
            rsqrt();
            break;
        case 19: // sign
            sign();
            break;
        case 20: // abs
            abs();
            break;
        case 21: // pow
            pow();
            break;
        case 22: // step
            step();
            break;
        case 23: // smoothstep
            smoothstep();
            break;
        case 24: // float4
            a = stack.pop();
            b = stack.pop();
            c = stack.pop();
            d = stack.pop();
            stack.push(vec4.fromValues(d[0], c[0], b[0], a[0]));
            break;
        case 25: // float3
            a = stack.pop();
            b = stack.pop();
            c = stack.pop();
            stack.push(vec4.fromValues(c[0], b[0], a[0], a[0]));
            break;
        case 26: // float2
            a = stack.pop();
            b = stack.pop();
            stack.push(vec4.fromValues(b[0], a[0], a[0], a[0]));
            break;
        case 27: // time
            const time = performance.now() * 0.001;
            stack.push(vec4.fromValues(time, time, time, time));
            break;
        case 28: // min
            min$1();
            break;
        case 29: // max
            max$1();
            break;
        case 30:
            SrgbLinearToGamma();
            break;
        case 31:
            SrgbGammaToLinear();
            break;
        case 32: // random
            random();
            break;
        case 33:
            normalize();
            break;
        case 34:
            length$1();
            break;
        case 35:
            sqr();
            break;
    }
}
function getByte(b, offset) {
    return (offset > b.length - 1) ? -1 : b[0 + offset];
}
function getFloat32(b, offset) {
    const sign = 1 - (2 * (b[3 + offset] >> 7)), exponent = (((b[3 + offset] << 1) & 0xff) | (b[2 + offset] >> 7)) - 127, mantissa = ((b[2 + offset] & 0x7f) << 16) | (b[1 + offset] << 8) | b[0 + offset];
    let ret;
    if (exponent === 128) {
        if (mantissa !== 0) {
            ret = NaN;
        }
        else {
            ret = sign * Infinity;
        }
    }
    else if (exponent === -127) { // Denormalized
        ret = sign * mantissa * pow2(-126 - 23);
    }
    else {
        ret = sign * (1 + mantissa * pow2(-23)) * pow2(exponent);
    }
    return vec4.fromValues(ret, ret, ret, ret);
}
function getlocation(b, offset) {
    return (offset > b.length - 2) ? -1 : (b[1 + offset] << 8) | b[0 + offset];
}
/*
function _saturate(value) {
    return Math.min(Math.max(value, 0), 1);
}
*/
function getRandomArbitrary(min, max) {
    return Math.random() * (max - min) + min;
}
function not() {
    const a = stack.pop();
    a[0] = Number(!a[0]);
    a[1] = Number(!a[1]);
    a[2] = Number(!a[2]);
    a[3] = Number(!a[3]);
    stack.push(a);
}
function equality() {
    const a = stack.pop();
    const b = stack.pop();
    a[0] = Number(b[0] == a[0]);
    a[1] = Number(b[1] == a[1]);
    a[2] = Number(b[2] == a[2]);
    a[3] = Number(b[3] == a[3]);
    stack.push(a);
}
function inequality() {
    const a = stack.pop();
    const b = stack.pop();
    a[0] = Number(b[0] != a[0]);
    a[1] = Number(b[1] != a[1]);
    a[2] = Number(b[2] != a[2]);
    a[3] = Number(b[3] != a[3]);
    stack.push(a);
}
function greater() {
    const a = stack.pop();
    const b = stack.pop();
    a[0] = Number(b[0] > a[0]);
    a[1] = Number(b[1] > a[1]);
    a[2] = Number(b[2] > a[2]);
    a[3] = Number(b[3] > a[3]);
    stack.push(a);
}
function greaterEqual() {
    const a = stack.pop();
    const b = stack.pop();
    a[0] = Number(b[0] >= a[0]);
    a[1] = Number(b[1] >= a[1]);
    a[2] = Number(b[2] >= a[2]);
    a[3] = Number(b[3] >= a[3]);
    stack.push(a);
}
function less() {
    const a = stack.pop();
    const b = stack.pop();
    a[0] = Number(b[0] < a[0]);
    a[1] = Number(b[1] < a[1]);
    a[2] = Number(b[2] < a[2]);
    a[3] = Number(b[3] < a[3]);
    stack.push(a);
}
function lessEqual() {
    const a = stack.pop();
    const b = stack.pop();
    a[0] = Number(b[0] <= a[0]);
    a[1] = Number(b[1] <= a[1]);
    a[2] = Number(b[2] <= a[2]);
    a[3] = Number(b[3] <= a[3]);
    stack.push(a);
}
function add() {
    const a = stack.pop();
    const b = stack.pop();
    a[0] = b[0] + a[0];
    a[1] = b[1] + a[1];
    a[2] = b[2] + a[2];
    a[3] = b[3] + a[3];
    stack.push(a);
}
function subtract() {
    const a = stack.pop();
    const b = stack.pop();
    a[0] = b[0] - a[0];
    a[1] = b[1] - a[1];
    a[2] = b[2] - a[2];
    a[3] = b[3] - a[3];
    stack.push(a);
}
function multiply() {
    const a = stack.pop();
    const b = stack.pop();
    a[0] = b[0] * a[0];
    a[1] = b[1] * a[1];
    a[2] = b[2] * a[2];
    a[3] = b[3] * a[3];
    stack.push(a);
}
function divide() {
    const a = stack.pop();
    const b = stack.pop();
    a[0] = b[0] / a[0];
    a[1] = b[1] / a[1];
    a[2] = b[2] / a[2];
    a[3] = b[3] / a[3];
    stack.push(a);
}
function modulo() {
    const a = stack.pop();
    const b = stack.pop();
    a[0] = b[0] % a[0];
    a[1] = b[1] % a[1];
    a[2] = b[2] % a[2];
    a[3] = b[3] % a[3];
    stack.push(a);
}
function negation() {
    const a = stack.pop();
    a[0] = -a[0];
    a[1] = -a[1];
    a[2] = -a[2];
    a[3] = -a[3];
    stack.push(a);
}
function swizzle(code) {
    const a = stack.pop();
    a[0] = a[(code >> 0) & 3];
    a[1] = a[(code >> 2) & 3];
    a[2] = a[(code >> 4) & 3];
    a[3] = a[(code >> 6) & 3];
    stack.push(a);
}
// Functions
function sin() {
    const a = stack.pop();
    a[0] = Math.sin(a[0]);
    a[1] = Math.sin(a[1]);
    a[2] = Math.sin(a[2]);
    a[3] = Math.sin(a[3]);
    stack.push(a);
}
function cos() {
    const a = stack.pop();
    a[0] = Math.cos(a[0]);
    a[1] = Math.cos(a[1]);
    a[2] = Math.cos(a[2]);
    a[3] = Math.cos(a[3]);
    stack.push(a);
}
function tan() {
    const a = stack.pop();
    a[0] = Math.tan(a[0]);
    a[1] = Math.tan(a[1]);
    a[2] = Math.tan(a[2]);
    a[3] = Math.tan(a[3]);
    stack.push(a);
}
function frac() {
    const a = stack.pop();
    a[0] = a[0] % 1;
    a[1] = a[1] % 1;
    a[2] = a[2] % 1;
    a[3] = a[3] % 1;
    stack.push(a);
}
function floor() {
    const a = stack.pop();
    a[0] = Math.floor(a[0]);
    a[1] = Math.floor(a[1]);
    a[2] = Math.floor(a[2]);
    a[3] = Math.floor(a[3]);
    stack.push(a);
}
function ceil() {
    const a = stack.pop();
    a[0] = Math.ceil(a[0]);
    a[1] = Math.ceil(a[1]);
    a[2] = Math.ceil(a[2]);
    a[3] = Math.ceil(a[3]);
    stack.push(a);
}
function saturate() {
    const a = stack.pop();
    a[0] = clamp$1(a[0], 0, 1);
    a[1] = clamp$1(a[1], 0, 1);
    a[2] = clamp$1(a[2], 0, 1);
    a[3] = clamp$1(a[3], 0, 1);
    stack.push(a);
}
function dot4() {
    const a = stack.pop();
    const b = stack.pop();
    a[0] = a[1] = a[2] = a[3] = a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
    stack.push(a);
}
function dot3() {
    const a = stack.pop();
    const b = stack.pop();
    a[0] = a[1] = a[2] = a[3] = a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    stack.push(a);
}
function dot2() {
    const a = stack.pop();
    const b = stack.pop();
    a[0] = a[1] = a[2] = a[3] = a[0] * b[0] + a[1] * b[1];
    stack.push(a);
}
function log() {
    const a = stack.pop();
    a[0] = Math.log(a[0]);
    a[1] = Math.log(a[1]);
    a[2] = Math.log(a[2]);
    a[3] = Math.log(a[3]);
    stack.push(a);
}
function log2() {
    const a = stack.pop();
    a[0] = Math.log2(a[0]);
    a[1] = Math.log2(a[1]);
    a[2] = Math.log2(a[2]);
    a[3] = Math.log2(a[3]);
    stack.push(a);
}
function log10() {
    const a = stack.pop();
    a[0] = Math.log10(a[0]);
    a[1] = Math.log10(a[1]);
    a[2] = Math.log10(a[2]);
    a[3] = Math.log10(a[3]);
    stack.push(a);
}
function exp() {
    const a = stack.pop();
    a[0] = Math.exp(a[0]);
    a[1] = Math.exp(a[1]);
    a[2] = Math.exp(a[2]);
    a[3] = Math.exp(a[3]);
    stack.push(a);
}
function exp2() {
    const a = stack.pop();
    a[0] = 2 ** a[0];
    a[1] = 2 ** a[1];
    a[2] = 2 ** a[2];
    a[3] = 2 ** a[3];
    stack.push(a);
}
function sqrt() {
    const a = stack.pop();
    a[0] = Math.sqrt(a[0]);
    a[1] = Math.sqrt(a[1]);
    a[2] = Math.sqrt(a[2]);
    a[3] = Math.sqrt(a[3]);
    stack.push(a);
}
function rsqrt() {
    const a = stack.pop();
    a[0] = 1 / Math.sqrt(a[0]);
    a[1] = 1 / Math.sqrt(a[1]);
    a[2] = 1 / Math.sqrt(a[2]);
    a[3] = 1 / Math.sqrt(a[3]);
    stack.push(a);
}
function sign() {
    const a = stack.pop();
    a[0] = Math.sign(a[0]);
    a[1] = Math.sign(a[1]);
    a[2] = Math.sign(a[2]);
    a[3] = Math.sign(a[3]);
    stack.push(a);
}
function abs() {
    const a = stack.pop();
    a[0] = Math.abs(a[0]);
    a[1] = Math.abs(a[1]);
    a[2] = Math.abs(a[2]);
    a[3] = Math.abs(a[3]);
    stack.push(a);
}
function pow() {
    const a = stack.pop();
    const b = stack.pop();
    a[0] = b[0] ** a[0];
    a[1] = b[1] ** a[1];
    a[2] = b[2] ** a[2];
    a[3] = b[3] ** a[3];
    stack.push(a);
}
function step() {
    const a = stack.pop();
    const b = stack.pop();
    a[0] = b[0] >= a[0] ? 1 : 0;
    a[1] = b[1] >= a[1] ? 1 : 0;
    a[2] = b[2] >= a[2] ? 1 : 0;
    a[3] = b[3] >= a[3] ? 1 : 0;
    stack.push(a);
}
function _smoothstep(min, max, x) {
    x = clamp$1((x - min) / (max - min), 0.0, 1.0);
    return x * x * (3 - 2 * x);
}
function smoothstep() {
    const x = stack.pop();
    const max = stack.pop();
    const min = stack.pop();
    x[0] = _smoothstep(min[0], max[0], x[0]);
    x[1] = _smoothstep(min[1], max[1], x[1]);
    x[2] = _smoothstep(min[2], max[2], x[2]);
    x[3] = _smoothstep(min[3], max[3], x[3]);
    stack.push(x);
}
function min$1() {
    const a = stack.pop();
    const b = stack.pop();
    a[0] = Math.min(b[0], a[0]);
    a[1] = Math.min(b[1], a[1]);
    a[2] = Math.min(b[2], a[2]);
    a[3] = Math.min(b[3], a[3]);
    stack.push(a);
}
function max$1() {
    const a = stack.pop();
    const b = stack.pop();
    a[0] = Math.max(b[0], a[0]);
    a[1] = Math.max(b[1], a[1]);
    a[2] = Math.max(b[2], a[2]);
    a[3] = Math.max(b[3], a[3]);
    stack.push(a);
}
function SrgbLinearToGamma() {
    const a = stack.pop();
    //saturate
    a[0] = Math.min(Math.max(a[0], 0), 1);
    a[1] = Math.min(Math.max(a[1], 0), 1);
    a[2] = Math.min(Math.max(a[2], 0), 1);
    a[3] = Math.min(Math.max(a[3], 0), 1);
    a[0] = (a[0] <= 0.0031308) ? (a[0] * 12.92) : (1.055 * Math.pow(a[0], (1.0 / 2.4))) - 0.055;
    a[1] = (a[1] <= 0.0031308) ? (a[1] * 12.92) : (1.055 * Math.pow(a[1], (1.0 / 2.4))) - 0.055;
    a[2] = (a[2] <= 0.0031308) ? (a[2] * 12.92) : (1.055 * Math.pow(a[2], (1.0 / 2.4))) - 0.055;
    a[3] = (a[3] <= 0.0031308) ? (a[3] * 12.92) : (1.055 * Math.pow(a[3], (1.0 / 2.4))) - 0.055;
    stack.push(a);
}
function SrgbGammaToLinear() {
    const a = stack.pop();
    //saturate
    a[0] = Math.min(Math.max(a[0], 0), 1);
    a[1] = Math.min(Math.max(a[1], 0), 1);
    a[2] = Math.min(Math.max(a[2], 0), 1);
    a[3] = Math.min(Math.max(a[3], 0), 1);
    a[0] = (a[0] <= 0.04045) ? (a[0] / 12.92) : (Math.pow((a[0] + 0.055) / 1.055, 2.4));
    a[1] = (a[1] <= 0.04045) ? (a[1] / 12.92) : (Math.pow((a[1] + 0.055) / 1.055, 2.4));
    a[2] = (a[2] <= 0.04045) ? (a[2] / 12.92) : (Math.pow((a[2] + 0.055) / 1.055, 2.4));
    a[3] = (a[3] <= 0.04045) ? (a[3] / 12.92) : (Math.pow((a[3] + 0.055) / 1.055, 2.4));
    stack.push(a);
}
function random() {
    const a = stack.pop();
    const b = stack.pop();
    a[0] = getRandomArbitrary(b[0], a[0]);
    a[1] = getRandomArbitrary(b[1], a[1]);
    a[2] = getRandomArbitrary(b[2], a[2]);
    a[3] = getRandomArbitrary(b[3], a[3]);
    stack.push(a);
}
function normalize() {
    const a = stack.pop();
    vec4.normalize(a, a);
    stack.push(a);
}
function length$1() {
    const a = stack.pop();
    a[0] = a[1] = a[2] = a[3] = Math.hypot(a[0], a[1], a[2]);
    stack.push(a);
}
function sqr() {
    const a = stack.pop();
    a[0] = a[0] * a[0];
    a[1] = a[1] * a[1];
    a[2] = a[2] * a[2];
    a[3] = a[3] * a[3];
    stack.push(a);
}
var FunctionCode;
(function (FunctionCode) {
    FunctionCode[FunctionCode["Sin"] = 0] = "Sin";
    FunctionCode[FunctionCode["Cos"] = 1] = "Cos";
    FunctionCode[FunctionCode["Tan"] = 2] = "Tan";
    FunctionCode[FunctionCode["Frac"] = 3] = "Frac";
    FunctionCode[FunctionCode["Floor"] = 4] = "Floor";
    FunctionCode[FunctionCode["Ceil"] = 5] = "Ceil";
    FunctionCode[FunctionCode["Saturate"] = 6] = "Saturate";
    FunctionCode[FunctionCode["Clamp"] = 7] = "Clamp";
    FunctionCode[FunctionCode["Lerp"] = 8] = "Lerp";
    FunctionCode[FunctionCode["Dot4"] = 9] = "Dot4";
    FunctionCode[FunctionCode["Dot3"] = 10] = "Dot3";
    FunctionCode[FunctionCode["Dot2"] = 11] = "Dot2";
    FunctionCode[FunctionCode["Log"] = 12] = "Log";
    FunctionCode[FunctionCode["Log2"] = 13] = "Log2";
    FunctionCode[FunctionCode["Log10"] = 14] = "Log10";
    FunctionCode[FunctionCode["Exp"] = 15] = "Exp";
    FunctionCode[FunctionCode["Exp2"] = 16] = "Exp2";
    FunctionCode[FunctionCode["Sqrt"] = 17] = "Sqrt";
    FunctionCode[FunctionCode["Rsqrt"] = 18] = "Rsqrt";
    FunctionCode[FunctionCode["Sign"] = 19] = "Sign";
    FunctionCode[FunctionCode["Abs"] = 20] = "Abs";
    FunctionCode[FunctionCode["Pow"] = 21] = "Pow";
    FunctionCode[FunctionCode["Step"] = 22] = "Step";
    FunctionCode[FunctionCode["Smoothstep"] = 23] = "Smoothstep";
    FunctionCode[FunctionCode["Float4"] = 24] = "Float4";
    FunctionCode[FunctionCode["Float3"] = 25] = "Float3";
    FunctionCode[FunctionCode["Float2"] = 26] = "Float2";
    FunctionCode[FunctionCode["Time"] = 27] = "Time";
    FunctionCode[FunctionCode["Min"] = 28] = "Min";
    FunctionCode[FunctionCode["Max"] = 29] = "Max";
    FunctionCode[FunctionCode["SrgbLinearToGamma"] = 30] = "SrgbLinearToGamma";
    FunctionCode[FunctionCode["SrgbGammaToLinear"] = 31] = "SrgbGammaToLinear";
    FunctionCode[FunctionCode["Random"] = 32] = "Random";
    FunctionCode[FunctionCode["Normalize"] = 33] = "Normalize";
    FunctionCode[FunctionCode["Length"] = 34] = "Length";
    FunctionCode[FunctionCode["Sqr"] = 35] = "Sqr";
    FunctionCode[FunctionCode["TextureSize"] = 36] = "TextureSize";
})(FunctionCode || (FunctionCode = {}));
var OpCode;
(function (OpCode) {
    OpCode[OpCode["Return"] = 0] = "Return";
    // 1 ?
    OpCode[OpCode["Goto"] = 2] = "Goto";
    // 3 ?
    OpCode[OpCode["Ternary"] = 4] = "Ternary";
    // 5 ?
    OpCode[OpCode["Function"] = 6] = "Function";
    OpCode[OpCode["Float32"] = 7] = "Float32";
    OpCode[OpCode["StoreVariable"] = 8] = "StoreVariable";
    OpCode[OpCode["LoadVariable"] = 9] = "LoadVariable";
    // 10 ?
    // 11 ?
    OpCode[OpCode["Not"] = 12] = "Not";
    OpCode[OpCode["Equal"] = 13] = "Equal";
    OpCode[OpCode["NotEqual"] = 14] = "NotEqual";
    OpCode[OpCode["Greater"] = 15] = "Greater";
    OpCode[OpCode["GreaterEqual"] = 16] = "GreaterEqual";
    OpCode[OpCode["Less"] = 17] = "Less";
    OpCode[OpCode["LessEqual"] = 18] = "LessEqual";
    OpCode[OpCode["Addition"] = 19] = "Addition";
    OpCode[OpCode["Subtraction"] = 20] = "Subtraction";
    OpCode[OpCode["Multiplication"] = 21] = "Multiplication";
    OpCode[OpCode["Division"] = 22] = "Division";
    OpCode[OpCode["Modulo"] = 23] = "Modulo";
    OpCode[OpCode["Negation"] = 24] = "Negation";
    OpCode[OpCode["AttributeLiteral"] = 25] = "AttributeLiteral";
    OpCode[OpCode["Swizzle"] = 30] = "Swizzle";
    OpCode[OpCode["Exists"] = 31] = "Exists";
})(OpCode || (OpCode = {}));
function decompileDynamicExpression(dynamicName, byteCode, renderAttributes) {
    const operand = toOperation(byteCode, renderAttributes);
    if (operand) {
        //console.error(dynamicName, );
        return operandsToString(operand) ?? null;
    }
    return null;
}
function toOperation(byteCode, renderAttributes, startPointer = 0, operandStack = []) {
    let pointer = startPointer - 1;
    //const operandStack: Operand[] = [];
    while (pointer < byteCode.length) {
        ++pointer;
        const opcode = byteCode[pointer];
        switch (opcode) {
            case OpCode.Return:
                operandStack.push({ operator: opcode, operand1: operandStack.pop() });
                return operandStack;
            case OpCode.Goto:
                const branch = toOperation(byteCode, renderAttributes, getlocation(byteCode, pointer + 1), operandStack);
                return branch;
            case OpCode.Ternary:
                const conditionalValue = operandStack.pop();
                const branch1 = toOperation(byteCode, renderAttributes, getlocation(byteCode, pointer + 1));
                const branch2 = toOperation(byteCode, renderAttributes, getlocation(byteCode, pointer + 3));
                if (branch1 && branch2) {
                    operandStack.push({ operator: opcode, operand1: conditionalValue, branch1: branch1, branch2: branch2 });
                }
                else {
                    console.error('missing branch at', pointer, byteCode);
                }
                pointer = Infinity; // Stop
                break;
            case OpCode.Function:
                const operand = functionToOperation(getlocation(byteCode, pointer + 1), operandStack);
                if (operand) {
                    operandStack.push(operand);
                }
                pointer += 2;
                break;
            case OpCode.Float32:
                operandStack.push(getFloat32(byteCode, pointer + 1)[0]); // getFloat32 returns a vec4, but we only need a scalar
                pointer += 4;
                break;
            case OpCode.StoreVariable:
            case OpCode.Swizzle:
                operandStack.push({ operator: opcode, operand1: getByte(byteCode, pointer + 1), operand2: operandStack.pop() });
                ++pointer;
                break;
            case OpCode.LoadVariable:
                operandStack.push({ operator: opcode, operand1: getByte(byteCode, pointer + 1) });
                ++pointer;
                break;
            // Unary operators
            case OpCode.Not:
            case OpCode.Negation:
                operandStack.push({ operator: opcode, operand1: operandStack.pop() });
                break;
            case OpCode.Equal:
            case OpCode.NotEqual:
            case OpCode.Greater:
            case OpCode.GreaterEqual:
            case OpCode.Less:
            case OpCode.LessEqual:
            case OpCode.Addition:
            case OpCode.Subtraction:
            case OpCode.Multiplication:
            case OpCode.Division:
            case OpCode.Modulo:
                operandStack.push({ operator: opcode, operand2: operandStack.pop(), operand1: operandStack.pop() });
                break;
            case OpCode.AttributeLiteral:
            case OpCode.Exists:
                const hash = (byteCode[pointer + 1] + (byteCode[pointer + 2] << 8) + (byteCode[pointer + 3] << 16) + (byteCode[pointer + 4] << 24)) >>> 0;
                pointer += 4;
                let stringValue = getAttribute(hash, renderAttributes);
                operandStack.push({ operator: opcode, operand1: stringValue });
                break;
            default:
                console.error('Unknown opcode ', opcode, ' at location ', pointer);
                break;
        }
    }
    if (operandStack.length) {
        return operandStack;
    }
    return null;
}
const functions = new Map([
    [FunctionCode.Sin, [1, 'sin']],
    [FunctionCode.Cos, [1, 'cos']],
    [FunctionCode.Tan, [1, 'tan']],
    [FunctionCode.Frac, [1, 'frac']],
    [FunctionCode.Floor, [1, 'floor']],
    [FunctionCode.Ceil, [1, 'ceil']],
    [FunctionCode.Saturate, [1, 'saturate']],
    [FunctionCode.Clamp, [3, 'clamp']],
    [FunctionCode.Lerp, [3, 'lerp']],
    [FunctionCode.Dot4, [2, 'dot4']],
    [FunctionCode.Dot3, [2, 'dot3']],
    [FunctionCode.Dot2, [2, 'dot2']],
    [FunctionCode.Log, [1, 'log']],
    [FunctionCode.Log2, [1, 'log2']],
    [FunctionCode.Log10, [1, 'log10']],
    [FunctionCode.Exp, [1, 'exp']],
    [FunctionCode.Exp2, [1, 'exp2']],
    [FunctionCode.Sqrt, [1, 'sqrt']],
    [FunctionCode.Rsqrt, [1, 'rsqrt']],
    [FunctionCode.Sign, [1, 'sign']],
    [FunctionCode.Abs, [1, 'abs']],
    [FunctionCode.Pow, [2, 'pow']],
    [FunctionCode.Step, [2, 'step']],
    [FunctionCode.Smoothstep, [3, 'smoothstep']],
    [FunctionCode.Float4, [4, 'float4']],
    [FunctionCode.Float3, [3, 'float3']],
    [FunctionCode.Float2, [2, 'float2']],
    [FunctionCode.Time, [0, 'time']],
    [FunctionCode.Min, [2, 'min']],
    [FunctionCode.Max, [2, 'max']],
    [FunctionCode.SrgbLinearToGamma, [1, 'SrgbLinearToGamma']],
    [FunctionCode.SrgbGammaToLinear, [1, 'SrgbGammaToLinear']],
    [FunctionCode.Random, [2, 'random']],
    [FunctionCode.Normalize, [1, 'normalize']],
    [FunctionCode.Length, [1, 'length']],
    [FunctionCode.Sqr, [1, 'sqr']],
    [FunctionCode.TextureSize, [1, 'TextureSize']],
]);
function functionToOperation(functionCode, operandStack) {
    const params = functions.get(functionCode);
    if (params === undefined) {
        console.error('undefined function' + functionCode);
        return null;
    }
    const operand = { operator: OpCode.Function, function: functionCode };
    if (params[0] > 3) {
        operand.operand4 = operandStack.pop();
    }
    if (params[0] > 2) {
        operand.operand3 = operandStack.pop();
    }
    if (params[0] > 1) {
        operand.operand2 = operandStack.pop();
    }
    if (params[0] > 0) {
        operand.operand1 = operandStack.pop();
    }
    return operand;
}
var Precedence;
(function (Precedence) {
    Precedence[Precedence["Lowest"] = 0] = "Lowest";
    Precedence[Precedence["Ternary"] = 1] = "Ternary";
    Precedence[Precedence["Additive"] = 2] = "Additive";
    Precedence[Precedence["Multiplicative"] = 3] = "Multiplicative";
    Precedence[Precedence["Function"] = 4] = "Function";
    Precedence[Precedence["Literal"] = 5] = "Literal";
})(Precedence || (Precedence = {}));
const operations = new Map();
operations.set(OpCode.Return, { operator: 'return ', precedence: Precedence.Lowest, operands: 1 });
operations.set(OpCode.Goto, { operator: 'goto', precedence: Precedence.Lowest, operands: 0 });
operations.set(OpCode.Ternary, { operator: '', precedence: Precedence.Ternary, operands: 1 /*not counting branches*/ });
operations.set(OpCode.StoreVariable, { operator: '', precedence: Precedence.Lowest, operands: 2 });
operations.set(OpCode.LoadVariable, { operator: '', precedence: Precedence.Literal, operands: 1 });
operations.set(OpCode.Not, { operator: '!', precedence: Precedence.Additive, operands: 1 });
operations.set(OpCode.Equal, { operator: '==', precedence: Precedence.Additive, operands: 2 });
operations.set(OpCode.NotEqual, { operator: '!=', precedence: Precedence.Additive, operands: 2 });
operations.set(OpCode.Greater, { operator: '>', precedence: Precedence.Additive, operands: 2 });
operations.set(OpCode.GreaterEqual, { operator: '>=', precedence: Precedence.Additive, operands: 2 });
operations.set(OpCode.Less, { operator: '<', precedence: Precedence.Additive, operands: 2 });
operations.set(OpCode.LessEqual, { operator: '<=', precedence: Precedence.Additive, operands: 2 });
operations.set(OpCode.Addition, { operator: '+', precedence: Precedence.Additive, operands: 2 });
operations.set(OpCode.Subtraction, { operator: '-', precedence: Precedence.Additive, operands: 2 });
operations.set(OpCode.Multiplication, { operator: '*', precedence: Precedence.Additive, operands: 2 });
operations.set(OpCode.Division, { operator: '/', precedence: Precedence.Additive, operands: 2 });
operations.set(OpCode.Modulo, { operator: '%', precedence: Precedence.Additive, operands: 2 });
operations.set(OpCode.Negation, { operator: '-', precedence: Precedence.Literal, operands: 1 });
operations.set(OpCode.AttributeLiteral, { operator: '', precedence: Precedence.Literal, operands: 1 });
operations.set(OpCode.Swizzle, { operator: '', precedence: Precedence.Function, operands: 2 });
operations.set(OpCode.Exists, { operator: '', precedence: Precedence.Function, operands: 1 });
function operandsToString(operands) {
    if (operands.length == 0) {
        return null;
    }
    let result = '';
    for (const [i, operand] of operands.entries()) {
        const opeResult = operandToString(operand);
        if (!opeResult) {
            return null;
        }
        result += opeResult[0];
        if (i < operands.length - 1) {
            result += '\n';
        }
    }
    return result;
}
function toSwizzle(code) {
    const s = 'xyzw';
    return `.${s[(code >> 0) & 3]}${s[(code >> 2) & 3]}${s[(code >> 4) & 3]}${s[(code >> 6) & 3]}`;
}
function operandToString(operand) {
    if (typeof operand == 'number') {
        return [String(smartRound(operand)), Precedence.Literal];
    }
    if (typeof operand == 'string') {
        return [operand, Precedence.Literal];
    }
    if (operand.operator == OpCode.Function) {
        const f = functionToString(operand);
        if (f) {
            return [f, Precedence.Function];
        }
        else {
            return null;
        }
    }
    const ope = operations.get(operand.operator);
    if (!ope) {
        console.error('Unknown operator ', operand.operator);
        return null;
    }
    const opes = [];
    for (let i = 0; i < ope.operands; i++) {
        let operandN;
        switch (i) { // TODO: improve that code
            case 0:
                operandN = operand.operand1;
                break;
            case 1:
                operandN = operand.operand2;
                break;
            case 2:
                operandN = operand.operand3;
                break;
            case 3:
                operandN = operand.operand4;
                break;
        }
        if (operandN !== undefined) {
            const o = operandToString(operandN);
            if (o) {
                let oo = o?.[0];
                if (o?.[1] < ope.precedence) {
                    oo = `(${oo})`;
                }
                opes.push(oo);
            }
            else {
                console.error('no operand ' + i, operand);
            }
        }
        else {
            console.error('missing an operand ' + i, operand);
        }
    }
    switch (operand.operator) {
        case OpCode.Goto:
            return [`${operandsToString(operand.branch1)}`, ope.precedence];
        case OpCode.Ternary:
            return [`${opes[0]} ? ${operandsToString(operand.branch1)} : ${operandsToString(operand.branch2)}`, ope.precedence];
        case OpCode.StoreVariable:
            return [`var${opes[0]} = ${opes[1]}`, ope.precedence];
        case OpCode.LoadVariable:
            return [`var${opes[0]}`, ope.precedence];
        case OpCode.Swizzle:
            return [`${opes[1]}${toSwizzle(Number(opes[0]))}`, ope.precedence];
        case OpCode.Exists:
            return [`exists(${ope.operator}${opes[0]})`, ope.precedence];
    }
    switch (ope.operands) {
        case 0:
            return [`${ope.operator}${opes[0]}`, ope.precedence];
        case 1:
            return [`${ope.operator}${opes[0]}`, ope.precedence];
        case 2:
            return [`${opes[0]} ${ope.operator} ${opes[1]}`, ope.precedence];
        case 3:
            return [`${opes[0]} ${ope.operator} ${opes[1]}`, ope.precedence];
    }
}
function functionToString(operand) {
    let operands = [];
    /*
    let operand2: string | undefined;
    let operand3: string | undefined;
    let operand4: string | undefined;
    */
    const params = functions.get(operand.function);
    if (params === undefined) {
        console.error('undefined function' + operand.function);
        return null;
    }
    if (operand.operand1 !== undefined) {
        operands[0] = operandToString(operand.operand1)?.[0];
    }
    if (operand.operand2 !== undefined) {
        operands[1] = operandToString(operand.operand2)?.[0];
    }
    if (operand.operand3 !== undefined) {
        operands[2] = operandToString(operand.operand3)?.[0];
    }
    if (operand.operand4 !== undefined) {
        operands[3] = operandToString(operand.operand4)?.[0];
    }
    let p = '';
    for (let i = 0; i < params[0]; i++) {
        const opeI = operands[i];
        if (opeI === undefined) {
            console.error(`Missing param ${i} for function ${params[1]}`);
            return null;
        }
        const ope = operandToString(opeI)?.[0];
        if (ope) {
            p += ope;
            if (i < params[0] - 1) {
                p += ', ';
            }
        }
    }
    return `${params[1]}( ${p} )`;
}

const UNIFORMS = new Map([
    ['g_vColorTint', 'g_vColorTint'],
    ['g_vEmissiveColor', 'g_vEmissiveColor'],
    ['g_tColor', 'colorMap'],
    ['g_tAmbientOcclusion', 'g_tAmbientOcclusion'],
    ['g_tColorA', 'g_tColorA'],
    ['g_tColorB', 'g_tColorB'],
    ['g_tColorC', 'g_tColorC'],
    //['g_tDetail', 'detailMap'],
    //['g_tDetail2', 'detail2Map'],
    ['g_tMasks', 'g_tMasks'],
    ['g_tNormalA', 'g_tNormalA'],
    ['g_tEmissiveB', 'g_tEmissiveB'],
    ['g_tEmissiveC', 'g_tEmissiveC'],
    ['g_flDetailBlendFactor', 'g_flDetailBlendFactor'],
    ['g_flMaterialCloakFactor', 'g_flMaterialCloakFactor'],
]);
const TEXTURE_UNIFORMS = new Map([
    ['g_tColor', ['colorMap', 'USE_COLOR_MAP']],
    ['TextureColor', ['colorMap', 'USE_COLOR_MAP']],
    ['g_tNormal', ['normalMap', 'USE_NORMAL_MAP']],
    ['g_tAmbientOcclusion', ['aoMap', 'USE_AO_MAP']],
    ['g_tTintColor', ['tintColorMap', 'USE_TINT_COLOR_MAP']],
    ['g_tSelfIllumFlowWaveform', ['selfIllumFlowWaveformMap', 'USE_SIFW_MAP']],
    ['g_tMaskParameters', ['maskParametersMap', 'USE_MASK_PARAMETERS_MAP']], //TextureSelfIllumMask
    ['g_tColorA', ['colorAMap', 'USE_COLOR_A_MAP']],
    ['g_tColorB', ['colorBMap', 'USE_COLOR_B_MAP']],
    ['g_tColorC', ['colorCMap', 'USE_COLOR_C_MAP']],
    ['g_tColor1', ['color1Map', 'USE_COLOR_1_MAP']],
    ['g_tMask', ['maskMap', 'USE_MASK_MAP']],
    ['g_tNormalA', ['normalAMap', 'USE_NORMAL_A_MAP']],
    ['g_tEmissiveB', ['emissiveBMap', 'USE_EMISSIVE_B_MAP']],
    ['g_tEmissiveC', ['emissiveCMap', 'USE_EMISSIVE_C_MAP']],
    ['g_tMasks1', ['mask1Map', 'USE_MASK1_MAP']],
    ['g_tMasks2', ['mask2Map', 'USE_MASK2_MAP']],
    ['g_tDetail', ['detail1Map', 'USE_DETAIL1_MAP']],
    ['g_tDetail2', ['detail2Map', 'USE_DETAIL2_MAP']],
    ['g_tMetalness', ['metalnessMap', 'USE_METALNESS_MAP']],
    ['g_tDisplacementMask', ['displacementMaskMap', 'USE_DISPLACEMENT_MASK_MAP']],
    ['g_tSpecular', ['specularMap', 'USE_SPECULAR_MAP']],
    ['g_tSpiralNormal', ['spiralNormalMap', 'USE_SPIRAL_NORMAL_MAP']],
    ['g_tSpiralOverlay', ['spiralOverlayMap', 'USE_SPIRAL_OVERLAY_MAP']],
    ['g_tCubeMap', ['cubeMap', 'USE_CUBE_MAP']],
    ['g_tNormalRoughness', ['normalMap', 'USE_NORMAL_MAP']],
    ['g_tTintMaskEdgeMask', ['tintMaskEdgeMaskMap', 'USE_TINT_MASK_EDGE_MASK_MAP']],
    ['g_tSelfIllumMask', ['selfIllumMaskMap', 'USE_SELF_ILLUM_MASK_MAP']],
    //g_tAnimationTexture
]);
const DEFAULT_ALPHA_TEST_REFERENCE = 0.7;
class Source2Material extends Material {
    #source2File;
    repository;
    #detailTexCoordOffset = vec4.create();
    #detailTexCoordScale = vec4.create();
    shader;
    constructor(repository, shader, source2File) {
        super();
        this.repository = repository;
        this.shader = shader;
        this.#source2File = source2File;
        this.#setupUniforms();
        this.setupUniformsOnce();
    }
    setupUniformsOnce() {
        //TODO: F_RENDER_BACKFACES
        //F_DO_NOT_CAST_SHADOWS
        //F_MASKS_1
        //
        //---- Specular ----
        //F_MASK_CUBE_MAP_BY_METALNESS 1
        //F_SPECULAR_CUBE_MAP 1
        /*

        0: {m_name: "F_RENDER_BACKFACES", _name: "MaterialParamInt_t", m_nValue: 1}
        1: {m_name: "F_USE_STATUS_EFFECTS_PROXY", _name: "MaterialParamInt_t", m_nValue: 1}
        2: {m_name: "F_MASKS_1", _name: "MaterialParamInt_t", m_nValue: 1}
        3: {m_name: "F_MASKS_2", _name: "MaterialParamInt_t", m_nValue: 1}
        4: {m_name: "F_MORPH_SUPPORTED", _name: "MaterialParamInt_t", m_nValue: 1}
        5: {m_name: "F_SEPARATE_ALPHA_TRANSFORM", _name: "MaterialParamInt_t", m_nValue: 1}
        6: {m_name: "F_SEPARATE_NORMAL_TRANSFORM", _name: "MaterialParamInt_t", m_nValue: 1}
        7: {m_name: "F_ALPHA_TEST", _name: "MaterialParamInt_t", m_nValue: 1}
        8: {m_name: "F_DIFFUSE_WARP", _name: "MaterialParamInt_t", m_nValue: 1}
        */
        if (this.getIntParam('F_RENDER_BACKFACES')) {
            this.renderFace(RenderFace.Both);
        }
        if (this.getIntParam('F_TRANSLUCENT')) {
            this.setBlending(MATERIAL_BLENDING_NORMAL);
            this.setDefine('IS_TRANSLUCENT');
        }
        if (this.getIntParam('F_MASKS_1')) {
            this.setDefine('USE_MASK1_MAP');
        }
        if (this.getIntParam('F_MASKS_2')) {
            this.setDefine('USE_MASK2_MAP');
        }
        if (this.getIntParam('F_ENABLE_CLOAK')) {
            this.setDefine('ENABLE_CLOAK');
        }
        if (this.getIntParam('F_ADDITIVE_BLEND')) {
            this.setBlending(MATERIAL_BLENDING_ADDITIVE);
            this.setDefine('IS_TRANSLUCENT');
        }
        if (this.getIntParam('F_ALPHA_TEST') == 1) {
            this.setDefine('ALPHA_TEST'); //TODOv3: set this automaticaly
            this.uniforms['uAlphaTestReference'] = this.#getParam('g_flAlphaTestReference') ?? DEFAULT_ALPHA_TEST_REFERENCE;
        }
        if (this.getIntParam('F_SEPARATE_ALPHA_TRANSFORM')) {
            this.setDefine('USE_SEPARATE_ALPHA_TRANSFORM');
        }
        if (this.getIntParam('F_SEPARATE_NORMAL_TRANSFORM')) {
            this.setDefine('USE_SEPARATE_NORMAL_TRANSFORM');
        }
        const detailBlendMode = this.getIntParam('F_DETAIL');
        if (detailBlendMode != null) {
            this.setDefine('DETAIL_BLEND_MODE', String(detailBlendMode));
        }
        else {
            this.removeDefine('DETAIL_BLEND_MODE');
        }
        if (this.getIntParam('F_SELF_ILLUM') == 1) {
            this.setDefine('F_SELF_ILLUM');
        }
        this.uniforms['g_vDetailTexCoordOffset'] = this.getVectorParam('g_vDetailTexCoordOffset', this.#detailTexCoordOffset) ?? this.#detailTexCoordOffset;
        this.uniforms['g_vDetailTexCoordScale'] = this.getVectorParam('g_vDetailTexCoordScale', this.#detailTexCoordScale) ?? this.#detailTexCoordScale;
        this.uniforms['g_vDetail1ColorTint'] = vec4.fromValues(1, 1, 1, 1);
        this.uniforms['g_vDetail2ColorTint'] = vec4.fromValues(1, 1, 1, 1);
        this.uniforms['g_vColorTint'] = vec4.fromValues(1, 1, 1, 0);
        this.initFloatUniforms();
        this.initVectorUniforms();
        //this.initTextureUniforms();
        /*
        0: {m_name: "g_flDetailBlendToFull", _name: "MaterialParamFloat_t", m_flValue: 0}
        1: {m_name: "g_flEnvMapBlendToFull", _name: "MaterialParamFloat_t", m_flValue: 0}
        2: {m_name: "g_flMetalnessBlendToFull", _name: "MaterialParamFloat_t", m_flValue: 0}
        3: {m_name: "g_flReflectionsTintByBaseBlendToNone", _name: "MaterialParamFloat_t", m_flValue: 0}
        4: {m_name: "g_flSelfIllumBlendToFull", _name: "MaterialParamFloat_t", m_flValue: 0}
        5: {m_name: "g_flSpecularBlendToFull", _name: "MaterialParamFloat_t", m_flValue: 0}
        6: {m_name: "g_flSpecularExponentBlendToFull", _name: "MaterialParamFloat_t", m_flValue: 0}
        7: {m_name: "g_flCloakBlurAmount", _name: "MaterialParamFloat_t", m_flValue: 0.004999999888241291}
        8: {m_name: "g_flCloakIntensity", _name: "MaterialParamFloat_t", m_flValue: 0.8500000238418579}
        9: {m_name: "g_flCloakRefractAmount", _name: "MaterialParamFloat_t", m_flValue: 0.10000000149011612}
        10: {m_name: "g_flMaterialCloakFactor", _name: "MaterialParamFloat_t", m_flValue: 0}
        11: {m_name: "g_flDiffuseModulationAmount", _name: "MaterialParamFloat_t", m_flValue: 1}
        12: {m_name: "g_flTexCoordRotation", _name: "MaterialParamFloat_t", m_flValue: 0}
        13: {m_name: "g_flDetailBlendFactor", _name: "MaterialParamFloat_t", m_flValue: 1}
        14: {m_name: "g_flDetailTexCoordRotation", _name: "MaterialParamFloat_t", m_flValue: 0}
        15: {m_name: "g_flDetail2BlendFactor", _name: "MaterialParamFloat_t", m_flValue: 0}
        16: {m_name: "g_flFresnelModulatesAlpha", _name: "MaterialParamFloat_t", m_flValue: 0}
        17: {m_name: "g_flAmbientScale", _name: "MaterialParamFloat_t", m_flValue: 1}
        18: {m_name: "g_flBloomScale", _name: "MaterialParamFloat_t", m_flValue: 0}
        19: {m_name: "g_flBloomShift", _name: "MaterialParamFloat_t", m_flValue: 0}
        20: {m_name: "g_flRimLightScale", _name: "MaterialParamFloat_t", m_flValue: 5}
        21: {m_name: "g_flCubeMapScalar", _name: "MaterialParamFloat_t", m_flValue: 5}
        22: {m_name: "g_flSpecularExponent", _name: "MaterialParamFloat_t", m_flValue: 15}
        23: {m_name: "g_flSpecularScale", _name: "MaterialParamFloat_t", m_flValue: 5}
        24: {m_name: "g_flAlphaTestReference", _name: "MaterialParamFloat_t", m_flValue: 0.5}
        */
    }
    #setupUniforms() {
        for (const [paramName, uniformName] of UNIFORMS) {
            //console.error(uniformName);
            const paramValue = this.#getParam(paramName);
            if (paramValue) {
                this.setUniform(uniformName, paramValue);
            }
        }
    }
    clone() {
        return new this.constructor(this.repository, this.shader, this.#source2File);
    }
    getTextureParam(textureName) {
        if (this.#source2File) {
            //TODO: use getMaterialResourceData()
            const textures = this.#source2File.getBlockStructAsElementArray('DATA', 'MaterialResourceData_t.m_textureParams') ?? this.#source2File.getBlockStructAsElementArray('DATA', 'm_textureParams');
            if (textures) {
                for (const texture of textures) {
                    if (texture.getValueAsString('m_name') == textureName) {
                        return texture.getValueAsResource('m_pValue');
                    }
                }
            }
        }
        return null;
    }
    updateMaterial(time, mesh) {
        this.#processProxies(time, mesh.materialsParams);
    }
    #processProxies(time, proxyParams) {
        //todov3//rename function
        /*let proxies = this.proxies;
        for (let proxyIndex = 0, l = proxies.length; proxyIndex < l; ++proxyIndex) {
            proxies[proxyIndex].execute(this.variables, this.proxyParams, time);
        }*/
        this._afterProcessProxies(proxyParams);
        this.afterProcessProxies(proxyParams);
    }
    _afterProcessProxies(proxyParams) {
        //this.setupUniforms();
        this.initTextureUniforms(); //TODO : do this only once
        /*
                let g_tMasks1 = this.getTextureByName('g_tMasks1');
                if (g_tMasks1) {
                    this.uniforms['mask1Map'] = Source2TextureManager.getTexture(this.repository, g_tMasks1, 0);//TODOv3: rename uniform
                }

                let g_tMasks2 = this.getTextureByName('g_tMasks2');
                if (g_tMasks2) {
                    this.uniforms['mask2Map'] = Source2TextureManager.getTexture(this.repository, g_tMasks2, 0);//TODOv3: rename uniform
                }

                let g_tDetail = this.getTextureByName('g_tDetail');
                if (g_tDetail) {
                    this.uniforms['detail1Map'] = Source2TextureManager.getTexture(this.repository, g_tDetail, 0);//TODOv3: rename uniform
                    this.setDefine('USE_DETAIL1_MAP');//TODOv3: set this automaticaly
                } else {
                    //this.uniforms['detail1Map'] = TextureManager.createCheckerTexture();
                    this.setDefine('USE_DETAIL1_MAP', false);//TODOv3: set this automaticaly
                }

                let g_tDetail2 = this.getTextureByName('g_tDetail2');
                if (g_tDetail2) {
                    this.uniforms['detail2Map'] = Source2TextureManager.getTexture(this.repository, g_tDetail2, 0);//TODOv3: rename uniform
                    this.setDefine('USE_DETAIL2_MAP');//TODOv3: set this automaticaly
                } else {
                    this.setDefine('USE_DETAIL2_MAP', false);//TODOv3: set this automaticaly
                }*/
        //TODO: only do what is in m_dynamicParams
        this.setDynamicUniform('g_vDetailTexCoordOffset');
        this.setDynamicUniform('g_vDetailTexCoordScale');
        this.setDynamicUniform('g_vAlphaTexCoordOffset');
        this.setDynamicUniform('g_flDetailBlendFactor');
        this.setDynamicUniform('g_flDetailTexCoordRotation');
        this.setDynamicUniform('g_vDetail1ColorTint');
        this.setDynamicUniform('g_vSpecularColor');
        //this.setDynamicUniform('g_vNormalTexCoordOffset');
    }
    setDynamicUniform(uniformName) {
        const value = this.getDynamicParam(uniformName);
        if (value) {
            if (uniformName.startsWith('g_fl')) {
                this.uniforms[uniformName] = value[0];
            }
            else {
                this.uniforms[uniformName] = value;
            }
        }
    }
    afterProcessProxies(proxyParams) {
    }
    setUniform(uniformName, uniformValue) {
        this.uniforms[uniformName] = uniformValue;
    }
    initFloatUniforms() {
        if (this.#source2File) {
            const floats = this.#source2File.getMaterialResourceData('m_floatParams');
            if (floats) {
                for (const fl of floats) {
                    const name = fl.getValueAsString('m_name');
                    const value = fl.getValueAsNumber('m_flValue');
                    if (name !== null && value !== null) {
                        this.setUniform(name, value);
                    }
                }
            }
        }
    }
    initVectorUniforms() {
        if (this.#source2File) {
            const vectors = this.#source2File.getMaterialResourceData('m_vectorParams');
            if (vectors) {
                for (const vector of vectors) {
                    const name = vector.getValueAsString('m_name');
                    const value = vector.getValueAsVec4('m_value', vec4.create());
                    if (name !== null && value !== null) {
                        this.setUniform(name, value);
                    }
                }
            }
        }
    }
    getUniforms() {
        return [UNIFORMS];
    }
    getTextureUniforms() {
        return [TEXTURE_UNIFORMS];
    }
    async initTextureUniforms() {
        for (const map of this.getTextureUniforms()) {
            for (const [paramName, [uniformName, defineName]] of map) {
                const paramValue = this.getTextureParam(paramName);
                if (paramValue) {
                    const texture = await Source2TextureManager.getTexture(this.repository, paramValue, 0);
                    this.setTexture(uniformName, texture, defineName);
                    if (texture) {
                        for (const [name, define] of texture.defines) {
                            this.defines[name] = define;
                        }
                    }
                }
            }
        }
    }
    #getParam(paramName) {
        if (paramName.startsWith('g_f')) {
            return this.getFloatParam(paramName);
        }
        else if (paramName.startsWith('g_v')) {
            return this.getVectorParam(paramName, vec4.create() /*TODO: optimize*/);
        }
        else if (paramName.startsWith('g_n')) {
            return this.getIntParam(paramName);
        } /* else if (paramName.startsWith('g_t')) {
            let textureName = this.getTextureByName(paramName);
            if (textureName) {
                return Source2TextureManager.getTexture(this.repository, textureName, 0);
            } else {
                return null;//TODO: disable texture;
            }
        }*/
        return null;
    }
    #getParams(name, isFloat, isVector, isResource) {
        if (!this.#source2File) {
            return null;
        }
        const values = this.#source2File.getBlockStructAsElementArray('DATA', 'MaterialResourceData_t.' + name) ?? this.#source2File.getBlockStructAsElementArray('DATA', name);
        if (!values) {
            return null;
        }
        const result = new Map();
        for (const v of values) {
            const name = v.getSubValueAsString('m_name');
            const value = isFloat ? v.getSubValueAsNumber('m_flValue') : isVector ? v.getSubValueAsVec4('m_value', vec4.create()) : isResource ? v.getSubValueAsResource('m_pValue') : v.getSubValueAsNumber('m_nValue');
            if (name && value != null) {
                result.set(name, value);
            }
        }
        return result;
    }
    getIntParam(intName) {
        if (!this.#source2File) {
            return null;
        }
        const ints = this.#source2File.getBlockStructAsElementArray('DATA', 'MaterialResourceData_t.m_intParams') ?? this.#source2File.getBlockStructAsElementArray('DATA', 'm_intParams');
        if (ints) {
            for (const int of ints) {
                if (int.getSubValueAsString('m_name') == intName) {
                    return int.getSubValueAsNumber('m_nValue');
                }
            }
        }
        return null;
    }
    getIntParams() {
        return this.#getParams('m_intParams', false, false, false);
    }
    getFloatParam(floatName) {
        if (!this.#source2File) {
            return null;
        }
        const floats = this.#source2File.getBlockStructAsElementArray('DATA', 'MaterialResourceData_t.m_floatParams') ?? this.#source2File.getBlockStructAsElementArray('DATA', 'm_floatParams');
        if (floats) {
            for (const fl of floats) {
                if (fl.getSubValueAsString('m_name') == floatName) {
                    return fl.getSubValueAsNumber('m_flValue');
                }
            }
        }
        return null;
    }
    getFloatParams() {
        return this.#getParams('m_floatParams', true, false, false);
    }
    getVectorParam(vectorName, out) {
        if (this.#source2File) {
            const vectors = this.#source2File.getBlockStructAsElementArray('DATA', 'MaterialResourceData_t.m_vectorParams') ?? this.#source2File.getBlockStructAsElementArray('DATA', 'm_vectorParams');
            if (vectors) {
                for (const vector of vectors) {
                    if (vector.getSubValueAsString('m_name') == vectorName) {
                        vector.getSubValueAsVec4('m_value', out);
                        return out;
                    }
                }
            }
        }
        return null;
    }
    getVectorParams() {
        return this.#getParams('m_vectorParams', false, true, false);
    }
    #getDynamicParam(name) {
        const dynamicParams = this.#source2File.getBlockStructAsElementArray('DATA', 'MaterialResourceData_t.m_dynamicParams') ?? this.#source2File.getBlockStructAsElementArray('DATA', 'm_dynamicParams'); // || this.#source2File.getBlockStruct('DATA.keyValue.root.m_dynamicParams');
        if (!dynamicParams) {
            return null;
        }
        for (const dynamicParam of dynamicParams) {
            if (dynamicParam.getSubValueAsString('m_name') == name) {
                const bytes = dynamicParam.getSubValueAsUint8Array('m_value');
                if (bytes) {
                    return bytes;
                }
            }
        }
        return null;
    }
    getDynamicParam(name) {
        if (!this.#source2File) {
            return null;
        }
        const bytes = this.#getDynamicParam(name);
        if (bytes) {
            return executeDynamicExpression(bytes, this.#source2File.getBlockStructAsStringArray('DATA', 'MaterialResourceData_t.m_renderAttributesUsed') ?? this.#source2File.getBlockStructAsStringArray('DATA', 'm_renderAttributesUsed') ?? []) ?? null;
        }
        return null;
    }
    getDecompiledDynamicParam(name) {
        if (!this.#source2File) {
            return null;
        }
        const bytes = this.#getDynamicParam(name);
        if (bytes) {
            return [decompileDynamicExpression(this.#source2File.fileName + ':' + name, bytes, this.#source2File.getBlockStructAsStringArray('DATA', 'MaterialResourceData_t.m_renderAttributesUsed') ?? this.#source2File.getBlockStructAsStringArray('DATA', 'm_renderAttributesUsed') ?? []), bytes];
        }
        return null;
    }
    getDynamicParams() {
        if (!this.#source2File) {
            return null;
        }
        const values = this.#source2File.getBlockStructAsElementArray('DATA', 'MaterialResourceData_t.m_dynamicParams') ?? this.#source2File.getBlockStructAsElementArray('DATA', 'm_dynamicParams');
        if (!values) {
            return null;
        }
        const result = new Map();
        for (const v of values) {
            const name = v.getSubValueAsString('m_name');
            const value = v.getSubValueAsUint8Array('m_value');
            if (name && value != null) {
                result.set(name, [decompileDynamicExpression(this.#source2File.fileName + ':' + name, value, this.#source2File.getBlockStructAsStringArray('DATA', 'MaterialResourceData_t.m_renderAttributesUsed') ?? this.#source2File.getBlockStructAsStringArray('DATA', 'm_renderAttributesUsed') ?? []), value]);
            }
        }
        return result;
    }
    getTextureParams() {
        return this.#getParams('m_textureParams', false, false, true);
    }
}

class Source2CablesMaterial extends Source2Material {
    get shaderSource() {
        return 'source2_cables';
    }
}
Source2MaterialLoader.registerMaterial('cables.vfx', Source2CablesMaterial);

//materials/colorwarps/dota_reef_dead.vmat_c
class Source2ColorCorrection extends Source2Material {
    get shaderSource() {
        return 'source2_color_correction';
    }
}
Source2MaterialLoader.registerMaterial('colorcorrection.vfx', Source2ColorCorrection);

// deadlock/core materials/grass/grasstile.vmat_c
class Source2GrassTile extends Source2Material {
    get shaderSource() {
        return 'source2_sky'; // TODO: create shader
    }
}
Source2MaterialLoader.registerMaterial('grasstile.vfx', Source2GrassTile);

// materials/models/items/venomancer/mechamancer/mechamancer_fluid.vmat_c
// materials/models/items/pudge/pudge_hungry_clown_car/pudge_hungry_clown_car_fluid.vmat_c
// materials/models/items/lion/lion_dungeon_poacher_shoulder/lion_dungeon_poacher_shoulder_jar.vmat_c
class Source2LiquidFx extends Source2Material {
    get shaderSource() {
        return 'source2_liquid_fx';
    }
}
Source2MaterialLoader.registerMaterial('liquid_fx.vfx', Source2LiquidFx);

// deadlock/core materials/panorama/panorama.vmat_c
class Source2Panorama extends Source2Material {
    get shaderSource() {
        return 'source2_sky'; // TODO: create shader
    }
}
Source2MaterialLoader.registerMaterial('panorama.vfx', Source2Panorama);

// deadlock/core materials/panorama/panorama_fancyquad.vmat_c
class Source2PanoramaFancyQuad extends Source2Material {
    get shaderSource() {
        return 'source2_sky'; // TODO: create shader
    }
}
Source2MaterialLoader.registerMaterial('panorama_fancyquad.vfx', Source2PanoramaFancyQuad);

// deadlock/core materials/physics/flat_basic.vmat_c
class Source2PhyscisWireframe extends Source2Material {
    get shaderSource() {
        return 'source2_sky'; // TODO: create shader
    }
}
Source2MaterialLoader.registerMaterial('physics_wireframe.vfx', Source2PhyscisWireframe);

class Source2RefractMaterial extends Source2Material {
    get shaderSource() {
        return 'source2_refract';
    }
}
Source2MaterialLoader.registerMaterial('refract.vfx', Source2RefractMaterial);

//materials/skybox/dota_secretshop_interior.vmat_c
class Source2Sky extends Source2Material {
    get shaderSource() {
        return 'source2_sky';
    }
}
Source2MaterialLoader.registerMaterial('sky.vfx', Source2Sky);

class Source2CsgoCharacter extends Source2Material {
    get shaderSource() {
        return 'source2_hero'; //TODO: code proper shader
    }
}
Source2MaterialLoader.registerMaterial('csgo_character.vfx', Source2CsgoCharacter);

class Source2CsgoComplex extends Source2Material {
    get shaderSource() {
        return 'source2_hero'; //TODO: code proper shader
    }
}
Source2MaterialLoader.registerMaterial('csgo_complex.vfx', Source2CsgoComplex);

class Source2CsgoEffects extends Source2Material {
    get shaderSource() {
        return 'source2_hero'; //TODO: code proper shader
    }
}
Source2MaterialLoader.registerMaterial('csgo_effects.vfx', Source2CsgoEffects);

class Source2CsgoEnvironmentBlend extends Source2Material {
    get shaderSource() {
        return 'source2_csgo_environment';
    }
}
Source2MaterialLoader.registerMaterial('csgo_environment_blend.vfx', Source2CsgoEnvironmentBlend);

class Source2CsgoEnvironment extends Source2Material {
    get shaderSource() {
        return 'source2_csgo_environment';
    }
}
Source2MaterialLoader.registerMaterial('csgo_environment.vfx', Source2CsgoEnvironment);

class Source2CsgoFoliage extends Source2Material {
    get shaderSource() {
        return 'source2_vr_xen_foliage'; //TODO: code proper shader
    }
}
Source2MaterialLoader.registerMaterial('csgo_foliage.vfx', Source2CsgoFoliage);

class Source2CsgoGlass extends Source2Material {
    get shaderSource() {
        return 'source2_vr_simple'; //TODO: code proper shader
    }
}
Source2MaterialLoader.registerMaterial('csgo_glass.vfx', Source2CsgoGlass);

class Source2CsgoSimple extends Source2Material {
    get shaderSource() {
        return 'source2_vr_simple'; //TODO: code proper shader
    }
}
Source2MaterialLoader.registerMaterial('csgo_simple.vfx', Source2CsgoSimple);

class Source2CsgoStaticOverlay extends Source2Material {
    get shaderSource() {
        return 'source2_hero'; //TODO: code proper shader
    }
}
Source2MaterialLoader.registerMaterial('csgo_static_overlay.vfx', Source2CsgoStaticOverlay);

class Source2CsgoUnlitGeneric extends Source2Material {
    get shaderSource() {
        return 'source2_hero'; //TODO: code proper shader
    }
}
Source2MaterialLoader.registerMaterial('csgo_unlitgeneric.vfx', Source2CsgoUnlitGeneric);

class Source2CsgoVertexLitGeneric extends Source2Material {
    get shaderSource() {
        return 'source2_hero'; //TODO: code proper shader
    }
}
Source2MaterialLoader.registerMaterial('csgo_vertexlitgeneric.vfx', Source2CsgoVertexLitGeneric);

class Source2CsgoWeaponStattrak extends Source2Material {
    _afterProcessProxies(proxyParams) {
        //Proxy param: $ent_stattrak
        super._afterProcessProxies(proxyParams);
        this.setDynamicUniform('g_nStatTrakValue');
    }
    get shaderSource() {
        return 'source2_csgo_weapon_stattrak';
    }
}
Source2MaterialLoader.registerMaterial('csgo_weapon_stattrak.vfx', Source2CsgoWeaponStattrak);

const STICKER_COUNT = 5;
class WeaponSticker {
    sticker = '';
    holoSpectrum = '';
    normalRoughness = '';
    sfxMask = '';
}
class Source2CsgoWeapon extends Source2Material {
    setupUniformsOnce() {
        super.setupUniformsOnce();
        if (this.getIntParam('F_STICKERS')) {
            this.setDefine('ENABLE_STICKERS');
        }
        for (let i = 0; i < STICKER_COUNT; i++) {
            //if (this.getIntParam(`g_bEnableSticker${i}`)) {
            this.setDefine(`ENABLE_STICKER${i}`);
            //}
        }
    }
    getUniforms() {
        const uniforms = super.getUniforms();
        const m = new Map();
        for (let i = 0; i < STICKER_COUNT; i++) {
            m.set(`g_flSticker${i}Rotation`, `g_flSticker${i}Rotation`);
            m.set(`g_flSticker${i}Wear`, `g_flSticker${i}Wear`);
            m.set(`g_fWearScratchesSticker${i}`, `g_fWearScratchesSticker${i}`);
            m.set(`g_vSticker${i}Offset`, `g_vSticker${i}Offset`);
            m.set(`g_vSticker${i}Scale`, `g_vSticker${i}Scale`);
            m.set(`g_vWearBiasSticker${i}`, `g_vWearBiasSticker${i}`);
        }
        uniforms.push(m);
        return uniforms;
    }
    getTextureUniforms() {
        const uniforms = super.getTextureUniforms();
        const m = new Map();
        for (let i = 0; i < STICKER_COUNT; i++) {
            m.set(`g_tHoloSpectrumSticker${i}`, [`holoSpectrumSticker${i}Map`, `USE_HOLO_SPECTRUM_STICKER${i}_MAP`]);
            m.set(`g_tNormalRoughnessSticker${i}`, [`normalRoughnessSticker${i}Map`, `USE_NORMAL_ROUGHNESS_STICKER${i}_MAP`]);
            m.set(`g_tSfxMaskSticker${i}`, [`sfxMaskSticker${i}Map`, `USE_SFX_MASK_STICKER${i}_MAP`]);
            m.set(`g_tSticker${i}`, [`sticker${i}Map`, `USE_STICKER${i}_MAP`]);
        }
        m.set('g_tStickerWepInputs', [`stickerWepInputsMap`, `USE_STICKER_WEP_INPUT_MAP`]);
        uniforms.push(m);
        return uniforms;
    }
    get shaderSource() {
        return 'source2_csgo_weapon';
    }
}
Source2MaterialLoader.registerMaterial('csgo_weapon.vfx', Source2CsgoWeapon);
/*
{
    "m_materialName": "materials/models/weapons/v_models/rif_ak47/ak47.vmat",
    "m_shaderName": "csgo_weapon.vfx",
    "m_intParams": [
        {
            "m_name": "F_STICKERS",
            "m_nValue": 1
        },
        {
            "m_name": "g_bEnableSticker0",
            "m_nValue": 0
        },
        {
            "m_name": "g_bEnableSticker1",
            "m_nValue": 0
        },
        {
            "m_name": "g_bEnableSticker2",
            "m_nValue": 0
        },
        {
            "m_name": "g_bEnableSticker3",
            "m_nValue": 0
        },
        {
            "m_name": "g_bEnableSticker4",
            "m_nValue": 0
        },
        {
            "m_name": "g_bFogEnabled",
            "m_nValue": 1
        },
        {
            "m_name": "g_nScaleTexCoordUByModelScaleAxis",
            "m_nValue": 0
        },
        {
            "m_name": "g_nScaleTexCoordVByModelScaleAxis",
            "m_nValue": 0
        },
        {
            "m_name": "g_nTextureAddressModeU",
            "m_nValue": 0
        },
        {
            "m_name": "g_nTextureAddressModeV",
            "m_nValue": 0
        }
    ],
    "m_floatParams": [
        {
            "m_name": "g_flMetalnessTransitionBias",
            "m_flValue": 2
        },
        {
            "m_name": "g_flModelTintAmount",
            "m_flValue": 1
        },
        {
            "m_name": "g_flSticker0Rotation",
            "m_flValue": 0
        },
        {
            "m_name": "g_flSticker0Wear",
            "m_flValue": 0
        },
        {
            "m_name": "g_flSticker1Rotation",
            "m_flValue": 0
        },
        {
            "m_name": "g_flSticker1Wear",
            "m_flValue": 0
        },
        {
            "m_name": "g_flSticker2Rotation",
            "m_flValue": 0
        },
        {
            "m_name": "g_flSticker2Wear",
            "m_flValue": 0
        },
        {
            "m_name": "g_flSticker3Rotation",
            "m_flValue": 0
        },
        {
            "m_name": "g_flSticker3Wear",
            "m_flValue": 0
        },
        {
            "m_name": "g_flSticker4Rotation",
            "m_flValue": 0
        },
        {
            "m_name": "g_flSticker4Wear",
            "m_flValue": 0
        },
        {
            "m_name": "g_flTexCoordRotation",
            "m_flValue": 0
        },
        {
            "m_name": "g_fWearScratchesSticker0",
            "m_flValue": 1
        },
        {
            "m_name": "g_fWearScratchesSticker1",
            "m_flValue": 1
        },
        {
            "m_name": "g_fWearScratchesSticker2",
            "m_flValue": 1
        },
        {
            "m_name": "g_fWearScratchesSticker3",
            "m_flValue": 1
        },
        {
            "m_name": "g_fWearScratchesSticker4",
            "m_flValue": 1
        }
    ],
    "m_vectorParams": [
        {
            "m_name": "g_vColorTint",
            "m_value": [
                1,
                1,
                1,
                0
            ]
        },
        {
            "m_name": "g_vMetalnessRemapRange",
            "m_value": [
                0,
                1,
                0,
                0
            ]
        },
        {
            "m_name": "g_vSticker0Offset",
            "m_value": [
                0.15399999916553497,
                -0.43799999356269836,
                0,
                0
            ]
        },
        {
            "m_name": "g_vSticker0Scale",
            "m_value": [
                15.350000381469727,
                15.350000381469727,
                0,
                0
            ]
        },
        {
            "m_name": "g_vSticker1Offset",
            "m_value": [
                0.06499999761581421,
                -0.4320000112056732,
                0,
                0
            ]
        },
        {
            "m_name": "g_vSticker1Scale",
            "m_value": [
                15.350000381469727,
                15.350000381469727,
                0,
                0
            ]
        },
        {
            "m_name": "g_vSticker2Offset",
            "m_value": [
                -0.03200000151991844,
                -0.43799999356269836,
                0,
                0
            ]
        },
        {
            "m_name": "g_vSticker2Scale",
            "m_value": [
                15.350000381469727,
                15.350000381469727,
                0,
                0
            ]
        },
        {
            "m_name": "g_vSticker3Offset",
            "m_value": [
                -0.164000004529953,
                -0.4440000057220459,
                0,
                0
            ]
        },
        {
            "m_name": "g_vSticker3Scale",
            "m_value": [
                15.350000381469727,
                15.350000381469727,
                0,
                0
            ]
        },
        {
            "m_name": "g_vSticker4Offset",
            "m_value": [
                0,
                0,
                0,
                0
            ]
        },
        {
            "m_name": "g_vSticker4Scale",
            "m_value": [
                0,
                0,
                0,
                0
            ]
        },
        {
            "m_name": "g_vTexCoordCenter",
            "m_value": [
                0.5,
                0.5,
                0,
                0
            ]
        },
        {
            "m_name": "g_vTexCoordOffset",
            "m_value": [
                0,
                0,
                0,
                0
            ]
        },
        {
            "m_name": "g_vTexCoordScale",
            "m_value": [
                1,
                1,
                0,
                0
            ]
        },
        {
            "m_name": "g_vTexCoordScrollSpeed",
            "m_value": [
                0,
                0,
                0,
                0
            ]
        },
        {
            "m_name": "g_vWearBiasSticker0",
            "m_value": [
                1,
                1,
                0,
                0
            ]
        },
        {
            "m_name": "g_vWearBiasSticker1",
            "m_value": [
                1,
                1,
                0,
                0
            ]
        },
        {
            "m_name": "g_vWearBiasSticker2",
            "m_value": [
                1,
                1,
                0,
                0
            ]
        },
        {
            "m_name": "g_vWearBiasSticker3",
            "m_value": [
                1,
                1,
                0,
                0
            ]
        },
        {
            "m_name": "g_vWearBiasSticker4",
            "m_value": [
                1,
                1,
                0,
                0
            ]
        }
    ],
    "m_textureParams": [
        {
            "m_name": "g_tAmbientOcclusion",
            "m_pValue": "materials/models/weapons/v_models/rif_ak47/ak47_ao_psd_286fb1af.vtex"
        },
        {
            "m_name": "g_tColor",
            "m_pValue": "materials/models/weapons/v_models/rif_ak47/ak47_color_psd_1f318532.vtex"
        },
        {
            "m_name": "g_tHoloSpectrumSticker0",
            "m_pValue": "materials/default/stickers/default_holospectrum_tga_e12c79bd.vtex"
        },
        {
            "m_name": "g_tHoloSpectrumSticker1",
            "m_pValue": "materials/default/stickers/default_holospectrum_tga_e12c79bd.vtex"
        },
        {
            "m_name": "g_tHoloSpectrumSticker2",
            "m_pValue": "materials/default/stickers/default_holospectrum_tga_e12c79bd.vtex"
        },
        {
            "m_name": "g_tHoloSpectrumSticker3",
            "m_pValue": "materials/default/stickers/default_holospectrum_tga_e12c79bd.vtex"
        },
        {
            "m_name": "g_tHoloSpectrumSticker4",
            "m_pValue": "materials/default/stickers/default_holospectrum_tga_e12c79bd.vtex"
        },
        {
            "m_name": "g_tMetalness",
            "m_pValue": "materials/models/weapons/v_models/rif_ak47/ak47_rough_psd_73589151.vtex"
        },
        {
            "m_name": "g_tNormal",
            "m_pValue": "materials/models/weapons/v_models/rif_ak47/ak47_normal_psd_57f37ac9.vtex"
        },
        {
            "m_name": "g_tNormalRoughnessSticker0",
            "m_pValue": "materials/default/default_normal_tga_4c6e7391.vtex"
        },
        {
            "m_name": "g_tNormalRoughnessSticker1",
            "m_pValue": "materials/default/default_normal_tga_4c6e7391.vtex"
        },
        {
            "m_name": "g_tNormalRoughnessSticker2",
            "m_pValue": "materials/default/default_normal_tga_4c6e7391.vtex"
        },
        {
            "m_name": "g_tNormalRoughnessSticker3",
            "m_pValue": "materials/default/default_normal_tga_4c6e7391.vtex"
        },
        {
            "m_name": "g_tNormalRoughnessSticker4",
            "m_pValue": "materials/default/default_normal_tga_4c6e7391.vtex"
        },
        {
            "m_name": "g_tSfxMaskSticker0",
            "m_pValue": "materials/default/stickers/default_holomask_tga_daef1ed1.vtex"
        },
        {
            "m_name": "g_tSfxMaskSticker1",
            "m_pValue": "materials/default/stickers/default_holomask_tga_daef1ed1.vtex"
        },
        {
            "m_name": "g_tSfxMaskSticker2",
            "m_pValue": "materials/default/stickers/default_holomask_tga_daef1ed1.vtex"
        },
        {
            "m_name": "g_tSfxMaskSticker3",
            "m_pValue": "materials/default/stickers/default_holomask_tga_daef1ed1.vtex"
        },
        {
            "m_name": "g_tSfxMaskSticker4",
            "m_pValue": "materials/default/stickers/default_holomask_tga_daef1ed1.vtex"
        },
        {
            "m_name": "g_tSticker0",
            "m_pValue": "materials/default/stickers/sticker_default_psd_7f7731d3.vtex"
        },
        {
            "m_name": "g_tSticker1",
            "m_pValue": "materials/default/stickers/sticker_default_psd_7f7731d3.vtex"
        },
        {
            "m_name": "g_tSticker2",
            "m_pValue": "materials/default/stickers/sticker_default_psd_7f7731d3.vtex"
        },
        {
            "m_name": "g_tSticker3",
            "m_pValue": "materials/default/stickers/sticker_default_psd_7f7731d3.vtex"
        },
        {
            "m_name": "g_tSticker4",
            "m_pValue": "materials/default/stickers/sticker_default_psd_7f7731d3.vtex"
        },
        {
            "m_name": "g_tStickerGlitterNormal",
            "m_pValue": "materials/default/stickers/squares_glitter_normal_tga_25145674.vtex"
        },
        {
            "m_name": "g_tStickerScratches",
            "m_pValue": "materials/default/stickers/sticker_default_scratches_psd_a9ad199b.vtex"
        },
        {
            "m_name": "g_tStickerWepInputs",
            "m_pValue": "weapons/models/ak47/materials/stickers/weapon_rif_ak47_sticker_mask_legacy_tga_1bdb00a.vtex"
        }
    ],
    "m_dynamicParams": [],
    "m_dynamicTextureParams": [],
    "m_intAttributes": [],
    "m_floatAttributes": [],
    "m_vectorAttributes": [],
    "m_textureAttributes": [],
    "m_stringAttributes": [
        {
            "m_name": "composite_inputs",
            "m_value": "materials/models/weapons/customization/rif_ak47/rif_ak47_composite_inputs.vmat"
        },
        {
            "m_name": "PreviewModel",
            "m_value": "weapons/models/ak47/weapon_rif_ak47.vmdl"
        }
    ],
    "m_renderAttributesUsed": []
}
*/

class Source2IceSurfaceDotaMaterial extends Source2Material {
    get shaderSource() {
        return 'source2_ice_surface_dota';
    }
}
Source2MaterialLoader.registerMaterial('ice_surface_dota.vfx', Source2IceSurfaceDotaMaterial);

class Source2ProjectedDotaMaterial extends Source2Material {
    get shaderSource() {
        return 'source2_projected_dota';
    }
}
Source2MaterialLoader.registerMaterial('projected_dota.vfx', Source2ProjectedDotaMaterial);

class Source2StickersMaterial extends Source2Material {
    get shaderSource() {
        return 'source2_stickers';
    }
}
Source2MaterialLoader.registerMaterial('stickers.vfx', Source2StickersMaterial);

class Source2VrBlackUnlit extends Source2Material {
    get shaderSource() {
        return 'source2_vr_black_unlit';
    }
}
Source2MaterialLoader.registerMaterial('vr_black_unlit.vfx', Source2VrBlackUnlit);

class Source2VrComplex extends Source2Material {
    get shaderSource() {
        return 'source2_vr_complex';
    }
}
Source2MaterialLoader.registerMaterial('vr_complex.vfx', Source2VrComplex);

class Source2VrEyeball extends Source2Material {
    get shaderSource() {
        return 'source2_vr_eyeball';
    }
}
Source2MaterialLoader.registerMaterial('vr_eyeball.vfx', Source2VrEyeball);

class Source2VrGlass extends Source2Material {
    get shaderSource() {
        return 'source2_vr_glass';
    }
}
Source2MaterialLoader.registerMaterial('vr_glass.vfx', Source2VrGlass);

class Source2VrMonitor extends Source2Material {
    get shaderSource() {
        return 'source2_vr_monitor';
    }
}
Source2MaterialLoader.registerMaterial('vr_monitor.vfx', Source2VrMonitor);

class Source2VrSimple extends Source2Material {
    get shaderSource() {
        return 'source2_vr_simple';
    }
}
Source2MaterialLoader.registerMaterial('vr_simple.vfx', Source2VrSimple);
Source2MaterialLoader.registerMaterial('vr_simple_2layer_parallax.vfx', Source2VrSimple); //TODO : create own material

class Source2VrSimple2WayBlend extends Source2Material {
    get shaderSource() {
        return 'source2_vr_simple_2way_blend';
    }
}
Source2MaterialLoader.registerMaterial('vr_simple_2way_blend.vfx', Source2VrSimple2WayBlend);

class Source2VrSimple3LayerParallax extends Source2Material {
    get shaderSource() {
        return 'source2_vr_simple_3layer_parallax';
    }
}
Source2MaterialLoader.registerMaterial('vr_simple_3layer_parallax.vfx', Source2VrSimple3LayerParallax);
/*

m_textureParams: Array(7)
0: {m_name: "g_tNormalA", _name: "MaterialParamTexture_t", m_pValue: "models/weapons/vr_alyxtool/materials/multi_screen_r_normal_psd_fd9ddafa.vtex"}
1: {m_name: "g_tColorC", _name: "MaterialParamTexture_t", m_pValue: "models/weapons/vr_alyxtool/materials/multitool_screen_r_vmat_g_tcolorc_79c08dd3.vtex"}
2: {m_name: "g_tColorB", _name: "MaterialParamTexture_t", m_pValue: "models/weapons/vr_alyxtool/materials/multitool_screen_r_vmat_g_tcolorb_9bba1794.vtex"}
3: {m_name: "g_tEmissiveB", _name: "MaterialParamTexture_t", m_pValue: "materials/default/default_tga_449484c6.vtex"}
4: {m_name: "g_tEmissiveC", _name: "MaterialParamTexture_t", m_pValue: "materials/default/default_tga_449484c6.vtex"}
5: {m_name: "g_tMasks", _name: "MaterialParamTexture_t", m_pValue: "models/weapons/vr_alyxtool/materials/multi_screen_r_mask_psd_255bc5b7.vtex"}
6: {m_name: "g_tColorA", _name: "MaterialParamTexture_t", m_pValue: "models/weapons/vr_alyxtool/materials/multi_screen_r_color_psd_4f0a4fd7.vtex"}
*/

class Source2VrSkin extends Source2Material {
    get shaderSource() {
        return 'source2_vr_skin';
    }
}
Source2MaterialLoader.registerMaterial('vr_skin.vfx', Source2VrSkin);

class Source2VrXenFoliage extends Source2Material {
    get shaderSource() {
        return 'source2_vr_xen_foliage';
    }
}
Source2MaterialLoader.registerMaterial('vr_xen_foliage.vfx', Source2VrXenFoliage);

class Source2Crystal extends Source2Material {
    setupUniformsOnce() {
        super.setupUniformsOnce();
        this.setBlending(MATERIAL_BLENDING_ADDITIVE);
        this.setDefine('IS_TRANSLUCENT');
    }
    getShaderSource() {
        return 'source2_crystal';
    }
}
Source2MaterialLoader.registerMaterial('crystal.vfx', Source2Crystal);

class Source2EnvironmentBlend extends Source2Material {
    get shaderSource() {
        return 'source2_csgo_environment';
    }
}
Source2MaterialLoader.registerMaterial('environment_blend.vfx', Source2EnvironmentBlend);
Source2MaterialLoader.registerMaterial('environment_layer.vfx', Source2EnvironmentBlend); //TODO: proper material

class Source2Error extends Source2Material {
    constructor(repository, shader, source2File) {
        super(repository, shader, source2File);
        this.renderFace(RenderFace.Both);
    }
    get shaderSource() {
        return 'source2_error';
    }
}
Source2MaterialLoader.registerMaterial('error.vfx', Source2Error);

class Source2Generic extends Source2Material {
    get shaderSource() {
        return 'source2_hero'; //TODO: code proper shader
    }
}
Source2MaterialLoader.registerMaterial('generic.vfx', Source2Generic);

class Source2Pbr extends Source2Material {
    get shaderSource() {
        return 'source2_pbr';
    }
}
Source2MaterialLoader.registerMaterial('pbr.vfx', Source2Pbr);

class Source2GlobalLitSimple extends Source2Material {
    getShaderSource() {
        return 'source2_global_lit_simple';
    }
}
Source2MaterialLoader.registerMaterial('global_lit_simple.vfx', Source2GlobalLitSimple);

class Source2Hero extends Source2Material {
    get shaderSource() {
        return 'source2_hero';
    }
}
Source2MaterialLoader.registerMaterial('hero.vfx', Source2Hero);

class Source2HeroFluid extends Source2Material {
    get shaderSource() {
        return 'source2_hero_fluid';
    }
}
Source2MaterialLoader.registerMaterial('hero_fluid.vfx', Source2HeroFluid);

class Source2SpringMeteor extends Source2Material {
    get shaderSource() {
        return 'source2_spring_meteor';
    }
}
Source2MaterialLoader.registerMaterial('spring_meteor.vfx', Source2SpringMeteor);

class Source2SpriteCard extends Source2Material {
    #texturePath = '';
    constructor(repository, shader = 'spritecard.vfx', source2File) {
        super(repository, shader, source2File);
        //TODO: we should adapt transparency depending on particle renderer params ?
        this.setTransparency(GL_SRC_ALPHA, GL_DST_ALPHA);
        //this.setTransparency(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        this.setTransparency(GL_SRC_ALPHA, GL_ONE);
        this.renderFace(RenderFace.Both);
        this.setUniform('uFinalTextureScale', vec2.fromValues(1, 1));
        this.setUniform('uColorScale', vec3.fromValues(1, 1, 1));
        //this.setTransparency( GL_SRC_ALPHA, GL_ONE);
        this.setTransparency(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
    }
    setOutputBlendMode(outputBlendMode /*TODO; create enum*/) {
        switch (outputBlendMode) {
            case 0:
                this.setTransparency(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
                break;
            case 1: //PARTICLE_OUTPUT_BLEND_MODE_ADD
                this.setTransparency(GL_SRC_ALPHA, GL_ONE);
                break;
            case 2: //PARTICLE_OUTPUT_BLEND_MODE_BLEND_ADD //TODO ?
                this.setTransparency(GL_SRC_ALPHA, GL_ONE);
                break;
            case 3: //PARTICLE_OUTPUT_BLEND_MODE_HALF_BLEND_ADD //TODO ?
                this.setTransparency(GL_SRC_ALPHA, GL_ONE);
                break;
            case 4: //PARTICLE_OUTPUT_BLEND_MODE_NEG_HALF_BLEND_ADD //TODO ?
                this.setTransparency(GL_SRC_ALPHA, GL_ONE);
                break;
            case 5: //PARTICLE_OUTPUT_BLEND_MODE_MOD2X
                this.setTransparency(GL_SRC_ALPHA, GL_DST_ALPHA);
                break;
            case 5: //PARTICLE_OUTPUT_BLEND_MODE_LIGHTEN //TODO ?
                this.setTransparency(GL_SRC_ALPHA, GL_ONE);
                break;
        }
    }
    async setTexturePath(texturePath) {
        this.#texturePath = texturePath;
    }
    async initTextureUniforms() {
        await super.initTextureUniforms();
        if (this.#texturePath) {
            this.setTexture('colorMap', await Source2TextureManager.getTexture(this.repository, this.#texturePath, 0), 'USE_COLOR_MAP');
        }
    }
    getFrameSpan(sequence) {
        console.error('code me');
        return 0;
    }
    getShaderSource() {
        return 'source2_spritecard';
    }
}
Source2MaterialLoader.registerMaterial('spritecard.vfx', Source2SpriteCard);

class Source2UI extends Source2Material {
    get shaderSource() {
        return 'source2_ui';
    }
}
Source2MaterialLoader.registerMaterial('ui.vfx', Source2UI);

class Source2Unlit extends Source2Material {
    get shaderSource() {
        return 'source2_hero'; //TODO: code proper shader
    }
}
Source2MaterialLoader.registerMaterial('unlit.vfx', Source2Unlit);

const vec$7 = vec3.create();
const DEFAULT_MIN_DISTANCE = 0;
const DEFAULT_MAX_DISTANCE$1 = 1000;
const DEFAULT_GLOBAL_CENTER = false;
class ConstrainDistance extends Operator {
    #centerOffset = vec3.create();
    #globalCenter = DEFAULT_GLOBAL_CENTER;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_CenterOffset':
                param.getValueAsVec3(this.#centerOffset);
                break;
            case 'm_bGlobalCenter':
                this.#globalCenter = param.getValueAsBool() ?? DEFAULT_GLOBAL_CENTER;
                break;
            case 'm_fMinDistance':
            case 'm_fMaxDistance':
            // used in applyConstraint
            default:
                super._paramChanged(paramName, param);
        }
    }
    applyConstraint(particle) {
        const minDistance = this.getParamScalarValue('m_fMinDistance') ?? DEFAULT_MIN_DISTANCE;
        const maxDistance = this.getParamScalarValue('m_fMaxDistance') ?? DEFAULT_MAX_DISTANCE$1;
        this.getParameter('offset of center');
        this.getParameter('control point number');
        const cp = this.system.getControlPoint(this.controlPointNumber);
        const v = vec3.clone(particle.position);
        if (cp) {
            vec3.sub(v, v, cp.getWorldPosition(vec$7));
        }
        const distance = vec3.length(v);
        if (distance > 0) {
            vec3.scale(v, v, 1 / distance);
            if (distance < minDistance) {
                vec3.scale(v, v, minDistance);
                vec3.add(particle.position, cp.getWorldPosition(vec$7), v);
            }
            else {
                if (distance > maxDistance) {
                    vec3.scale(v, v, maxDistance);
                    vec3.add(particle.position, cp.getWorldPosition(vec$7), v);
                }
            }
        }
    }
}
RegisterSource2ParticleOperator('C_OP_ConstrainDistance', ConstrainDistance);

const DEFAULT_EMISSION_DURATION = 0;
const DEFAULT_EMISSION_START_TIME = 0;
const DEFAULT_EMIT_RATE = 100;
class ContinuousEmitter extends Emitter {
    //#emitRate = DEFAULT_EMIT_RATE;
    #remainder = 0;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_flEmissionDuration':
            case 'm_flEmitRate':
            case 'm_flStartTime':
                // used in doEmit
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doEmit(elapsedTime) {
        // TODO: use m_flEmissionDuration
        const emissionDuration = this.getParamScalarValue('m_flEmissionDuration') ?? DEFAULT_EMISSION_DURATION;
        const emissionStartTime = this.getParamScalarValue('m_flStartTime') ?? DEFAULT_EMISSION_START_TIME;
        //let emitRate = this.#emitRate;
        //const emissionDuration = this.getParameter('emission_duration') ?? 0;
        const fade = this.getOperatorFade();
        const emitRate = (this.getParamScalarValue('m_flEmitRate') ?? DEFAULT_EMIT_RATE) * fade;
        let currentTime = this.system.currentTime;
        if (currentTime < emissionStartTime)
            return;
        if (emissionDuration != 0 && (currentTime > emissionStartTime + emissionDuration))
            return;
        let nToEmit = this.#remainder + elapsedTime * emitRate;
        this.#remainder = nToEmit % 1;
        nToEmit = Math.floor(nToEmit);
        const timeStampStep = elapsedTime / nToEmit;
        for (let i = 0; i < nToEmit; ++i) {
            const particle = this.emitParticle(currentTime, elapsedTime);
            if (particle == null) {
                break; // Break if a particule can't emitted (max reached)
            }
            currentTime += timeStampStep;
        }
    }
}
RegisterSource2ParticleOperator('C_OP_ContinuousEmitter', ContinuousEmitter);

const DEFAULT_SNAPSHOT_CONTROL_POINT = -1; // TODO: check default value
const DEFAULT_MAX_EMITTED_PER_FRAME = -1; // TODO: check default value
const DEFAULT_INIT_FROM_KILLED_PARENT_PARTICLES = 0; // TODO: check default value
class InstantaneousEmitter extends Emitter {
    #emitted = 0;
    #initFromKilledParentParticles = DEFAULT_INIT_FROM_KILLED_PARENT_PARTICLES;
    #maxEmittedPerFrame = DEFAULT_MAX_EMITTED_PER_FRAME;
    #snapshotControlPoint = DEFAULT_SNAPSHOT_CONTROL_POINT;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_nParticlesToEmit':
            case 'm_flStartTime':
                break;
            case 'm_flInitFromKilledParentParticles':
                this.#initFromKilledParentParticles = param.getValueAsNumber() ?? DEFAULT_INIT_FROM_KILLED_PARENT_PARTICLES;
                break;
            case 'm_nMaxEmittedPerFrame':
                console.error('do this param', paramName, param);
                this.#maxEmittedPerFrame = param.getValueAsNumber() ?? DEFAULT_MAX_EMITTED_PER_FRAME;
                break;
            case 'm_nSnapshotControlPoint':
                this.#snapshotControlPoint = param.getValueAsNumber() ?? DEFAULT_SNAPSHOT_CONTROL_POINT;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doEmit(elapsedTime) {
        //todo: use snapshotControlPoint
        let particlesToEmit = this.getParamScalarValue('m_nParticlesToEmit') ?? 100;
        this.getParamScalarValue('m_flStartTime') ?? 0;
        const system = this.system;
        if (this.#snapshotControlPoint != -1) {
            const snapshot = system.getControlPoint(this.#snapshotControlPoint)?.snapshot;
            if (snapshot) {
                particlesToEmit = snapshot.particleCount;
            }
            else {
                particlesToEmit = 0; //yep no snapshot = no particle
            }
        }
        //TODO: check start timeout
        let nToEmit = particlesToEmit - this.#emitted;
        if (this.#maxEmittedPerFrame != -1) {
            nToEmit = Math.min(nToEmit, this.#maxEmittedPerFrame);
        }
        let currentTime = system.currentTime;
        const timeStampStep = elapsedTime / nToEmit;
        for (let i = 0; i < nToEmit; ++i) {
            const particle = this.emitParticle(currentTime, elapsedTime);
            if (particle == null) {
                break; // Break if a particule can't emitted (max reached)
            }
            currentTime += timeStampStep;
            ++this.#emitted;
        }
    }
    reset() {
        this.#emitted = 0;
    }
}
RegisterSource2ParticleOperator('C_OP_InstantaneousEmitter', InstantaneousEmitter);

const DEFAULT_PARTICLES_TO_MAINTAIN = 100;
class MaintainEmitter extends Emitter {
    #particlesToMaintain = DEFAULT_PARTICLES_TO_MAINTAIN;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_nParticlesToMaintain':
                this.#particlesToMaintain = param.getValueAsNumber() ?? DEFAULT_PARTICLES_TO_MAINTAIN;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doEmit(elapsedTime) {
        const nToEmit = this.#particlesToMaintain - this.system.livingParticles.length;
        if (nToEmit > 0) {
            let currentTime = this.system.currentTime;
            const timeStampStep = elapsedTime / nToEmit;
            for (let i = 0; i < nToEmit; ++i) {
                const particle = this.emitParticle(currentTime, elapsedTime);
                if (particle == null) {
                    break; // Break if a particule can't emitted (max reached)
                }
                currentTime += timeStampStep;
            }
        }
    }
}
RegisterSource2ParticleOperator('C_OP_MaintainEmitter', MaintainEmitter);

const DEFAULT_SCALE_CONTROL_POINT$2 = -1; //disabled
const DEFAULT_SCALE_CONTROL_POINT_FIELD$1 = Source2ParticleCpField.X;
const DEFAULT_WORLD_NOISE_POINT = -1; //disabled
const DEFAULT_ABS_VAL$1 = false;
const DEFAULT_ABS_VAL_INV$1 = false;
const DEFAULT_OFFSET$5 = 0;
const DEFAULT_OUTPUT_MIN$7 = 0; //emission minimum
const DEFAULT_OUTPUT_MAX$7 = 100; //emission maximum
const DEFAULT_NOISE_SCALE$4 = 0.1;
const DEFAULT_WORLD_NOISE_SCALE = 0.001;
const DEFAULT_WORLD_TIME_SCALE$1 = 0;
class NoiseEmitter extends Emitter {
    #scaleControlPoint = DEFAULT_SCALE_CONTROL_POINT$2;
    #scaleControlPointField = DEFAULT_SCALE_CONTROL_POINT_FIELD$1;
    #worldNoisePoint = DEFAULT_WORLD_NOISE_POINT; //world noise scale control point
    #absVal = DEFAULT_ABS_VAL$1;
    #absValInv = DEFAULT_ABS_VAL_INV$1;
    #offset = DEFAULT_OFFSET$5; //time coordinate offset
    #outputMin = DEFAULT_OUTPUT_MIN$7;
    #outputMax = DEFAULT_OUTPUT_MAX$7;
    #noiseScale = DEFAULT_NOISE_SCALE$4; //time noise coordinate scale
    #worldNoiseScale = DEFAULT_WORLD_NOISE_SCALE;
    #offsetLoc = vec3.create(); //spatial coordinate offset
    #worldTimeScale = DEFAULT_WORLD_TIME_SCALE$1; //world time noise coordinate scale
    #remainder = 0;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_nScaleControlPoint':
                this.#scaleControlPoint = param.getValueAsNumber() ?? DEFAULT_SCALE_CONTROL_POINT$2;
                break;
            case 'm_nScaleControlPointField':
                this.#scaleControlPointField = param.getValueAsNumber() ?? DEFAULT_SCALE_CONTROL_POINT_FIELD$1;
                break;
            case 'm_nWorldNoisePoint':
                this.#worldNoisePoint = param.getValueAsNumber() ?? DEFAULT_WORLD_NOISE_POINT;
                break;
            case 'm_bAbsVal':
                this.#absVal = param.getValueAsBool() ?? DEFAULT_ABS_VAL$1;
                break;
            case 'm_bAbsValInv':
                this.#absValInv = param.getValueAsBool() ?? DEFAULT_ABS_VAL_INV$1;
                break;
            case 'm_flOffset':
                this.#offset = param.getValueAsNumber() ?? DEFAULT_OFFSET$5;
                break;
            case 'm_flOutputMin':
                this.#outputMin = param.getValueAsNumber() ?? DEFAULT_OUTPUT_MIN$7;
                break;
            case 'm_flOutputMax':
                this.#outputMax = param.getValueAsNumber() ?? DEFAULT_OUTPUT_MAX$7;
                break;
            case 'm_flNoiseScale':
                this.#noiseScale = param.getValueAsNumber() ?? DEFAULT_NOISE_SCALE$4;
                break;
            case 'm_flWorldNoiseScale':
                this.#worldNoiseScale = param.getValueAsNumber() ?? DEFAULT_WORLD_NOISE_SCALE;
                break;
            case 'm_vecOffsetLoc':
                param.getValueAsVec3(this.#offsetLoc);
                break;
            case 'm_flWorldTimeScale':
                this.#worldTimeScale = param.getValueAsNumber() ?? DEFAULT_WORLD_TIME_SCALE$1;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doEmit(elapsedTime) {
        //TODO: code me
        const emission_start_time = this.startTime;
        let emission_rate = (this.#outputMin + this.#outputMax) * 0.5;
        const emission_duration = this.emissionDuration;
        const fade = this.getOperatorFade();
        emission_rate *= fade;
        let currentTime = this.system.currentTime;
        if (currentTime < emission_start_time)
            return;
        if (emission_duration != 0 && (currentTime > emission_start_time + emission_duration))
            return;
        let nToEmit = this.#remainder + elapsedTime * emission_rate;
        this.#remainder = nToEmit % 1;
        nToEmit = Math.floor(nToEmit);
        const timeStampStep = elapsedTime / nToEmit;
        for (let i = 0; i < nToEmit; ++i) {
            const particle = this.emitParticle(currentTime, elapsedTime);
            if (particle == null) {
                break; // Break if a particule can't emitted (max reached)
            }
            currentTime += timeStampStep;
        }
    }
}
RegisterSource2ParticleOperator('C_OP_NoiseEmitter', NoiseEmitter);

const vecCenter = vec3.create();
const vec$6 = vec3.create();
const DEFAULT_APPLY_MIN_FORCE = false; // TODO: check default value
class AttractToControlPoint extends Operator {
    #componentScale = vec3.fromValues(1, 1, 1);
    #falloffPower = 0;
    #scaleLocal = false;
    #applyMinForce = false;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_vecComponentScale': // TODO: mutualize ?
                param.getValueAsVec3(this.#componentScale);
                break;
            case 'm_fFalloffPower':
                this.#falloffPower = param.getValueAsNumber() ?? 0; // TODO: check default value
                break;
            case 'm_bScaleLocal':
                this.#scaleLocal = param.getValueAsBool() ?? false; // TODO: check default value
                break;
            case 'm_bApplyMinForce':
                console.error('do this param', paramName, param);
                this.#applyMinForce = param.getValueAsBool() ?? DEFAULT_APPLY_MIN_FORCE;
                break;
            case 'm_fForceAmount':
            case 'm_fForceAmountMin':
                // used in doForce
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doForce(particle, elapsedTime, accumulatedForces, strength) {
        const forceAmount = this.getParamScalarValue('m_fForceAmount') ?? 100; // TODO: check default value
        this.getParamScalarValue('m_fForceAmountMin') ?? 0; // TODO: check default value
        (-4.0 * this.#falloffPower) << 0; // convert to what pow_fixedpoint_exponent_simd wants
        const fForceScale = -forceAmount * strength /*flStrength*/;
        const cp = this.system.getControlPoint(this.controlPointNumber);
        if (!cp) {
            return;
        }
        vec3.subtract(vecCenter, particle.position, cp.getWorldPosition(vec$6)); //TODO: add particle base cp
        let len = vec3.length(vecCenter);
        if (len === 0) {
            len = FLT_EPSILON;
        }
        vec3.scale(vecCenter, vecCenter, fForceScale / len * Math.pow(len, -this.#falloffPower));
        vec3.add(accumulatedForces, accumulatedForces, vecCenter);
        //TODO: use m_vecComponentScale m_bScaleLocal m_bApplyMinForce
    }
}
RegisterSource2ParticleOperator('C_OP_AttractToControlPoint', AttractToControlPoint);

class CPVelocityForce extends Operator {
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_flScale':
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doForce(particle, elapsedTime, accumulatedForces, strength) {
        this.getParamScalarValue('m_flScale') ?? 1;
        //TODO
    }
}
RegisterSource2ParticleOperator('C_OP_CPVelocityForce', CPVelocityForce);

class RandomForce extends Operator {
    #minForce = vec3.create();
    #maxForce = vec3.create();
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_MinForce':
                param.getValueAsVec3(this.#minForce);
                break;
            case 'm_MaxForce':
                param.getValueAsVec3(this.#maxForce);
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doForce(particle, elapsedTime, accumulatedForces, strength) {
        vec3.add(accumulatedForces, accumulatedForces, vec3RandomBox(vec3.create(), this.#minForce, this.#maxForce));
    }
}
RegisterSource2ParticleOperator('C_OP_RandomForce', RandomForce);

const DEFAULT_FORCE_AMOUNT = 100; // TODO: check default value
class TwistAroundAxis extends Operator {
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_fForceAmount':
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doForce(particle, elapsedTime, accumulatedForces, strength) {
        this.getParamScalarValue('m_fForceAmount') ?? DEFAULT_FORCE_AMOUNT;
    }
}
RegisterSource2ParticleOperator('C_OP_TwistAroundAxis', TwistAroundAxis);

const DEFAULT_NOISE_SCALE$3 = 1; // TODO: check default value
const DEFAULT_NOISE_SCALE_LOC$1 = 1; // TODO: check default value
class AgeNoise extends Operator {
    #noiseScale = DEFAULT_NOISE_SCALE$3;
    #noiseScaleLoc = DEFAULT_NOISE_SCALE_LOC$1;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_flNoiseScale':
                this.#noiseScale = param.getValueAsNumber() ?? DEFAULT_NOISE_SCALE$3;
                break;
            case 'm_flNoiseScaleLoc':
                this.#noiseScaleLoc = param.getValueAsNumber() ?? DEFAULT_NOISE_SCALE_LOC$1;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doInit(particle, elapsedTime, strength) {
        //TODO
    }
}
RegisterSource2ParticleOperator('C_INIT_AgeNoise', AgeNoise);

const DEFAULT_VELOCITY_SCALE = 0; // TODO: check default value
const DEFAULT_INCREMENT$1 = 1; // TODO: check default value
const DEFAULT_RANDOM_DISTRIBUTION$1 = false; // TODO: check default value
const DEFAULT_RANDOM_SEED$3 = 0; // TODO: check default value
const DEFAULT_SUB_FRAME = true; // TODO: check default value
class CreateFromParentParticles extends Operator {
    #velocityScale = DEFAULT_VELOCITY_SCALE;
    #increment = DEFAULT_INCREMENT$1;
    #randomDistribution = DEFAULT_RANDOM_DISTRIBUTION$1;
    #randomSeed = DEFAULT_RANDOM_SEED$3;
    #subFrame = DEFAULT_SUB_FRAME;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_flVelocityScale':
                this.#velocityScale = param.getValueAsNumber() ?? DEFAULT_VELOCITY_SCALE;
                break;
            case 'm_flIncrement':
                this.#increment = param.getValueAsNumber() ?? DEFAULT_INCREMENT$1;
                break;
            case 'm_bRandomDistribution':
                this.#randomDistribution = param.getValueAsBool() ?? DEFAULT_RANDOM_DISTRIBUTION$1;
                break;
            case 'm_nRandomSeed':
                console.error('do this param', paramName, param);
                this.#randomSeed = Number(param);
                break;
            case 'm_bSubFrame':
                this.#subFrame = param.getValueAsBool() ?? DEFAULT_SUB_FRAME;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doInit(particle, elapsedTime, strength) {
        const parent = this.system.parentSystem;
        if (parent == null) {
            return;
        }
        const base = parent.getParticle(0 /*TODO: particle index*/);
        if (base == null) {
            particle.die();
            return;
        }
        base.getWorldPos(particle.position);
        base.getLocalPos(particle.position);
        vec3.copy(particle.prevPosition, particle.position);
        particle.PositionFromParentParticles = true;
        //TODO: fix this operator
    }
}
RegisterSource2ParticleOperator('C_INIT_CreateFromParentParticles', CreateFromParentParticles);

const DEFAULT_CONTROL_POINT$1 = 0;
const DEFAULT_TYPE$1 = Source2ParticleModelType.ControlPoint;
const DEFAULT_USE_ORIENTATION = true;
class Source2ParticleModelInput {
    type = DEFAULT_TYPE$1;
    controlPoint = DEFAULT_CONTROL_POINT$1;
    useOrientation = DEFAULT_USE_ORIENTATION;
    static fromOperatorParam(param, input) {
        input.type = stringToModelType(param.getSubValueAsString('m_nType')) ?? DEFAULT_TYPE$1;
        input.controlPoint = param.getSubValueAsNumber('m_nControlPoint') ?? DEFAULT_CONTROL_POINT$1;
        input.useOrientation = param.getSubValueAsBool('m_bUseOrientation') ?? DEFAULT_USE_ORIENTATION;
        // TODO: add model / entity params
    }
}

const DEFAULT_CONTROL_POINT = 0;
const DEFAULT_TYPE = Source2ParticleTransformType.ControlPoint;
class Source2ParticleTransformInput {
    type = DEFAULT_TYPE;
    controlPoint = DEFAULT_CONTROL_POINT;
    static fromOperatorParam(param, input) {
        input.type = stringToTransformType(param.getSubValueAsString('m_nType')) ?? DEFAULT_TYPE;
        input.controlPoint = param.getSubValueAsNumber('m_nControlPoint') ?? DEFAULT_CONTROL_POINT;
        // TODO: other params
    }
}

const vec$5 = vec3.create();
const DEFAULT_FORCE_IN_MODEL = 0;
const DEFAULT_SCALE_TO_VOLUME = false;
const DEFAULT_HITBOX_VALUE_FROM_CONTROL_POINT_INDEX = -1;
const DEFAULT_BONE_VELOCITY$1 = 0;
const DEFAULT_MAX_BONE_VELOCITY = 0;
const DEFAULT_HITBOX_SET_NAME$2 = 'default';
const DEFAULT_LOCAL_COORDS$3 = false;
const DEFAULT_USE_BONES$1 = false;
class CreateOnModel extends Operator {
    #modelInput = new Source2ParticleModelInput();
    #transformInput = new Source2ParticleTransformInput();
    #forceInModel = DEFAULT_FORCE_IN_MODEL;
    #scaleToVolume = DEFAULT_SCALE_TO_VOLUME;
    #hitboxValueFromControlPointIndex = DEFAULT_HITBOX_VALUE_FROM_CONTROL_POINT_INDEX;
    #boneVelocity = DEFAULT_BONE_VELOCITY$1; //inherited velocity scale
    #maxBoneVelocity = DEFAULT_MAX_BONE_VELOCITY; //maximum inherited velocity
    #hitboxSetName = DEFAULT_HITBOX_SET_NAME$2;
    #localCoords = DEFAULT_LOCAL_COORDS$3; //bias in local space
    #useBones = DEFAULT_USE_BONES$1; //use bones instead of hitboxes
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_nForceInModel':
                this.#forceInModel = param.getValueAsNumber() ?? DEFAULT_FORCE_IN_MODEL;
                break;
            case 'm_bScaleToVolume':
                this.#scaleToVolume = param.getValueAsBool() ?? DEFAULT_SCALE_TO_VOLUME;
                break;
            case 'm_nHitboxValueFromControlPointIndex':
                this.#hitboxValueFromControlPointIndex = param.getValueAsNumber() ?? DEFAULT_HITBOX_VALUE_FROM_CONTROL_POINT_INDEX;
                break;
            case 'm_flBoneVelocity':
                this.#boneVelocity = param.getValueAsNumber() ?? DEFAULT_BONE_VELOCITY$1;
                break;
            case 'm_flMaxBoneVelocity':
                console.error('do this param', paramName, param);
                this.#maxBoneVelocity = param.getValueAsNumber() ?? DEFAULT_MAX_BONE_VELOCITY;
                break;
            case 'm_HitboxSetName':
                this.#hitboxSetName = param.getValueAsString() ?? DEFAULT_HITBOX_SET_NAME$2;
                break;
            case 'm_bLocalCoords':
                this.#localCoords = param.getValueAsBool() ?? DEFAULT_LOCAL_COORDS$3;
                break;
            case 'm_bUseBones':
                this.#useBones = param.getValueAsBool() ?? DEFAULT_USE_BONES$1;
                break;
            case 'm_modelInput':
            case 'm_transformInput':
            case 'm_nDesiredHitbox':
            case 'm_vecHitBoxScale':
            case 'm_vecDirectionBias':
                //used in doInit
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doInit(particle, elapsedTime, strength) {
        // TODO: use m_vecHitBoxScale, forceInModel, directionBias, hitboxSetName, m_modelInput, m_transformInput, m_nDesiredHitbox, m_vecDirectionBias
        //const hitBoxScale = this.getParamVectorValue('m_vecHitBoxScale');
        const controlPoint = this.system.getControlPoint(this.controlPointNumber);
        if (controlPoint) {
            const controllingModel = controlPoint.parentModel;
            if (controllingModel?.getRandomPointOnModel) {
                const bones = [] /*TODO: improve type*/;
                particle.bones = bones;
                particle.initialVec = vec3.create();
                const position = controllingModel.getRandomPointOnModel(vec3.create(), particle.initialVec, bones);
                if (controlPoint) {
                    vec3.copy(particle.position, position);
                    vec3.copy(particle.prevPosition, position);
                }
            }
            else {
                if (controlPoint) {
                    vec3.copy(particle.position, controlPoint.getWorldPosition(vec$5));
                    vec3.copy(particle.prevPosition, particle.position);
                }
            }
        }
    }
}
RegisterSource2ParticleOperator('C_INIT_CreateOnModel', CreateOnModel);

vec3.create();
const DEFAULT_HEIGHT_CP = 1;
const DEFAULT_DESIRED_HEIGHT = 1;
const DEFAULT_FORCE_Z = false;
class CreateOnModelAtHeight extends Operator {
    #heightCP = DEFAULT_HEIGHT_CP;
    #desiredHeight = DEFAULT_HEIGHT_CP;
    #forceZ = DEFAULT_FORCE_Z;
    /*
    #forceInModel = 0;
    #desiredHitbox = -1;
    #hitboxValueFromControlPointIndex = -1;
    #boneVelocity = 0;
    #maxBoneVelocity = 0;
    #directionBias = vec3.create();
    #hitboxSetName = 'default';
    #localCoords = false;
    #useBones = false;
    */
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_nHeightCP':
                this.#heightCP = param.getValueAsNumber() ?? DEFAULT_HEIGHT_CP;
                break;
            case 'm_flDesiredHeight':
                this.#heightCP = param.getValueAsNumber() ?? DEFAULT_DESIRED_HEIGHT;
                break;
            case 'm_bForceZ':
                this.#forceZ = param.getValueAsBool() ?? DEFAULT_FORCE_Z;
                break;
            case 'm_vecHitBoxScale':
                // used in doInit
                break;
            /*
        case 'm_nForceInModel':
            this.#forceInModel = param.getValueAsNumber() ?? 0;
            break;
        case 'm_nDesiredHitbox':
            console.error('do this param', paramName, param);
            this.#desiredHitbox = (param);
            break;
        case 'm_nHitboxValueFromControlPointIndex':
            console.error('do this param', paramName, param);
            this.#hitboxValueFromControlPointIndex = (param);
            break;
        case 'm_flBoneVelocity':
            console.error('do this param', paramName, param);
            this.#boneVelocity = param;
            break;
        case 'm_flMaxBoneVelocity':
            console.error('do this param', paramName, param);
            this.#maxBoneVelocity = param;
            break;
        case 'm_vecDirectionBias':
            param.getValueAsVec3(this.#directionBias);
            break;
        case 'm_HitboxSetName':
            this.#hitboxSetName = param.getValueAsString() ?? '';
            break;
        case 'm_bLocalCoords':
            this.#localCoords = param.getValueAsBool() ?? false;
            break;
        case 'm_bUseBones':
            console.error('do this param', paramName, param);
            this.#useBones = param;
            break;
            */
            default:
                super._paramChanged(paramName, param);
        }
    }
    doInit(particle, elapsedTime, strength) {
        // TODO
        /*
        // TODO: use m_vecHitBoxScale, forceInModel, directionBias, hitboxSetName
        //const hitBoxScale = this.getParamVectorValue('m_vecHitBoxScale');

        const controlPoint = this.system.getControlPoint(this.controlPointNumber);
        if (controlPoint) {
            const controllingModel = controlPoint.parentModel;
            if ((controllingModel as any)?.getRandomPointOnModel) {
                const bones = [];
                particle.bones = bones;
                particle.initialVec = vec3.create();
                const position = (controllingModel as any).getRandomPointOnModel(vec3.create(), particle.initialVec, bones);
                if (controlPoint) {
                    vec3.copy(particle.position, position);
                    vec3.copy(particle.prevPosition, position);
                }
            } else {
                if (controlPoint) {
                    vec3.copy(particle.position, controlPoint.getWorldPosition(vec));
                    vec3.copy(particle.prevPosition, particle.position);
                }
            }
        }*/
    }
}
RegisterSource2ParticleOperator('C_INIT_CreateOnModelAtHeight', CreateOnModelAtHeight);

const DEFAULT_BULGE_CONTROL = 0;
const DEFAULT_BULGE = 0;
const DEFAULT_START_CONTROL_POINT_NUMBER = 0;
const DEFAULT_END_CONTROL_POINT_NUMBER = 0;
const DEFAULT_MID_POINT$1 = 0.5;
class Source2ParticlePathParams {
    bulgeControl = DEFAULT_BULGE_CONTROL;
    bulge = DEFAULT_BULGE;
    startControlPointNumber = DEFAULT_START_CONTROL_POINT_NUMBER;
    endControlPointNumber = DEFAULT_END_CONTROL_POINT_NUMBER;
    midPoint = DEFAULT_MID_POINT$1;
    startPointOffset = vec3.create();
    midPointOffset = vec3.create();
    endOffset = vec3.create();
    static fromOperatorParam(param, path) {
        path.bulge = param.getSubValueAsNumber('m_flBulge') ?? DEFAULT_BULGE;
        path.bulgeControl = param.getSubValueAsNumber('m_nBulgeControl') ?? DEFAULT_BULGE_CONTROL;
        path.startControlPointNumber = param.getSubValueAsNumber('m_nStartControlPointNumber') ?? DEFAULT_START_CONTROL_POINT_NUMBER;
        path.endControlPointNumber = param.getSubValueAsNumber('m_nEndControlPointNumber') ?? DEFAULT_END_CONTROL_POINT_NUMBER;
        path.midPoint = param.getSubValueAsNumber('m_flMidPoint') ?? DEFAULT_MID_POINT$1;
        param.getSubValueAsVec3('m_vStartPointOffset', path.startPointOffset);
        param.getSubValueAsVec3('m_vMidPointOffset', path.midPointOffset);
        param.getSubValueAsVec3('m_vEndOffset', path.endOffset);
    }
}

const vec$4 = vec3.create();
const DEFAULT_LOOP$1 = true;
const DEFAULT_CP_PAIR = false;
const DEFAULT_SAVE_OFFSET$1 = false;
class CreateSequentialPath extends Operator {
    #loop = DEFAULT_LOOP$1; //restart behavior (0 = bounce, 1 = loop )
    #cpPairs = DEFAULT_CP_PAIR; //use sequential CP pairs between start and end point
    #saveOffset = DEFAULT_SAVE_OFFSET$1;
    #pathParams = new Source2ParticlePathParams();
    #t = 0;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_bLoop':
                this.#loop = param.getValueAsBool() ?? DEFAULT_LOOP$1;
                break;
            case 'm_bCPPairs':
                this.#cpPairs = param.getValueAsBool() ?? DEFAULT_CP_PAIR;
                break;
            case 'm_bSaveOffset':
                this.#saveOffset = param.getValueAsBool() ?? DEFAULT_SAVE_OFFSET$1;
                break;
            case 'm_PathParams':
                Source2ParticlePathParams.fromOperatorParam(param, this.#pathParams);
                break;
            case 'm_fMaxDistance':
            case 'm_flNumToAssign':
                //used in doInit
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doInit(particle, elapsedTime, strength) {
        //TODO: use other parameters m_fMaxDistance, m_flNumToAssign
        // TODO: check if m_flNumToAssign is really computed real time
        const startControlPointNumber = this.#pathParams.startControlPointNumber;
        const endControlPointNumber = this.#pathParams.endControlPointNumber;
        const startControlPoint = this.system.getControlPoint(startControlPointNumber);
        const endControlPoint = this.system.getControlPoint(endControlPointNumber);
        if (startControlPoint && endControlPoint) {
            const delta = startControlPoint.deltaPosFrom(endControlPoint, vec$4);
            vec3.scale(delta, delta, this.#t);
            vec3.add(particle.position, startControlPoint.currentWorldPosition, delta);
            vec3.copy(particle.prevPosition, particle.position);
            //++this.sequence;
            //this.#t += this.step;
            if (this.#t > 1.0) { //TODO: handle loop
                this.#t = 0;
            }
        }
    }
}
//TODO Not sure what the difference is between v1 and v2 ?
RegisterSource2ParticleOperator('C_INIT_CreateSequentialPath', CreateSequentialPath);
RegisterSource2ParticleOperator('C_INIT_CreateSequentialPathV2', CreateSequentialPath);

const DEFAULT_DISTRIBUTE_EVENLY = false;
const DEFAULT_SEED = -1;
class Source2ParticleRandomParams {
    distributeEvenly = DEFAULT_DISTRIBUTE_EVENLY;
    seed = DEFAULT_SEED;
    static fromOperatorParam(param, path) {
        path.distributeEvenly = param.getSubValueAsBool('m_bDistributeEvenly') ?? DEFAULT_DISTRIBUTE_EVENLY;
        path.seed = param.getSubValueAsNumber('m_nSeed') ?? DEFAULT_SEED;
    }
}

const tempQuat$2 = quat.create();
const tempVec3$3 = vec3.create();
const tempVec3_2$1 = vec3.create();
const DEFAULT_LOCAl_SPACE = false;
const DEFAULT_USE_NEW_CODE = false;
class CreateWithinBox extends Operator {
    #vecMin = vec4.create();
    #vecMax = vec4.create();
    #localSpace = DEFAULT_LOCAl_SPACE;
    #randomParams = new Source2ParticleRandomParams();
    #useNewCode = DEFAULT_USE_NEW_CODE;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_bLocalSpace':
                this.#localSpace = param.getValueAsBool() ?? DEFAULT_LOCAl_SPACE;
                break;
            case 'm_randomnessParameters':
                Source2ParticleRandomParams.fromOperatorParam(param, this.#randomParams);
                break;
            case 'm_bUseNewCode':
                this.#useNewCode = param.getValueAsBool() ?? DEFAULT_USE_NEW_CODE;
                break;
            case 'm_vecMin':
            case 'm_vecMax':
                // used in doInit
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doInit(particle, elapsedTime) {
        //TODO: useNewCode ??
        this.getParamVectorValue(this.#vecMin, 'm_vecMin', particle);
        this.getParamVectorValue(this.#vecMax, 'm_vecMax', particle);
        vec3RandomBox(tempVec3$3, this.#vecMin, this.#vecMax);
        /*
        if (this.#scaleCP !== -1) {
            const scaleCp = this.system.getControlPointForScale(this.#scaleCP);
            if (scaleCp) {
                scaleCp.getWorldPosition(tempVec3_2);
                vec3.scale(tempVec3, tempVec3, tempVec3_2[0]);//x position of the scale cp is used as scaling
            }
        }
            */
        const controlPoint = this.system.getControlPoint(this.controlPointNumber);
        if (controlPoint) {
            controlPoint.getWorldPosition(tempVec3_2$1);
            if (this.#localSpace) {
                vec3.transformQuat(tempVec3$3, tempVec3$3, controlPoint.getWorldQuaternion(tempQuat$2));
                vec3.add(tempVec3$3, tempVec3$3, tempVec3_2$1);
            }
            else {
                vec3.add(tempVec3$3, tempVec3$3, tempVec3_2$1);
            }
        }
        vec3.copy(particle.position, tempVec3$3);
        vec3.copy(particle.prevPosition, tempVec3$3);
    }
}
RegisterSource2ParticleOperator('C_INIT_CreateWithinBox', CreateWithinBox);

const DEFAULT_SPEED$1 = vec3.create();
const DEFAULT_DISTANCE_BIAS = vec3.fromValues(1, 1, 1);
//const vec = vec3.create();
const createWithinSphereSpeedMin = vec4.create();
const createWithinSphereSpeedMax = vec4.create();
const createWithinSphereDistanceBias = vec4.create();
const DEFAULT_SPEED_RAND_EXP = 1; // TODO: check default value
const DEFAULT_LOCAL_COORDS$2 = false; // TODO: check default value
class CreateWithinSphere extends Operator {
    #distanceBiasAbs = vec3.create();
    #speedRandExp = DEFAULT_SPEED_RAND_EXP;
    #localCoords = DEFAULT_LOCAL_COORDS$2; //bias in local system
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_LocalCoordinateSystemSpeedMin':
            case 'm_LocalCoordinateSystemSpeedMax':
            case 'm_fRadiusMin':
            case 'm_fRadiusMax':
            case 'm_vecDistanceBias':
            case 'm_fSpeedMin':
            case 'm_fSpeedMax':
                break;
            case 'm_vecDistanceBiasAbs':
                param.getValueAsVec3(this.#distanceBiasAbs);
                break;
            case 'm_fSpeedRandExp':
                this.#speedRandExp = param.getValueAsNumber() ?? DEFAULT_SPEED_RAND_EXP;
                break;
            case 'm_bLocalCoords':
                this.#localCoords = param.getValueAsBool() ?? DEFAULT_LOCAL_COORDS$2;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doInit(particle, elapsedTime, strength) {
        const localCoordinateSystemSpeedMin = (this.getParamVectorValue(createWithinSphereSpeedMin, 'm_LocalCoordinateSystemSpeedMin', particle) ?? DEFAULT_SPEED$1);
        const localCoordinateSystemSpeedMax = (this.getParamVectorValue(createWithinSphereSpeedMax, 'm_LocalCoordinateSystemSpeedMax', particle) ?? DEFAULT_SPEED$1);
        const m_vecDistanceBias = (this.getParamVectorValue(createWithinSphereDistanceBias, 'm_vecDistanceBias', particle) ?? DEFAULT_DISTANCE_BIAS);
        const radiusMin = this.getParamScalarValue('m_fRadiusMin') ?? 0; // TODO: check default value
        const radiusMax = this.getParamScalarValue('m_fRadiusMax') ?? 0; // TODO: check default value
        const speedMin = this.getParamScalarValue('m_fSpeedMin') ?? 0; // TODO: check default value
        const speedMax = this.getParamScalarValue('m_fSpeedMax') ?? 0; // TODO: check default value
        const m_vecDistanceBiasAbs = this.#distanceBiasAbs;
        //const controlPointNumber = this.getParameter('control_point_number');
        const m_bDistanceBias = (m_vecDistanceBias[0] != 1.0) || (m_vecDistanceBias[1] != 1.0) || (m_vecDistanceBias[2] != 1.0);
        const m_bDistanceBiasAbs = (m_vecDistanceBiasAbs[0] != 0.0) || (m_vecDistanceBiasAbs[1] != 0.0) || (m_vecDistanceBiasAbs[2] != 0.0);
        const speed = RandomFloatExp(speedMin, speedMax, this.#speedRandExp); //(speedMax - speedMin) * Math.random() + speedMin;
        const randpos = vec3.create();
        let cp;
        //for(int nTryCtr = 0 ; nTryCtr < 10; nTryCtr++)
        {
            const flLength = RandomVectorInUnitSphere(randpos);
            // Absolute value and biasing for creating hemispheres and ovoids.
            if (m_bDistanceBiasAbs) {
                if (m_vecDistanceBiasAbs[0] != 0.0) {
                    randpos[0] = Math.abs(randpos[0]);
                }
                if (m_vecDistanceBiasAbs[1] != 0.0) {
                    randpos[1] = Math.abs(randpos[1]);
                }
                if (m_vecDistanceBiasAbs[2] != 0.0) {
                    randpos[2] = Math.abs(randpos[2]);
                }
            }
            vec3.mul(randpos, randpos, m_vecDistanceBias); //randpos *= m_vecDistanceBias;
            vec3.normalize(randpos, randpos); //randpos.NormalizeInPlace();
            vec3.clone(randpos);
            vec3.scale(randpos, randpos, lerp(radiusMin, radiusMax, flLength));
            if (!m_bDistanceBias || !this.#localCoords) {
                /*Vector vecControlPoint;
                pParticles->GetControlPointAtTime(nCurrentControlPoint, *ct, &vecControlPoint);
                randpos += vecControlPoint;*/
                cp = particle.system.getControlPoint(this.controlPointNumber);
                if (cp) {
                    vec3.add(randpos, randpos, cp.currentWorldPosition);
                }
            }
            else {
                /*matrix3x4_t mat;
                pParticles->GetControlPointTransformAtTime(nCurrentControlPoint, *ct, &mat);
                Vector vecTransformLocal = vec3_origin;
                VectorTransform(randpos, mat, vecTransformLocal);
                randpos = vecTransformLocal;*/
                cp = particle.system.getControlPoint(this.controlPointNumber);
                if (cp) {
                    vec3.transformQuat(randpos, randpos, cp.currentWorldQuaternion);
                    vec3.add(randpos, randpos, cp.currentWorldPosition);
                }
            }
        }
        vec3.copy(particle.position, randpos);
        vec3RandomBox(particle.velocity, localCoordinateSystemSpeedMin, localCoordinateSystemSpeedMax);
        if (cp) {
            vec3.transformQuat(particle.velocity, particle.velocity, cp.currentWorldQuaternion);
        }
        if (speed) {
            const v = vec3.random(vec3.create(), speed);
            vec3.add(particle.velocity, particle.velocity, v);
            //vec3.add(randpos, randpos, v);
        }
        //quat.invert(particle.cpOrientationInvert, particle.cpOrientation);
        //vec3.transformQuat(particle.velocity, particle.velocity, particle.cpOrientation);
        const vGrav = vec3.clone(particle.velocity);
        particle.velocity[0] = vGrav[2];
        particle.velocity[1] = vGrav[1];
        particle.velocity[2] = -vGrav[0];
        particle.velocity[0] = vGrav[0];
        particle.velocity[1] = vGrav[1];
        particle.velocity[2] = vGrav[2];
        //particle.velocity[2] = -vGrav[2];
        //vec3.add(particle.prevPosition, particle.position, particle.velocity);//TODO: fix
        vec3.scaleAndAdd(randpos, randpos, particle.velocity, -elapsedTime);
        vec3.copy(particle.prevPosition, randpos);
    }
}
RegisterSource2ParticleOperator('C_INIT_CreateWithinSphere', CreateWithinSphere);

const DEFAULT_FIELD_OUTPUT$8 = Source2ParticleScalarField.Radius;
const DEFAULT_ABS_VAL = false;
const DEFAULT_ABS_VAL_INV = false;
const DEFAULT_OFFSET$4 = 0;
const DEFAULT_OUTPUT_MIN$6 = 0;
const DEFAULT_OUTPUT_MAX$6 = 1;
const DEFAULT_NOISE_SCALE$2 = 0.1;
const DEFAULT_NOISE_SCALE_LOC = 0.001;
const DEFAULT_WORLD_TIME_SCALE = 0;
class CreationNoise extends Operator {
    #fieldOutput = DEFAULT_FIELD_OUTPUT$8;
    #absVal = DEFAULT_ABS_VAL;
    #absValInv = DEFAULT_ABS_VAL_INV;
    #offset = DEFAULT_OFFSET$4;
    #outputMin = DEFAULT_OUTPUT_MIN$6;
    #outputMax = DEFAULT_OUTPUT_MAX$6;
    #noiseScale = DEFAULT_NOISE_SCALE$2;
    #noiseScaleLoc = DEFAULT_NOISE_SCALE_LOC;
    #offsetLoc = vec3.create(); //spatial coordinate offset
    #worldTimeScale = DEFAULT_WORLD_TIME_SCALE;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_nFieldOutput':
                this.#fieldOutput = param.getValueAsNumber() ?? DEFAULT_FIELD_OUTPUT$8;
                break;
            case 'm_bAbsVal':
                this.#absVal = param.getValueAsBool() ?? DEFAULT_ABS_VAL;
                break;
            case 'm_bAbsValInv':
                this.#absValInv = param.getValueAsBool() ?? DEFAULT_ABS_VAL_INV;
                break;
            case 'm_flOffset':
                this.#offset = param.getValueAsNumber() ?? DEFAULT_OFFSET$4;
                break;
            case 'm_flOutputMin':
                this.#outputMin = param.getValueAsNumber() ?? DEFAULT_OUTPUT_MIN$6;
                break;
            case 'm_flOutputMax':
                this.#outputMax = param.getValueAsNumber() ?? DEFAULT_OUTPUT_MAX$6;
                break;
            case 'm_flNoiseScale':
                this.#noiseScale = param.getValueAsNumber() ?? DEFAULT_NOISE_SCALE$2;
                break;
            case 'm_flNoiseScaleLoc':
                this.#noiseScaleLoc = param.getValueAsNumber() ?? DEFAULT_NOISE_SCALE_LOC;
                break;
            case 'm_vecOffsetLoc':
                param.getValueAsVec3(this.#offsetLoc);
                break;
            case 'm_flWorldTimeScale': //TODO: mutualize
                this.#worldTimeScale = param.getValueAsNumber() ?? DEFAULT_WORLD_TIME_SCALE;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doInit(particle, elapsedTime, strength) {
        const fieldOutput = this.fieldOutput;
        //let nAbsVal = 0xffffffff;
        let flAbsScale = 0.5;
        if (this.#absVal) {
            //nAbsVal = 0x7fffffff;
            flAbsScale = 1.0;
        }
        let fMin = this.#outputMin;
        let fMax = this.#outputMax;
        if (ATTRIBUTES_WHICH_ARE_ANGLES & (1 << fieldOutput)) {
            fMin *= DEG_TO_RAD;
            fMax *= DEG_TO_RAD;
        }
        const CoordScaleLoc = this.#noiseScaleLoc;
        let ValueScale, ValueBase;
        ValueScale = (flAbsScale * (fMax - fMin));
        ValueBase = (fMin + ((1.0 - flAbsScale) * (fMax - fMin)));
        let CoordLoc, CoordBase;
        //let pCreationTime = particle.cTime;//pParticles->GetFloatAttributePtr( PARTICLE_ATTRIBUTE_CREATION_TIME, start_p );
        const Offset = this.#offset;
        const a = (particle.cTime + Offset) * this.#noiseScale + performance.now() * this.#worldTimeScale;
        CoordBase = vec3.fromValues(a, a, a);
        CoordLoc = vec3.create();
        //CoordBase *= this.noiseScale;
        //CoordWorldTime = Vector( (Plat_MSTime() * m_flWorldTimeScale), (Plat_MSTime() * m_flWorldTimeScale), (Plat_MSTime() * m_flWorldTimeScale) );
        //CoordBase += CoordWorldTime;
        const Coord = vec3.create();
        //for( ; nParticleCount--; start_p++ )
        {
            vec3.copy(Coord, CoordBase);
            vec3.copy(CoordLoc, particle.position);
            vec3.add(CoordLoc, CoordLoc, this.#offsetLoc);
            //CoordLoc += m_vecOffsetLoc;
            vec3.scale(CoordLoc, CoordLoc, CoordScaleLoc);
            //CoordLoc *= CoordScaleLoc;
            vec3.add(Coord, Coord, CoordLoc);
            //Coord += CoordLoc;
            //fltx4 flNoise128;
            //FourVectors fvNoise;
            //let fvNoise = vec3.clone(Coord);
            //fvNoise.DuplicateVector( Coord );
            //flNoise128 = NoiseSIMD( fvNoise , 0);
            //float flNoise = SubFloat( flNoise128, 0 );
            let flNoise = NoiseSIMD(Coord[0], Coord[1], Coord[2]);
            //*( (int *) &flNoise)  &= nAbsVal;
            if (this.#absVal) {
                flNoise = Math.abs(flNoise);
            }
            if (this.#absValInv) {
                flNoise = 1.0 - flNoise;
            }
            const flInitialNoise = (ValueBase + (ValueScale * flNoise));
            /*
            //TODO
            if ( ATTRIBUTES_WHICH_ARE_0_TO_1 & (1 << m_nFieldOutput ) )
            {
                flInitialNoise = clamp(flInitialNoise, 0.0f, 1.0f );
            }*/
            //*( pAttr ) = flInitialNoise;
            particle.setInitialField(this.fieldOutput, flInitialNoise);
        }
    }
}
RegisterSource2ParticleOperator('C_INIT_CreationNoise', CreationNoise);

const DEFAULT_SCALE$2 = 1; // TODO: check default value
const DEFAULT_FIELD_OUTPUT$7 = PARTICLE_FIELD_RADIUS; // TODO: check default value
const DEFAULT_INCREMENT = 1; // TODO: check default value
const DEFAULT_RANDOM_DISTRIBUTION = false; // TODO: check default value
const DEFAULT_RANDOM_SEED$2 = 0; // TODO: check default value
class InheritFromParentParticles extends Operator {
    #scale = DEFAULT_SCALE$2;
    #fieldOutput = DEFAULT_FIELD_OUTPUT$7;
    #increment = DEFAULT_INCREMENT;
    #randomDistribution = false;
    #randomSeed = 0;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_flScale':
                this.#scale = param.getValueAsNumber() ?? DEFAULT_SCALE$2;
                break;
            case 'm_nIncrement':
                this.#increment = param.getValueAsNumber() ?? DEFAULT_INCREMENT;
                break;
            case 'm_bRandomDistribution':
                this.#randomDistribution = param.getValueAsBool() ?? DEFAULT_RANDOM_DISTRIBUTION;
                break;
            case 'm_nRandomSeed':
                this.#randomSeed = param.getValueAsNumber() ?? DEFAULT_RANDOM_SEED$2;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doInit(particle, elapsedTime, strength) {
        //TODO: use m_flScale m_nIncrement m_bRandomDistribution m_nRandomSeed
        const parentSystem = this.system.parentSystem;
        if (parentSystem) {
            const parentParticle = parentSystem.getParticle(particle.id - 1);
            if (parentParticle) {
                particle.setField(this.#fieldOutput, parentParticle.getField(this.#fieldOutput));
            }
        }
    }
}
RegisterSource2ParticleOperator('C_INIT_InheritFromParentParticles', InheritFromParentParticles);

class InitFloat extends Operator {
    #setMethod = '';
    constructor(system) {
        super(system);
        this.fieldOutput = PARTICLE_FIELD_RADIUS;
    }
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_InputValue':
                // Used in doInit
                break;
            /*
            case 'm_nOutputField':
                console.error('do this param', paramName, param);
                this.#fieldOutput = param.getValueAsNumber() ?? PARTICLE_FIELD_RADIUS;
                break;
            */
            case 'm_nSetMethod': //TODO: mutualize
                this.#setMethod = param.getValueAsString() ?? '';
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doInit(particle, elapsedTime, strength) {
        const value = this.getParamScalarValue('m_InputValue', particle);
        //TODO: use setMethod
        particle.setField(this.fieldOutput, value, this.#setMethod == 'PARTICLE_SET_SCALE_INITIAL_VALUE', true);
        //setField(field = 0, value, mulInitial = false, setInitial = false, additive = false) {
    }
}
RegisterSource2ParticleOperator('C_INIT_InitFloat', InitFloat);

const DEFAULT_PARTICLE_TEXTURE = 'materials/particle/base_sprite.vtex';
const ATTRIBUTE_NAME_PER_FIELD = ['position', 'lifespan', 'position', 'radius', , , 'color'];

/*
export const PARTICLE_FIELD_LIFETIME = 1;
export const PARTICLE_FIELD_POSITION_PREVIOUS = 2;
export const PARTICLE_FIELD_RADIUS = 3;
export const PARTICLE_FIELD_ROTATION_ROLL = 4;
export const PARTICLE_FIELD_ROTATION_ROLL_SPEED = 5;
export const PARTICLE_FIELD_COLOR = 6;
export const PARTICLE_FIELD_ALPHA = 7;
export const PARTICLE_FIELD_CREATION_TIME = 8;
export const PARTICLE_FIELD_SEQUENCE_NUMBER = 9;
export const PARTICLE_FIELD_TRAIL_LENGTH = 10;
export const PARTICLE_FIELD_PARTICLE_ID = 11;
export const PARTICLE_FIELD_YAW = 12;
export const PARTICLE_FIELD_SEQUENCE_NUMBER_2 = 13;
export const PARTICLE_FIELD_HITBOX_INDEX = 14;
export const PARTICLE_FIELD_HITBOX_OFFSET_POSITION = 15;
export const PARTICLE_FIELD_ALPHA_ALTERNATE = 16;
export const PARTICLE_FIELD_SCRATCH_VECTOR = 17;
export const PARTICLE_FIELD_SCRATCH_FLOAT = 18;
export const PARTICLE_FIELD_NONE = 19;
export const PARTICLE_FIELD_PITCH = 20;
export const PARTICLE_FIELD_NORMAL = 21;
export const PARTICLE_FIELD_GLOW_RGB = 22;
export const PARTICLE_FIELD_GLOW_ALPHA = 23;
export const PARTICLE_FIELD_SCRATCH_FLOAT_1 = 26;
export const PARTICLE_FIELD_SCRATCH_FLOAT_2 = 27;
export const PARTICLE_FIELD_SCRATCH_VECTOR2 = 30;
export const PARTICLE_FIELD_BONE_INDICE = 31;
export const PARTICLE_FIELD_BONE_WEIGHT = 32;
export const PARTICLE_FIELD_PARENT_PARTICLE_INDEX = 33;
export const PARTICLE_FIELD_FORCE_SCALE = 34;
export const PARTICLE_FIELD_MANUAL_ANIMATION_FRAME = 38;
export const PARTICLE_FIELD_SHADER_EXTRA_DATA_1 = 39;
export const PARTICLE_FIELD_SHADER_EXTRA_DATA_2 = 40;
*/
const v$c = vec3.create();
const DEFAULT_ATTRIBUTE_TO_READ = -1; // TODO: check default value
const DEFAULT_ATTRIBUTE_TO_WRITE = PARTICLE_FIELD_POSITION; // TODO: check default value
const DEFAULT_LOCAL_SPACE_CP$1 = 0; // TODO: check default value
const DEFAULT_RANDOM$1 = false; // TODO: check default value
const DEFAULT_REVERSE = false; // TODO: check default value
const DEFAULT_RANDOM_SEED$1 = 0; // TODO: check default value
const DEFAULT_LOCAL_SPACE_ANGLES = false; // TODO: check default value
class InitFromCPSnapshot extends Operator {
    #attributeToRead = DEFAULT_ATTRIBUTE_TO_READ;
    #attributeToWrite = DEFAULT_ATTRIBUTE_TO_WRITE;
    #localSpaceCP = DEFAULT_LOCAL_SPACE_CP$1;
    #random = DEFAULT_RANDOM$1;
    #reverse = DEFAULT_REVERSE;
    #randomSeed = DEFAULT_RANDOM_SEED$1;
    #localSpaceAngles = DEFAULT_LOCAL_SPACE_ANGLES;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_nAttributeToRead':
                this.#attributeToRead = param.getValueAsNumber() ?? DEFAULT_ATTRIBUTE_TO_READ;
                break;
            case 'm_nAttributeToWrite':
                this.#attributeToWrite = param.getValueAsNumber() ?? DEFAULT_ATTRIBUTE_TO_WRITE;
                break;
            case 'm_nLocalSpaceCP':
                this.#localSpaceCP = param.getValueAsNumber() ?? DEFAULT_LOCAL_SPACE_CP$1;
                break;
            case 'm_bRandom':
                this.#random = param.getValueAsBool() ?? DEFAULT_RANDOM$1;
                break;
            case 'm_bReverse':
                this.#reverse = param.getValueAsBool() ?? DEFAULT_REVERSE;
                break;
            case 'm_nRandomSeed':
                this.#randomSeed = param.getValueAsNumber() ?? DEFAULT_RANDOM_SEED$1;
                break;
            case 'm_bLocalSpaceAngles':
                this.#localSpaceAngles = param.getValueAsBool() ?? DEFAULT_LOCAL_SPACE_ANGLES;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doInit(particle, elapsedTime, strength) {
        if (this.#attributeToRead == -1) {
            return;
        }
        const system = this.system;
        const snapshot = system.getControlPoint(this.controlPointNumber)?.snapshot;
        if (snapshot) {
            const attributeToReadName = ATTRIBUTE_NAME_PER_FIELD[this.#attributeToRead]; //TODO: check this.#attributeToRead range
            const attributeToRead = snapshot.attributes[attributeToReadName];
            if (attributeToRead) {
                let id;
                if (this.#random) {
                    id = (snapshot.particleCount * Math.random() << 0) % snapshot.particleCount;
                }
                else {
                    id = (particle.id - 1) % snapshot.particleCount;
                }
                if (this.#attributeToWrite == PARTICLE_FIELD_POSITION) {
                    const localSpaceCP = system.getControlPoint(this.#localSpaceCP);
                    if (localSpaceCP) {
                        //TODO: check attributeToRead[id] is actually a vector
                        //TODO: only transform position when this.localSpaceAngles = true
                        {
                            vec3.transformMat4(v$c, attributeToRead[id], localSpaceCP.currentWorldTransformation);
                        }
                        particle.setInitialField(this.#attributeToWrite, v$c);
                    }
                }
                else {
                    particle.setInitialField(this.#attributeToWrite, attributeToRead[id]);
                }
            }
        }
    }
}
RegisterSource2ParticleOperator('C_INIT_InitFromCPSnapshot', InitFromCPSnapshot);

vec3.create();
vec3.fromValues(1, 1, 1);
vec3.create();
vec3.fromValues(100000.5, 300000.25, 9000000.75);
vec3.fromValues(110000.25, 310000.75, 9100000.5);
vec3.create();
vec3.create();
vec3.create();
vec3.create();
vec3.create();
const DEFAULT_IGNORE_DT$3 = false;
class InitialVelocityNoise extends Operator {
    #absVal = vec3.create();
    #absValInv = vec3.create();
    #localSpace = false;
    #ignoreDt = DEFAULT_IGNORE_DT$3;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_vecAbsVal':
                param.getValueAsVec3(this.#absVal);
                break;
            case 'm_vecAbsValInv':
                param.getValueAsVec3(this.#absValInv);
                break;
            case 'm_bLocalSpace': //TODO: put this param in Operator ?
                this.#localSpace = param.getValueAsBool() ?? false;
                break;
            case 'm_bIgnoreDt':
                this.#ignoreDt = param.getValueAsBool() ?? DEFAULT_IGNORE_DT$3;
                break;
            //TODO: m_TransformInput
            case 'm_vecOutputMin':
            case 'm_vecOutputMax':
            case 'm_vecOffsetLoc':
            case 'm_flOffset':
            case 'm_flNoiseScale':
            case 'm_flNoiseScaleLoc':
                //used in doInit
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doInit(particle, elapsedTime, strength) {
        //TODO: use m_vecOffsetLoc, m_vecOutputMin,m_vecOutputMax,  m_flOffset, m_flNoiseScale, m_flNoiseScaleLoc
        //TODO: fix this operator
        /*

        const outputMin = this.getParamVectorValue('m_vecOutputMin') ?? DEFAULT_OUTPUT_MIN;
        const outputMax = this.getParamVectorValue('m_vecOutputMax') ?? DEFAULT_OUTPUT_MAX;
        const offsetLoc = this.getParamVectorValue('m_vecOffsetLoc') ?? DEFAULT_OFFSET_LOC;
        const offset = this.getParamScalarValue('m_flOffset') ?? 0;
        const noiseScale = this.getParamScalarValue('m_flNoiseScale') ?? 1;
        const noiseScaleLoc = this.getParamScalarValue('m_flNoiseScaleLoc') ?? 0.01;


        //let nAbsValX = 0xffffffff;
        //let nAbsValY = 0xffffffff;
        //let nAbsValZ = 0xffffffff;
        let flAbsScaleX = 0.5;
        let flAbsScaleY = 0.5;
        let flAbsScaleZ = 0.5;
        // Set up single if check for absolute value inversion inside the loop
        const m_bNoiseAbs = (this.#absValInv[0] != 0.0) || (this.#absValInv[1] != 0.0) || (this.#absValInv[2] != 0.0);
        // Set up values for more optimal absolute value calculations inside the loop
        if (this.#absVal[0] != 0.0) {
            //nAbsValX = 0x7fffffff;
            flAbsScaleX = 1.0;
        }
        if (this.#absVal[1] != 0.0) {
            //nAbsValY = 0x7fffffff;
            flAbsScaleY = 1.0;
        }
        if (this.#absVal[2] != 0.0) {
            //nAbsValZ = 0x7fffffff;
            flAbsScaleZ = 1.0;
        }

        //float ValueScaleX, ValueScaleY, ValueScaleZ, ValueBaseX, ValueBaseY, ValueBaseZ;

        const ValueScaleX = flAbsScaleX * (outputMax[0] - outputMin[0]);
        const ValueBaseX = outputMin[0] + ((1.0 - flAbsScaleX) * (outputMax[0] - outputMin[0]));

        const ValueScaleY = (flAbsScaleY * (outputMax[1] - outputMin[1]));
        const ValueBaseY = (outputMin[1] + ((1.0 - flAbsScaleY) * (outputMax[1] - outputMin[1])));

        const ValueScaleZ = (flAbsScaleZ * (outputMax[2] - outputMin[2]));
        const ValueBaseZ = (outputMin[2] + ((1.0 - flAbsScaleZ) * (outputMax[2] - outputMin[2])));


        //float CoordScale = m_flNoiseScale;
        //float CoordScaleLoc = m_flNoiseScaleLoc;

        //for( ; nParticleCount--; start_p++ )
        {
            //const float *xyz = pParticles->GetFloatAttributePtr( PARTICLE_ATTRIBUTE_XYZ, start_p );
            //float *pxyz = pParticles->GetFloatAttributePtrForWrite( PARTICLE_ATTRIBUTE_PREV_XYZ, start_p );
            //const float *pCreationTime = pParticles->GetFloatAttributePtr( PARTICLE_ATTRIBUTE_CREATION_TIME, start_p );

            //Vector Coord, Coord2, Coord3, CoordLoc;
            //SetVectorFromAttribute( CoordLoc, xyz );
            //CoordLoc += m_vecOffsetLoc;
            vec3.add(CoordLoc, particle.position, offsetLoc);

            //float Offset = m_flOffset;
            const a = (particle.cTime + offset) * noiseScale;
            //Coord = Vector ( (*pCreationTime + Offset), (*pCreationTime + Offset), (*pCreationTime + Offset) );
            vec3.set(Coord, a, a, a);

            //Coord *= CoordScale;
            //CoordLoc *= CoordScaleLoc;
            vec3.scale(CoordLoc, CoordLoc, noiseScaleLoc);
            //Coord += CoordLoc;
            vec3.add(Coord, Coord, CoordLoc);

            //Coord2 = ( Coord );
            vec3.add(Coord2, Coord, ofs_y);
            //Coord3 = ( Coord );
            vec3.add(Coord3, Coord, ofs_z);

            //fltx4 flNoise128;
            //FourVectors fvNoise;

            /*fvNoise.DuplicateVector( Coord );
            flNoise128 = NoiseSIMD( fvNoise );
            float flNoiseX = SubFloat( flNoise128, 0 );* /
            let flNoiseX = NoiseSIMD(Coord, 0, 0);

            /*fvNoise.DuplicateVector( Coord2 + ofs_y );
            flNoise128 = NoiseSIMD( fvNoise );
            float flNoiseY = SubFloat( flNoise128, 0 );* /
            let flNoiseY = NoiseSIMD(Coord2, 0, 0);

            /*fvNoise.DuplicateVector( Coord3 + ofs_z );
            flNoise128 = NoiseSIMD( fvNoise );
            float flNoiseZ = SubFloat( flNoise128, 0 );* /
            let flNoiseZ = NoiseSIMD(Coord3, 0, 0);

            //*( (int *) &flNoiseX)  &= nAbsValX;
            //*( (int *) &flNoiseY)  &= nAbsValY;
            //*( (int *) &flNoiseZ)  &= nAbsValZ;
            if (this.#absVal[0]) {
                flNoiseX = Math.abs(flNoiseX);
            }

            if (this.#absVal[1]) {
                flNoiseY = Math.abs(flNoiseY);
            }

            if (this.#absVal[2]) {
                flNoiseZ = Math.abs(flNoiseZ);
            }

            if (m_bNoiseAbs) {
                if (this.#absValInv[0] != 0.0) {
                    flNoiseX = 1.0 - flNoiseX;
                }

                if (this.#absValInv[1] != 0.0) {
                    flNoiseY = 1.0 - flNoiseY;
                }
                if (this.#absValInv[2] != 0.0) {
                    flNoiseZ = 1.0 - flNoiseZ;
                }
            }

            //Vector poffset;
            poffset[0] = (ValueBaseX + (ValueScaleX * flNoiseX)) * elapsedTime;
            poffset[1] = (ValueBaseY + (ValueScaleY * flNoiseY)) * elapsedTime;
            poffset[2] = (ValueBaseZ + (ValueScaleZ * flNoiseZ)) * elapsedTime;

            //poffset *= pParticles->m_flPreviousDt;

            if (this.#localSpace) {
                /*				matrix3x4_t mat;
                                pParticles->GetControlPointTransformAtTime( m_nControlPointNumber, *pCreationTime, &mat );
                                Vector vecTransformLocal = vec3_origin;
                                VectorRotate( poffset, mat, vecTransformLocal );
                                poffset = vecTransformLocal;* /
                const cp = this.system.getControlPoint(this.controlPointNumber);
                if (cp) {
                    vec3.transformQuat(poffset, poffset, cp.getWorldQuaternion());
                    //vec3.add(randpos, randpos, cp.getWorldPosition(vec));
                }
            }
            /*pxyz[0] -= poffset.x;
            pxyz[4] -= poffset.y;
            pxyz[8] -= poffset.z;* /
            vec3.sub(particle.prevPosition, particle.prevPosition, poffset);
        }
        */
    }
    initMultipleOverride() {
        return true;
    }
}
RegisterSource2ParticleOperator('C_INIT_InitialVelocityNoise', InitialVelocityNoise);

const mat$1 = mat4.create();
const nmat$2 = mat3.create();
const IDENTITY_MAT4$1 = mat4.create();
const DEFAULT_SNAPSHOT_CONTROL_POINT_NUMBER = 1;
const DEFAULT_RANDOM = false;
const DEFAULT_RANDOM_SEED = 0;
const DEFAULT_RIGID$1 = false;
const DEFAULT_SET_NORMAL = false;
const DEFAULT_IGNORE_DT$2 = false;
const DEFAULT_MIN_NORMAL_VELOCITY = 0;
const DEFAULT_MAX_NORMAL_VELOCITY = 0;
const DEFAULT_INDEX_TYPE = Source2ParticleSnapshotReadType.Increment;
const DEFAULT_BONE_VELOCITY = 0;
const DEFAULT_BONE_VELOCITY_MAX = 0;
const DEFAULT_COPY_COLOR = false;
const DEFAULT_COPY_ALPHA = false;
const DEFAULT_COPY_RADIUS = false;
class InitSkinnedPositionFromCPSnapshot extends Operator {
    #rigidOnce = false;
    #snapshotControlPointNumber = DEFAULT_SNAPSHOT_CONTROL_POINT_NUMBER;
    #random = DEFAULT_RANDOM;
    #randomSeed = DEFAULT_RANDOM_SEED;
    #rigid = DEFAULT_RIGID$1; //prepare for rigid lock
    #setNormal = DEFAULT_SET_NORMAL;
    #ignoreDt = DEFAULT_IGNORE_DT$2; //normal velocity ignore delta time
    #minNormalVelocity = DEFAULT_MIN_NORMAL_VELOCITY;
    #maxNormalVelocity = DEFAULT_MAX_NORMAL_VELOCITY;
    #indexType = DEFAULT_INDEX_TYPE;
    #boneVelocity = DEFAULT_BONE_VELOCITY;
    #boneVelocityMax = DEFAULT_BONE_VELOCITY_MAX;
    #copyColor = DEFAULT_COPY_COLOR;
    #copyAlpha = DEFAULT_COPY_ALPHA;
    #copyRadius = DEFAULT_COPY_RADIUS;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_nSnapshotControlPointNumber':
                this.#snapshotControlPointNumber = param.getValueAsNumber() ?? DEFAULT_SNAPSHOT_CONTROL_POINT_NUMBER;
                break;
            case 'm_bRandom':
                this.#random = param.getValueAsBool() ?? DEFAULT_RANDOM;
                break;
            case 'm_nRandomSeed':
                this.#randomSeed = param.getValueAsNumber() ?? DEFAULT_RANDOM_SEED;
                break;
            case 'm_bRigid':
                this.#rigid = param.getValueAsBool() ?? DEFAULT_RIGID$1;
                break;
            case 'm_bSetNormal':
                this.#setNormal = param.getValueAsBool() ?? DEFAULT_SET_NORMAL;
                break;
            case 'm_bIgnoreDt':
                this.#ignoreDt = param.getValueAsBool() ?? DEFAULT_IGNORE_DT$2;
                break;
            case 'm_flMinNormalVelocity':
                this.#minNormalVelocity = param.getValueAsNumber() ?? DEFAULT_MIN_NORMAL_VELOCITY;
                break;
            case 'm_flMaxNormalVelocity':
                this.#maxNormalVelocity = param.getValueAsNumber() ?? DEFAULT_MAX_NORMAL_VELOCITY;
                break;
            case 'm_nIndexType':
                this.#indexType = stringToSnapshotReadType(param.getValueAsString()) ?? DEFAULT_INDEX_TYPE;
                break;
            case 'm_flBoneVelocity':
                this.#boneVelocity = param.getValueAsNumber() ?? DEFAULT_BONE_VELOCITY;
                break;
            case 'm_flBoneVelocityMax':
                this.#boneVelocityMax = param.getValueAsNumber() ?? DEFAULT_BONE_VELOCITY_MAX;
                break;
            case 'm_bCopyColor':
                this.#copyColor = param.getValueAsBool() ?? DEFAULT_COPY_COLOR;
                break;
            case 'm_bCopyAlpha':
                this.#copyAlpha = param.getValueAsBool() ?? DEFAULT_COPY_ALPHA;
                break;
            case 'm_bCopyRadius':
                this.#copyRadius = param.getValueAsBool() ?? DEFAULT_COPY_RADIUS;
                break;
            case 'm_flReadIndex':
                //used in doInit
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doInit(particle, elapsedTime, strength) {
        //TODO: use all parameters
        //use  m_flReadIndex
        const system = this.system;
        const snapshot = system.getControlPoint(this.#snapshotControlPointNumber)?.snapshot;
        if (!snapshot) {
            return;
        }
        const cp = system.getControlPoint(this.controlPointNumber);
        if (!cp) {
            return;
        }
        /*let attributeToReadName = ATTRIBUTE_NAME_PER_FIELD[this.attributeToRead];
        if (TESTING && attributeToReadName === undefined) {
            throw 'Unknown field';
        }*/
        let attributeId;
        if (this.#random) {
            attributeId = (snapshot.particleCount * Math.random() << 0) % snapshot.particleCount;
        }
        else {
            attributeId = (particle.id - 1) % snapshot.particleCount;
        }
        const positionAttribute = snapshot.attributes['position'];
        if (!positionAttribute) {
            return;
        }
        const position = positionAttribute[attributeId];
        particle.setInitialField(PARTICLE_FIELD_POSITION, position);
        particle.initialSkinnedPosition = position;
        const skinningAttribute = snapshot.attributes['skinning'];
        if (skinningAttribute) {
            particle.skinning = skinningAttribute[attributeId];
        }
        const hitboxAttribute = snapshot.attributes['hitbox'];
        if (hitboxAttribute) {
            particle.snapHitbox = hitboxAttribute[attributeId];
            console.error('particle.snapHitbox = hitboxAttribute[attributeId];');
        }
        const hitboxOffsetAttribute = snapshot.attributes['hitbox_offset'];
        if (hitboxOffsetAttribute) {
            particle.snapHitboxOffset = hitboxOffsetAttribute[attributeId];
            console.error('particle.snapHitboxOffset = hitboxOffsetAttribute[attributeId];');
        }
        if (this.#rigid) {
            return;
        }
        let bone, boneName, boneWeight, boneMat;
        const model = cp.model;
        if (!model) {
            return;
        }
        const skeleton = model.skeleton;
        if (!skeleton) {
            return;
        }
        const particleSkinning = particle.skinning;
        const particleInitialPosition = particle.initialSkinnedPosition;
        const particleInitialNormal = particle.initialSkinnedNormal ?? DEFAULT_PARTICLE_NORMAL;
        if (particleInitialPosition) {
            if (particleSkinning) {
                mat$1[0] = 0;
                mat$1[1] = 0;
                mat$1[2] = 0;
                mat$1[4] = 0;
                mat$1[5] = 0;
                mat$1[6] = 0;
                mat$1[8] = 0;
                mat$1[9] = 0;
                mat$1[10] = 0;
                mat$1[12] = 0;
                mat$1[13] = 0;
                mat$1[14] = 0;
                for (let i = 0; i < 4; ++i) {
                    boneName = particleSkinning.bones[i];
                    if (boneName) {
                        bone = skeleton.getBoneByName(boneName);
                        boneWeight = particleSkinning.weights[i];
                        if (bone && boneWeight) {
                            boneMat = bone ? bone.boneMat : IDENTITY_MAT4$1;
                            mat$1[0] += boneWeight * boneMat[0];
                            mat$1[1] += boneWeight * boneMat[1];
                            mat$1[2] += boneWeight * boneMat[2];
                            mat$1[4] += boneWeight * boneMat[4];
                            mat$1[5] += boneWeight * boneMat[5];
                            mat$1[6] += boneWeight * boneMat[6];
                            mat$1[8] += boneWeight * boneMat[8];
                            mat$1[9] += boneWeight * boneMat[9];
                            mat$1[10] += boneWeight * boneMat[10];
                            mat$1[12] += boneWeight * boneMat[12];
                            mat$1[13] += boneWeight * boneMat[13];
                            mat$1[14] += boneWeight * boneMat[14];
                        }
                    }
                }
                //console.error(mat);
                vec3.transformMat4(particle.position, particleInitialPosition, mat$1);
                mat3.normalFromMat4(nmat$2, mat$1);
                vec3.transformMat3(particle.normal, particleInitialNormal, nmat$2);
                vec3.copy(particle.prevPosition, particle.position);
            }
            else {
                //Probably should do it better, but it just works
                const particleHitbox = particle.snapHitbox;
                particle.snapHitboxOffset;
                if (particleHitbox) {
                    bone = skeleton.getBoneByName(particleHitbox);
                    if (bone) {
                        boneMat = bone ? bone.boneMat : IDENTITY_MAT4$1;
                        vec3.transformMat4(particle.position, particleInitialPosition, boneMat);
                        mat3.normalFromMat4(nmat$2, boneMat);
                        vec3.transformMat3(particle.normal, particleInitialNormal, nmat$2);
                        vec3.copy(particle.prevPosition, particle.position);
                    }
                }
            }
        }
    }
}
RegisterSource2ParticleOperator('C_INIT_InitSkinnedPositionFromCPSnapshot', InitSkinnedPositionFromCPSnapshot);
/*

            m_flReadIndex =
            {
                m_nType = "PF_TYPE_LITERAL"
                m_nMapType = "PF_MAP_TYPE_DIRECT"
                m_flLiteralValue = 1.0
                m_NamedValue = ""
                m_nControlPoint = 0
                m_nScalarAttribute = 3
                m_nVectorAttribute = 6
                m_nVectorComponent = 0
                m_flRandomMin = 0.0
                m_flRandomMax = 1.0
                m_bHasRandomSignFlip = false
                m_nRandomSeed = -1
                m_nRandomMode = "PF_RANDOM_MODE_CONSTANT"
                m_flLOD0 = 0.0
                m_flLOD1 = 0.0
                m_flLOD2 = 0.0
                m_flLOD3 = 0.0
                m_nNoiseInputVectorAttribute = 0
                m_flNoiseOutputMin = 0.0
                m_flNoiseOutputMax = 1.0
                m_flNoiseScale = 0.1
                m_vecNoiseOffsetRate = [ 0.0, 0.0, 0.0 ]
                m_flNoiseOffset = 0.0
                m_nNoiseOctaves = 1
                m_nNoiseTurbulence = "PF_NOISE_TURB_NONE"
                m_nNoiseType = "PF_NOISE_TYPE_PERLIN"
                m_nNoiseModifier = "PF_NOISE_MODIFIER_NONE"
                m_flNoiseTurbulenceScale = 1.0
                m_flNoiseTurbulenceMix = 0.5
                m_flNoiseImgPreviewScale = 1.0
                m_bNoiseImgPreviewLive = true
                m_flNoCameraFallback = 0.0
                m_bUseBoundsCenter = false
                m_nInputMode = "PF_INPUT_MODE_CLAMPED"
                m_flMultFactor = 1.0
                m_flInput0 = 0.0
                m_flInput1 = 1.0
                m_flOutput0 = 0.0
                m_flOutput1 = 1.0
                m_flNotchedRangeMin = 0.0
                m_flNotchedRangeMax = 1.0
                m_flNotchedOutputOutside = 0.0
                m_flNotchedOutputInside = 1.0
                m_nRoundType = "PF_ROUND_TYPE_NEAREST"
                m_nBiasType = "PF_BIAS_TYPE_STANDARD"
                m_flBiasParameter = 0.0
                m_Curve =
                {
                    m_spline = [  ]
                    m_tangents = [  ]
                    m_vDomainMins = [ 0.0, 0.0 ]
                    m_vDomainMaxs = [ 0.0, 0.0 ]
                }
            }
                */

const DEFAULT_INPUT_VALUE = vec3.create();
const initVecTempVec4 = vec4.create();
const DEFAULT_FIELD_OUTPUT$6 = PARTICLE_FIELD_COLOR; // TODO: check default value
const DEFAULT_SET_METHOD$4 = 'PARTICLE_SET_SCALE_INITIAL_VALUE'; // TODO: check default value
const DEFAULT_SCALE_INITIAL_RANGE$2 = false; // TODO: check default value
class InitVec extends Operator {
    #setMethod = DEFAULT_SET_METHOD$4;
    #scaleInitialRange = DEFAULT_SCALE_INITIAL_RANGE$2;
    #fieldOutput = DEFAULT_FIELD_OUTPUT$6;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_InputValue':
                // used in doInit
                break;
            case 'm_nOutputField': // TODO: mutualize
                this.#fieldOutput = param.getValueAsNumber() ?? DEFAULT_FIELD_OUTPUT$6;
                break;
            case 'm_nSetMethod': // TODO: mutualize
                this.#setMethod = param.getValueAsString() ?? DEFAULT_SET_METHOD$4;
                break;
            case 'm_bScaleInitialRange':
                this.#scaleInitialRange = param.getValueAsBool() ?? DEFAULT_SCALE_INITIAL_RANGE$2;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doInit(particle, elapsedTime, strength) {
        const inputValue = this.getParamVectorValue(initVecTempVec4, 'm_InputValue', particle) ?? DEFAULT_INPUT_VALUE;
        particle.setField(this.#fieldOutput, inputValue, this.#scaleInitialRange || this.#setMethod == 'PARTICLE_SET_SCALE_INITIAL_VALUE');
    }
}
RegisterSource2ParticleOperator('C_INIT_InitVec', InitVec);

//Notice this is not the default particle normal.
//This operator change the default normal from +Z to +X
const DEFAULT_NORMAL = vec3.fromValues(1, 0, 0);
class NormalAlignToCP extends Operator {
    _paramChanged(paramName, param) {
        switch (paramName) {
            default:
                super._paramChanged(paramName, param);
        }
    }
    doInit(particle, elapsedTime, strength) {
        //This operator overrides the normal
        const cp = this.system.getControlPoint(this.controlPointNumber);
        if (cp) {
            //cp.getWorldTransformation(particle.cpPreviousTransform);
            vec3.transformQuat(particle.normal, DEFAULT_NORMAL, cp.currentWorldQuaternion);
        }
    }
}
RegisterSource2ParticleOperator('C_INIT_NormalAlignToCP', NormalAlignToCP);

const v$b = vec3.create();
const DEFAULT_LOCAL_COORDS$1 = false; // TODO: check default value
const DEFAULT_NORMALIZE = false; // TODO: check default value
class NormalOffset extends Operator {
    #offsetMin = vec3.create(); // TODO: check default value
    #offsetMax = vec3.create(); // TODO: check default value
    #localCoords = DEFAULT_LOCAL_COORDS$1; // TODO: check default value
    #normalize = DEFAULT_NORMALIZE; // TODO: check default value
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_OffsetMin':
                param.getValueAsVec3(this.#offsetMin);
                break;
            case 'm_OffsetMax':
                param.getValueAsVec3(this.#offsetMax);
                break;
            case 'm_bLocalCoords':
                this.#localCoords = param.getValueAsBool() ?? DEFAULT_LOCAL_COORDS$1;
                break;
            case 'm_bNormalize':
                this.#normalize = param.getValueAsBool() ?? DEFAULT_NORMALIZE;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doInit(particle, elapsedTime, strength) {
        vec3RandomBox(v$b, this.#offsetMin, this.#offsetMax);
        if (this.#localCoords) {
            const cp = this.system.getControlPoint(this.controlPointNumber);
            vec3.transformQuat(v$b, v$b, cp.currentWorldQuaternion);
        }
        vec3.add(particle.normal, particle.normal, v$b);
        if (this.#normalize) {
            vec3.normalize(particle.normal, particle.normal);
        }
    }
    initMultipleOverride() {
        return true;
    }
}
RegisterSource2ParticleOperator('C_INIT_NormalOffset', NormalOffset);

const DEFAULT_OFFSET$3 = vec3.create();
const DEFAULT_LOCAL_COORDS = false;
const DEFAULT_PROPORTIONAL$4 = false;
const offset$1 = vec3.create();
class PositionOffset extends Operator {
    #localCoords = DEFAULT_LOCAL_COORDS;
    #proportional = DEFAULT_PROPORTIONAL$4;
    #offsetMin = vec4.create();
    #offsetMax = vec4.create();
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_OffsetMin':
            case 'm_OffsetMax':
                // used in doInit
                break;
            case 'm_bLocalCoords':
                this.#localCoords = param.getValueAsBool() ?? DEFAULT_LOCAL_COORDS;
                break;
            case 'm_bProportional': //TODO: mutualize ?
                this.#proportional = param.getValueAsBool() ?? DEFAULT_PROPORTIONAL$4;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doInit(particle, elapsedTime, strength) {
        // TODO: use m_bProportional
        const offsetMin = this.getParamVectorValue(this.#offsetMin, 'm_OffsetMin', particle) ?? DEFAULT_OFFSET$3;
        const offsetMax = this.getParamVectorValue(this.#offsetMax, 'm_OffsetMax', particle) ?? DEFAULT_OFFSET$3;
        vec3RandomBox(offset$1, offsetMin, offsetMax);
        if (this.#localCoords) {
            const cp = particle.system.getControlPoint(this.controlPointNumber);
            if (cp) {
                vec3.transformQuat(offset$1, offset$1, cp.getWorldQuaternion());
            }
        }
        vec3.add(particle.position, particle.position, offset$1);
        vec3.add(particle.prevPosition, particle.prevPosition, offset$1);
    }
    initMultipleOverride() {
        return true;
    }
}
RegisterSource2ParticleOperator('C_INIT_PositionOffset', PositionOffset);

const v$a = vec3.create();
const DEFAULT_SCALE_CONTROL_POINT_NUMBER = -1; // TODO: check default value
const DEFAULT_RADIUS_COMPONENT = -1; // TODO: check default value
const DEFAULT_WARP_TIME = 0; // TODO: check default value
const DEFAULT_WARP_START_TIME = 0; // TODO: check default value
const DEFAULT_PREV_POS_SCALE$2 = 1; // TODO: check default value
const DEFAULT_INVERT_WARP = false; // TODO: check default value
const DEFAULT_USE_COUNT = false; // TODO: check default value
class PositionWarp extends Operator {
    #warpMin = vec3.fromValues(1, 1, 1); // TODO: check default value
    #warpMax = vec3.fromValues(1, 1, 1); // TODO: check default value
    #scaleControlPointNumber = DEFAULT_SCALE_CONTROL_POINT_NUMBER;
    #radiusComponent = DEFAULT_RADIUS_COMPONENT;
    #warpTime = DEFAULT_WARP_TIME;
    #warpStartTime = DEFAULT_WARP_START_TIME;
    #prevPosScale = DEFAULT_PREV_POS_SCALE$2;
    #invertWarp = DEFAULT_INVERT_WARP;
    #useCount = DEFAULT_USE_COUNT;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_vecWarpMin':
                param.getValueAsVec3(this.#warpMin);
                break;
            case 'm_vecWarpMax':
                param.getValueAsVec3(this.#warpMax);
                break;
            case 'm_nScaleControlPointNumber':
                this.#scaleControlPointNumber = param.getValueAsNumber() ?? DEFAULT_SCALE_CONTROL_POINT_NUMBER;
                break;
            case 'm_nRadiusComponent':
                this.#radiusComponent = param.getValueAsNumber() ?? DEFAULT_RADIUS_COMPONENT; //TODO: check [-1 0 1 2]
                break;
            case 'm_flWarpTime':
                this.#warpTime = param.getValueAsNumber() ?? DEFAULT_WARP_TIME;
                break;
            case 'm_flWarpStartTime':
                this.#warpStartTime = param.getValueAsNumber() ?? DEFAULT_WARP_START_TIME;
                break;
            case 'm_flPrevPosScale':
                this.#prevPosScale = param.getValueAsNumber() ?? DEFAULT_PREV_POS_SCALE$2;
                break;
            case 'm_bInvertWarp':
                this.#invertWarp = param.getValueAsBool() ?? DEFAULT_INVERT_WARP;
                break;
            case 'm_bUseCount':
                this.#useCount = param.getValueAsBool() ?? DEFAULT_USE_COUNT;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doInit(particle, elapsedTime, strength) {
        //TODO: use time parameters, m_bUseCount
        vec3RandomBox(v$a, this.#warpMin, this.#warpMax);
        if (this.#scaleControlPointNumber != -1) {
            const scaleCp = this.system.getControlPoint(this.#scaleControlPointNumber);
            if (scaleCp) {
                vec3.mul(v$a, v$a, scaleCp._position); //Not sure if it's position or world position
            }
        }
        if (this.#radiusComponent != -1) {
            particle.radius *= v$a[this.#radiusComponent] ?? 1;
        }
        vec3.mul(particle.position, particle.position, v$a);
        vec3.mul(particle.prevPosition, particle.prevPosition, v$a);
        if (this.#prevPosScale != -1) {
            vec3.scale(particle.prevPosition, particle.prevPosition, this.#prevPosScale);
        }
    }
}
RegisterSource2ParticleOperator('C_INIT_PositionWarp', PositionWarp);

class RadiusFromCPObject extends Operator {
    doInit(particle, elapsedTime, strength) {
        //TODO:  I don't really know what it is supposed to do
    }
}
RegisterSource2ParticleOperator('C_INIT_RadiusFromCPObject', RadiusFromCPObject);

const randomColorTempVec4 = vec4.create();
const DEFAULT_UPDATE_THRESHOLD = 32; // TODO: check default value
const DEFAULT_TINT_CP = 0; // TODO: check default value
const DEFAULT_LIGHT_AMPLIFICATION = 1; // TODO: check default value
const DEFAULT_TINT_PERC = 0; // TODO: check default value
const DEFAULT_TINT_BLEND_MODE = Source2ParticleTintBlendMode.Replace; // TODO: check default value
class RandomColor extends Operator {
    #colorMin = vec4.fromValues(1, 1, 1, 1); // TODO: check default value
    #colorMax = vec4.fromValues(1, 1, 1, 1); // TODO: check default value
    #tintMin = vec3.fromValues(0, 0, 0); // TODO: check default value
    #tintMax = vec3.fromValues(1, 1, 1); // TODO: check default value
    #updateThreshold = DEFAULT_UPDATE_THRESHOLD;
    #tintCP = DEFAULT_TINT_CP;
    #tintBlendMode = DEFAULT_TINT_BLEND_MODE;
    #lightAmplification = DEFAULT_LIGHT_AMPLIFICATION;
    #tintPerc = DEFAULT_TINT_PERC;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_ColorMin':
                //console.error('do this param', paramName, param);
                //vec3.set(this.#colorMin, Number(param[0]) / 255, Number(param[1]) / 255, Number(param[2]) / 255);
                if (param.getValueAsVec4(randomColorTempVec4)) {
                    vec4.scale(this.#colorMin, randomColorTempVec4, 1 / 255);
                }
                break;
            case 'm_ColorMax':
                if (param.getValueAsVec4(randomColorTempVec4)) {
                    vec4.scale(this.#colorMax, randomColorTempVec4, 1 / 255);
                }
                break;
            case 'm_TintMin':
                if (param.getValueAsVec3(this.#tintMin)) {
                    vec3.scale(this.#tintMin, this.#tintMin, 1 / 255);
                }
                break;
            case 'm_TintMax':
                if (param.getValueAsVec3(this.#tintMax)) {
                    vec3.scale(this.#tintMax, this.#tintMax, 1 / 255);
                }
                break;
            case 'm_flUpdateThreshold':
                this.#updateThreshold = param.getValueAsNumber() ?? DEFAULT_UPDATE_THRESHOLD;
                break;
            case 'm_nTintCP':
                this.#tintCP = param.getValueAsNumber() ?? DEFAULT_TINT_CP;
                break;
            case 'm_nTintBlendMode':
                this.#tintBlendMode = stringToTintBlendMode(param.getValueAsString()) ?? DEFAULT_TINT_BLEND_MODE;
                break;
            case 'm_flLightAmplification':
                this.#lightAmplification = param.getValueAsNumber() ?? DEFAULT_LIGHT_AMPLIFICATION;
                break;
            case 'm_flTintPerc':
                this.#tintPerc = param.getValueAsNumber() ?? DEFAULT_TINT_PERC;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doInit(particle, elapsedTime, strength) {
        //TODO: use tint
        const rand = Math.random();
        vec4.lerp(particle.color, this.#colorMin, this.#colorMax, rand);
        vec4.copy(particle.initialColor, particle.color);
    }
}
RegisterSource2ParticleOperator('C_INIT_RandomColor', RandomColor);

const DEFAULT_SEQUENCE_MIN = 0; // TODO: check default value
const DEFAULT_SEQUENCE_MAX = 0; // TODO: check default value
class RandomSecondSequence extends Operator {
    #sequenceMin = DEFAULT_SEQUENCE_MIN;
    #sequenceMax = DEFAULT_SEQUENCE_MAX;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_nSequenceMin':
                this.#sequenceMin = param.getValueAsNumber() ?? DEFAULT_SEQUENCE_MIN;
                break;
            case 'm_nSequenceMax':
                this.#sequenceMax = param.getValueAsNumber() ?? DEFAULT_SEQUENCE_MAX;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doInit(particle, elapsedTime, strength) {
        particle.sequence2 = Math.round((this.#sequenceMax - this.#sequenceMin) * Math.random()) + this.#sequenceMin;
    }
}
RegisterSource2ParticleOperator('C_INIT_RandomSecondSequence', RandomSecondSequence);

class RandomSequence extends Operator {
    #sequenceMin = 0;
    #sequenceMax = 0;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_nSequenceMin':
                this.#sequenceMin = param.getValueAsNumber() ?? 0;
                break;
            case 'm_nSequenceMax':
                this.#sequenceMax = param.getValueAsNumber() ?? 0;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doInit(particle, elapsedTime, strength) {
        particle.setInitialSequence(Math.round((this.#sequenceMax - this.#sequenceMin) * Math.random()) + this.#sequenceMin);
    }
}
RegisterSource2ParticleOperator('C_INIT_RandomSequence', RandomSequence);

const DEFAULT_PERCENT = 0.5;
class RandomYawFlip extends Operator {
    #percent = DEFAULT_PERCENT;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_flPercent':
                this.#percent = param.getValueAsNumber() ?? DEFAULT_PERCENT;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doInit(particle, elapsedTime, strength) {
        particle.rotationYaw += (Math.random() < this.#percent) ? Math.PI : 0;
    }
    initMultipleOverride() {
        return true;
    }
}
RegisterSource2ParticleOperator('C_INIT_RandomYawFlip', RandomYawFlip);

const v$9 = vec3.create();
const v1 = vec3.fromValues(1, 1, 1);
const DEFAULT_CP_INPUT$2 = 0; // TODO: check default value
const DEFAULT_START_TIME$1 = -1; // TODO: check default value
const DEFAULT_END_TIME$1 = -1; // TODO: check default value
const DEFAULT_SET_METHOD$3 = 'PARTICLE_SET_SCALE_INITIAL_VALUE'; // TODO: check default value
const DEFAULT_OFFSET$2 = false; // TODO: check default value
const DEFAULT_ACCELERATE = false; // TODO: check default value
const DEFAULT_LOCAL_SPACE_CP = -1; // TODO: check default value
const DEFAULT_REMAP_BIAS$1 = 0.5; // TODO: check default value
const DEFAULT_SCALE_INITIAL_RANGE$1 = false; // TODO: check default value
const DEFAULT_FIELD_OUTPUT$5 = PARTICLE_FIELD_POSITION; // TODO: check default value
class RemapCPtoVector extends Operator {
    #cpInput = DEFAULT_CP_INPUT$2;
    #inputMin = vec3.create(); // TODO: check default value
    #inputMax = vec3.create(); // TODO: check default value
    #outputMin = vec3.create(); // TODO: check default value
    #outputMax = vec3.create(); // TODO: check default value
    #startTime = DEFAULT_START_TIME$1;
    #endTime = DEFAULT_END_TIME$1;
    #setMethod = DEFAULT_SET_METHOD$3;
    #offset = DEFAULT_OFFSET$2;
    #accelerate = DEFAULT_ACCELERATE;
    #localSpaceCP = DEFAULT_LOCAL_SPACE_CP;
    #remapBias = DEFAULT_REMAP_BIAS$1;
    #scaleInitialRange = DEFAULT_SCALE_INITIAL_RANGE$1; // TODO: search default value
    #fieldOutput = DEFAULT_FIELD_OUTPUT$5;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_nCPInput':
                this.#cpInput = param.getValueAsNumber() ?? DEFAULT_CP_INPUT$2;
                break;
            case 'm_vInputMin':
                param.getValueAsVec3(this.#inputMin);
                break;
            case 'm_vInputMax':
                param.getValueAsVec3(this.#inputMax);
                break;
            case 'm_vOutputMin':
                param.getValueAsVec3(this.#outputMin);
                break;
            case 'm_vOutputMax':
                param.getValueAsVec3(this.#outputMax);
                break;
            case 'm_flStartTime':
                console.error('do this param', paramName, param);
                this.#startTime = param.getValueAsNumber() ?? DEFAULT_START_TIME$1;
                break;
            case 'm_flEndTime':
                this.#endTime = param.getValueAsNumber() ?? DEFAULT_END_TIME$1;
                break;
            case 'm_nSetMethod':
                this.#setMethod = param.getValueAsString() ?? DEFAULT_SET_METHOD$3;
                break;
            case 'm_bOffset':
                this.#offset = param.getValueAsBool() ?? DEFAULT_OFFSET$2;
                break;
            case 'm_bAccelerate':
                this.#accelerate = param.getValueAsBool() ?? DEFAULT_ACCELERATE;
                break;
            case 'm_nLocalSpaceCP':
                console.error('do this param', paramName, param);
                this.#localSpaceCP = param.getValueAsNumber() ?? DEFAULT_LOCAL_SPACE_CP;
                break;
            case 'm_flRemapBias':
                this.#remapBias = param.getValueAsNumber() ?? DEFAULT_REMAP_BIAS$1;
                break;
            case 'm_bScaleInitialRange':
                this.#scaleInitialRange = param.getValueAsBool() ?? DEFAULT_SCALE_INITIAL_RANGE$1;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doInit(particle, elapsedTime, strength) {
        //TODO: use missing parameters
        const inputMin = this.#inputMin;
        const inputMax = this.#inputMax;
        const outputMin = this.#outputMin;
        const outputMax = this.#outputMax;
        const input = this.system.getControlPoint(this.#cpInput).currentWorldPosition;
        v$9[0] = RemapValClampedBias(input[0], inputMin[0], inputMax[0], outputMin[0], outputMax[0], this.#remapBias);
        v$9[1] = RemapValClampedBias(input[1], inputMin[1], inputMax[1], outputMin[1], outputMax[1], this.#remapBias);
        v$9[2] = RemapValClampedBias(input[2], inputMin[2], inputMax[2], outputMin[2], outputMax[2], this.#remapBias);
        const scaleInitial = this.#scaleInitialRange || this.#setMethod == 'PARTICLE_SET_SCALE_INITIAL_VALUE'; //TODO: optimize
        if (scaleInitial) {
            vec3.lerp(v$9, v1, v$9, strength);
        }
        else {
            vec3.lerp(v$9, particle.getField(this.#fieldOutput), v$9, strength);
        }
        particle.setField(this.#fieldOutput, v$9, scaleInitial);
    }
}
RegisterSource2ParticleOperator('C_INIT_RemapCPtoVector', RemapCPtoVector);

const DEFAULT_INPUT_MIN$4 = 0;
const DEFAULT_INPUT_MAX$4 = 10;
const DEFAULT_SCALE_CONTROL_POINT$1 = -1; // TODO: check default value
const DEFAULT_SCALE_CONTROL_POINT_FIELD = -1; // TODO: check default value
const DEFAULT_OUTPUT_MIN$5 = 0; // TODO: check default value
const DEFAULT_OUTPUT_MAX$5 = 1; // TODO: check default value
const DEFAULT_ACTIVE_RANGE$1 = false; // TODO: check default value
const DEFAULT_INVERT = false; // TODO: check default value
const DEFAULT_WRAP = false; // TODO: check default value
const DEFAULT_REMAP_BIAS = 0.5; // TODO: check default value
class RemapParticleCountToScalar extends Operator {
    #inputMin = DEFAULT_INPUT_MIN$4;
    #inputMax = DEFAULT_INPUT_MAX$4;
    #scaleControlPoint = DEFAULT_SCALE_CONTROL_POINT$1;
    #scaleControlPointField = DEFAULT_SCALE_CONTROL_POINT_FIELD;
    #outputMin = DEFAULT_OUTPUT_MIN$5;
    #outputMax = DEFAULT_OUTPUT_MAX$5;
    #activeRange = DEFAULT_ACTIVE_RANGE$1;
    #invert = DEFAULT_INVERT;
    #wrap = DEFAULT_WRAP;
    remapBias = DEFAULT_REMAP_BIAS;
    //#fieldOutput = PARTICLE_FIELD_RADIUS;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_nInputMin':
                this.#inputMin = param.getValueAsNumber() ?? DEFAULT_INPUT_MIN$4;
                break;
            case 'm_nInputMax':
                this.#inputMax = param.getValueAsNumber() ?? DEFAULT_INPUT_MAX$4;
                break;
            case 'm_nScaleControlPoint':
                this.#scaleControlPoint = param.getValueAsNumber() ?? DEFAULT_SCALE_CONTROL_POINT$1;
                break;
            case 'm_nScaleControlPointField':
                this.#scaleControlPointField = param.getValueAsNumber() ?? DEFAULT_SCALE_CONTROL_POINT_FIELD;
                break;
            case 'm_flOutputMin':
                this.#outputMin = param.getValueAsNumber() ?? DEFAULT_OUTPUT_MIN$5;
                break;
            case 'm_flOutputMax':
                this.#outputMax = param.getValueAsNumber() ?? DEFAULT_OUTPUT_MAX$5;
                break;
            case 'm_bActiveRange':
                this.#activeRange = param.getValueAsBool() ?? DEFAULT_ACTIVE_RANGE$1;
                break;
            case 'm_bInvert':
                this.#invert = param.getValueAsBool() ?? DEFAULT_INVERT;
                break;
            case 'm_bWrap':
                this.#wrap = param.getValueAsBool() ?? DEFAULT_WRAP;
                break;
            case 'm_flRemapBias':
                this.remapBias = param.getValueAsNumber() ?? DEFAULT_REMAP_BIAS;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doInit(particle, elapsedTime, strength) {
        //TODO: use bias, invert m_nScaleControlPointField parameters
        let value = particle.id;
        if (this.#wrap) {
            value = value % (this.#inputMax + 1);
        }
        if (this.#activeRange && (value < this.#inputMin || value > this.#inputMax)) {
            return;
        }
        value = RemapValClampedBias(value, this.#inputMin, this.#inputMax, this.#outputMin, this.#outputMax, this.remapBias);
        particle.setField(this.fieldOutput, value, this.setMethod == 'PARTICLE_SET_SCALE_INITIAL_VALUE');
    }
}
RegisterSource2ParticleOperator('C_INIT_RemapParticleCountToScalar', RemapParticleCountToScalar);

const va = vec3.create();
const o = vec3.create();
const DEFAULT_EVEN_DISTRIBUTION = false; // TODO: check default value
const DEFAULT_XY_VELOCITY_ONLY = true; // TODO: check default value
class RingWave extends Operator {
    #evenDistribution = DEFAULT_EVEN_DISTRIBUTION;
    #xyVelocityOnly = DEFAULT_XY_VELOCITY_ONLY;
    t = 0;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_flParticlesPerOrbit':
            case 'm_flInitialRadius':
            case 'm_flThickness':
            case 'm_flInitialSpeedMin':
            case 'm_flInitialSpeedMax':
            case 'm_flRoll':
            case 'm_flPitch':
            case 'm_flYaw':
                break;
            case 'm_bEvenDistribution':
                this.#evenDistribution = param.getValueAsBool() ?? DEFAULT_EVEN_DISTRIBUTION;
                break;
            case 'm_bXYVelocityOnly':
                this.#xyVelocityOnly = param.getValueAsBool() ?? DEFAULT_XY_VELOCITY_ONLY;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doInit(particle, elapsedTime, strength) {
        //TODO: use all parameters
        const particlesPerOrbit = this.getParamScalarValue('m_flParticlesPerOrbit') ?? -1; //even distribution count
        const initialRadius = this.getParamScalarValue('m_flInitialRadius') ?? 0;
        this.getParamScalarValue('m_flThickness') ?? 0;
        this.getParamScalarValue('m_flInitialSpeedMin') ?? 0;
        this.getParamScalarValue('m_flInitialSpeedMax') ?? 0;
        const roll = this.getParamScalarValue('m_flRoll') ?? 0;
        const pitch = this.getParamScalarValue('m_flPitch') ?? 0;
        const yaw = this.getParamScalarValue('m_flYaw') ?? 0;
        let theta;
        if (this.#evenDistribution) {
            const step = particlesPerOrbit == -1 ? TWO_PI / this.system.livingParticles.length : TWO_PI / particlesPerOrbit;
            this.t += step;
            theta = this.t;
        }
        else {
            theta = Math.random() * TWO_PI;
        }
        vec3.set(va, initialRadius * Math.cos(theta), initialRadius * Math.sin(theta), 0);
        if (roll) {
            vec3.rotateX(va, va, o, roll * DEG_TO_RAD);
        }
        if (pitch) {
            vec3.rotateY(va, va, o, pitch * DEG_TO_RAD);
        }
        if (yaw) {
            vec3.rotateZ(va, va, o, yaw * DEG_TO_RAD);
        }
        const controlPoint = this.system.getControlPoint(this.controlPointNumber);
        if (controlPoint) {
            vec3.transformMat4(va, va, controlPoint.currentWorldTransformation);
        }
        vec3.copy(particle.position, va);
        vec3.copy(particle.prevPosition, va);
    }
}
RegisterSource2ParticleOperator('C_INIT_RingWave', RingWave);

class SequenceLifeTime extends Operator {
    doInit(particle, elapsedTime, strength) {
        //TODO: I don't know what to do
    }
}
RegisterSource2ParticleOperator('C_INIT_SequenceLifeTime', SequenceLifeTime);

const v$8 = vec3.create();
const DEFAULT_LOCAL_SPACE$2 = true; // TODO: check default value
class SetRigidAttachment extends Operator {
    #localSpace = DEFAULT_LOCAL_SPACE$2;
    #fieldOutput = PARTICLE_FIELD_POSITION_PREVIOUS;
    #fieldInput = PARTICLE_FIELD_POSITION;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_bLocalSpace':
                this.#localSpace = param.getValueAsBool() ?? DEFAULT_LOCAL_SPACE$2;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doInit(particle, elapsedTime, strength) {
        //TODO : use m_bLocalSpace
        if (!this.#localSpace) {
            throw 'code me';
        }
        vec3.sub(v$8, particle.getVectorField(v$8, this.#fieldInput), this.system.getControlPoint(this.controlPointNumber).currentWorldPosition);
        particle.setField(this.#fieldOutput, v$8);
    }
}
RegisterSource2ParticleOperator('C_INIT_SetRigidAttachment', SetRigidAttachment);

const DEFAULT_SPEED = vec3.create();
const randomVector = vec3.create();
const tempVec3$2 = vec3.create();
const velocityRandomTempVec4_0 = vec4.create();
const velocityRandomTempVec4_1 = vec4.create();
const DEFAULT_IGNORE_DT$1 = false; // TODO: check default value
class VelocityRandom extends Operator {
    #ignoreDT = DEFAULT_IGNORE_DT$1;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_LocalCoordinateSystemSpeedMin':
            case 'm_LocalCoordinateSystemSpeedMax':
            case 'm_fSpeedMin':
            case 'm_fSpeedMax':
                // used in doInit
                break;
            case 'm_bIgnoreDT':
                this.#ignoreDT = param.getValueAsBool() ?? DEFAULT_IGNORE_DT$1;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doInit(particle, elapsedTime, strength) {
        const localCoordinateSystemSpeedMin = this.getParamVectorValue(velocityRandomTempVec4_0, 'm_LocalCoordinateSystemSpeedMin', particle) ?? DEFAULT_SPEED;
        const localCoordinateSystemSpeedMax = this.getParamVectorValue(velocityRandomTempVec4_1, 'm_LocalCoordinateSystemSpeedMax', particle) ?? DEFAULT_SPEED;
        const speedMin = this.getParamScalarValue('m_fSpeedMin') ?? 0;
        const speedMax = this.getParamScalarValue('m_fSpeedMax') ?? 0;
        const randomSpeed = (speedMax - speedMin) * Math.random() + speedMin;
        if (vec3.exactEquals(localCoordinateSystemSpeedMin, DEFAULT_SPEED) &&
            vec3.exactEquals(localCoordinateSystemSpeedMax, DEFAULT_SPEED)) {
            vec3.random(randomVector);
        }
        else {
            vec3RandomBox(randomVector, localCoordinateSystemSpeedMin, localCoordinateSystemSpeedMax);
        }
        if (randomSpeed != 0) {
            vec3.random(tempVec3$2, randomSpeed);
            vec3.add(randomVector, randomVector, tempVec3$2);
        }
        const cp = particle.system.getControlPoint(this.controlPointNumber);
        if (cp) {
            vec3.transformQuat(randomVector, randomVector, cp.getWorldQuaternion());
        }
        if (!this.#ignoreDT) {
            vec3.scale(randomVector, randomVector, -elapsedTime);
        }
        vec3.add(particle.prevPosition, particle.prevPosition, randomVector);
    }
    initMultipleOverride() {
        return true;
    }
}
RegisterSource2ParticleOperator('C_INIT_VelocityRandom', VelocityRandom);

const DEFAULT_MAX_CONSTRAINTS_PASSES = 3;
vec3.create();
class BasicMovement extends Operator {
    #gravity = vec3.create();
    #drag = 0;
    #maxConstraintPasses = DEFAULT_MAX_CONSTRAINTS_PASSES;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_Gravity':
                param.getValueAsVec3(this.#gravity); //TODO: default gravity ?
                break;
            case 'm_fDrag':
                this.#drag = param.getValueAsNumber() ?? 0;
                break;
            case 'm_nMaxConstraintPasses':
                this.#maxConstraintPasses = param.getValueAsNumber() ?? DEFAULT_MAX_CONSTRAINTS_PASSES;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        /*if (particle.id == 5) {
            console.error(particle.prevPosition, particle.position);
        }*/
        const adj_dt = (elapsedTime / this.system.previousElapsedTime) * ExponentialDecay((1.0 - Math.max(0.0, this.#drag)), (1.0 / 30.0), elapsedTime);
        const accumulatedForces = vec3.clone(this.#gravity);
        for (const force of this.system.forces.values()) {
            force.forceParticle(particle, elapsedTime, accumulatedForces);
        }
        const accFactor = vec3.scale(vec3.create(), accumulatedForces, elapsedTime * elapsedTime);
        const vecTemp = vec3.sub(vec3.create(), particle.position, particle.prevPosition);
        vec3.scale(vecTemp, vecTemp, adj_dt);
        vec3.add(vecTemp, vecTemp, accFactor);
        vec3.copy(particle.prevPosition, particle.position);
        vec3.add(particle.position, particle.position, vecTemp);
        this.system.stepConstraints(particle);
    }
}
RegisterSource2ParticleOperator('C_OP_BasicMovement', BasicMovement);

/*
const DEFAULT_IGNORE_DELTA = false;// TODO: check default value
const DEFAULT_INPUT_MIN = 0;// TODO: check default value
const DEFAULT_INPUT_MAX = 1;// TODO: check default value
const DEFAULT_SET_METHOD = 'PARTICLE_SET_SCALE_CURRENT_VALUE';// TODO: check default value
*/
const DEFAULT_OUTPUT_MIN$4 = 0;
const DEFAULT_OUTPUT_MAX$4 = 1;
class ClampScalar extends Operator {
    #outputMin = DEFAULT_OUTPUT_MIN$4;
    #outputMax = DEFAULT_OUTPUT_MAX$4;
    /*
    #ignoreDelta = DEFAULT_IGNORE_DELTA;
    #inputMin = DEFAULT_INPUT_MIN;
    #inputMax = DEFAULT_INPUT_MAX;
    #setMethod = DEFAULT_SET_METHOD;
    */
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_flOutputMin': //TODO: mutualize
                this.#outputMin = param.getValueAsNumber() ?? DEFAULT_OUTPUT_MIN$4;
                break;
            case 'm_flOutputMax': //TODO: mutualize
                this.#outputMax = param.getValueAsNumber() ?? DEFAULT_OUTPUT_MAX$4;
                break;
            /*
            case 'm_bIgnoreDelta':
                this.#ignoreDelta = param.getValueAsBool() ?? DEFAULT_IGNORE_DELTA;
                break;
            case 'm_flInputMin':
                this.#inputMin = param.getValueAsNumber() ?? DEFAULT_INPUT_MIN;
                break;
            case 'm_flInputMax':
                this.#inputMin = param.getValueAsNumber() ?? DEFAULT_INPUT_MAX;
                break;
            case 'm_nSetMethod':
                this.#setMethod = param.getValueAsString() ?? DEFAULT_SET_METHOD;
                break;
                */
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        //TODO
    }
}
RegisterSource2ParticleOperator('C_OP_ClampScalar', ClampScalar);

const colorInterpolateTempVec4 = vec4.create();
const DEFAULT_FADE_START_TIME = 0; // TODO: check default value
const DEFAULT_FADE_END_TIME = 1; // TODO: check default value
const DEFAULT_EASE_IN_AND_OUT$1 = false; // TODO: check default value
class ColorInterpolate extends Operator {
    #colorFade = vec4.fromValues(1, 1, 1, 1); // TODO: check default value
    #fadeStartTime = DEFAULT_FADE_START_TIME;
    #fadeEndTime = DEFAULT_FADE_END_TIME;
    #easeInAndOut = DEFAULT_EASE_IN_AND_OUT$1;
    #invTime = 1; //computed
    constructor(system) {
        super(system);
        this.#update();
    }
    #update() {
        this.#invTime = 1.0 / (this.#fadeEndTime - this.#fadeStartTime);
    }
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_ColorFade':
                if (param.getValueAsVec4(colorInterpolateTempVec4)) {
                    vec4.scale(this.#colorFade, colorInterpolateTempVec4, 1 / 255);
                }
                break;
            case 'm_flFadeStartTime':
                this.#fadeStartTime = param.getValueAsNumber() ?? DEFAULT_FADE_START_TIME;
                this.#update();
                break;
            case 'm_flFadeEndTime':
                this.#fadeEndTime = param.getValueAsNumber() ?? DEFAULT_FADE_END_TIME;
                this.#update();
                break;
            case 'm_bEaseInAndOut': //TODO: check thoses params m_bEaseInAndOut and m_bEaseInOut
                //case 'm_bEaseInOut':
                this.#easeInAndOut = param.getValueAsBool() ?? DEFAULT_EASE_IN_AND_OUT$1;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        vec3.clone(particle.initialColor); //TODO: optimize
        const proportionOfLife = Math.min(particle.currentTime / particle.timeToLive, 1.0);
        if (proportionOfLife < this.#fadeStartTime) {
            return;
        }
        if (proportionOfLife < this.#fadeEndTime) {
            const a = (proportionOfLife - this.#fadeStartTime) * this.#invTime;
            vec3.lerp(particle.color, particle.initialColor, this.#colorFade, a);
            return;
        }
        vec4.copy(particle.color, this.#colorFade);
    }
}
RegisterSource2ParticleOperator('C_OP_ColorInterpolate', ColorInterpolate);

const v$7 = vec3.create();
const DEFAULT_RANGE$1 = 100; // TODO: check default value
const DEFAULT_SCALE$1 = 100; // TODO: check default value
class DampenToCP extends Operator {
    #range = DEFAULT_RANGE$1;
    #scale = DEFAULT_SCALE$1;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_flRange':
                this.#range = param.getValueAsNumber() ?? DEFAULT_RANGE$1;
                break;
            case 'm_flScale':
                this.#scale = param.getValueAsNumber() ?? DEFAULT_SCALE$1;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        // TODO: use m_flScale
        const cp = this.system.getControlPoint(this.controlPointNumber);
        const distance = vec3.distance(particle.position, cp.currentWorldPosition);
        if (distance > this.#range) {
            return;
        }
        else {
            const dampenAmount = distance / this.#range;
            vec3.sub(v$7, particle.position, particle.prevPosition);
            vec3.scale(v$7, v$7, dampenAmount);
            vec3.add(particle.position, particle.prevPosition, v$7);
            //TODO: operator strength
        }
    }
}
RegisterSource2ParticleOperator('C_OP_DampenToCP', DampenToCP);

const vec$3 = vec3.create();
const DEFAULT_DISTANCE = 0; // TODO: check default value
const DEFAULT_CULL_INSIDE = false; // TODO: check default value
class DistanceCull extends Operator {
    #pointOffset = vec3.create(); // TODO: check default value
    #distance = DEFAULT_DISTANCE;
    #cullInside = DEFAULT_CULL_INSIDE;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_nControlPoint': // TODO: mutualize ?
                this.controlPointNumber = param.getValueAsNumber() ?? DEFAULT_CONTROL_POINT_NUMBER;
                break;
            case 'm_vecPointOffset':
                param.getValueAsVec3(this.#pointOffset);
                break;
            case 'm_flDistance':
                this.#distance = param.getValueAsNumber() ?? 0;
                break;
            case 'm_bCullInside':
                this.#cullInside = param.getValueAsBool() ?? DEFAULT_CULL_INSIDE;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        const cp = this.system.getControlPoint(this.controlPointNumber);
        if (cp) {
            const origin = cp.getWorldPosition(vec$3);
            vec3.add(origin, origin, this.#pointOffset);
            if (this.#cullInside) { //TODO: improve this
                if (vec3.distance(particle.position, origin) < this.#distance) {
                    particle.die();
                }
            }
            else {
                if (vec3.distance(particle.position, origin) > this.#distance) {
                    particle.die();
                }
            }
        }
    }
}
RegisterSource2ParticleOperator('C_OP_DistanceCull', DistanceCull);

const DEFAULT_COMPONENT_SCALE = vec3.fromValues(1, 1, 1);
const distanceToCPTempVec4 = vec4.create();
const DEFAULT_INPUT_MIN$3 = 0; // TODO: check default value
const DEFAULT_INPUT_MAX$3 = 128; // TODO: check default value
const DEFAULT_OUTPUT_MIN$3 = 0; // TODO: check default value
const DEFAULT_OUTPUT_MAX$3 = 128; // TODO: check default value
const DEFAULT_LOS = true; // TODO: check default value
const DEFAULT_LOS_SCALE = 0; // TODO: check default value
const DEFAULT_COLLISION_GROUP_NAME$1 = ''; // TODO: check default value
const DEFAULT_MAX_TRACE_LENGTH$1 = -1; // TODO: check default value
const DEFAULT_ACTIVE_RANGE = false; // TODO: check default value
const DEFAULT_ADDITIVE$2 = false; // TODO: check default value
const DEFAULT_SCALE_INITIAL_RANGE = false; // TODO: check default value
const DEFAULT_START_CP = 0; // TODO: check default value
class DistanceToCP extends Operator {
    //#fieldOutput = PARTICLE_FIELD_RADIUS/*TODO: create enum*/;
    #inputMin = DEFAULT_INPUT_MIN$3;
    #inputMax = DEFAULT_INPUT_MAX$3;
    #outputMin = DEFAULT_OUTPUT_MIN$3;
    #outputMax = DEFAULT_OUTPUT_MAX$3;
    #startCP = DEFAULT_START_CP;
    #los = DEFAULT_LOS;
    #collisionGroupName = DEFAULT_COLLISION_GROUP_NAME$1;
    #maxTraceLength = DEFAULT_MAX_TRACE_LENGTH$1;
    #losScale = DEFAULT_LOS_SCALE;
    #setMethod;
    #activeRange = DEFAULT_ACTIVE_RANGE;
    #additive = DEFAULT_ADDITIVE$2;
    #scaleInitialRange = DEFAULT_SCALE_INITIAL_RANGE;
    #outputMin1 = 0; // computed
    #outputMax1 = 0; // computed
    #update() {
        if (ATTRIBUTES_WHICH_ARE_0_TO_1 & (1 << this.fieldOutput)) {
            this.#outputMin1 = clamp$1(this.#outputMin, 0, 1);
            this.#outputMax1 = clamp$1(this.#outputMax, 0, 1);
        }
        else {
            this.#outputMin1 = this.#outputMin;
            this.#outputMax1 = this.#outputMax;
        }
    }
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_vecComponentScale':
                throw `do this param ${paramName}`;
            case 'm_nFieldOutput':
                this.fieldOutput = param.getValueAsNumber() ?? PARTICLE_FIELD_RADIUS;
                this.#update();
                break;
            case 'm_flInputMin':
                this.#inputMin = param.getValueAsNumber() ?? 0;
                break;
            case 'm_flInputMax':
                this.#inputMax = param.getValueAsNumber() ?? DEFAULT_INPUT_MAX$3;
                break;
            case 'm_flOutputMin':
                this.#outputMin = param.getValueAsNumber() ?? 0;
                this.#update();
                break;
            case 'm_flOutputMax':
                this.#outputMax = param.getValueAsNumber() ?? 1;
                this.#update();
                break;
            case 'm_nStartCP':
                this.#startCP = param.getValueAsNumber() ?? 0;
                break;
            case 'm_bLOS':
                this.#los = param.getValueAsBool() ?? DEFAULT_LOS;
                break;
            case 'm_CollisionGroupName':
                this.#collisionGroupName = param.getValueAsString() ?? DEFAULT_COLLISION_GROUP_NAME$1;
                break;
            case 'm_flMaxTraceLength':
                this.#maxTraceLength = param.getValueAsNumber() ?? DEFAULT_MAX_TRACE_LENGTH$1;
                break;
            case 'm_flLOSScale':
                this.#losScale = param.getValueAsNumber() ?? DEFAULT_LOS_SCALE;
                break;
            case 'm_nSetMethod':
                this.#setMethod = param.getValueAsString();
                break;
            case 'm_bActiveRange':
                this.#activeRange = param.getValueAsBool() ?? DEFAULT_ACTIVE_RANGE;
                break;
            case 'm_bAdditive':
                this.#additive = param.getValueAsBool() ?? DEFAULT_ADDITIVE$2;
                break;
            case 'm_bScaleInitialRange':
                this.#scaleInitialRange = param.getValueAsBool() ?? DEFAULT_SCALE_INITIAL_RANGE;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        //TODO: use setMethod
        this.getParamVectorValue(distanceToCPTempVec4, 'm_vecComponentScale', particle) ?? DEFAULT_COMPONENT_SCALE;
        const flMin = this.#outputMin1;
        const flMax = this.#outputMax1;
        /*if ( ATTRIBUTES_WHICH_ARE_0_TO_1 & ( 1 << m_nFieldOutput ) )
        {
            flMin = clamp(m_flOutputMin, 0.0f, 1.0f );
            flMax = clamp(m_flOutputMax, 0.0f, 1.0f );
        }*/
        //Vector vecControlPoint1 = pParticles->GetControlPointAtCurrentTime( m_nStartCP );
        const vecControlPoint1 = this.system.getControlPointPosition(this.#startCP);
        //let vecPosition2 = vec3.create();
        const vecDelta = vec3.create();
        const vecEndPoint = vec3.create();
        // FIXME: SSE-ize
        //for ( int i = 0; i < pParticles->m_nActiveParticles; ++i )
        {
            //Vector vecPosition2;
            //const float *pXYZ = pParticles->GetFloatAttributePtr(PARTICLE_ATTRIBUTE_XYZ, i );
            //vecPosition2 = Vector(pXYZ[0], pXYZ[4], pXYZ[8]);
            //vec3.copy(vecPosition2, particle.position);
            //Vector vecDelta = vecControlPoint1 - vecPosition2;
            vec3.sub(vecDelta, vecControlPoint1, particle.position);
            const flDistance = vec3.length(vecDelta); //vecDelta.Length();
            if (this.#activeRange && (flDistance < this.#inputMin || flDistance > this.#inputMax)) {
                return; //continue;
            }
            if (this.#los) {
                //Vector vecEndPoint = vecPosition2;
                vec3.copy(vecEndPoint, particle.position);
                if (this.#maxTraceLength != -1.0 && this.#maxTraceLength < flDistance) {
                    //VectorNormalize(vecEndPoint);
                    vec3.normalize(vecEndPoint, vecEndPoint);
                    //vecEndPoint *= m_flMaxTraceLength;
                    vec3.scale(vecEndPoint, vecEndPoint, this.#maxTraceLength);
                    //vecEndPoint += vecControlPoint1;
                    vec3.add(vecEndPoint, vecEndPoint, vecControlPoint1);
                }
                /*CBaseTrace tr;
                g_pParticleSystemMgr->Query()->TraceLine( vecControlPoint1, vecEndPoint, MASK_OPAQUE_AND_NPCS, NULL , m_nCollisionGroupNumber, &tr );
                if (tr.fraction != 1.0f)
                {
                    flDistance *= tr.fraction * m_flLOSScale;
                }*/
                //TODO
            }
            const flOutput = RemapValClamped(flDistance, this.#inputMin, this.#inputMax, flMin, flMax);
            /*if ( m_bScaleInitialRange )
            {
                const float *pInitialOutput = pParticles->GetInitialFloatAttributePtr( m_nFieldOutput, i );
                flOutput = *pInitialOutput * flOutput;
            }*/
            //float *pOutput = pParticles->GetFloatAttributePtrForWrite( m_nFieldOutput, i );
            //TODO: use m_nSetMethod m_bActiveRange m_bAdditive m_bScaleInitialRange
            let output = particle.getField(this.fieldOutput);
            //*pOutput = Lerp (flStrength, *pOutput, flOutput);
            output = lerp(output, flOutput, strength);
            particle.setField(this.fieldOutput, output);
            //float *pOutput = pParticles->GetFloatAttributePtrForWrite( m_nFieldOutput, i );
            //float flOutput = RemapValClamped( flDistance, m_flInputMin, m_flInputMax, flMin, flMax  );
            //*pOutput = Lerp (flStrength, *pOutput, flOutput);
        }
    }
}
RegisterSource2ParticleOperator('C_OP_DistanceToCP', DistanceToCP);

const DEFAULT_START_FADE_IN_TIME = 0;
const DEFAULT_END_FADE_IN_TIME = 0.5;
const DEFAULT_START_FADE_OUT_TIME$1 = 0.5;
const DEFAULT_END_FADE_OUT_TIME$1 = 1;
const DEFAULT_START_ALPHA = 1;
const DEFAULT_END_ALPHA = 0;
const DEFAULT_FORCE_PRESERVE_PARTICLE_ORDER = false;
class FadeAndKill extends Operator {
    #startFadeInTime = DEFAULT_START_FADE_IN_TIME;
    #endFadeInTime = DEFAULT_END_FADE_IN_TIME;
    #startFadeOutTime = DEFAULT_START_FADE_OUT_TIME$1;
    #endFadeOutTime = DEFAULT_END_FADE_OUT_TIME$1;
    #startAlpha = DEFAULT_START_ALPHA;
    #endAlpha = DEFAULT_END_ALPHA;
    #forcePreserveParticleOrder = DEFAULT_FORCE_PRESERVE_PARTICLE_ORDER;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_flStartFadeInTime':
                this.#startFadeInTime = param.getValueAsNumber() ?? DEFAULT_START_FADE_IN_TIME;
                break;
            case 'm_flEndFadeInTime':
                this.#endFadeInTime = param.getValueAsNumber() ?? DEFAULT_END_FADE_IN_TIME;
                break;
            case 'm_flStartFadeOutTime':
                this.#startFadeOutTime = param.getValueAsNumber() ?? DEFAULT_START_FADE_OUT_TIME$1;
                break;
            case 'm_flEndFadeOutTime':
                this.#endFadeOutTime = param.getValueAsNumber() ?? DEFAULT_END_FADE_OUT_TIME$1;
                break;
            case 'm_flStartAlpha':
                this.#startAlpha = param.getValueAsNumber() ?? DEFAULT_START_ALPHA;
                break;
            case 'm_flEndAlpha':
                this.#endAlpha = param.getValueAsNumber() ?? DEFAULT_END_ALPHA;
                break;
            case 'm_bForcePreserveParticleOrder':
                this.#forcePreserveParticleOrder = param.getValueAsBool() ?? DEFAULT_FORCE_PRESERVE_PARTICLE_ORDER;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        //TODO:use forcePreserveParticleOrder
        const startAlpha = this.#startAlpha;
        const endAlpha = this.#endAlpha;
        const startFadeInTime = this.#startFadeInTime;
        const endFadeInTime = this.#endFadeInTime;
        const startFadeOutTime = this.#startFadeOutTime;
        const endFadeOutTime = this.#endFadeOutTime;
        const proportionOfLife = particle.currentTime / particle.timeToLive;
        const fl4FadeInDuration = endFadeInTime - startFadeInTime;
        const fl4OOFadeInDuration = 1.0 / fl4FadeInDuration;
        const fl4FadeOutDuration = endFadeOutTime - startFadeOutTime;
        const fl4OOFadeOutDuration = 1.0 / fl4FadeOutDuration;
        let fl4Goal, fl4NewAlpha;
        switch (true) {
            case proportionOfLife <= startFadeInTime:
                break;
            case proportionOfLife < endFadeInTime:
                fl4Goal = particle.startAlpha * startAlpha;
                fl4NewAlpha = SimpleSplineRemapValWithDeltasClamped(proportionOfLife, startFadeInTime, fl4FadeInDuration, fl4OOFadeInDuration, fl4Goal, particle.startAlpha - fl4Goal);
                particle.alpha = fl4NewAlpha;
                break;
            case proportionOfLife < startFadeOutTime:
                break;
            case proportionOfLife < endFadeOutTime:
                fl4Goal = particle.startAlpha * endAlpha;
                fl4NewAlpha = SimpleSplineRemapValWithDeltasClamped(proportionOfLife, startFadeOutTime, fl4FadeOutDuration, fl4OOFadeOutDuration, particle.startAlpha, fl4Goal - particle.startAlpha);
                particle.alpha = fl4NewAlpha;
                break;
        }
        if (particle.timeToLive < particle.currentTime) {
            particle.die();
        }
    }
}
RegisterSource2ParticleOperator('C_OP_FadeAndKill', FadeAndKill);

const DEFAULT_FADE_IN_TIME_MIN = 0.25;
const DEFAULT_FADE_IN_TIME_MAX = 0.25;
const DEFAULT_FADE_IN_TIME_EXP = 1;
const DEFAULT_PROPORTIONAL$3 = true;
class FadeIn extends Operator {
    #fadeInTimeMin = DEFAULT_FADE_IN_TIME_MIN;
    #fadeInTimeMax = DEFAULT_FADE_IN_TIME_MAX;
    #fadeInTimeExp = DEFAULT_FADE_IN_TIME_EXP;
    #proportional = DEFAULT_PROPORTIONAL$3;
    //computed
    #fadeInTime = 0;
    #invFadeInTime = 0;
    constructor(system) {
        super(system);
        this.#update();
    }
    #update() {
        //TODO: this is wrong: must be done per particle
        this.#fadeInTime = RandomFloatExp(this.#fadeInTimeMin, this.#fadeInTimeMax, this.#fadeInTimeExp);
        this.#invFadeInTime = 1.0 / this.#fadeInTime;
    }
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_flFadeInTimeMin':
                this.#fadeInTimeMin = param.getValueAsNumber() ?? DEFAULT_FADE_IN_TIME_MIN;
                this.#update();
                break;
            case 'm_flFadeInTimeMax':
                this.#fadeInTimeMax = param.getValueAsNumber() ?? DEFAULT_FADE_IN_TIME_MAX;
                this.#update();
                break;
            case 'm_flFadeInTimeExp':
                this.#fadeInTimeExp = param.getValueAsNumber() ?? DEFAULT_FADE_IN_TIME_EXP;
                this.#update();
                break;
            case 'm_bProportional':
                this.#proportional = param.getValueAsBool() ?? DEFAULT_PROPORTIONAL$3;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        particle.alpha = SimpleSplineRemapValWithDeltasClamped(this.#proportional ? particle.currentTime / particle.timeToLive : particle.currentTime, 0, this.#fadeInTime, this.#invFadeInTime, 0, particle.startAlpha);
    }
}
RegisterSource2ParticleOperator('C_OP_FadeIn', FadeIn);

const DEFAULT_FADE_IN_TIME = 0.25; // TODO: check default value
class FadeInSimple extends Operator {
    #fadeInTime = DEFAULT_FADE_IN_TIME;
    #invFadeInTime;
    constructor(system) {
        super(system);
        this.#update();
    }
    #update() {
        this.#invFadeInTime = 1.0 / this.#fadeInTime;
    }
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_flFadeInTime':
                this.#fadeInTime = param.getValueAsNumber() ?? DEFAULT_FADE_IN_TIME;
                this.#update();
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        const proportionOfLife = particle.currentTime / particle.timeToLive;
        particle.alpha = SimpleSplineRemapValWithDeltasClamped(proportionOfLife, 0, this.#fadeInTime, this.#invFadeInTime, 0, particle.startAlpha);
        //TODO: use fieldOutput
    }
}
RegisterSource2ParticleOperator('C_OP_FadeInSimple', FadeInSimple);

const DEFAULT_FADE_OUT_TIME_MIN = 0.25;
const DEFAULT_FADE_OUT_TIME_MAX = 0.25;
const DEFAULT_FADE_OUT_TIME_EXP = 1;
const DEFAULT_FADE_BIAS = 0.5;
const DEFAULT_PROPORTIONAL$2 = true;
const DEFAULT_EASE_IN_AND_OUT = true;
class FadeOut extends Operator {
    #fadeOutTimeMin = DEFAULT_FADE_OUT_TIME_MIN;
    #fadeOutTimeMax = DEFAULT_FADE_OUT_TIME_MAX;
    #fadeOutTimeExp = DEFAULT_FADE_OUT_TIME_EXP;
    #fadeBias = DEFAULT_FADE_BIAS;
    #proportional = DEFAULT_PROPORTIONAL$2;
    #easeInAndOut = DEFAULT_EASE_IN_AND_OUT;
    //computed
    #fadeOutTime = 0;
    #startFadeOutTime = 0;
    #invFadeOutTime = 0;
    constructor(system) {
        super(system);
        this.#update();
    }
    #update() {
        //TODO: this is wrong: must be done per particle
        this.#fadeOutTime = RandomFloatExp(this.#fadeOutTimeMin, this.#fadeOutTimeMax, this.#fadeOutTimeExp);
        this.#startFadeOutTime = 1.0 - this.#fadeOutTime;
        this.#invFadeOutTime = 1.0 / this.#fadeOutTime;
    }
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_flFadeOutTimeMin':
                this.#fadeOutTimeMin = param.getValueAsNumber() ?? DEFAULT_FADE_OUT_TIME_MIN;
                this.#update();
                break;
            case 'm_flFadeOutTimeMax':
                this.#fadeOutTimeMax = param.getValueAsNumber() ?? DEFAULT_FADE_OUT_TIME_MAX;
                this.#update();
                break;
            case 'm_flFadeOutTimeExp':
                this.#fadeOutTimeExp = param.getValueAsNumber() ?? DEFAULT_FADE_OUT_TIME_EXP;
                this.#update();
                break;
            case 'm_flFadeBias':
                this.#fadeBias = param.getValueAsNumber() ?? DEFAULT_FADE_BIAS;
                this.#update();
                break;
            case 'm_bProportional':
                this.#proportional = param.getValueAsBool() ?? DEFAULT_PROPORTIONAL$2;
                break;
            case 'm_bEaseInAndOut':
                this.#easeInAndOut = param.getValueAsBool() ?? DEFAULT_EASE_IN_AND_OUT;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        //TODO: use fadeBias, easeInAndOut
        //particle.alpha = SimpleSplineRemapValWithDeltasClamped(this.proportional ? particle.currentTime / particle.timeToLive : particle.currentTime, 0, this.fadeInTime, this.invFadeInTime, 0, particle.startAlpha);
        particle.alpha = SimpleSplineRemapValWithDeltasClamped(this.#proportional ? particle.currentTime / particle.timeToLive : particle.currentTime, this.#startFadeOutTime, this.#fadeOutTime, this.#invFadeOutTime, particle.startAlpha, -particle.startAlpha);
        //TODO: if not proportional, set start time per particle
    }
}
RegisterSource2ParticleOperator('C_OP_FadeOut', FadeOut);

const DEFAULT_FADE_OUT_TIME = 0.25;
class FadeOutSimple extends Operator {
    fadeOutTime = DEFAULT_FADE_OUT_TIME;
    startFadeOutTime;
    invFadeOutTime;
    constructor(system) {
        super(system);
        this.#update();
    }
    #update() {
        this.startFadeOutTime = 1.0 - this.fadeOutTime;
        this.invFadeOutTime = 1.0 / this.fadeOutTime;
    }
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_flFadeOutTime':
                this.fadeOutTime = param.getValueAsNumber() ?? DEFAULT_FADE_OUT_TIME;
                this.#update();
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        particle.alpha = SimpleSplineRemapValWithDeltasClamped(particle.proportionOfLife, this.startFadeOutTime, this.fadeOutTime, this.invFadeOutTime, particle.startAlpha, -particle.startAlpha);
        //TODO: use fieldOutput
    }
}
RegisterSource2ParticleOperator('C_OP_FadeOutSimple', FadeOutSimple);

const DEFAULT_BIAS$1 = 0.5;
class InterpolateRadius extends Operator {
    #startTime = 0;
    #endTime = 1;
    #startScale = 1;
    #endScale = 1;
    #easeInAndOut = false;
    #bias = DEFAULT_BIAS$1;
    #invTime = 1;
    #biasParam = 1;
    #scaleWidth = 0;
    constructor(system) {
        super(system);
        this._update();
    }
    _update() {
        this.#invTime = 1.0 / (this.#endTime - this.#startTime);
        this.#biasParam = 1.0 / this.#bias - 2;
        this.#scaleWidth = this.#endScale - this.#startScale;
    }
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_flStartTime':
                this.#startTime = param.getValueAsNumber() ?? 0;
                this._update();
                break;
            case 'm_flEndTime':
                this.#endTime = param.getValueAsNumber() ?? 1;
                this._update();
                break;
            case 'm_flStartScale':
                this.#startScale = param.getValueAsNumber() ?? 1;
                this._update();
                break;
            case 'm_flEndScale':
                this.#endScale = param.getValueAsNumber() ?? 1;
                this._update();
                break;
            case 'm_bEaseInAndOut':
                this.#easeInAndOut = param.getValueAsBool() ?? false;
                break;
            case 'm_flBias':
                this.#bias = param.getValueAsNumber() ?? DEFAULT_BIAS$1;
                this._update();
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        const fl4LifeDuration = particle.timeToLive;
        let fl4GoodMask = CmpGtSIMD(fl4LifeDuration, 0);
        const fl4CurTime = this.system.currentTime;
        const fl4LifeTime = MulSIMD(SubSIMD(fl4CurTime, particle.cTime), ReciprocalEstSIMD(fl4LifeDuration)); // maybe need accurate div here?
        fl4GoodMask = AndSIMD(fl4GoodMask, CmpGeSIMD(fl4LifeTime, this.#startTime));
        fl4GoodMask = AndSIMD(fl4GoodMask, CmpLtSIMD(fl4LifeTime, this.#endTime));
        fl4GoodMask = (fl4LifeDuration > 0) && (fl4LifeTime >= this.#startTime) && (fl4LifeTime < this.#endTime);
        if (fl4GoodMask /* IsAnyNegative(fl4GoodMask) */) {
            let fl4FadeWindow = MulSIMD(SubSIMD(fl4LifeTime, this.#startTime), this.#invTime);
            if (this.#easeInAndOut) {
                fl4FadeWindow = AddSIMD(this.#startScale, MulSIMD(SimpleSpline(fl4FadeWindow), this.#scaleWidth));
            }
            else {
                if (this.#bias != 0.5) {
                    fl4FadeWindow = AddSIMD(this.#startScale, MulSIMD(BiasSIMD(fl4FadeWindow, this.#biasParam), this.#scaleWidth));
                }
                else {
                    fl4FadeWindow = AddSIMD(this.#startScale, MulSIMD(fl4FadeWindow, this.#scaleWidth));
                }
            }
            if (fl4GoodMask) {
                particle.radius = fl4FadeWindow * particle.initialRadius;
            }
        }
    }
}
RegisterSource2ParticleOperator('C_OP_InterpolateRadius', InterpolateRadius);

const DEFAULT_OUTPUT = 0; // TODO: check default value
const DEFAULT_LERP_TIME = 0; // TODO: check default value
class LerpEndCapScalar extends Operator {
    #output = DEFAULT_OUTPUT;
    #lerpTime = DEFAULT_OUTPUT;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_flOutput':
                this.#output = param.getValueAsNumber() ?? DEFAULT_OUTPUT;
                break;
            case 'm_flLerpTime':
                this.#lerpTime = param.getValueAsNumber() ?? DEFAULT_LERP_TIME;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        //TODO
    }
}
RegisterSource2ParticleOperator('C_OP_LerpEndCapScalar', LerpEndCapScalar);

class LifespanDecay extends Operator {
    doOperate(particle, elapsedTime, strength) {
        if (particle.timeToLive < particle.currentTime) {
            particle.die();
        }
    }
}
RegisterSource2ParticleOperator('C_OP_Decay', LifespanDecay);

const DEFAULT_LIFE_TIME_FADE_START = 0;
const DEFAULT_LIFE_TIME_FADE_END = 0;
const DEFAULT_JUMP_THRESHOLD$1 = 100;
const DEFAULT_PREV_POS_SCALE$1 = 1;
const DEFAULT_HITBOX_SET_NAME$1 = 'default';
const DEFAULT_RIGID = false;
const DEFAULT_USE_BONES = false;
const DEFAULT_FIELD_OUTPUT$4 = Source2ParticleVectorField.Position;
const DEFAULT_FIELD_OUTPUT_PREV = Source2ParticleVectorField.Position;
const DEFAULT_ROTATION_SET_TYPE = Source2ParticleRotationSetType.None;
const DEFAULT_RIGID_ROTATION_LOCK = false;
class LockToBone extends Operator {
    #lifeTimeFadeStart = DEFAULT_LIFE_TIME_FADE_START;
    #lifeTimeFadeEnd = DEFAULT_LIFE_TIME_FADE_END;
    #jumpThreshold = DEFAULT_JUMP_THRESHOLD$1;
    #prevPosScale = DEFAULT_PREV_POS_SCALE$1;
    #hitboxSetName = DEFAULT_HITBOX_SET_NAME$1;
    #rigid = DEFAULT_RIGID;
    #useBones = DEFAULT_USE_BONES; //use bones instead of hitboxes
    #fieldOutput = DEFAULT_FIELD_OUTPUT$4;
    #fieldOutputPrev = DEFAULT_FIELD_OUTPUT_PREV;
    #rotationSetType = DEFAULT_ROTATION_SET_TYPE;
    #rigidRotationLock = DEFAULT_RIGID_ROTATION_LOCK;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_flLifeTimeFadeStart':
                this.#lifeTimeFadeStart = param.getValueAsNumber() ?? DEFAULT_LIFE_TIME_FADE_START;
                break;
            case 'm_flLifeTimeFadeEnd':
                this.#lifeTimeFadeEnd = param.getValueAsNumber() ?? DEFAULT_LIFE_TIME_FADE_END;
                break;
            case 'm_flJumpThreshold':
                this.#jumpThreshold = param.getValueAsNumber() ?? DEFAULT_JUMP_THRESHOLD$1;
                break;
            case 'm_flPrevPosScale':
                this.#prevPosScale = param.getValueAsNumber() ?? DEFAULT_PREV_POS_SCALE$1;
                break;
            case 'm_HitboxSetName':
                this.#hitboxSetName = param.getValueAsString() ?? DEFAULT_HITBOX_SET_NAME$1;
                break;
            case 'm_bRigid':
                this.#rigid = param.getValueAsBool() ?? DEFAULT_RIGID;
                break;
            case 'm_bUseBones':
                this.#useBones = param.getValueAsBool() ?? DEFAULT_USE_BONES;
                break;
            case 'm_nFieldOutput':
                this.#fieldOutput = param.getValueAsNumber() ?? DEFAULT_FIELD_OUTPUT$4;
                break;
            case 'm_nFieldOutputPrev':
                this.#fieldOutputPrev = param.getValueAsNumber() ?? DEFAULT_FIELD_OUTPUT_PREV;
                break;
            case 'm_nRotationSetType':
                this.#rotationSetType = stringToRotationSetType(param.getValueAsString()) ?? DEFAULT_ROTATION_SET_TYPE;
                break;
            case 'm_bRigidRotationLock':
                this.#rigidRotationLock = param.getValueAsBool() ?? DEFAULT_RIGID_ROTATION_LOCK;
                break;
            case 'm_modelInput':
            case 'm_transformInput':
            case 'm_vecRotation':
            case 'm_flRotLerp':
                // used in doOperate
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        error();
        // TODO: use 'm_modelInput''m_transformInput', m_vecRotation, m_flRotLerp
        /*
                    m_modelInput =
            {
                m_nType = "PM_TYPE_CONTROL_POINT"
                m_nControlPoint = 2
            }
            m_transformInput =
            {
                m_bUseOrientation = false
                m_nControlPoint = 1
            }
                */
    }
}
RegisterSource2ParticleOperator('C_OP_LockToBone', LockToBone);
const error = once$1(() => console.error('TODO C_OP_LockToBone'));

const vec$2 = vec3.create();
const DEFAULT_NUM_TO_ASSIGN = 100; // TODO: check default value
const DEFAULT_LOOP = true; // TODO: check default value
const DEFAULT_MAX_DISTANCE = 0; // TODO: check default value
const DEFAULT_SAVE_OFFSET = false; // TODO: check default value
const DEFAULT_CP_PAIRS = false; // TODO: check default value
const DEFAULT_MID_POINT = 0.5; // TODO: check default value
class MaintainSequentialPath extends Operator {
    #numToAssign = DEFAULT_NUM_TO_ASSIGN;
    assignedSoFar = 0;
    #step = 0.01;
    loop = DEFAULT_LOOP;
    bounceDirection = 1;
    #maxDistance = DEFAULT_MAX_DISTANCE;
    cpPairs = DEFAULT_CP_PAIRS;
    #saveOffset = DEFAULT_SAVE_OFFSET;
    #midPoint = DEFAULT_MID_POINT;
    #startPointOffset = vec3.create(); // TODO: check default value
    #midPointOffset = vec3.create(); // TODO: check default value
    #endOffset = vec3.create(); // TODO: check default value
    operateAllParticlesRemoveme = true;
    #pathParams = new Source2ParticlePathParams();
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_flNumToAssign':
                this.#numToAssign = param.getValueAsNumber() ?? DEFAULT_NUM_TO_ASSIGN;
                this.#step = 1 / (this.#numToAssign - 1);
                break;
            case 'm_bLoop':
                this.loop = param.getValueAsBool() ?? DEFAULT_LOOP;
                break;
            case 'm_PathParams':
                Source2ParticlePathParams.fromOperatorParam(param, this.#pathParams);
                break;
            case 'm_fMaxDistance':
                this.#maxDistance = param.getValueAsNumber() ?? DEFAULT_MAX_DISTANCE;
                break;
            case 'm_bCPPairs':
                this.cpPairs = param.getValueAsBool() ?? DEFAULT_CP_PAIRS;
                break;
            case 'm_bSaveOffset':
                this.#saveOffset = param.getValueAsBool() ?? DEFAULT_SAVE_OFFSET;
                break;
            case 'm_flMidPoint':
                this.#midPoint = param.getValueAsNumber() ?? DEFAULT_MID_POINT;
                break;
            case 'm_vStartPointOffset':
                param.getValueAsVec3(this.#startPointOffset);
                break;
            case 'm_vMidPointOffset':
                param.getValueAsVec3(this.#midPointOffset);
                break;
            case 'm_vEndOffset':
                param.getValueAsVec3(this.#endOffset);
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particles, elapsedTime, strength) {
        const t = vec3.create();
        //TODO: use other parameters
        const startControlPointNumber = this.#pathParams.startControlPointNumber;
        const endControlPointNumber = this.#pathParams.endControlPointNumber;
        const startControlPoint = this.system.getControlPoint(startControlPointNumber);
        const endControlPoint = this.system.getControlPoint(endControlPointNumber);
        if (startControlPoint && endControlPoint) {
            const numToAssign = this.#numToAssign;
            let assignedSoFar = this.assignedSoFar;
            const delta = startControlPoint.deltaPosFrom(endControlPoint, vec$2);
            for (const particle of particles) {
                vec3.scale(t, delta, assignedSoFar * this.#step);
                vec3.add(particle.position, startControlPoint.currentWorldPosition, t);
                vec3.copy(particle.prevPosition, particle.position);
                assignedSoFar += this.bounceDirection;
                if (assignedSoFar >= numToAssign || assignedSoFar < 0) {
                    if (this.loop) {
                        assignedSoFar = 0;
                        this.bounceDirection = 1;
                    }
                    else {
                        this.bounceDirection = -this.bounceDirection;
                    }
                }
            }
            this.assignedSoFar = assignedSoFar;
        }
    }
}
RegisterSource2ParticleOperator('C_OP_MaintainSequentialPath', MaintainSequentialPath);

//const tempMat4 = mat4.create();
vec3.create();
vec3.create();
const v$6 = vec3.create();
const DEFAULT_SCALE_CONTROL_POINT = -1; //disabled
const DEFAULT_SCALE_CP_FIELD = Source2ParticleCpField.X;
const DEFAULT_FIELD_INPUT = Source2ParticleVectorField.PreviousPosition;
const DEFAULT_FIELD_OUTPUT$3 = Source2ParticleVectorField.Position;
const DEFAULT_OFFSET_LOCAL$2 = true;
let MovementRigidAttachToCP$1 = class MovementRigidAttachToCP extends Operator {
    #scaleControlPoint = DEFAULT_SCALE_CONTROL_POINT;
    #scaleCPField = DEFAULT_SCALE_CP_FIELD; //-1: disabled, 0: X, 1: Y, 2 :Z
    #fieldInput = DEFAULT_FIELD_INPUT;
    #fieldOutput = DEFAULT_FIELD_OUTPUT$3;
    #offsetLocal = DEFAULT_OFFSET_LOCAL$2;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_nScaleControlPoint':
                console.error('do this param', paramName, param);
                this.#scaleControlPoint = param.getValueAsNumber() ?? DEFAULT_SCALE_CONTROL_POINT;
                break;
            case 'm_nScaleCPField':
                this.#scaleCPField = param.getValueAsNumber() ?? DEFAULT_SCALE_CP_FIELD;
                break;
            case 'm_nFieldInput':
                this.#fieldInput = param.getValueAsNumber() ?? DEFAULT_FIELD_INPUT;
                break;
            case 'm_nFieldOutput':
                this.#fieldOutput = param.getValueAsNumber() ?? DEFAULT_FIELD_OUTPUT$3;
                break;
            case 'm_bOffsetLocal':
                this.#offsetLocal = param.getValueAsBool() ?? DEFAULT_OFFSET_LOCAL$2;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        //TODO: use scale cp and other parameters
        const cp = this.system.getControlPoint(this.controlPointNumber);
        if (cp) {
            /*if (!particle.initialCPPosition) {
                particle.initialCPPosition = vec3.clone(cp.getWorldPosition(vec));
            } else {
                vec3.copy(particle.initialCPPosition, particle.cpPosition);
            }

            particle.cpPosition = vec3.clone(cp.getWorldPosition(vec));

            const delta = vec3.subtract(vec3.create(), particle.cpPosition, particle.initialCPPosition);

            const deltaL = vec3.length(delta);
            particle.deltaL = particle.deltaL ?? 0;
            particle.deltaL += deltaL;

            //console.log(deltaL);
            if (this.range != 0 && particle.deltaL > this.range) {
                particle.posLockedToCP = -1;
            }

            mat4.invert(tempMat4, particle.cpPreviousTransform);

            let currentTransform = cp.getWorldTransformation(particle.cpPreviousTransform);//store the current tranform in the previous transform since we won't use it further
            mat4.mul(tempMat4, currentTransform, tempMat4);


            vec3.transformMat4(particle.position, particle.position, tempMat4);
            vec3.transformMat4(particle.prevPosition, particle.prevPosition, tempMat4);*/
            let delta;
            if (!particle.MovementRigidAttachToCP) {
                //TODO: this is dumb. try to do it better
                delta = cp.currentWorldTransformation;
                particle.MovementRigidAttachToCP = true;
            }
            else {
                delta = cp.deltaWorldTransformation;
            }
            //vec3.transformMat4(particle.position, particle.position, delta);
            //vec3.transformMat4(particle.prevPosition, particle.prevPosition, delta);
            vec3.transformMat4(v$6, particle.getField(this.#fieldInput), delta);
            particle.setField(this.#fieldInput, v$6);
            particle.setField(this.#fieldOutput, v$6);
        }
    }
};
RegisterSource2ParticleOperator('C_OP_MovementRigidAttachToCP', MovementRigidAttachToCP$1);

const m4 = mat4.create();
const q$1 = quat.create();
const v$5 = vec3.create();
const movementRotateParticleAroundAxisTempVec4 = vec4.create();
const DEFAULT_AXIS = vec3.fromValues(0, 0, 1);
const DEFAULT_LOCAL_SPACE$1 = false; // TODO: check default value
class MovementRotateParticleAroundAxis extends Operator {
    #localSpace = DEFAULT_LOCAL_SPACE$1;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_vecRotAxis':
            case 'm_flRotRate':
                // used in doOperate
                break;
            case 'm_nCP':
                this.controlPointNumber = param.getValueAsNumber() ?? DEFAULT_CONTROL_POINT_NUMBER;
                break;
            case 'm_bLocalSpace': //TODO: mutualize
                this.#localSpace = param.getValueAsBool() ?? DEFAULT_LOCAL_SPACE$1;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        const axis = vec3.normalize(movementRotateParticleAroundAxisTempVec4, this.getParamVectorValue(movementRotateParticleAroundAxisTempVec4, 'm_vecRotAxis', particle) ?? DEFAULT_AXIS);
        const rotationRate = this.getParamScalarValue('m_flRotRate') ?? 180;
        const cp = this.system.getControlPoint(this.controlPointNumber);
        if (this.#localSpace) {
            quat.copy(q$1, cp.currentWorldQuaternion);
        }
        else {
            quat.identity(q$1);
        }
        vec3.transformQuat(axis, axis, q$1);
        mat4.identity(m4);
        mat4.rotate(m4, m4, DEG_TO_RAD * rotationRate * elapsedTime * elapsedTime, axis);
        vec3.sub(v$5, particle.position, cp.currentWorldPosition);
        //TODO: should we do previous position too ?
        vec3.transformMat4(v$5, v$5, m4);
        vec3.add(particle.position, v$5, cp.currentWorldPosition);
    }
}
RegisterSource2ParticleOperator('C_OP_MovementRotateParticleAroundAxis', MovementRotateParticleAroundAxis);

const Coord$1 = vec3.create();
const DEFAULT_FIELD_OUTPUT$2 = Source2ParticleScalarField.Radius;
const DEFAULT_OUTPUT_MIN$2 = 0;
const DEFAULT_OUTPUT_MAX$2 = 1;
const DEFAULT_NOISE_SCALE$1 = 0.1;
const DEFAULT_ADDITIVE$1 = false;
const DEFAULT_NOISE_ANIMATION_TIME_SCALE$1 = 0;
class Noise extends Operator {
    #fieldOutput = DEFAULT_FIELD_OUTPUT$2;
    #outputMin = DEFAULT_OUTPUT_MIN$2;
    #outputMax = DEFAULT_OUTPUT_MAX$2;
    #noiseScale = DEFAULT_NOISE_SCALE$1; //noise coordinate scale
    #additive = DEFAULT_ADDITIVE$1;
    #noiseAnimationTimeScale = DEFAULT_NOISE_ANIMATION_TIME_SCALE$1;
    // computed
    #outputMinRad = 0;
    #outputMaxRad = 0;
    #valueScale = 0;
    #valueBase = 0;
    constructor(system) {
        super(system);
        this.#update();
    }
    #update() {
        if (ATTRIBUTES_WHICH_ARE_ANGLES & (1 << this.#fieldOutput)) {
            this.#outputMinRad = this.#outputMin * DEG_TO_RAD;
            this.#outputMaxRad = this.#outputMax * DEG_TO_RAD;
        }
        else {
            this.#outputMinRad = this.#outputMin;
            this.#outputMaxRad = this.#outputMax;
        }
        this.#valueScale = 0.5 * (this.#outputMaxRad - this.#outputMinRad);
        this.#valueBase = this.#outputMinRad + this.#valueScale;
    }
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_nFieldOutput':
                this.#fieldOutput = param.getValueAsNumber() ?? DEFAULT_FIELD_OUTPUT$2;
                this.#update();
                break;
            case 'm_flOutputMin': //TODO: mutualize
                this.#outputMin = param.getValueAsNumber() ?? DEFAULT_OUTPUT_MIN$2;
                this.#update();
                break;
            case 'm_flOutputMax': //TODO: mutualize
                this.#outputMax = param.getValueAsNumber() ?? DEFAULT_OUTPUT_MAX$2;
                this.#update();
                break;
            case 'm_fl4NoiseScale':
                this.#noiseScale = param.getValueAsNumber() ?? DEFAULT_NOISE_SCALE$1;
                break;
            case 'm_bAdditive':
                this.#additive = param.getValueAsBool() ?? DEFAULT_ADDITIVE$1;
                break;
            case 'm_flNoiseAnimationTimeScale':
                this.#noiseAnimationTimeScale = param.getValueAsNumber() ?? DEFAULT_NOISE_ANIMATION_TIME_SCALE$1;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        // TODO: use other params #additive, noiseAnimationTimeScale
        vec3.scale(Coord$1, particle.position, this.#noiseScale);
        const noise = NoiseSIMD(Coord$1[0], Coord$1[1], Coord$1[2]) * this.#valueScale + this.#valueBase;
        particle.setField(this.#fieldOutput, noise);
        //TODO: use m_fl4NoiseScale m_bAdditive m_flNoiseAnimationTimeScale
    }
}
RegisterSource2ParticleOperator('C_OP_Noise', Noise);

const normalizeVectorVec3 = vec3.create();
const DEFAULT_SCALE_FACTOR = 1;
class NormalizeVector extends Operator {
    #fieldOutput = Source2ParticleVectorField.Position;
    #scale = DEFAULT_SCALE_FACTOR;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_flScale':
                this.#scale = param.getValueAsNumber() ?? DEFAULT_SCALE_FACTOR;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        particle.getVectorField(normalizeVectorVec3, this.#fieldOutput);
        vec3.normalize(normalizeVectorVec3, normalizeVectorVec3);
        vec3.scale(normalizeVectorVec3, normalizeVectorVec3, this.#scale);
        particle.setField(this.#fieldOutput, normalizeVectorVec3);
    }
}
RegisterSource2ParticleOperator('C_OP_NormalizeVector', NormalizeVector);

//const mat = mat4.create();
const nmat$1 = mat3.create();
class NormalLock extends Operator {
    doOperate(particle, elapsedTime, strength) {
        const cp = this.system.getControlPoint(this.controlPointNumber);
        if (cp) {
            //mat4.invert(mat, particle.cpPreviousTransform);
            //let currentTransform = cp.getWorldTransformation(particle.cpPreviousTransform);//store the current tranform in the previous transform since we won't use it further
            //mat4.mul(mat, currentTransform, mat);
            mat3.normalFromMat4(nmat$1, cp.deltaWorldTransformation);
            vec3.transformMat3(particle.normal, particle.normal, nmat$1);
        }
    }
}
RegisterSource2ParticleOperator('C_OP_NormalLock', NormalLock);

const DEFAULT_RATE_MIN$2 = 0; // TODO: check default value
const DEFAULT_RATE_MAX$2 = 0; // TODO: check default value
const DEFAULT_FREQUENCY_MIN = 1; // TODO: check default value
const DEFAULT_FREQUENCY_MAX = 1; // TODO: check default value
const DEFAULT_FIELD$5 = PARTICLE_FIELD_ALPHA; // TODO: check default value
const DEFAULT_PROPORTIONAL$1 = true; // TODO: check default value
const DEFAULT_PROPORTIONAL_OP$3 = true; // TODO: check default value
const DEFAULT_START_TIME_MIN$4 = 0; // TODO: check default value
const DEFAULT_START_TIME_MAX$4 = 0; // TODO: check default value
const DEFAULT_END_TIME_MIN$4 = 1; // TODO: check default value
const DEFAULT_END_TIME_MAX$4 = 1; // TODO: check default value
const DEFAULT_OSC_MULT$2 = 2; // TODO: check default value
const DEFAULT_OSC_ADD$2 = 0.5; // TODO: check default value
class OscillateScalar extends Operator {
    #rateMin = DEFAULT_RATE_MIN$2;
    #rateMax = DEFAULT_RATE_MAX$2;
    #frequencyMin = DEFAULT_FREQUENCY_MIN;
    #frequencyMax = DEFAULT_FREQUENCY_MAX;
    #field = DEFAULT_FIELD$5;
    #proportional = DEFAULT_PROPORTIONAL$1;
    #proportionalOp = DEFAULT_PROPORTIONAL_OP$3;
    #startTimeMin = DEFAULT_START_TIME_MIN$4;
    #startTimeMax = DEFAULT_START_TIME_MAX$4;
    #endTimeMin = DEFAULT_END_TIME_MIN$4;
    #endTimeMax = DEFAULT_END_TIME_MAX$4;
    #oscMult = DEFAULT_OSC_MULT$2;
    #oscAdd = DEFAULT_OSC_ADD$2;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_RateMin': // TODO: mutualize ?
                this.#rateMin = param.getValueAsNumber() ?? DEFAULT_RATE_MIN$2;
                break;
            case 'm_RateMax':
                this.#rateMax = param.getValueAsNumber() ?? DEFAULT_RATE_MAX$2;
                break;
            case 'm_FrequencyMin':
                this.#frequencyMin = param.getValueAsNumber() ?? DEFAULT_FREQUENCY_MIN;
                break;
            case 'm_FrequencyMax':
                this.#frequencyMax = param.getValueAsNumber() ?? DEFAULT_FREQUENCY_MAX;
                break;
            case 'm_nField':
                this.#field = param.getValueAsNumber() ?? DEFAULT_FIELD$5;
                break;
            case 'm_bProportional':
                this.#proportional = param.getValueAsBool() ?? DEFAULT_PROPORTIONAL$1;
                break;
            case 'm_bProportionalOp':
                this.#proportionalOp = param.getValueAsBool() ?? DEFAULT_PROPORTIONAL_OP$3;
                break;
            case 'm_flStartTime_min':
                this.#startTimeMin = param.getValueAsNumber() ?? DEFAULT_START_TIME_MIN$4;
                break;
            case 'm_flStartTime_max':
                this.#startTimeMax = param.getValueAsNumber() ?? DEFAULT_START_TIME_MAX$4;
                break;
            case 'm_flEndTime_min':
                this.#endTimeMin = param.getValueAsNumber() ?? DEFAULT_END_TIME_MAX$4;
                break;
            case 'm_flEndTime_max':
                this.#endTimeMax = param.getValueAsNumber() ?? DEFAULT_END_TIME_MAX$4;
                break;
            case 'm_flOscMult': // TODO: mutualize ?
                this.#oscMult = param.getValueAsNumber() ?? DEFAULT_OSC_MULT$2;
                break;
            case 'm_flOscAdd': // TODO: mutualize ?
                this.#oscAdd = param.getValueAsNumber() ?? DEFAULT_OSC_ADD$2;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        const fl4StartTimeWidth = this.#startTimeMax - this.#startTimeMin;
        const fl4EndTimeWidth = this.#endTimeMax - this.#endTimeMin;
        const fl4FrequencyWidth = this.#frequencyMax - this.#frequencyMin;
        const fl4RateWidth = this.#rateMax - this.#rateMin;
        const fl4ScaleFactor = /*flStrength * */ elapsedTime;
        const fl4CosFactor = this.#oscMult * particle.currentTime + this.#oscAdd;
        if (particle.timeToLive) {
            let fl4LifeTime;
            if (this.#proportionalOp) {
                fl4LifeTime = particle.proportionOfLife;
            }
            else {
                fl4LifeTime = particle.currentTime;
            }
            //TODO: use random table
            let fl4StartTime = 0.5; //Math.random();//pParticles->RandomFloat(*pParticleId, nRandomOffset + 11);
            fl4StartTime = this.#startTimeMin + fl4StartTimeWidth * fl4StartTime;
            //TODO: use random table
            let fl4EndTime = 0.5; //Math.random();//pParticles->RandomFloat(*pParticleId, nRandomOffset + 12);
            fl4EndTime = this.#endTimeMin + fl4EndTimeWidth * fl4EndTime;
            if ((fl4LifeTime >= fl4StartTime) && (fl4LifeTime < fl4EndTime)) {
                //TODO: use random table
                let fl4Frequency = 0.5; //Math.random();//pParticles->RandomFloat(*pParticleId, nRandomOffset);
                fl4Frequency = this.#frequencyMin + fl4FrequencyWidth * fl4Frequency;
                //TODO: use random table
                let fl4Rate = 0.5; //Math.random();//pParticles->RandomFloat(*pParticleId, nRandomOffset + 1);
                fl4Rate = this.#rateMin + fl4RateWidth * fl4Rate;
                let fl4Cos;
                if (this.#proportional) {
                    fl4LifeTime = (particle.currentTime - particle.cTime) / particle.timeToLive;
                    fl4Cos = ((this.#oscMult * (fl4LifeTime * fl4Frequency)) + this.#oscAdd);
                }
                else {
                    fl4Cos = fl4CosFactor * fl4Frequency;
                }
                const fl4OscMultiplier = fl4Rate * fl4ScaleFactor;
                let fl4OscVal = particle.getField(this.#field) + fl4OscMultiplier * Math.sin(fl4Cos * Math.PI);
                if (this.#field == PARTICLE_FIELD_ALPHA) {
                    fl4OscVal = clamp$1(fl4OscVal, 0.0, 1.0);
                }
                particle.setField(this.#field, fl4OscVal);
            }
        }
    }
}
RegisterSource2ParticleOperator('C_OP_OscillateScalar', OscillateScalar);

const DEFAULT_RATE = 0;
const DEFAULT_FREQUENCY = 1;
const DEFAULT_FIELD$4 = Source2ParticleScalarField.Alpha;
const DEFAULT_OSC_MULT$1 = 2;
const DEFAULT_OSC_ADD$1 = 0.5;
class OscillateScalarSimple extends Operator {
    #rate = DEFAULT_RATE;
    #frequency = DEFAULT_FREQUENCY;
    #field = DEFAULT_FIELD$4;
    #oscMult = DEFAULT_OSC_MULT$1;
    #oscAdd = DEFAULT_OSC_ADD$1;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_Rate':
                this.#rate = param.getValueAsNumber() ?? DEFAULT_RATE;
                break;
            case 'm_Frequency':
                this.#frequency = param.getValueAsNumber() ?? DEFAULT_FREQUENCY;
                break;
            case 'm_nField':
                this.#field = param.getValueAsNumber() ?? DEFAULT_FIELD$4;
                break;
            case 'm_flOscMult':
                this.#oscMult = param.getValueAsNumber() ?? DEFAULT_OSC_MULT$1;
                break;
            case 'm_flOscAdd':
                this.#oscAdd = param.getValueAsNumber() ?? DEFAULT_OSC_ADD$1;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        const currentTime = this.system.currentTime;
        const sinFactor = (this.#oscMult * currentTime + this.#oscAdd) * this.#frequency;
        let value = particle.getScalarField(this.#field) + this.#rate * Math.sin(sinFactor * Math.PI) * DEG_TO_RAD; //DEG_TO_RAD seems to apply to all field even radius, alpha and so on. Valve style
        if (this.#field == PARTICLE_FIELD_ALPHA) {
            value = clamp$1(value, 0.0, 1.0);
        }
        particle.setField(this.#field, value);
    }
}
RegisterSource2ParticleOperator('C_OP_OscillateScalarSimple', OscillateScalarSimple);

const DEFAULT_OFFSET$1 = true; // TODO: check default value
const DEFAULT_END_TIME_MIN$3 = 1; // TODO: check default value
const DEFAULT_END_TIME_MAX$3 = 1; // TODO: check default value
const DEFAULT_PROPORTIONAL = true; // TODO: check default value
const DEFAULT_PROPORTIONAL_OP$2 = true; // TODO: check default value
const DEFAULT_FIELD$3 = 0; // TODO: check default value
const DEFAULT_START_TIME_MIN$3 = 0; // TODO: check default value
const DEFAULT_START_TIME_MAX$3 = 0; // TODO: check default value
const DEFAULT_OSC_MULT = 2; // TODO: check default value
const DEFAULT_OSC_ADD = 0.5; // TODO: check default value
class OscillateVector extends Operator {
    #rateMin = vec3.create(); // TODO: check default value
    #rateMax = vec3.create(); // TODO: check default value
    #frequencyMin = vec3.fromValues(1, 1, 1); // TODO: check default value
    #frequencyMax = vec3.fromValues(1, 1, 1); // TODO: check default value
    #field = DEFAULT_FIELD$3;
    #proportional = DEFAULT_PROPORTIONAL;
    #proportionalOp = DEFAULT_PROPORTIONAL_OP$2;
    #offset = DEFAULT_OFFSET$1;
    #startTimeMin = DEFAULT_START_TIME_MIN$3;
    #startTimeMax = DEFAULT_START_TIME_MAX$3;
    #endTimeMin = DEFAULT_END_TIME_MIN$3;
    #endTimeMax = DEFAULT_END_TIME_MAX$3;
    #oscMult = DEFAULT_OSC_MULT;
    #oscAdd = DEFAULT_OSC_ADD;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_RateMin':
                param.getValueAsVec3(this.#rateMin);
                break;
            case 'm_RateMax':
                param.getValueAsVec3(this.#rateMax);
                break;
            case 'm_FrequencyMin':
                param.getValueAsVec3(this.#frequencyMin);
                break;
            case 'm_FrequencyMax':
                param.getValueAsVec3(this.#frequencyMax);
                break;
            case 'm_nField':
                this.#field = param.getValueAsNumber() ?? DEFAULT_FIELD$3;
                break;
            case 'm_bProportional':
                this.#proportional = param.getValueAsBool() ?? DEFAULT_PROPORTIONAL;
                break;
            case 'm_bProportionalOp':
                this.#proportionalOp = param.getValueAsBool() ?? DEFAULT_PROPORTIONAL_OP$2;
                break;
            case 'm_bOffset':
                this.#offset = param.getValueAsBool() ?? DEFAULT_OFFSET$1;
                break;
            case 'm_flStartTime_min':
                this.#startTimeMin = param.getValueAsNumber() ?? DEFAULT_START_TIME_MIN$3;
                break;
            case 'm_flStartTime_max':
                this.#startTimeMax = param.getValueAsNumber() ?? DEFAULT_START_TIME_MAX$3;
                break;
            case 'm_flEndTime_min':
                this.#endTimeMin = param.getValueAsNumber() ?? DEFAULT_END_TIME_MIN$3;
                break;
            case 'm_flEndTime_max':
                this.#endTimeMax = param.getValueAsNumber() ?? DEFAULT_END_TIME_MAX$3;
                break;
            case 'm_flOscMult':
                this.#oscMult = param.getValueAsNumber() ?? DEFAULT_OSC_MULT;
                break;
            case 'm_flOscAdd':
                this.#oscAdd = param.getValueAsNumber() ?? DEFAULT_OSC_ADD;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        const m_nField = this.#field;
        particle.cTime; //CM128AttributeIterator pCreationTime(PARTICLE_ATTRIBUTE_CREATION_TIME, pParticles);
        const pLifeDuration = particle.timeToLive; //CM128AttributeIterator pLifeDuration(PARTICLE_ATTRIBUTE_LIFE_DURATION, pParticles);
        //C4IAttributeIterator pParticleId (PARTICLE_ATTRIBUTE_PARTICLE_ID, pParticles);
        //C4VAttributeWriteIterator pOscField (m_nField, pParticles) ;
        const fl4CurTime = particle.currentTime;
        //const nRandomOffset = particle->OperatorRandomSampleOffset();
        const fvOscVal = vec3.create(); //todov3optimize
        const flStrength = 1;
        const fl4ScaleFactor = flStrength * elapsedTime;
        const fl4CosFactorMultiplier = this.#oscMult;
        const fl4CosFactorAdd = this.#oscAdd;
        const fl4CosFactor = fl4CosFactorMultiplier * fl4CurTime + fl4CosFactorAdd;
        const fl4CosFactorProp = fl4CosFactorMultiplier;
        const fl4StartTimeWidth = this.#startTimeMax - this.#startTimeMin;
        const fl4EndTimeWidth = this.#endTimeMax - this.#endTimeMin;
        const fvFrequencyMin = this.#frequencyMin;
        const fvFrequencyWidth = vec3.sub(vec3.create(), this.#frequencyMax, fvFrequencyMin); //todov3optimize
        const fvRateMin = this.#rateMin;
        const fvRateWidth = vec3.sub(vec3.create(), this.#rateMax, fvRateMin); //todov3optimize
        //int nCtr = pParticles->m_nPaddedActiveParticles;
        //do
        {
            const fl4LifeDuration = pLifeDuration;
            const fl4GoodMask = fl4LifeDuration > 0.0;
            let fl4LifeTime;
            if (this.#proportionalOp) {
                fl4LifeTime = particle.currentTime / particle.timeToLive;
            }
            else {
                fl4LifeTime = particle.currentTime;
            }
            //TODO: use random table
            let fl4StartTime = Math.random(); //pParticles->RandomFloat(*pParticleId, nRandomOffset + 11);
            fl4StartTime = this.#startTimeMin + fl4StartTimeWidth * fl4StartTime;
            //TODO: use random table
            let fl4EndTime = Math.random(); //pParticles->RandomFloat(*pParticleId, nRandomOffset + 12);
            fl4EndTime = this.#endTimeMin + fl4EndTimeWidth * fl4EndTime;
            if ((fl4LifeTime >= fl4StartTime) && (fl4LifeTime < fl4EndTime)) {
                //TODO: use random table
                const fvFrequency = vec3.fromValues(Math.random(), Math.random(), Math.random());
                //fvFrequency[0] = pParticles->RandomFloat(*pParticleId, nRandomOffset + 8);
                //fvFrequency[1] = pParticles->RandomFloat(*pParticleId, nRandomOffset + 12);
                //fvFrequency[2] = pParticles->RandomFloat(*pParticleId, nRandomOffset + 15);
                vec3.mul(fvFrequency, fvFrequency, fvFrequencyWidth);
                vec3.add(fvFrequency, fvFrequency, fvFrequencyMin);
                const fvRate = vec3.fromValues(Math.random(), Math.random(), Math.random());
                //fvRate[0] = pParticles->RandomFloat(*pParticleId, nRandomOffset + 3);
                //fvRate[1] = pParticles->RandomFloat(*pParticleId, nRandomOffset + 7);
                //fvRate[2] = pParticles->RandomFloat(*pParticleId, nRandomOffset + 9);
                //fvRate = AddSIMD(fvRateMin, MulSIMD(fvRateWidth, fvRate));
                vec3.mul(fvRate, fvRate, fvRateWidth);
                vec3.add(fvRate, fvRate, fvRateMin);
                const fvCos = vec3.create(); //todov3optimize
                if (this.#proportional) {
                    fl4LifeTime = particle.currentTime / particle.timeToLive;
                    fvCos[0] = fl4CosFactorProp * fvFrequency[0] * fl4LifeTime + fl4CosFactorAdd;
                    fvCos[1] = fl4CosFactorProp * fvFrequency[1] * fl4LifeTime + fl4CosFactorAdd;
                    fvCos[2] = fl4CosFactorProp * fvFrequency[2] * fl4LifeTime + fl4CosFactorAdd;
                }
                else {
                    vec3.scale(fvCos, fvFrequency, fl4CosFactor);
                }
                const fvOscMultiplier = vec3.create(); //todov3optimize
                vec3.scale(fvOscMultiplier, fvRate, fl4ScaleFactor);
                const fvOutput = vec4.create(); //TODO: perf//todov3optimize
                this.getInputValueAsVector(m_nField, particle, fvOutput); //*pOscField;
                fvOscVal[0] = AddSIMD(fvOutput[0], MulSIMD(fvOscMultiplier[0], SinEst01SIMD(fvCos[0])));
                fvOscVal[1] = AddSIMD(fvOutput[1], MulSIMD(fvOscMultiplier[1], SinEst01SIMD(fvCos[1])));
                fvOscVal[2] = AddSIMD(fvOutput[2], MulSIMD(fvOscMultiplier[2], SinEst01SIMD(fvCos[2])));
                const pOscField = vec3.create(); //todov3optimize
                if (m_nField == 6) {
                    pOscField[0] = MaskedAssign(fl4GoodMask, MaxSIMD(MinSIMD(fvOscVal[0], Four_Ones), Four_Zeros), fvOutput[0]);
                    pOscField[1] = MaskedAssign(fl4GoodMask, MaxSIMD(MinSIMD(fvOscVal[1], Four_Ones), Four_Zeros), fvOutput[1]);
                    pOscField[2] = MaskedAssign(fl4GoodMask, MaxSIMD(MinSIMD(fvOscVal[2], Four_Ones), Four_Zeros), fvOutput[2]);
                }
                else {
                    //pOscField[0] = MaskedAssign(fl4GoodMask, fvOscVal[0], fvOutput[0]);
                    //pOscField[1] = MaskedAssign(fl4GoodMask, fvOscVal[1], fvOutput[1]);
                    //pOscField[2] = MaskedAssign(fl4GoodMask, fvOscVal[2], fvOutput[2]);
                    pOscField[0] = fvOscVal[0];
                    pOscField[1] = fvOscVal[1];
                    pOscField[2] = fvOscVal[2];
                }
                this.setOutputValue(m_nField, pOscField, particle);
            }
            //++pCreationTime;
            //++pLifeDuration;
            //++pOscField;
            //++pParticleId;
            //} while (--nCtr);
        }
    }
}
RegisterSource2ParticleOperator('C_OP_OscillateVector', OscillateVector);

const DEFAULT_PIN_BREAK = Source2PinBreakType.None;
const DEFAULT_OFFSET_LOCAL$1 = false;
const DEFAULT_PARTICLE_SELECTION = Source2ParticleSelection.First;
const DEFAULT_BREAK_CP_NUMBER = -1;
const DEFAULT_RETAIN_INITIAL_VELOCITY = false;
class PinParticleToCP extends Operator {
    static doOnce = false;
    #offsetLocal = DEFAULT_OFFSET_LOCAL$1;
    #particleSelection = DEFAULT_PARTICLE_SELECTION; //PARTICLE_SELECTION_LAST
    #pinBreakType = DEFAULT_PIN_BREAK; //PARTICLE_PIN_DISTANCE_NEIGHBOR
    #breakControlPointNumber = DEFAULT_BREAK_CP_NUMBER;
    #breakControlPointNumber2 = DEFAULT_BREAK_CP_NUMBER;
    #retainInitialVelocity = DEFAULT_RETAIN_INITIAL_VELOCITY;
    /*
    { name: 'm_nOpEndCapState', type: OperatorDefinitionType.Enum, enum: Source2ParticleEndCapState, defaultValue: Source2ParticleEndCapState.AlwaysEnabled, complex: false },
    { name: 'm_nPinBreakType', type: OperatorDefinitionType.Enum, enum: Source2PinBreakType, defaultValue: Source2PinBreakType.None, complex: false },
    { name: 'm_nControlPointNumber', type: OperatorDefinitionType.Integer, defaultValue: 0, complex: false },
    { name: 'm_vecOffset', type: OperatorDefinitionType.Vec3, defaultValue: vec3.create(), complex: true },
    { name: 'm_bOffsetLocal', type: OperatorDefinitionType.Bool, defaultValue: true, complex: false },
    { name: 'm_nParticleSelection', type: OperatorDefinitionType.Enum, enum: Source2ParticleSelection, defaultValue: Source2ParticleSelection.First, complex: false },
    { name: 'm_nParticleNumber', type: OperatorDefinitionType.Integer, defaultValue: 0, complex: true },
    { name: 'm_flBreakDistance', type: OperatorDefinitionType.Float, defaultValue: 1.75, complex: true },
    { name: 'm_flBreakSpeed', type: OperatorDefinitionType.Float, defaultValue: 0, complex: true },
    { name: 'm_flAge', type: OperatorDefinitionType.Float, defaultValue: 0, complex: true },
    { name: 'm_nBreakControlPointNumber', type: OperatorDefinitionType.Integer, defaultValue: -1, complex: false },
    { name: 'm_nBreakControlPointNumber2', type: OperatorDefinitionType.Integer, defaultValue: -1, complex: false },
    { name: 'm_flBreakValue', type: OperatorDefinitionType.Float, defaultValue: 0, complex: true },
    { name: 'm_flInterpolation', type: OperatorDefinitionType.Float, defaultValue: 1, complex: true },
    { name: 'm_bRetainInitialVelocity', type: OperatorDefinitionType.Bool, defaultValue: false, complex: false },
    { name: 'm_flOpStrength', type: OperatorDefinitionType.Float, defaultValue: 1, complex: true },
    { name: 'm_nOpEndCapState', type: OperatorDefinitionType.Enum, defaultValue: Source2ParticleEndCapState.AlwaysEnabled, complex: false },
     */
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_nPinBreakType':
                this.#pinBreakType = stringToPinBreakType(param.getValueAsString()) ?? DEFAULT_PIN_BREAK;
                break;
            case 'm_bOffsetLocal':
                this.#offsetLocal = param.getValueAsBool() ?? DEFAULT_OFFSET_LOCAL$1;
                break;
            case 'm_nParticleSelection':
                this.#particleSelection = stringToParticleSelection(param.getValueAsString()) ?? DEFAULT_PARTICLE_SELECTION;
                break;
            case 'm_nBreakControlPointNumber':
                this.#breakControlPointNumber = param.getValueAsNumber() ?? DEFAULT_BREAK_CP_NUMBER;
                break;
            case 'm_nBreakControlPointNumber2':
                this.#breakControlPointNumber2 = param.getValueAsNumber() ?? DEFAULT_BREAK_CP_NUMBER;
                break;
            case 'm_bRetainInitialVelocity':
                this.#retainInitialVelocity = param.getValueAsBool() ?? DEFAULT_RETAIN_INITIAL_VELOCITY;
                break;
            case 'm_vecOffset':
            case 'm_nParticleNumber':
            case 'm_flBreakDistance':
            case 'm_flBreakSpeed':
            case 'm_flAge':
            case 'm_flBreakValue':
            case 'm_flInterpolation':
                // used in doOperate
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        //m_nParticleNumber
        //TODO
        console.error('code me');
    }
}
RegisterSource2ParticleOperator('C_OP_PinParticleToCP', PinParticleToCP);

const vec$1 = vec3.create();
const DEFAULT_PLANE_OFFSET = 0; // TODO: check default value
const DEFAULT_LOCAL_SPACE = false;
const DEFAULT_PLANE_CONTROL_POINT = 0; // TODO: check default value
class PlaneCull extends Operator {
    #planeControlPoint = DEFAULT_PLANE_CONTROL_POINT;
    #planeDirection = vec3.fromValues(0, 0, 1); // TODO: check default value
    #localSpace = DEFAULT_LOCAL_SPACE;
    #planeOffset = DEFAULT_PLANE_OFFSET;
    #planeDirectionOffset = vec3.create(); //computed
    constructor(system) {
        super(system);
        this.#update();
    }
    #update() {
        vec3.scale(this.#planeDirectionOffset, this.#planeDirection, this.#planeOffset);
    }
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_nPlaneControlPoint':
                this.#planeControlPoint = param.getValueAsNumber() ?? DEFAULT_PLANE_CONTROL_POINT;
                break;
            case 'm_vecPlaneDirection':
                param.getValueAsVec3(this.#planeDirection);
                vec3.normalize(this.#planeDirection, this.#planeDirection);
                this.#update();
                break;
            case 'm_bLocalSpace':
                this.#localSpace = param.getValueAsBool() ?? DEFAULT_LOCAL_SPACE;
                break;
            case 'm_flPlaneOffset':
                this.#planeOffset = param.getValueAsNumber() ?? DEFAULT_PLANE_OFFSET;
                this.#update();
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        // TODO: use m_bLocalSpace
        const cp = this.system.getControlPoint(this.#planeControlPoint);
        if (cp) {
            const origin = cp.getWorldPosition(vec$1);
            vec3.sub(origin, origin, this.#planeDirectionOffset);
            vec3.sub(origin, particle.position, origin);
            if (vec3.dot(this.#planeDirection, origin) < 0) {
                particle.die();
            }
        }
    }
}
RegisterSource2ParticleOperator('C_OP_PlaneCull', PlaneCull);

vec3.create();
vec3.create();
//const tempQuat = quat.create();
vec3.create();
const DEFAULT_JUMP_THRESHOLD = 512;
const DEFAULT_RANGE = 0; // TODO: check default value
const DEFAULT_START_TIME_MIN$2 = 1; // TODO: check default value
const DEFAULT_START_TIME_MAX$2 = 1; // TODO: check default value
const DEFAULT_START_TIME_EXP = 1; // TODO: check default value
const DEFAULT_END_TIME_MIN$2 = 1; // TODO: check default value
const DEFAULT_END_TIME_MAX$2 = 1; // TODO: check default value
const DEFAULT_END_TIME_EXP = 1; // TODO: check default value
const DEFAULT_PREV_POS_SCALE = 1;
const DEFAULT_LOCK_ROT = false; // TODO: check default value
const DEFAULT_START_FADE_OUT_TIME = 0; // TODO: check default value
const DEFAULT_END_FADE_OUT_TIME = 0; // TODO: check default value
class PositionLock extends Operator {
    #startTimeMin = DEFAULT_START_TIME_MIN$2;
    #startTimeMax = DEFAULT_START_TIME_MAX$2;
    #startTimeExp = DEFAULT_START_TIME_EXP;
    #endTimeMin = DEFAULT_END_TIME_MIN$2;
    #endTimeMax = DEFAULT_END_TIME_MAX$2;
    #endTimeExp = DEFAULT_END_TIME_EXP;
    #range = DEFAULT_RANGE;
    #jumpThreshold = DEFAULT_JUMP_THRESHOLD;
    #prevPosScale = DEFAULT_PREV_POS_SCALE;
    #lockRot = DEFAULT_LOCK_ROT;
    #startFadeOutTime = DEFAULT_START_FADE_OUT_TIME;
    #endFadeOutTime = DEFAULT_END_FADE_OUT_TIME;
    constructor(system) {
        super(system);
        this.#update();
    }
    #update() {
        //TODO: this is wrong: must be done per particle
        this.#startFadeOutTime = RandomFloatExp(this.#startTimeMin, this.#startTimeMax, this.#startTimeExp);
        this.#endFadeOutTime = RandomFloatExp(this.#endTimeMin, this.#endTimeMax, this.#endTimeExp);
    }
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_flStartTime_min':
                this.#startTimeMin = param.getValueAsNumber() ?? DEFAULT_START_TIME_MIN$2;
                this.#update();
                break;
            case 'm_flStartTime_max':
                this.#startTimeMax = param.getValueAsNumber() ?? DEFAULT_START_TIME_MAX$2;
                this.#update();
                break;
            case 'm_flStartTime_exp':
                this.#startTimeExp = param.getValueAsNumber() ?? DEFAULT_START_TIME_EXP;
                this.#update();
                break;
            case 'm_flEndTime_min':
                this.#endTimeMin = param.getValueAsNumber() ?? DEFAULT_END_TIME_MIN$2;
                this.#update();
                break;
            case 'm_flEndTime_max':
                this.#endTimeMax = param.getValueAsNumber() ?? DEFAULT_END_TIME_MAX$2;
                this.#update();
                break;
            case 'm_flEndTime_exp':
                this.#endTimeExp = param.getValueAsNumber() ?? DEFAULT_END_TIME_EXP;
                this.#update();
                break;
            case 'm_flRange': // TODO: mutualize ?
                this.#range = param.getValueAsNumber() ?? DEFAULT_RANGE;
                break;
            case 'm_flJumpThreshold': // TODO: mutualize ?
                this.#jumpThreshold = param.getValueAsNumber() ?? DEFAULT_JUMP_THRESHOLD;
                break;
            case 'm_flPrevPosScale':
                this.#prevPosScale = param.getValueAsNumber() ?? DEFAULT_PREV_POS_SCALE;
                break;
            case 'm_bLockRot':
                this.#lockRot = param.getValueAsBool() ?? false;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        // TODO: use jumpThreshold
        const proportionOfLife = clamp$1(particle.proportionOfLife, 0, 1);
        if (proportionOfLife > this.#endFadeOutTime) {
            return;
        }
        const cp = this.system.getControlPoint(this.controlPointNumber);
        if (cp) {
            let delta;
            /*	if (!particle.initialCPPosition) {
                    particle.initialCPPosition = vec3.clone(cp.getWorldPosition(vec));
                } else {
                    vec3.copy(particle.initialCPPosition, particle.cpPosition);
                }

                particle.cpPosition = vec3.clone(cp.getWorldPosition(vec));

                let delta = vec3.subtract(vec3.create(), particle.cpPosition, particle.initialCPPosition);

                const deltaL = vec3.length(delta);
                particle.deltaL = particle.deltaL ?? 0;
                particle.deltaL += deltaL;

                //console.log(deltaL);
                if (this.range != 0 && particle.deltaL > this.range) {
                    particle.posLockedToCP = -1;
                }*/
            //TODO: use m_flRange and other parameters
            if (this.#lockRot) {
                delta = cp.deltaWorldTransformation;
                vec3.transformMat4(particle.position, particle.position, delta);
                vec3.transformMat4(particle.prevPosition, particle.prevPosition, delta);
                //TODO: do LockStrength
            }
            else {
                delta = cp.deltaWorldPosition;
                vec3.add(particle.position, particle.position, delta);
                vec3.add(particle.prevPosition, particle.prevPosition, delta);
            }
        }
    }
}
RegisterSource2ParticleOperator('C_OP_PositionLock', PositionLock);

const DEFAULT_RATE_MIN$1 = 0; // TODO: check default value
const DEFAULT_RATE_MAX$1 = 0; // TODO: check default value
const DEFAULT_START_TIME_MIN$1 = 0; // TODO: check default value
const DEFAULT_START_TIME_MAX$1 = 0; // TODO: check default value
const DEFAULT_END_TIME_MIN$1 = 0; // TODO: check default value
const DEFAULT_END_TIME_MAX$1 = 0; // TODO: check default value
const DEFAULT_FIELD$2 = PARTICLE_FIELD_RADIUS; // TODO: check default value
const DEFAULT_PROPORTIONAL_OP$1 = true; // TODO: check default value
class RampScalarLinear extends Operator {
    #rateMin = DEFAULT_RATE_MIN$1;
    #rateMax = DEFAULT_RATE_MAX$1;
    #startTimeMin = DEFAULT_START_TIME_MIN$1;
    #startTimeMax = DEFAULT_START_TIME_MAX$1;
    #endTimeMin = DEFAULT_END_TIME_MIN$1;
    #endTimeMax = DEFAULT_END_TIME_MAX$1;
    #field = DEFAULT_FIELD$2; // TODO: not sure about the field
    #proportionalOp = DEFAULT_PROPORTIONAL_OP$1;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_RateMin':
                this.#rateMin = param.getValueAsNumber() ?? DEFAULT_RATE_MIN$1;
                break;
            case 'm_RateMax':
                this.#rateMax = param.getValueAsNumber() ?? DEFAULT_RATE_MAX$1;
                break;
            case 'm_flStartTime_min':
                console.error('do this param', paramName, param);
                this.#startTimeMin = param.getValueAsNumber() ?? DEFAULT_START_TIME_MIN$1;
                break;
            case 'm_flStartTime_max':
                this.#startTimeMax = param.getValueAsNumber() ?? DEFAULT_START_TIME_MAX$1;
                break;
            case 'm_flEndTime_min':
                this.#endTimeMin = param.getValueAsNumber() ?? DEFAULT_END_TIME_MIN$1;
                break;
            case 'm_flEndTime_max':
                this.#endTimeMax = param.getValueAsNumber() ?? DEFAULT_END_TIME_MAX$1;
                break;
            case 'm_nField':
                this.#field = param.getValueAsNumber() ?? PARTICLE_FIELD_RADIUS;
                break;
            case 'm_bProportionalOp':
                this.#proportionalOp = param.getValueAsBool() ?? DEFAULT_PROPORTIONAL_OP$1;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        const context = particle.context.get(this);
        let rate, startTime, endTime;
        if (context == undefined) {
            //Init per particle parameters
            rate = RandomFloat(this.#rateMin, this.#rateMax);
            startTime = RandomFloat(this.#startTimeMin, this.#startTimeMax);
            endTime = RandomFloat(this.#endTimeMin, this.#endTimeMax);
            particle.context.set(this, { r: rate, s: startTime, e: endTime });
        }
        else {
            rate = context.r;
            startTime = context.s;
            endTime = context.e;
        }
        const particleTime = this.#proportionalOp ? particle.proportionOfLife : particle.currentTime;
        if (particleTime < startTime || particleTime > endTime) {
            return;
        }
        const value = particle.getField(this.#field) + rate * elapsedTime;
        particle.setField(this.#field, value);
    }
}
RegisterSource2ParticleOperator('C_OP_RampScalarLinear', RampScalarLinear);

class RampScalarLinearSimple extends Operator {
    #rate = 0;
    #startTime = 0;
    #endTime = 1; //TODO: check default value
    #field = PARTICLE_FIELD_RADIUS;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_Rate':
                this.#rate = param.getValueAsNumber() ?? 0;
                break;
            case 'm_flStartTime':
                this.#startTime = param.getValueAsNumber() ?? 0;
                break;
            case 'm_flEndTime': // TODO: mutualize param ?
                this.#endTime = param.getValueAsNumber() ?? 1;
                break;
            case 'm_nField':
                this.#field = param.getValueAsNumber() ?? PARTICLE_FIELD_RADIUS;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        const particleTime = particle.proportionOfLife;
        if (particleTime < this.#startTime || particleTime > this.#endTime) {
            return;
        }
        const value = particle.getField(this.#field) + this.#rate * elapsedTime;
        particle.setField(this.#field, value);
    }
}
RegisterSource2ParticleOperator('C_OP_RampScalarLinearSimple', RampScalarLinearSimple);

const DEFAULT_RATE_MIN = 0;
const DEFAULT_RATE_MAX = 0;
const DEFAULT_START_TIME_MIN = 0;
const DEFAULT_START_TIME_MAX = 0;
const DEFAULT_END_TIME_MIN = 1;
const DEFAULT_END_TIME_MAX = 1;
const DEFAULT_BIAS = 0.5;
const DEFAULT_PROPORTIONAL_OP = true;
const DEFAULT_EASE_OUT = false;
const DEFAULT_FIELD$1 = Source2ParticleScalarField.Radius;
class RampScalarSpline extends Operator {
    #rateMin = DEFAULT_RATE_MIN;
    #rateMax = DEFAULT_RATE_MAX;
    #startTimeMin = DEFAULT_START_TIME_MIN;
    #startTimeMax = DEFAULT_START_TIME_MAX;
    #endTimeMin = DEFAULT_END_TIME_MIN;
    #endTimeMax = DEFAULT_END_TIME_MAX;
    #field = DEFAULT_FIELD$1;
    #proportionalOp = DEFAULT_PROPORTIONAL_OP;
    #bias = DEFAULT_BIAS;
    #easeOut = DEFAULT_EASE_OUT;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_RateMin':
                this.#rateMin = param.getValueAsNumber() ?? DEFAULT_RATE_MIN;
                break;
            case 'm_RateMax':
                this.#rateMax = param.getValueAsNumber() ?? DEFAULT_RATE_MAX;
                break;
            case 'm_flStartTime_min':
                this.#startTimeMin = param.getValueAsNumber() ?? DEFAULT_START_TIME_MIN;
                break;
            case 'm_flStartTime_max':
                this.#startTimeMax = param.getValueAsNumber() ?? DEFAULT_START_TIME_MAX;
                break;
            case 'm_flEndTime_min':
                this.#endTimeMin = param.getValueAsNumber() ?? DEFAULT_END_TIME_MIN;
                break;
            case 'm_flEndTime_max':
                this.#endTimeMax = param.getValueAsNumber() ?? DEFAULT_END_TIME_MAX;
                break;
            case 'm_flBias':
                this.#bias = param.getValueAsNumber() ?? DEFAULT_BIAS;
                break;
            case 'm_nField':
                this.#field = param.getValueAsNumber() ?? DEFAULT_FIELD$1;
                break;
            case 'm_bProportionalOp':
                console.error('do this param', paramName, param);
                this.#proportionalOp = param.getValueAsBool() ?? DEFAULT_PROPORTIONAL_OP;
                break;
            case 'm_bEaseOut':
                this.#easeOut = param.getValueAsBool() ?? DEFAULT_EASE_OUT;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        //TODO : use m_flBias m_bEaseOut
        const context = particle.context.get(this);
        let rate, startTime, endTime;
        if (context == undefined) {
            //Init per particle parameters
            rate = RandomFloat(this.#rateMin, this.#rateMax);
            startTime = RandomFloat(this.#startTimeMin, this.#startTimeMax);
            endTime = RandomFloat(this.#endTimeMin, this.#endTimeMax);
            particle.context.set(this, { r: rate, s: startTime, e: endTime });
        }
        else {
            rate = context.r;
            startTime = context.s;
            endTime = context.e;
        }
        const particleTime = this.#proportionalOp ? particle.proportionOfLife : particle.currentTime;
        if (particleTime < startTime || particleTime > endTime) {
            return;
        }
        const value = particle.getField(this.#field) + rate * elapsedTime;
        particle.setField(this.#field, value);
    }
}
RegisterSource2ParticleOperator('C_OP_RampScalarSpline', RampScalarSpline);

const DEFAULT_VECTOR = vec3.fromValues(1, 0, 0);
const v$4 = vec3.create();
const DEFAULT_FIELD_OUTPUT$1 = PARTICLE_FIELD_POSITION; // TODO: check default value
const DEFAULT_SCALE = 1; // TODO: check default value
class RemapControlPointDirectionToVector extends Operator {
    #fieldOutput = DEFAULT_FIELD_OUTPUT$1;
    #scale = DEFAULT_SCALE;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_flScale':
                this.#scale = param.getValueAsNumber() ?? DEFAULT_SCALE;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        const cp = this.system.getControlPoint(this.controlPointNumber);
        vec3.transformQuat(v$4, DEFAULT_VECTOR, cp.currentWorldQuaternion);
        vec3.scale(v$4, v$4, this.#scale);
        particle.setField(this.#fieldOutput, v$4);
    }
}
RegisterSource2ParticleOperator('C_OP_RemapControlPointDirectionToVector', RemapControlPointDirectionToVector);

const tempQuat$1 = quat.create();
quat.create();
class RemapCPOrientationToRotations extends Operator {
    #vecRotation = vec3.create();
    #controlPointNumber = 0; //m_TransformInput
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_vecRotation':
                param.getValueAsVec3(this.#vecRotation); // pitch yaw roll (Y Z X)
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        const cp = this.system.getControlPoint(this.#controlPointNumber);
        if (cp) {
            cp.getWorldQuaternion(tempQuat$1);
            quat.rotateY(tempQuat$1, tempQuat$1, this.#vecRotation[0] * DEG_TO_RAD);
            quat.rotateZ(tempQuat$1, tempQuat$1, this.#vecRotation[1] * DEG_TO_RAD);
            quat.rotateX(tempQuat$1, tempQuat$1, this.#vecRotation[2] * DEG_TO_RAD);
            quat.copy(particle.quaternion, tempQuat$1);
        }
    }
}
RegisterSource2ParticleOperator('C_OP_RemapCPOrientationToRotations', RemapCPOrientationToRotations);

const DEFAULT_CP_INPUT$1 = 0; // TODO: check default value
const DEFAULT_FIELD = -1; // TODO: check default value
const DEFAULT_INPUT_MIN$2 = 0; // TODO: check default value
const DEFAULT_INPUT_MAX$2 = 1; // TODO: check default value
const DEFAULT_OUTPUT_MIN$1 = 0; // TODO: check default value
const DEFAULT_OUTPUT_MAX$1 = 1; // TODO: check default value
const DEFAULT_START_TIME = -1; // TODO: check default value
const DEFAULT_END_TIME = -1; // TODO: check default value
const DEFAULT_INTERP_RATE$1 = 0; // TODO: check default value
const DEFAULT_SET_METHOD$2 = 'PARTICLE_SET_SCALE_INITIAL_VALUE'; // TODO: check default value//TODO: enum
class RemapCPtoScalar extends Operator {
    //#fieldOutput = PARTICLE_FIELD_RADIUS;
    #cpInput = DEFAULT_CP_INPUT$1;
    #field = DEFAULT_FIELD;
    #inputMin = DEFAULT_INPUT_MIN$2;
    #inputMax = DEFAULT_INPUT_MAX$2;
    #outputMin = DEFAULT_OUTPUT_MIN$1;
    #outputMax = DEFAULT_OUTPUT_MAX$1;
    #startTime = DEFAULT_START_TIME;
    #endTime = DEFAULT_END_TIME;
    #interpRate = DEFAULT_INTERP_RATE$1;
    #setMethod = DEFAULT_SET_METHOD$2;
    //scaleInitialRange;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_nCPInput':
                this.#cpInput = param.getValueAsNumber() ?? DEFAULT_CP_INPUT$1;
                break;
            case 'm_nField':
                console.error('do this param', paramName, param);
                this.#field = param.getValueAsNumber() ?? DEFAULT_FIELD; //TODO check -1 / 0 / 1 / 2
                break;
            case 'm_flInputMin': // TODO: mutualize
                this.#inputMin = param.getValueAsNumber() ?? DEFAULT_INPUT_MIN$2;
                break;
            case 'm_flInputMax': // TODO: mutualize
                this.#inputMax = param.getValueAsNumber() ?? DEFAULT_INPUT_MAX$2;
                break;
            case 'm_flOutputMin': // TODO: mutualize
                this.#outputMin = param.getValueAsNumber() ?? DEFAULT_OUTPUT_MIN$1;
                break;
            case 'm_flOutputMax': // TODO: mutualize
                this.#outputMax = param.getValueAsNumber() ?? DEFAULT_OUTPUT_MAX$1;
                break;
            case 'm_flStartTime':
                this.#startTime = param.getValueAsNumber() ?? DEFAULT_START_TIME;
                break;
            case 'm_flEndTime':
                this.#endTime = param.getValueAsNumber() ?? DEFAULT_END_TIME;
                break;
            case 'm_flInterpRate':
                this.#interpRate = param.getValueAsNumber() ?? DEFAULT_INTERP_RATE$1;
                break;
            case 'm_nSetMethod':
                this.#setMethod = param.getValueAsString() ?? DEFAULT_SET_METHOD$2;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        //TODO: use m_flInterpRate
        const cpInputPos = this.system.getControlPoint(this.#cpInput).currentWorldPosition;
        let value = cpInputPos[this.#field] ?? 0;
        value = RemapValClamped(value, this.#inputMin, this.#inputMax, this.#outputMin, this.#outputMax);
        const scaleInitial = /*this.scaleInitialRange || */ this.#setMethod == 'PARTICLE_SET_SCALE_INITIAL_VALUE'; //TODO: optimize
        if (scaleInitial) {
            value = lerp(1, value, strength);
        }
        else {
            value = lerp(particle.getField(this.fieldOutput), value, strength);
        }
        particle.setField(this.fieldOutput, value, scaleInitial);
    }
}
RegisterSource2ParticleOperator('C_OP_RemapCPtoScalar', RemapCPtoScalar);

const DEFAULT_IGNORE_DELTA = false; // TODO: check default value
const DEFAULT_INPUT_MIN$1 = 0; // TODO: check default value
const DEFAULT_INPUT_MAX$1 = 1; // TODO: check default value
const DEFAULT_SET_METHOD$1 = 'PARTICLE_SET_SCALE_CURRENT_VALUE'; // TODO: check default value
class RemapSpeed extends Operator {
    #ignoreDelta = DEFAULT_IGNORE_DELTA;
    #inputMin = DEFAULT_INPUT_MIN$1;
    #inputMax = DEFAULT_INPUT_MAX$1;
    #setMethod = DEFAULT_SET_METHOD$1;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_bIgnoreDelta':
                this.#ignoreDelta = param.getValueAsBool() ?? DEFAULT_IGNORE_DELTA;
                break;
            case 'm_flInputMin':
                this.#inputMin = param.getValueAsNumber() ?? DEFAULT_INPUT_MIN$1;
                break;
            case 'm_flInputMax':
                this.#inputMin = param.getValueAsNumber() ?? DEFAULT_INPUT_MAX$1;
                break;
            case 'm_nSetMethod':
                this.#setMethod = param.getValueAsString() ?? DEFAULT_SET_METHOD$1;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        //TODO
    }
}
RegisterSource2ParticleOperator('C_OP_RemapSpeed', RemapSpeed);

const DEFAULT_INPUT_MIN = 0; // TODO: check default value
const DEFAULT_INPUT_MAX = 1; // TODO: check default value
const DEFAULT_OUTPUT_MIN = 0; // TODO: check default value
const DEFAULT_OUTPUT_MAX = 1; // TODO: check default value
const DEFAULT_OUT_CONTROL_POINT_NUMBER = 1; // TODO: check default value
class RemapSpeedtoCP extends Operator {
    #inputMin = DEFAULT_INPUT_MIN;
    #inputMax = DEFAULT_INPUT_MAX;
    #outputMin = DEFAULT_OUTPUT_MIN;
    #outputMax = DEFAULT_OUTPUT_MAX;
    #outControlPointNumber = DEFAULT_OUT_CONTROL_POINT_NUMBER;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_flInputMin':
                this.#inputMin = param.getValueAsNumber() ?? DEFAULT_INPUT_MIN;
                break;
            case 'm_flInputMax':
                this.#inputMin = param.getValueAsNumber() ?? DEFAULT_INPUT_MAX;
                break;
            case 'm_flOutputMin':
                this.#outputMin = param.getValueAsNumber() ?? DEFAULT_OUTPUT_MIN;
                break;
            case 'm_flOutputMax':
                this.#outputMax = param.getValueAsNumber() ?? DEFAULT_OUTPUT_MAX;
                break;
            case 'm_nOutControlPointNumber':
                this.#outputMax = param.getValueAsNumber() ?? DEFAULT_OUT_CONTROL_POINT_NUMBER;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        //TODO
    }
}
RegisterSource2ParticleOperator('C_OP_RemapSpeedtoCP', RemapSpeedtoCP);

class RepeatedTriggerChildGroup extends Operator {
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_flClusterCooldown':
                // used in doOperate
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        this.getParamScalarValue('m_flClusterCooldown');
        //TODO: i have no idea of what it does
    }
}
RegisterSource2ParticleOperator('C_OP_RepeatedTriggerChildGroup', RepeatedTriggerChildGroup);

const DEFAULT_CP_INPUT = 0; // TODO: check default value
const DEFAULT_CP_OUTPUT = 1; // TODO: check default value
class SetControlPointFromObjectScale extends Operator {
    #cpInput = 0;
    #cpOutput = 1;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_nCPInput':
                this.#cpInput = param.getValueAsNumber() ?? DEFAULT_CP_INPUT;
                break;
            case 'm_nCPOutput':
                this.#cpOutput = param.getValueAsNumber() ?? DEFAULT_CP_OUTPUT;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        this.system.getControlPoint(this.#cpInput);
        const cpOutput = this.system.getControlPoint(this.#cpOutput);
        //TODO: use the actual scale
        cpOutput.setPosition(vec3.fromValues(1, 1, 1));
    }
    isPreEmission() {
        return true;
    }
}
RegisterSource2ParticleOperator('C_OP_SetControlPointFromObjectScale', SetControlPointFromObjectScale);

quat.create();
const DEFAULT_CP = 1; // TODO: check default value
const DEFAULT_USE_WORLD_LOCATION$2 = false; // TODO: check default value
const DEFAULT_HEAD_LOCATION$3 = 0; // TODO: check default value
// TODO: check if disabled ?
class SetControlPointOrientation extends Operator {
    #useWorldLocation = DEFAULT_USE_WORLD_LOCATION$2;
    #randomize = false; // TODO: check default value
    #setOnce = false; // TODO: check default value
    #cp = DEFAULT_CP;
    #headLocation = DEFAULT_HEAD_LOCATION$3;
    #rotation = vec3.create(); // TODO: check default value
    #rotationB = vec3.create(); // TODO: check default value
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_flInterpolation':
                console.error('do this param', paramName, param);
                break;
            case 'm_bUseWorldLocation':
                this.#useWorldLocation = param.getValueAsBool() ?? DEFAULT_USE_WORLD_LOCATION$2;
                break;
            case 'm_bRandomize':
                console.error('do this param', paramName, param);
                this.#randomize = param.getValueAsBool() ?? false; // TODO: check default value
                break;
            case 'm_bSetOnce':
                console.error('do this param', paramName, param);
                this.#setOnce = param.getValueAsBool() ?? false; // TODO: check default value
                break;
            case 'm_nCP': //TODO: mutualize
                this.#cp = param.getValueAsNumber() ?? DEFAULT_CP;
                break;
            case 'm_nHeadLocation':
                this.#headLocation = param.getValueAsNumber() ?? DEFAULT_HEAD_LOCATION$3;
                break;
            case 'm_vecRotation':
                param.getValueAsVec3(this.#rotation);
                break;
            case 'm_vecRotationB':
                param.getValueAsVec3(this.#rotationB);
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        return;
    }
    isPreEmission() {
        return true;
    }
}
RegisterSource2ParticleOperator('C_OP_SetControlPointOrientation', SetControlPointOrientation);

const v$3 = vec3.create();
const DEFAULT_USE_WORLD_LOCATION$1 = false; // TODO: check default value
const DEFAULT_ORIENT$1 = false; // TODO: check default value
const DEFAULT_CP_1$2 = 1; // TODO: check default value
const DEFAULT_CP_2 = 2; // TODO: check default value
const DEFAULT_CP_3 = 3; // TODO: check default value
const DEFAULT_CP_4 = 4; // TODO: check default value
const DEFAULT_HEAD_LOCATION$2 = 0; // TODO: check default value
const DEFAULT_SET_ONCE$1 = false; // TODO: check default value
class SetControlPointPositions extends Operator {
    #useWorldLocation = DEFAULT_USE_WORLD_LOCATION$1;
    #orient = DEFAULT_ORIENT$1;
    #cp = [DEFAULT_CP_1$2, DEFAULT_CP_2, DEFAULT_CP_3, DEFAULT_CP_4];
    #cpPos = [vec3.fromValues(128, 0, 0), vec3.fromValues(0, 128, 0), vec3.fromValues(-128, 0, 0), vec3.fromValues(0, -128, 0)]; // TODO: check default value
    #headLocation = DEFAULT_HEAD_LOCATION$2;
    #setOnce = DEFAULT_SET_ONCE$1;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_bUseWorldLocation': // TODO: mutualize
                this.#useWorldLocation = param.getValueAsBool() ?? DEFAULT_USE_WORLD_LOCATION$1;
                break;
            case 'm_bOrient':
                this.#orient = param.getValueAsBool() ?? DEFAULT_ORIENT$1;
                break;
            case 'm_bSetOnce':
                this.#setOnce = param.getValueAsBool() ?? DEFAULT_SET_ONCE$1;
                break;
            case 'm_nCP1':
                this.#cp[0] = param.getValueAsNumber() ?? DEFAULT_CP_1$2;
                break;
            case 'm_nCP2':
                this.#cp[1] = param.getValueAsNumber() ?? DEFAULT_CP_2;
                break;
            case 'm_nCP3':
                this.#cp[2] = param.getValueAsNumber() ?? DEFAULT_CP_3;
                break;
            case 'm_nCP4':
                this.#cp[3] = param.getValueAsNumber() ?? DEFAULT_CP_4;
                break;
            case 'm_vecCP1Pos':
                param.getValueAsVec3(this.#cpPos[0]);
                break;
            case 'm_vecCP2Pos':
                param.getValueAsVec3(this.#cpPos[1]);
                break;
            case 'm_vecCP3Pos':
                param.getValueAsVec3(this.#cpPos[2]);
                break;
            case 'm_vecCP4Pos':
                param.getValueAsVec3(this.#cpPos[3]);
                break;
            case 'm_nHeadLocation':
                this.#headLocation = param.getValueAsNumber() ?? DEFAULT_HEAD_LOCATION$2;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        // TODO: use orient
        //const list = ['First', 'Second', 'Third', 'Fourth'];
        const useWorldLocation = this.#useWorldLocation;
        this.system.getControlPointPosition(this.#headLocation);
        let cpNumber;
        let cpLocation;
        const headLocation = this.system.getControlPoint(this.#headLocation);
        for (let cpIndex = 0; cpIndex < 4; ++cpIndex) {
            cpNumber = this.#cp[cpIndex];
            cpLocation = this.#cpPos[cpIndex];
            const cp = this.system.getControlPoint(cpNumber);
            if (!useWorldLocation) {
                vec3.transformQuat(v$3, cpLocation, headLocation.currentWorldQuaternion);
                vec3.add(v$3, v$3, headLocation.currentWorldPosition);
                cp.setPosition(v$3);
            }
            else {
                cp.setPosition(cpLocation);
                this.system.setControlPointPosition(cpNumber, cpLocation);
            }
        }
    }
    isPreEmission() {
        return true;
    }
}
RegisterSource2ParticleOperator('C_OP_SetControlPointPositions', SetControlPointPositions);

const DEFAULT_FOLLOW_ATTACHMENT = false; // TODO: check default value
const DEFAULT_ATTACHMENT_NAME = ''; // TODO: check default value
const DEFAULT_HITBOX_SET_NAME = 'default'; // TODO: check default value
const DEFAULT_FIRST_CONTROL_POINT$1 = 0; // TODO: check default value
const DEFAULT_FIRST_SOURCE_POINT = 0; // TODO: check default value
const DEFAULT_NUM_CONTROL_POINT = 1; // TODO: check default value
const DEFAULT_SKIN = false; // TODO: check default value
class SetControlPointsToModelParticles extends Operator {
    #followAttachment = DEFAULT_FOLLOW_ATTACHMENT;
    #attachmentName = DEFAULT_ATTACHMENT_NAME;
    #hitboxSetName = DEFAULT_HITBOX_SET_NAME;
    #firstControlPoint = DEFAULT_FIRST_CONTROL_POINT$1;
    #numControlPoints = DEFAULT_NUM_CONTROL_POINT;
    firstSourcePoint = DEFAULT_FIRST_SOURCE_POINT;
    #skin = DEFAULT_SKIN; //TODO: remove ?
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_HitboxSetName':
                this.#hitboxSetName = param.getValueAsString() ?? DEFAULT_HITBOX_SET_NAME;
                break;
            case 'm_AttachmentName':
                this.#attachmentName = param.getValueAsString() ?? DEFAULT_ATTACHMENT_NAME;
                break;
            case 'm_nFirstControlPoint':
                this.#firstControlPoint = param.getValueAsNumber() ?? DEFAULT_FIRST_CONTROL_POINT$1;
                break;
            case 'm_nNumControlPoints':
                this.#numControlPoints = param.getValueAsNumber() ?? DEFAULT_NUM_CONTROL_POINT;
                break;
            case 'm_nFirstSourcePoint':
                this.firstSourcePoint = param.getValueAsNumber() ?? DEFAULT_FIRST_SOURCE_POINT;
                break;
            case 'm_bSkin':
                this.#skin = param.getValueAsBool() ?? DEFAULT_SKIN;
                break;
            case 'm_bAttachment':
                this.#followAttachment = param.getValueAsBool() ?? DEFAULT_FOLLOW_ATTACHMENT;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime) {
        //todo: use m_bSkin m_bAttachment m_HitboxSetName m_AttachmentName
        const children = this.system.childSystems;
        const firstControlPoint = this.#firstControlPoint;
        const firstSourcePoint = this.firstSourcePoint;
        for (let i = 0; i < this.#numControlPoints; ++i) {
            const particle = this.system.livingParticles[firstSourcePoint + i];
            if (particle) {
                for (const child of children) {
                    const childCp = child.getOwnControlPoint(firstControlPoint + i);
                    childCp.position = particle.position;
                    if (this.#followAttachment) {
                        const model = this.system.getParentModel();
                        if (model) {
                            const attachment = model.getAttachment?.(this.#attachmentName);
                            if (attachment) {
                                childCp.quaternion = attachment.getWorldQuaternion();
                                childCp.quaternion = particle.quaternion;
                            }
                        }
                    }
                    if (childCp.lastComputed == -1) {
                        // Discard the delta if it's a newly create control point
                        childCp.resetDelta();
                    }
                }
            }
        }
    }
}
RegisterSource2ParticleOperator('C_OP_SetControlPointsToModelParticles', SetControlPointsToModelParticles);

const center$1 = vec3.create();
const DEFAULT_CP_1$1 = 1; // TODO: check default value
class SetControlPointToCenter extends Operator {
    #cp1 = DEFAULT_CP_1$1;
    #cp1Pos = vec3.create();
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_nCP1': // TODO: mutualize this parameter ?
                this.#cp1 = param.getValueAsNumber() ?? DEFAULT_CP_1$1;
                break;
            case 'm_vecCP1Pos':
                param.getValueAsVec3(this.#cp1Pos);
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        this.system.getBoundsCenter(center$1);
        vec3.add(center$1, center$1, this.#cp1Pos);
        this.system.getOwnControlPoint(this.#cp1).position = center$1;
    }
    isPreEmission() {
        return true;
    }
}
RegisterSource2ParticleOperator('C_OP_SetControlPointToCenter', SetControlPointToCenter);

const UNIT_VEC3_X = vec3.fromValues(1, 0, 0);
const UNIT_VEC3_Z = vec3.fromValues(0, 0, 1);
const q = quat.create();
const DEFAULT_INTERP_RATE = 0; // TODO: check default value
const DEFAULT_MAX_TRACE_LENGTH = 128; // TODO: check default value
const DEFAULT_TOLERANCE = 32; // TODO: check default value
const DEFAULT_TRACE_OFFSET = 64; // TODO: check default value
const DEFAULT_COLLISION_GROUP_NAME = 'NONE'; // TODO: check default value
const DEFAULT_INPUT_CP = 0; // TODO: check default value
const DEFAULT_OUTPUT_CP = 1; // TODO: check default value
const DEFAULT_INCLUDE_WATER = false; // TODO: check default value
class SetCPOrientationToGroundNormal extends Operator {
    #interpRate = DEFAULT_INTERP_RATE;
    #maxTraceLength = DEFAULT_MAX_TRACE_LENGTH;
    #tolerance = DEFAULT_TOLERANCE;
    #traceOffset = DEFAULT_TRACE_OFFSET;
    #collisionGroupName = DEFAULT_COLLISION_GROUP_NAME;
    #inputCP = DEFAULT_INPUT_CP;
    #outputCP = DEFAULT_OUTPUT_CP;
    #includeWater = DEFAULT_INCLUDE_WATER;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_flInterpRate':
                this.#interpRate = param.getValueAsNumber() ?? DEFAULT_INTERP_RATE;
                break;
            case 'm_flMaxTraceLength':
                this.#maxTraceLength = param.getValueAsNumber() ?? DEFAULT_MAX_TRACE_LENGTH;
                break;
            case 'm_flTolerance':
                this.#tolerance = param.getValueAsNumber() ?? DEFAULT_TOLERANCE;
                break;
            case 'm_flTraceOffset':
                this.#traceOffset = param.getValueAsNumber() ?? DEFAULT_TRACE_OFFSET;
                break;
            case 'm_CollisionGroupName': //TODO: mutualize
                this.#collisionGroupName = param.getValueAsString() ?? DEFAULT_COLLISION_GROUP_NAME;
                break;
            case 'm_nInputCP': //TODO: mutualize
                this.#inputCP = param.getValueAsNumber() ?? DEFAULT_INPUT_CP;
                break;
            case 'm_nOutputCP': //TODO mutualize
                this.#outputCP = param.getValueAsNumber() ?? DEFAULT_OUTPUT_CP;
                break;
            case 'm_bIncludeWater':
                this.#includeWater = param.getValueAsBool() ?? DEFAULT_INCLUDE_WATER;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        //TODO: do it properly
        const outputCP = this.system.getControlPoint(this.#outputCP);
        if (outputCP) {
            quat.rotationTo(q, UNIT_VEC3_X, UNIT_VEC3_Z);
            outputCP.quaternion = q;
        }
    }
}
RegisterSource2ParticleOperator('C_OP_SetCPOrientationToGroundNormal', SetCPOrientationToGroundNormal);

class SetFloat extends Operator {
    #normalizePerLiving = true;
    outputField = PARTICLE_FIELD_RADIUS; //TODO: not sure about the default field
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_InputValue':
                // used in dooperate
                break;
            case 'm_nOutputField': // TODO: mutualize param ?
                this.outputField = param.getValueAsNumber() ?? PARTICLE_FIELD_RADIUS;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        //TODO: use lerp
        const value = this.getParamScalarValue('m_InputValue', particle);
        //TODO: use setMethod
        particle.setField(this.outputField, value, this.setMethod == 'PARTICLE_SET_SCALE_INITIAL_VALUE');
        //particle.setField(this.outputField, value, this.setMethod == 'PARTICLE_SET_SCALE_INITIAL_VALUE');
    }
}
RegisterSource2ParticleOperator('C_OP_SetFloat', SetFloat);

const DEFAULT_SET_ORIENTATION$1 = false; // TODO: check default value
const DEFAULT_NUM_CONTROL_POINTS$1 = 1; // TODO: check default value
const DEFAULT_FIRST_SOURCE_CONTROL_POINT = 0; // TODO: check default value
const DEFAULT_CHILD_CONTROL_POINT = 0; // TODO: check default value
// TODO: check: can't create in dota tools
class SetParentControlPointsToChildCP extends Operator {
    #childGroupID = 0; // TODO: check default value
    #childControlPoint = DEFAULT_CHILD_CONTROL_POINT;
    #numControlPoints = DEFAULT_NUM_CONTROL_POINTS$1;
    #firstSourcePoint = DEFAULT_FIRST_SOURCE_CONTROL_POINT;
    #setOrientation = DEFAULT_SET_ORIENTATION$1;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_nChildGroupID':
                this.#childGroupID = param.getValueAsNumber() ?? 0;
                break;
            case 'm_nChildControlPoint':
                this.#childControlPoint = param.getValueAsNumber() ?? DEFAULT_CHILD_CONTROL_POINT;
                break;
            case 'm_nNumControlPoints':
                this.#numControlPoints = param.getValueAsNumber() ?? DEFAULT_NUM_CONTROL_POINTS$1;
                break;
            case 'm_nFirstSourcePoint':
                this.#firstSourcePoint = param.getValueAsNumber() ?? DEFAULT_FIRST_SOURCE_CONTROL_POINT;
                break;
            case 'm_bSetOrientation':
                this.#setOrientation = param.getValueAsBool() ?? DEFAULT_SET_ORIENTATION$1;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        // TODO: use setOrientation
        const children = this.system.childSystems;
        let childId = this.#childGroupID;
        let cpId = this.#firstSourcePoint;
        let count = this.#numControlPoints;
        while (count--) {
            const child = children[childId];
            const cp = this.system.getControlPoint(cpId);
            if (child && cp) {
                const childCp = child.getOwnControlPoint(this.#childControlPoint);
                childCp.position = cp.currentWorldPosition;
            }
            ++childId;
            ++cpId;
        }
    }
    isPreEmission() {
        return true;
    }
}
RegisterSource2ParticleOperator('C_OP_SetParentControlPointsToChildCP', SetParentControlPointsToChildCP);

const DEFAULT_CHILD_GROUP_ID = 0;
const DEFAULT_FIRST_CONTROL_POINT = 0;
const DEFAULT_NUM_CONTROL_POINTS = 1;
const DEFAULT_SET_ORIENTATION = false;
const DEFAULT_ORIENTATION_FIELD = Source2ParticleVectorField.Disabled;
const DEFAULT_NUM_BASED_ON_PARTICLE_COUNT = false;
class SetPerChildControlPoint extends Operator {
    #childGroupID = DEFAULT_CHILD_GROUP_ID;
    #firstControlPoint = DEFAULT_FIRST_CONTROL_POINT;
    #numControlPoints = DEFAULT_NUM_CONTROL_POINTS;
    #setOrientation = DEFAULT_SET_ORIENTATION; //set orientation from velocity
    #orientationField = DEFAULT_ORIENTATION_FIELD; //orientation vector
    #numBasedOnParticleCount = DEFAULT_NUM_BASED_ON_PARTICLE_COUNT;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_nChildGroupID':
                this.#childGroupID = param.getValueAsNumber() ?? DEFAULT_CHILD_GROUP_ID;
                break;
            case 'm_nFirstControlPoint':
                this.#firstControlPoint = param.getValueAsNumber() ?? DEFAULT_FIRST_CONTROL_POINT;
                break;
            case 'm_nNumControlPoints':
                this.#numControlPoints = param.getValueAsNumber() ?? DEFAULT_NUM_CONTROL_POINTS;
                break;
            case 'm_bSetOrientation':
                this.#setOrientation = param.getValueAsBool() ?? DEFAULT_SET_ORIENTATION;
                break;
            case 'm_nOrientationField':
                this.#orientationField = param.getValueAsNumber() ?? DEFAULT_ORIENTATION_FIELD;
                break;
            case 'm_bNumBasedOnParticleCount':
                this.#numBasedOnParticleCount = param.getValueAsBool() ?? DEFAULT_NUM_BASED_ON_PARTICLE_COUNT;
                break;
            case 'm_nParticleIncrement':
            case 'm_nFirstSourcePoint':
                //used in doOperate
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        //TODO: use m_nChildGroupID
        //TODO: set m_bSetOrientation
        const particleIncrement = this.getParamScalarValue('m_nParticleIncrement') ?? 1; // TODO: check default value
        let particleId = this.getParamScalarValue('m_nFirstSourcePoint') ?? 0; // TODO: check default value
        const children = this.system.childSystems;
        let childId = this.#childGroupID;
        let count = this.#numBasedOnParticleCount ? this.system.livingParticles.length : this.#numControlPoints;
        while (count--) {
            const child = children[childId];
            const sourceParticle = this.system.livingParticles[particleId];
            if (child && sourceParticle) {
                const childCp = child.getOwnControlPoint(this.#firstControlPoint);
                childCp.position = sourceParticle.position;
            }
            ++childId;
            particleId += particleIncrement;
        }
    }
}
RegisterSource2ParticleOperator('C_OP_SetPerChildControlPoint', SetPerChildControlPoint);

const v$2 = vec3.create();
const DEFAULT_USE_WORLD_LOCATION = false; // TODO: check default value
const DEFAULT_ORIENT = false; // TODO: check default value
const DEFAULT_CP1 = 1; // TODO: check default value
const DEFAULT_HEAD_LOCATION$1 = 0; // TODO: check default value
class SetRandomControlPointPosition extends Operator {
    #useWorldLocation = DEFAULT_USE_WORLD_LOCATION;
    #orient = DEFAULT_ORIENT;
    #cp1 = 1;
    #headLocation = DEFAULT_HEAD_LOCATION$1;
    cpMinPos = vec3.create(); // TODO: check default value
    cpMaxPos = vec3.create(); // TODO: check default value
    lastRandomTime = -1;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_bUseWorldLocation':
                this.#useWorldLocation = param.getValueAsBool() ?? DEFAULT_USE_WORLD_LOCATION;
                break;
            case 'm_bOrient':
                this.#orient = param.getValueAsBool() ?? DEFAULT_ORIENT;
                break;
            case 'm_nCP1':
                this.#cp1 = param.getValueAsNumber() ?? DEFAULT_CP1;
                break;
            case 'm_nHeadLocation':
                this.#headLocation = param.getValueAsNumber() ?? DEFAULT_HEAD_LOCATION$1;
                break;
            case 'm_vecCPMinPos':
                param.getValueAsVec3(this.cpMinPos);
                break;
            case 'm_vecCPMaxPos':
                param.getValueAsVec3(this.cpMaxPos);
                break;
            case 'm_flReRandomRate':
            case 'm_flInterpolation':
                //used in doOperate
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        const reRandomRate = this.getParamScalarValue('m_flReRandomRate') ?? -1; // TODO: check default value
        this.getParamScalarValue('m_flInterpolation') ?? 1; // TODO: check default value
        //TODO: do interpolation
        if ((reRandomRate >= 0 || this.lastRandomTime < 0) && (this.system.currentTime - this.lastRandomTime > reRandomRate)) {
            this.lastRandomTime = this.system.currentTime;
            vec3RandomBox(v$2, this.cpMinPos, this.cpMaxPos);
            const headLocation = this.system.getControlPoint(this.#headLocation);
            const cp1 = this.system.getControlPoint(this.#cp1);
            vec3.transformQuat(v$2, v$2, headLocation.currentWorldQuaternion);
            vec3.add(v$2, v$2, headLocation.currentWorldPosition);
            cp1.position = v$2;
            if (this.#orient) {
                cp1.setWorldQuaternion(headLocation.currentWorldQuaternion);
            }
        }
    }
    isPreEmission() {
        return true;
    }
}
RegisterSource2ParticleOperator('C_OP_SetRandomControlPointPosition', SetRandomControlPointPosition);

const DEFAULT_POSITION = vec3.fromValues(128, 0, 0);
const v$1 = vec3.create();
const tempVec4 = vec4.create();
const DEFAULT_CP_1 = 1; // TODO: check default value
const DEFAULT_USE_WORLD_POSITION = false; // TODO: check default value
const DEFAULT_SET_ONCE = false; // TODO: check default value
const DEFAULT_HEAD_LOCATION = 0; // TODO: check default value
class SetSingleControlPointPosition extends Operator {
    #useWorldLocation = DEFAULT_USE_WORLD_POSITION;
    #setOnce = DEFAULT_SET_ONCE;
    #cp1 = DEFAULT_CP_1;
    #headLocation = DEFAULT_HEAD_LOCATION;
    #set = false;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_vecCP1Pos':
                //used in doOperate
                break;
            case 'm_bUseWorldLocation':
                this.#useWorldLocation = param.getValueAsBool() ?? DEFAULT_USE_WORLD_POSITION;
                break;
            case 'm_bSetOnce': // TODO: mutualize
                this.#setOnce = param.getValueAsBool() ?? DEFAULT_SET_ONCE;
                break;
            case 'm_nCP1':
                this.#cp1 = param.getValueAsNumber() ?? DEFAULT_CP_1;
                break;
            case 'm_nHeadLocation':
                this.#headLocation = param.getValueAsNumber() ?? DEFAULT_HEAD_LOCATION;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    reset() {
        this.#set = false;
    }
    doOperate(particle, elapsedTime, strength) {
        const cp1Pos = this.getParamVectorValue(tempVec4, 'm_vecCP1Pos', particle) ?? DEFAULT_POSITION;
        //TODO
        if (!this.#setOnce || !this.#set) {
            const cp = this.system.getOwnControlPoint(this.#cp1);
            if (this.#useWorldLocation) {
                cp.setPosition(cp1Pos);
            }
            else {
                const headCp = this.system.getControlPoint(this.#headLocation);
                vec3.transformQuat(v$1, cp1Pos, headCp.currentWorldQuaternion);
                vec3.add(v$1, v$1, headCp.currentWorldPosition);
                cp.position = v$1;
            }
            this.#set = true;
        }
    }
    isPreEmission() {
        return true;
    }
}
RegisterSource2ParticleOperator('C_OP_SetSingleControlPointPosition', SetSingleControlPointPosition);

const tempQuat = quat.create();
const tempVec3$1 = vec3.create();
const tempVec3_2 = vec3.create();
const DEFAULT_OFFSET_LOCAL = false; // TODO: check default value
class SetToCP extends Operator {
    #offset = vec3.create();
    #offsetLocal = DEFAULT_OFFSET_LOCAL;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_vecOffset':
                param.getValueAsVec3(this.#offset);
                break;
            case 'm_bOffsetLocal': //TODO: mutualize
                this.#offsetLocal = param.getValueAsBool() ?? DEFAULT_OFFSET_LOCAL;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        const cp = this.system.getControlPoint(this.controlPointNumber);
        if (cp) {
            cp.getWorldPosition(tempVec3_2);
            if (this.#offsetLocal) {
                vec3.transformQuat(tempVec3$1, this.#offset, cp.getWorldQuaternion(tempQuat));
                vec3.add(tempVec3$1, tempVec3$1, tempVec3_2);
            }
            else {
                vec3.add(tempVec3$1, this.#offset, tempVec3_2);
            }
            vec3.copy(particle.position, tempVec3$1);
            vec3.copy(particle.prevPosition, tempVec3$1);
        }
    }
}
RegisterSource2ParticleOperator('C_OP_SetToCP', SetToCP);

const DEFAULT_VECTOR_VALUE = vec4.create();
const setVecTempVec4 = vec4.create();
const DEFAULT_OUTPUT_FIELD = Source2ParticleVectorField.Color;
const DEFAULT_SET_METHOD = Source2ParticleSetMethod.SetValue;
class SetVec extends Operator {
    #outputField = DEFAULT_OUTPUT_FIELD;
    #setMethod = DEFAULT_SET_METHOD;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_nOutputField':
                this.#outputField = param.getValueAsNumber() ?? DEFAULT_OUTPUT_FIELD;
                break;
            case 'm_nSetMethod':
                this.#setMethod = stringToSetMethod(param.getValueAsString()) ?? DEFAULT_SET_METHOD;
                break;
            case 'm_InputValue':
            case 'm_Lerp':
                // used in doOperate
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        //TODO: use lerp
        const inputValue = this.getParamVectorValue(setVecTempVec4, 'm_InputValue', particle) ?? DEFAULT_VECTOR_VALUE;
        this.getParamScalarValue('m_Lerp', particle) ?? 1;
        particle.setField(this.#outputField, inputValue, this.#setMethod == 'PARTICLE_SET_SCALE_INITIAL_VALUE');
    }
}
RegisterSource2ParticleOperator('C_OP_SetVec', SetVec);

const mat = mat4.create();
const nmat = mat3.create();
const IDENTITY_MAT4 = mat4.create();
const DEFAULT_TRANSFORM_NORMALS = false; // TODO: check default value
class SnapshotRigidSkinToBones extends Operator {
    #transformNormals = DEFAULT_TRANSFORM_NORMALS;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_bTransformNormals':
                //normal seems to be transformed whatever this parameter value is ?
                this.#transformNormals = param.getValueAsBool() ?? DEFAULT_TRANSFORM_NORMALS;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        let bone, boneName, boneWeight, boneMat;
        const cp = this.system.getControlPoint(this.controlPointNumber);
        if (!cp) {
            return;
        }
        const model = cp.model;
        if (!model) {
            return;
        }
        const skeleton = model.skeleton;
        if (!skeleton) {
            return;
        }
        const particleSkinning = particle.skinning;
        const particleInitialPosition = particle.initialSkinnedPosition;
        const particleInitialNormal = particle.initialSkinnedNormal ?? DEFAULT_PARTICLE_NORMAL;
        if (particleSkinning && particleInitialPosition) {
            mat[0] = 0;
            mat[1] = 0;
            mat[2] = 0;
            mat[4] = 0;
            mat[5] = 0;
            mat[6] = 0;
            mat[8] = 0;
            mat[9] = 0;
            mat[10] = 0;
            mat[12] = 0;
            mat[13] = 0;
            mat[14] = 0;
            for (let i = 0; i < 4; ++i) {
                boneName = particleSkinning.bones[i];
                if (boneName) {
                    bone = skeleton.getBoneByName(boneName);
                    boneWeight = particleSkinning.weights[i];
                    if (bone && boneWeight) {
                        boneMat = bone ? bone.boneMat : IDENTITY_MAT4;
                        mat[0] += boneWeight * boneMat[0];
                        mat[1] += boneWeight * boneMat[1];
                        mat[2] += boneWeight * boneMat[2];
                        mat[4] += boneWeight * boneMat[4];
                        mat[5] += boneWeight * boneMat[5];
                        mat[6] += boneWeight * boneMat[6];
                        mat[8] += boneWeight * boneMat[8];
                        mat[9] += boneWeight * boneMat[9];
                        mat[10] += boneWeight * boneMat[10];
                        mat[12] += boneWeight * boneMat[12];
                        mat[13] += boneWeight * boneMat[13];
                        mat[14] += boneWeight * boneMat[14];
                    }
                }
            }
            //console.error(mat);
            vec3.transformMat4(particle.position, particleInitialPosition, mat);
            mat3.normalFromMat4(nmat, mat);
            vec3.transformMat3(particle.normal, particleInitialNormal, nmat);
            vec3.copy(particle.prevPosition, particle.position);
        }
        else {
            //Probably should do it better, but it just works
            const particleHitbox = particle.snapHitbox;
            particle.snapHitboxOffset;
            if (particleHitbox) {
                bone = skeleton.getBoneByName(particleHitbox);
                if (bone) {
                    boneMat = bone ? bone.boneMat : IDENTITY_MAT4;
                    //vec3.transformMat4(particle.position, particleInitialPosition, boneMat);
                    mat3.normalFromMat4(nmat, boneMat);
                    vec3.transformMat3(particle.normal, particleInitialNormal, nmat);
                    vec3.copy(particle.prevPosition, particle.position);
                }
            }
        }
    }
}
RegisterSource2ParticleOperator('C_OP_SnapshotRigidSkinToBones', SnapshotRigidSkinToBones);
RegisterSource2ParticleOperator('C_OP_SnapshotSkinToBones', SnapshotRigidSkinToBones); //TODO: set proper operator

const DEFAULT_SPIN_RATE = 0; // TODO: check default value
const DEFAULT_SPIN_RATE_MIN = 0; // TODO: check default value
const DEFAULT_SPIN_RATE_STOP_TIME = 0; // TODO: check default value
class Spin extends Operator {
    #spinRateDegrees = DEFAULT_SPIN_RATE;
    #spinRateMinDegrees = DEFAULT_SPIN_RATE_MIN;
    #spinRateStopTime = DEFAULT_SPIN_RATE_STOP_TIME;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_nSpinRateDegrees':
                this.#spinRateDegrees = param.getValueAsNumber() ?? DEFAULT_SPIN_RATE;
                break;
            case 'm_nSpinRateMinDegrees':
                this.#spinRateMinDegrees = param.getValueAsNumber() ?? DEFAULT_SPIN_RATE_MIN;
                break;
            case 'm_fSpinRateStopTime':
                this.#spinRateStopTime = param.getValueAsNumber() ?? DEFAULT_SPIN_RATE_STOP_TIME;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        //particle.rotationRoll += particle.rotationSpeedRoll * elapsedTime;
        const m_fSpinRateStopTime = this.#spinRateStopTime;
        const m_fSpinRateRadians = (this.#spinRateDegrees) * DEG_TO_RAD; //TODO: optimize
        const m_fSpinRateMinRadians = (this.#spinRateMinDegrees) * DEG_TO_RAD; //TODO: optimize
        const fCurSpinRate = m_fSpinRateRadians /* * flStrength*/; //TODO
        if (fCurSpinRate == 0.0) {
            return;
        }
        const dt = elapsedTime;
        let drot = dt * Math.abs(fCurSpinRate * TWO_PI);
        if (m_fSpinRateStopTime == 0.0) {
            drot = drot % TWO_PI; //fmod(drot, (float)(2.0f * M_PI));
        }
        if (fCurSpinRate < 0.0) {
            drot = -drot;
        }
        //fltx4 Rot_Add = ReplicateX4(drot);
        const Rot_Add = drot;
        //fltx4 Pi_2 = ReplicateX4(2.0*M_PI);
        //fltx4 nPi_2 = ReplicateX4(-2.0*M_PI);
        // FIXME: This is wrong
        const minSpeedRadians = dt * Math.abs(m_fSpinRateMinRadians * TWO_PI); //fltx4 minSpeedRadians = ReplicateX4(dt * fabs(m_fSpinRateMinRadians * 2.0f * M_PI));
        const now = this.system.currentTime;
        const SpinRateStopTime = m_fSpinRateStopTime;
        //CM128AttributeIterator pCreationTimeStamp(PARTICLE_ATTRIBUTE_CREATION_TIME, pParticles);
        //CM128AttributeIterator pLifeDuration(PARTICLE_ATTRIBUTE_LIFE_DURATION, pParticles);
        //CM128AttributeWriteIterator pRot(GetAttributeToSpin(), pParticles);
        // HACK: Rather than redo this, I'm simply remapping the stop time into the percentage of lifetime, rather than seconds
        const LifeSpan = particle.timeToLive;
        let SpinFadePerc = 0;
        let OOSpinFadeRate = 0;
        if (m_fSpinRateStopTime) {
            SpinFadePerc = LifeSpan * SpinRateStopTime;
            OOSpinFadeRate = 1.0 / SpinFadePerc;
        }
        const Age = now - particle.cTime;
        const RScale = Math.max(0, 1.0 - (Age * OOSpinFadeRate));
        // Cap the rotation at a minimum speed
        let deltaRot = Rot_Add * RScale;
        //fltx4 Tooslow = CmpLeSIMD(deltaRot, minSpeedRadians);
        //deltaRot = OrSIMD(AndSIMD(Tooslow, minSpeedRadians), AndNotSIMD(Tooslow, deltaRot));
        deltaRot = Math.max(minSpeedRadians, deltaRot);
        const NewRot = particle.rotationRoll + deltaRot;
        // now, cap at +/- 2*pi
        /*fltx4 Toobig =CmpGeSIMD(NewRot, Pi_2);
        fltx4 Toosmall = CmpLeSIMD(NewRot, nPi_2);

        NewRot = OrSIMD(AndSIMD(Toobig, SubSIMD(NewRot, Pi_2)),
        AndNotSIMD(Toobig, NewRot));

        NewRot = OrSIMD(AndSIMD(Toosmall, AddSIMD(NewRot, Pi_2)),
        AndNotSIMD(Toosmall, NewRot));*/
        //NewRot = Math.min(Math.max(-Math.TWO_PI, NewRot), Math.TWO_PI);
        particle.rotationRoll = NewRot;
    }
}
RegisterSource2ParticleOperator('C_OP_Spin', Spin);

class SpinUpdate extends Operator {
    //This operator has no parameters
    doOperate(particle, elapsedTime, strength) {
        particle.rotationRoll += particle.rotationSpeedRoll * elapsedTime;
    }
}
RegisterSource2ParticleOperator('C_OP_SpinUpdate', SpinUpdate);

const Coord = vec3.create();
const output = vec3.create();
const ofs_y = vec3.fromValues(100000.5, 300000.25, 9000000.75);
const ofs_z = vec3.fromValues(110000.25, 310000.75, 9100000.5);
const DEFAULT_FIELD_OUTPUT = Source2ParticleVectorField.Color;
const DEFAULT_NOISE_SCALE = 0.1;
const DEFAULT_ADDITIVE = false;
const DEFAULT_OFFSET = false;
const DEFAULT_NOISE_ANIMATION_TIME_SCALE = 0;
class VectorNoise extends Operator {
    #fieldOutput = DEFAULT_FIELD_OUTPUT;
    #outputMin = vec3.create();
    #outputMax = vec3.fromValues(1, 1, 1);
    #noiseScale = DEFAULT_NOISE_SCALE; //noise coordinate scale
    #additive = DEFAULT_ADDITIVE;
    #offset = DEFAULT_OFFSET; //offset instead of accelerate position
    #noiseAnimationTimeScale = DEFAULT_NOISE_ANIMATION_TIME_SCALE;
    #valueScale = vec3.create(); //computed
    #valueBase = vec3.create(); //computed
    constructor(system) {
        super(system);
        this.#update();
    }
    #update() {
        vec3.sub(this.#valueScale, this.#outputMax, this.#outputMin);
        vec3.scale(this.#valueScale, this.#valueScale, 0.5);
        vec3.add(this.#valueBase, this.#outputMin, this.#valueScale);
        /*if (this.fieldOutput == PARTICLE_FIELD_COLOR) {
            vec3.scale(this.valueScale, this.valueScale, 1 / 255);
            vec3.scale(this.valueBase, this.valueBase, 1 / 255);
        }*/
    }
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_nFieldOutput':
                this.#fieldOutput = param.getValueAsNumber() ?? DEFAULT_FIELD_OUTPUT;
                this.#update();
                break;
            case 'm_vecOutputMin':
                param.getValueAsVec3(this.#outputMin);
                this.#update();
                break;
            case 'm_vecOutputMax':
                param.getValueAsVec3(this.#outputMax);
                this.#update();
                break;
            case 'm_fl4NoiseScale':
                this.#noiseScale = param.getValueAsNumber() ?? DEFAULT_NOISE_SCALE;
                this.#update();
                break;
            case 'm_bAdditive':
                this.#additive = param.getValueAsBool() ?? false;
                break;
            case 'm_bOffset': // TODO: mutualize
                this.#offset = param.getValueAsBool() ?? DEFAULT_OFFSET;
                break;
            case 'm_flNoiseAnimationTimeScale':
                this.#noiseAnimationTimeScale = param.getValueAsNumber() ?? DEFAULT_NOISE_ANIMATION_TIME_SCALE;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    doOperate(particle, elapsedTime, strength) {
        //TODO: fix this operator ('particles/units/heroes/hero_dark_willow/dark_willow_head_ambient_smoke.vpcf_c')
        vec3.scale(Coord, particle.position, this.#noiseScale * particle.currentTime * 0.001);
        output[0] = (NoiseSIMD(Coord[0], Coord[1], Coord[2]) * this.#valueScale[0] + this.#valueBase[0]);
        vec3.add(Coord, Coord, ofs_y);
        output[1] = (NoiseSIMD(Coord[0], Coord[1], Coord[2]) * this.#valueScale[1] + this.#valueBase[1]);
        vec3.add(Coord, Coord, ofs_z);
        output[2] = (NoiseSIMD(Coord[0], Coord[1], Coord[2]) * this.#valueScale[2] + this.#valueBase[2]);
        particle.setField(this.#fieldOutput, output, undefined, undefined, this.#additive);
    }
}
RegisterSource2ParticleOperator('C_OP_VectorNoise', VectorNoise);

// Base renderer for common attributes like textures
class RenderBase extends Operator {
    material = new Source2SpriteCard('');
    setDefaultTexture = true; //TODO: remove this property
    spriteSheet = null;
    constructor(system) {
        super(system);
        this.material.repository = system.repository;
    }
    setMaterial(material) {
        this.material = material;
    }
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_vecTexturesInput':
                const textureInput0 = param.getValueAsArray()?.[0]; //TODO: check multiple textures ?
                if (textureInput0 && textureInput0.isOperatorParam) {
                    this.setTexture(textureInput0.getSubValue('m_hTexture')?.getValueAsString() ?? DEFAULT_PARTICLE_TEXTURE);
                    const textureChannels = textureInput0.getSubValueAsString('m_nTextureChannels');
                    if (textureChannels) {
                        this.material.setDefine(textureChannels); //TODO: check values
                    }
                }
                break;
            /*
        case 'm_ColorScale':
            const colorScale = vec3.create();
            colorScale[0] = Number(param[0]) * COLOR_SCALE;
            colorScale[1] = Number(param[1]) * COLOR_SCALE;
            colorScale[2] = Number(param[2]) * COLOR_SCALE;
            this.material?.setUniform('uColorScale', colorScale);
            break;
            */
            // Renderer parameters
            case 'm_nOutputBlendMode':
                const blendMode = param.getValueAsString();
                if (blendMode) {
                    this.#setOutputBlendMode(blendMode);
                }
                break;
            case 'm_bAdditive':
                this.#setOutputBlendMode('PARTICLE_OUTPUT_BLEND_MODE_ADD');
                break;
            case 'm_bMod2X':
                this.#setOutputBlendMode('PARTICLE_OUTPUT_BLEND_MODE_MOD2X');
                break;
            /*
        case 'm_flRadiusScale':
            this.radiusScale = param.getValueAsNumber() ?? 1;
            break;
            */
            default:
                super._paramChanged(paramName, param);
        }
    }
    #setOutputBlendMode(outputBlendMode) {
        let blendMode = 0;
        switch (outputBlendMode) {
            case 'PARTICLE_OUTPUT_BLEND_MODE_ADD':
                blendMode = 1;
                break;
            case 'PARTICLE_OUTPUT_BLEND_MODE_BLEND_ADD':
                blendMode = 2;
                break;
            case 'PARTICLE_OUTPUT_BLEND_MODE_HALF_BLEND_ADD':
                blendMode = 3;
                break;
            case 'PARTICLE_OUTPUT_BLEND_MODE_NEG_HALF_BLEND_ADD':
                blendMode = 4;
                break;
            case 'PARTICLE_OUTPUT_BLEND_MODE_MOD2X':
                blendMode = 5;
                break;
            case 'PARTICLE_OUTPUT_BLEND_MODE_LIGHTEN':
                blendMode = 6;
                break;
            default:
                console.error('Unknown outputBlendMode ', outputBlendMode);
        }
        this.material?.setOutputBlendMode(blendMode);
    }
    async setTexture(texturePath) {
        this.setDefaultTexture = false;
        this.material.setTexturePath(texturePath);
        this.spriteSheet = await Source2TextureManager.getTextureSheet(this.system.repository, texturePath);
    }
}

class RenderBlobs extends RenderBase {
    #balls = [];
    #metaballs = new Metaballs();
    constructor(system) {
        super(system);
        this.material = new Source2SpriteCard(system.repository);
    }
    _paramChanged(paramName, param) {
        /*
        cube_width
            This is the density of the matrix through which the blob is meshed. Smaller numbers give higher precision at higher performance cost, while larger number will cause more swimming with movement but at a much cheaper cost.

        cutoff_radius
            The distance at which particles will attempt to connect with other particles to create a continuous mesh. Larger distances are more expensive, should be balanced carefully with cube_width for best performance.

        render_radius
            The visual radius of each particle. Note that this should be kept smaller than the cutoff radius or multiple particles will potentially overlap each other visually, which may cause a variety of visual errors.

        scale CP
            Allows the other visual properties to be scaled via an external Control Point. X = cube_width / Y = cutoff radius / Z = render radius
        */
        switch (paramName) {
            case 'm_cubeWidth':
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    initRenderer(particleSystem) {
        /*this.geometry = new BufferGeometry();
        this.mesh = new StaticMesh(this.geometry, this.material);
        this.mesh.setDefine('HARDWARE_PARTICLES');
        this.#createParticlesTexture();
        this.mesh.setUniform('uParticles', this.texture);

        this.maxParticles = particleSystem.maxParticles;*/
        //this.metaballs = new Metaballs();
        particleSystem.addChild(this.#metaballs);
    }
    updateParticles(particleSystem, particleList, elapsedTime) {
        this.#metaballs.cubeWidth = this.getParamScalarValue('m_cubeWidth') ?? 1;
        const renderRadius = this.getParamScalarValue('m_renderRadius') ?? 1.3;
        this.getParamScalarValue('m_cutoffRadius') ?? 3.3;
        const balls = [];
        for (let i = 0; i < Math.min(particleList.length, 500); i++) {
            const particle = particleList[i];
            let ball = this.#balls[i];
            if (!ball) {
                ball = new Metaball();
                this.#balls.push(ball);
            }
            ball.setRadius(renderRadius);
            ball.setPosition(particle.position);
            balls.push(ball);
        }
        this.#metaballs.setBalls(balls);
        this.#metaballs.updateGeometry();
    }
}
RegisterSource2ParticleOperator('C_OP_RenderBlobs', RenderBlobs);

const renderDeferredLightTempVec4 = vec4.create();
const DEFAULT_ALPHA_SCALE = 1;
const DEFAULT_COLOR_SCALE$2 = vec3.fromValues(1, 1, 1); // TODO: check default value
class RenderDeferredLight extends RenderBase {
    #startFalloff = 0; // TODO: check default value
    #texture = ''; // TODO: check default value
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_flStartFalloff':
                this.#startFalloff = param.getValueAsNumber() ?? 0; // TODO: check default value
                break;
            case 'm_hTexture':
                this.#texture = param.getValueAsString() ?? ''; // TODO: check default value
                break;
            case 'm_flRadiusScale':
            case 'm_flAlphaScale': // TODO: mutualize ?
            case 'm_vecColorScale':
                // used in updateParticles
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    initRenderer(particleSystem) {
    }
    updateParticles(particleSystem, particleList, elapsedTime) {
        this.getParamScalarValue('m_flRadiusScale') ?? 1;
        this.getParamScalarValue('m_flAlphaScale') ?? DEFAULT_ALPHA_SCALE;
        this.getParamVectorValue(renderDeferredLightTempVec4, 'm_vecColorScale') ?? DEFAULT_COLOR_SCALE$2;
        for (const particle of particleList) {
        }
    }
}
RegisterSource2ParticleOperator('C_OP_RenderDeferredLight', RenderDeferredLight);

const tempVec3 = vec3.create();
class RenderModels extends Operator {
    #modelList = new Map();
    #models = new Map();
    #skin = 0;
    #totalProbability = 0;
    //#modelPool = new Map();
    #allModels = new Map();
    #animated = false;
    _paramChanged(paramName, param) {
        switch (paramName) {
            case 'm_ModelList':
                this.#modelList.clear();
                this.#totalProbability = 0;
                // Example of system with multiple models: muerta_ultimate_ambient_flowers
                const models = param.getValueAsArray();
                if (!models) {
                    break;
                }
                for (const model of models) {
                    if (model.isOperatorParam) {
                        const modelName = model.getSubValue('m_model')?.getValueAsString();
                        if (modelName) {
                            const modelProbability = model.getSubValue('m_flRelativeProbabilityOfSpawn')?.getValueAsNumber() ?? 1;
                            this.#totalProbability += modelProbability;
                            this.#modelList.set(modelName, this.#totalProbability);
                        }
                    }
                }
                break;
            case 'm_nSkin':
                this.#skin = param.getValueAsNumber() ?? 0;
                this.#models.forEach(model => {
                    if (model) {
                        model.skin = this.#skin;
                    }
                });
                break;
            case 'm_bAnimated':
                this.#animated = param.getValueAsBool() ?? false;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    initRenderer(particleSystem) {
    }
    updateParticles(particleSystem, particleList, elapsedTime) {
        const activity = particleSystem.getAttribute('activity');
        for (let i = 0, l = particleList.length; i < l; ++i) {
            this.#updateParticle(particleSystem, i, particleList[i], activity?.activity, activity?.modifiers);
        }
    }
    #pickRandomModel() {
        const random = Math.random() * this.#totalProbability;
        for (const [modelName, modelProbability] of this.#modelList) {
            if (random <= modelProbability) {
                return modelName;
            }
        }
        return '';
    }
    async #getModel(repository, modelName) {
        for (const [model, datas] of this.#allModels) {
            if (!datas.used && (datas.modelName == modelName) && (datas.repository == repository)) {
                //this.#allModels.delete(model);
                datas.used = true;
                return model;
            }
        }
        const model = await Source2ModelManager.createInstance(repository, modelName, this.#animated);
        if (model) {
            this.#allModels.set(model, { repository: repository, modelName: modelName, used: true });
        }
        return model;
    }
    #returnModel(particle) {
        const model = this.#models.get(particle);
        if (model) {
            //previousModel.dispose();
            //console.log(previousModel)
            const datas = this.#allModels.get(model);
            if (datas) {
                datas.used = false;
            }
        }
    }
    async #updateParticle(particleSystem, particleIndex, particle, activityName, activityModifiers) {
        let model;
        if (!particle.modelName) {
            const modelName = this.#pickRandomModel();
            particle.modelName = modelName;
            this.#returnModel(particle);
            model = await this.#getModel(particleSystem.repository, particle.modelName);
            if (model) {
                this.#models.set(particle, model);
            }
            if (this.#skin && model) {
                model.skin = this.#skin;
            }
            particleSystem.addChild(model);
        }
        else {
            model = this.#models.get(particle);
        }
        /*if (model === undefined) {
            this.#models.push(null);

            model = await Source2ModelManager.createInstance(particleSystem.repository, this.#pickRandomModel(), true);

            if (this.#skin && model) {
                model.skin = this.#skin;
            }

            this.#models[particleIndex] = model;
            particleSystem.addChild(model);

            return
        }*/
        if (model) {
            model.position = particle.position;
            const radius = particle.radius;
            model.scale = vec3.set(tempVec3, radius, radius, radius);
            model.quaternion = particle.quaternion;
            model.playSequence(activityName, activityModifiers);
            if (particle.color[3] == 0) { //TODO: add an actual rendering tint / alpha on models
                model.setVisible(false);
            }
            else {
                model.setVisible();
            }
        }
    }
    dispose() {
        this.#allModels.forEach((_, model) => model.dispose());
    }
}
RegisterSource2ParticleOperator('C_OP_RenderModels', RenderModels);

const OPERATOR_PARAM_TEXTURE = 'm_hTexture';
var OperatorDefinitionType;
(function (OperatorDefinitionType) {
    OperatorDefinitionType[OperatorDefinitionType["Bool"] = 0] = "Bool";
    OperatorDefinitionType[OperatorDefinitionType["Integer"] = 1] = "Integer";
    OperatorDefinitionType[OperatorDefinitionType["Float"] = 2] = "Float";
    OperatorDefinitionType[OperatorDefinitionType["String"] = 3] = "String";
    OperatorDefinitionType[OperatorDefinitionType["Enum"] = 4] = "Enum";
    OperatorDefinitionType[OperatorDefinitionType["Vec2"] = 5] = "Vec2";
    OperatorDefinitionType[OperatorDefinitionType["Vec3"] = 6] = "Vec3";
    OperatorDefinitionType[OperatorDefinitionType["Vec4"] = 7] = "Vec4";
    OperatorDefinitionType[OperatorDefinitionType["Quat"] = 8] = "Quat";
})(OperatorDefinitionType || (OperatorDefinitionType = {}));
const operatorParams = new Map();
function addOperatorDefinitions(defs) {
    for (const def of defs) {
        operatorParams.set(def.name, def);
    }
}
addOperatorDefinitions([
    // From C_OP_PinParticleToCP
    /*
    { name: 'm_nOpEndCapState', type: OperatorDefinitionType.Enum, enum: Source2ParticleEndCapState, defaultValue: Source2ParticleEndCapState.AlwaysEnabled, complex: false },
    { name: 'm_nPinBreakType', type: OperatorDefinitionType.Enum, enum: Source2PinBreakType, defaultValue: Source2PinBreakType.None, complex: false },
    { name: 'm_nControlPointNumber', type: OperatorDefinitionType.Integer, defaultValue: 0, complex: false },
    { name: 'm_vecOffset', type: OperatorDefinitionType.Vec3, defaultValue: vec3.create(), complex: true },
    { name: 'm_bOffsetLocal', type: OperatorDefinitionType.Bool, defaultValue: true, complex: false },
    { name: 'm_nParticleSelection', type: OperatorDefinitionType.Enum, enum: Source2ParticleSelection, defaultValue: Source2ParticleSelection.First, complex: false },
    { name: 'm_nParticleNumber', type: OperatorDefinitionType.Integer, defaultValue: 0, complex: true },
    { name: 'm_flBreakDistance', type: OperatorDefinitionType.Float, defaultValue: 1.75, complex: true },
    { name: 'm_flBreakSpeed', type: OperatorDefinitionType.Float, defaultValue: 0, complex: true },
    { name: 'm_flAge', type: OperatorDefinitionType.Float, defaultValue: 0, complex: true },
    { name: 'm_nBreakControlPointNumber', type: OperatorDefinitionType.Integer, defaultValue: -1, complex: false },
    { name: 'm_nBreakControlPointNumber2', type: OperatorDefinitionType.Integer, defaultValue: -1, complex: false },
    { name: 'm_flBreakValue', type: OperatorDefinitionType.Float, defaultValue: 0, complex: true },
    { name: 'm_flInterpolation', type: OperatorDefinitionType.Float, defaultValue: 1, complex: true },
    { name: 'm_bRetainInitialVelocity', type: OperatorDefinitionType.Bool, defaultValue: false, complex: false },
    { name: 'm_flOpStrength', type: OperatorDefinitionType.Float, defaultValue: 1, complex: true },
    { name: 'm_nOpEndCapState', type: OperatorDefinitionType.Enum, defaultValue: Source2ParticleEndCapState.AlwaysEnabled, complex: false },
     */
    // From C_OP_SetFloat
    { name: 'm_InputValue', type: OperatorDefinitionType.Float, defaultValue: 0, complex: true },
    { name: 'm_nOutputField', type: OperatorDefinitionType.Enum, defaultValue: Source2ParticleScalarField.Radius, complex: false },
]);

const SEQUENCE_COMBINE_MODE_ALPHA_FROM0_RGB_FROM_1 = 1;

const renderRopesTempVec4 = vec4.create();
const DEFAULT_WORLD_SIZE = 10; // TODO: check default value
const DEFAULT_SCROLL_RATE = 10; // TODO: check default value
const DEFAULT_COLOR_SCALE$1 = vec3.fromValues(1, 1, 1); // TODO: check default value
const DEFAULT_DEPTH_BIAS$1 = 1; // TODO: check default value
const DEFAULT_FEATHERING_MODE$1 = 'PARTICLE_DEPTH_FEATHERING_ON_REQUIRED'; // TODO: check default value
const DEFAULT_FEATHERING_MAX_DIST$1 = 1; // TODO: check default value
const DEFAULT_COLOR_BLEND_TYPE = 'PARTICLE_COLOR_BLEND_MIN'; // TODO: check default value
class RenderRopes extends RenderBase {
    #textureVWorldSize = DEFAULT_WORLD_SIZE;
    #textureVScrollRate = DEFAULT_SCROLL_RATE;
    #textureScroll = 0;
    #maxParticles = 1000; //TODO: default value
    #texture;
    #imgData;
    #geometry = new BeamBufferGeometry();
    #addSelfAmount = 1; // TODO: check default value
    #saturateColorPreAlphaBlend = false; // TODO: check default value
    #minTesselation = 1; // TODO: check default value
    #maxTesselation = 1; // TODO: check default value
    #depthBias = DEFAULT_DEPTH_BIAS$1;
    #featheringMode = DEFAULT_FEATHERING_MODE$1;
    #featheringMaxDist = DEFAULT_FEATHERING_MAX_DIST$1;
    #colorBlendType = DEFAULT_COLOR_BLEND_TYPE;
    constructor(system) {
        super(system);
        this.mesh = new Mesh({ geometry: this.#geometry, material: this.material });
        this.setOrientationType(PARTICLE_ORIENTATION_SCREEN_ALIGNED);
        Source2MaterialManager.addMaterial(this.material);
        this.setDefaultTexture = true;
        //this.setParam(OPERATOR_PARAM_TEXTURE, 'materials/particle/base_sprite');//TODOv3: make a const
        //this.setParam(OPERATOR_PARAM_MOD_2X, false);
        //this.setParam(OPERATOR_PARAM_ORIENTATION_TYPE, ORIENTATION_TYPE_SCREEN_ALIGN);
        //this.setParam(OPERATOR_PARAM_SEQUENCE_COMBINE_MODE, SEQUENCE_COMBINE_MODE_USE_SEQUENCE_0);//TODOv3: get the actual default value
    }
    _paramChanged(paramName, param) {
        switch (paramName) {
            case OPERATOR_PARAM_TEXTURE:
                this.setTexture(param.getValueAsString() ?? ''); // TODO: check default value
                break;
            case 'm_nSequenceCombineMode':
                this.setSequenceCombineMode(param.getValueAsString() ?? ''); // TODO: check default value
                break;
            case 'm_flTextureVWorldSize':
                this.#textureVWorldSize = param.getValueAsNumber() ?? DEFAULT_WORLD_SIZE;
                break;
            case 'm_flTextureVScrollRate':
                this.#textureVScrollRate = param.getValueAsNumber() ?? DEFAULT_SCROLL_RATE;
                break;
            case 'm_flAddSelfAmount':
                this.#addSelfAmount = param.getValueAsNumber() ?? 1; // TODO: check default value
                break;
            case 'm_nMinTesselation':
                this.#minTesselation = param.getValueAsNumber() ?? 1; // TODO: check default value
                break;
            case 'm_nMaxTesselation':
                this.#maxTesselation = param.getValueAsNumber() ?? 1; // TODO: check default value
                break;
            case 'm_bSaturateColorPreAlphaBlend':
                this.#saturateColorPreAlphaBlend = param.getValueAsBool() ?? false; // TODO: check default value
                break;
            case 'm_flDepthBias':
                this.#depthBias = param.getValueAsNumber() ?? DEFAULT_DEPTH_BIAS$1; // TODO: check default value
                break;
            case 'm_nFeatheringMode': //TODO: mutualize in renderbase
                this.#featheringMode = param.getValueAsString() ?? DEFAULT_FEATHERING_MODE$1; // TODO: check default value
                break;
            case 'm_flFeatheringMaxDist':
                this.#featheringMaxDist = param.getValueAsNumber() ?? DEFAULT_FEATHERING_MAX_DIST$1;
                break;
            case 'm_nColorBlendType': //TODO: mutualize in renderbase
                this.#colorBlendType = param.getValueAsString() ?? DEFAULT_COLOR_BLEND_TYPE; // TODO: check default value
                break;
            case 'm_flFinalTextureScaleU':
            case 'm_flFinalTextureScaleV':
            case 'm_flOverbrightFactor': // TODO: mutualize ?
            case 'm_flRadiusScale':
            case 'm_vecColorScale':
                // used in updateParticles
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    setSequenceCombineMode(sequenceCombineMode) {
        this.material?.removeDefine('USE_TEXTURE_COORD_2');
        switch (sequenceCombineMode) {
            case 'SEQUENCE_COMBINE_MODE_ALPHA_FROM0_RGB_FROM_1':
                this.material?.setDefine('SEQUENCE_COMBINE_MODE', String(SEQUENCE_COMBINE_MODE_ALPHA_FROM0_RGB_FROM_1));
                this.material?.setDefine('USE_TEXTURE_COORD_2');
                break;
            default:
                console.error('Unknown sequenceCombineMode ', sequenceCombineMode);
        }
    }
    updateParticles(particleSystem, particleList, elapsedTime) {
        // TODO: use saturateColorPreAlphaBlend, m_nMinTesselation, m_nMaxTesselation, colorScale, m_flDepthBias, featheringMode
        this.mesh.setUniform('uOverbrightFactor', this.getParamScalarValue('m_flOverbrightFactor') ?? 1);
        this.getParamVectorValue(renderRopesTempVec4, 'm_vecColorScale') ?? DEFAULT_COLOR_SCALE$1;
        this.getParamScalarValue('m_flRadiusScale') ?? 1;
        this.#textureScroll += elapsedTime * this.#textureVScrollRate;
        this.getParameter('subdivision_count') ?? 3;
        const geometry = this.#geometry;
        const segments = [];
        let ropeLength = 0.0;
        let previousSegment = null;
        const textureVWorldSize = 1 / this.#textureVWorldSize;
        const textureScroll = this.#textureScroll;
        const alphaScale = this.getParamScalarValue('m_flAlphaScale') ?? 1;
        for (const particle of particleList) {
            //for (let i = 0, l = (particleList.length - 1) * subdivCount + 1; i < l; i++) {
            const segment = new BeamSegment(particle.position, [particle.color[0], particle.color[1], particle.color[2], particle.alpha * alphaScale], 0.0, particle.radius);
            vec3.copy(segment.normal, particle.normal);
            if (previousSegment) {
                ropeLength += segment.distanceTo(previousSegment);
            }
            segment.texCoordY = (ropeLength + textureScroll) * textureVWorldSize;
            segments.push(segment);
            previousSegment = segment;
        }
        geometry.segments = segments;
    }
    set maxParticles(maxParticles) {
        this.#maxParticles = maxParticles;
        this.#createParticlesArray();
    }
    initRenderer(particleSystem) {
        if (this.mesh) {
            this.mesh.serializable = false;
            this.mesh.hideInExplorer = true;
            this.mesh.setDefine('IS_ROPE');
            this.mesh.setDefine('USE_VERTEX_COLOR');
            this.#createParticlesTexture();
            this.mesh.setUniform('uParticles', this.#texture);
        }
        this.maxParticles = particleSystem.maxParticles;
        particleSystem.addChild(this.mesh);
    }
    #createParticlesArray() {
        this.#imgData = new Float32Array(this.#maxParticles * 4 * TEXTURE_WIDTH);
    }
    #createParticlesTexture() {
        this.#texture = TextureManager.createTexture();
        const gl = Graphics$1.glContext; //TODO
        gl.bindTexture(GL_TEXTURE_2D, this.#texture.texture);
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        gl.bindTexture(GL_TEXTURE_2D, null);
    }
    updateParticlesTexture() {
        const gl = Graphics$1.glContext;
        if (!this.#imgData || !this.#texture) {
            return;
        }
        gl.bindTexture(GL_TEXTURE_2D, this.#texture.texture);
        if (Graphics$1.isWebGL2) {
            gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA32F, TEXTURE_WIDTH, this.#maxParticles, 0, GL_RGBA, GL_FLOAT, this.#imgData);
        }
        else {
            gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, TEXTURE_WIDTH, this.#maxParticles, 0, GL_RGBA, GL_FLOAT, this.#imgData);
        }
        gl.bindTexture(GL_TEXTURE_2D, null);
    }
    #setupParticlesTexture(particleList, maxParticles) {
        const a = this.#imgData;
        if (!a) {
            return;
        }
        let index = 0;
        for (const particle of particleList) { //TODOv3
            /*let pose = bone.boneMat;
            for (let k = 0; k < 16; ++k) {
                a[index++] = pose[k];
            }*/
            a[index++] = particle.position[0];
            a[index++] = particle.position[1];
            a[index++] = particle.position[2];
            index++;
            a[index++] = particle.color[0];
            a[index++] = particle.color[1];
            a[index++] = particle.color[2];
            a[index++] = particle.alpha;
            a[index++] = particle.radius;
            index++;
            a[index++] = particle.rotationRoll;
            a[index++] = particle.rotationYaw;
            index++;
            index++;
            index++;
            index++;
            a[index++] = particle.normal[0];
            a[index++] = particle.normal[1];
            a[index++] = particle.normal[2];
            index += 13;
        }
        this.updateParticlesTexture();
    }
    init() {
        if (this.setDefaultTexture) {
            this.setTexture(DEFAULT_PARTICLE_TEXTURE);
        }
    }
}
RegisterSource2ParticleOperator('C_OP_RenderRopes', RenderRopes);

const renderSpritesTempVec4 = vec4.create();
const DEFAULT_MAX_SIZE = 5000;
const DEFAULT_BLEND_FRAMES_SEQ_0 = false; // TODO: check default value
const DEFAULT_ANIMATION_RATE$1 = 1; // TODO: check default value
const DEFAULT_START_FADE_SIZE = 1; // TODO: check default value
const DEFAULT_END_FADE_SIZE = 1; // TODO: check default value
const DEFAULT_FEATHERING_MODE = 'PARTICLE_DEPTH_FEATHERING_ON_REQUIRED'; // TODO: check default value
const DEFAULT_FEATHERING_MAX_DIST = 1; // TODO: check default value
const DEFAULT_DEPTH_BIAS = 1; // TODO: check default value
const DEFAULT_COLOR_SCALE = vec3.fromValues(1, 1, 1); // TODO: check default value
const DEFAULT_ADD_SELF_AMOUNT$1 = 1; // TODO: check default value
const DEFAULT_SATURATE_COLOR_PRE_ALPHA_BLEND$1 = false; // TODO: check default value
const DEFAULT_ANIMATION_TYPE = 'ANIMATION_TYPE_FIT_LIFETIME'; // TODO: check default value
const DEFAULT_REFRACT = false; // TODO: check default value
const DEFAULT_REFRACT_BLUR_RADIUS = 1; // TODO: check default value
const DEFAULT_GAMMA_CORRECT_VERTEX_COLORS = true; // TODO: check default value
class RenderSprites extends RenderBase {
    geometry = new BufferGeometry();
    #minSize = 0.0;
    #maxSize = DEFAULT_MAX_SIZE;
    #saturateColorPreAlphaBlend = DEFAULT_SATURATE_COLOR_PRE_ALPHA_BLEND$1;
    #maxParticles = 0;
    #featheringMode = DEFAULT_FEATHERING_MODE;
    #featheringMaxDist = DEFAULT_FEATHERING_MAX_DIST;
    texture = TextureManager.createTexture();
    imgData; //TODO: set private ?
    #addSelfAmount = DEFAULT_ADD_SELF_AMOUNT$1;
    #blendFramesSeq0 = DEFAULT_BLEND_FRAMES_SEQ_0;
    #animationRate = DEFAULT_ANIMATION_RATE$1;
    #startFadeSize = DEFAULT_START_FADE_SIZE;
    #endFadeSize = DEFAULT_END_FADE_SIZE;
    #depthBias = DEFAULT_DEPTH_BIAS;
    #animationType = DEFAULT_ANIMATION_TYPE;
    #refract = DEFAULT_REFRACT;
    #refractBlurRadius = DEFAULT_REFRACT_BLUR_RADIUS;
    #gammaCorrectVertexColors = DEFAULT_GAMMA_CORRECT_VERTEX_COLORS;
    constructor(system) {
        super(system);
        this.mesh = new Mesh({ geometry: this.geometry, material: this.material });
        this.setMaxParticles(1000); //TODO: default value
        this.setOrientationType(PARTICLE_ORIENTATION_SCREEN_ALIGNED);
        Source2MaterialManager.addMaterial(this.material);
        //this.setParam(OPERATOR_PARAM_TEXTURE, 'materials/particle/base_sprite');//TODOv3: make a const
        //this.setParam(OPERATOR_PARAM_MOD_2X, false);
        //this.setParam(OPERATOR_PARAM_ORIENTATION_TYPE, ORIENTATION_TYPE_SCREEN_ALIGN);
        //this.setParam(OPERATOR_PARAM_SEQUENCE_COMBINE_MODE, SEQUENCE_COMBINE_MODE_USE_SEQUENCE_0);//TODOv3: get the actual default value
    }
    _paramChanged(paramName, param) {
        switch (paramName) {
            case OPERATOR_PARAM_TEXTURE:
                this.setTexture(param.getValueAsString() ?? ''); // TODO: check default value
                break;
            case 'm_nSequenceCombineMode':
                this.setSequenceCombineMode(param.getValueAsString() ?? ''); // TODO: check default value
                break;
            case 'm_flMinSize':
                this.#minSize = (param.getValueAsNumber() ?? 0) * 200.; //TODO: use the actual screen size
                break;
            case 'm_flMaxSize':
                this.#maxSize = (param.getValueAsNumber() ?? DEFAULT_MAX_SIZE) * 200.; //TODO: use the actual screen size
                break;
            case 'm_bSaturateColorPreAlphaBlend':
                this.#saturateColorPreAlphaBlend = param.getValueAsBool() ?? DEFAULT_SATURATE_COLOR_PRE_ALPHA_BLEND$1;
                break;
            case 'm_bBlendFramesSeq0':
                this.#blendFramesSeq0 = param.getValueAsBool() ?? DEFAULT_BLEND_FRAMES_SEQ_0;
                break;
            case 'm_flDepthBias': //TODO: mutualize in renderbase
                this.#depthBias = param.getValueAsNumber() ?? DEFAULT_DEPTH_BIAS; // TODO: check default value
                break;
            case 'm_nFeatheringMode':
                this.#featheringMode = param.getValueAsString() ?? DEFAULT_FEATHERING_MODE; // TODO: check default value
                break;
            case 'm_flFeatheringMaxDist':
                this.#featheringMaxDist = param.getValueAsNumber() ?? DEFAULT_FEATHERING_MAX_DIST;
                break;
            case 'm_flAddSelfAmount': // TODO: mutualize ?
                this.#addSelfAmount = param.getValueAsNumber() ?? DEFAULT_ADD_SELF_AMOUNT$1;
                break;
            case 'm_flAnimationRate':
                this.#animationRate = param.getValueAsNumber() ?? DEFAULT_ANIMATION_RATE$1;
                break;
            case 'm_flStartFadeSize':
                this.#startFadeSize = param.getValueAsNumber() ?? DEFAULT_START_FADE_SIZE;
                break;
            case 'm_flEndFadeSize':
                this.#endFadeSize = param.getValueAsNumber() ?? DEFAULT_END_FADE_SIZE;
                break;
            case 'm_nAnimationType':
                this.#animationType = param.getValueAsString() ?? DEFAULT_ANIMATION_TYPE;
                break;
            case 'm_bRefract':
                this.#refract = param.getValueAsBool() ?? DEFAULT_REFRACT;
                break;
            case 'm_nRefractBlurRadius':
                this.#refractBlurRadius = param.getValueAsNumber() ?? DEFAULT_REFRACT_BLUR_RADIUS;
                break;
            case 'm_bGammaCorrectVertexColors':
                this.#gammaCorrectVertexColors = param.getValueAsBool() ?? DEFAULT_GAMMA_CORRECT_VERTEX_COLORS;
                break;
            case 'm_flRadiusScale': // TODO: mutualize ?
            case 'm_flAlphaScale': // TODO: mutualize ?
            case 'm_flOverbrightFactor': // TODO: mutualize ?
            case 'm_flRefractAmount':
            case 'VisibilityInputs':
            case 'm_vecColorScale':
                // used in updateParticles
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    setSequenceCombineMode(sequenceCombineMode /*TODO: create enum*/) {
        this.material.removeDefine('USE_TEXTURE_COORD_2');
        switch (sequenceCombineMode) {
            case 'SEQUENCE_COMBINE_MODE_ALPHA_FROM0_RGB_FROM_1':
                this.material.setDefine('SEQUENCE_COMBINE_MODE', String(SEQUENCE_COMBINE_MODE_ALPHA_FROM0_RGB_FROM_1));
                this.material.setDefine('USE_TEXTURE_COORD_2');
                break;
            default:
                console.error('Unknown sequenceCombineMode ', sequenceCombineMode);
        }
    }
    updateParticles(particleSystem, particleList, elapsedTime) {
        // TODO: use m_flRefractAmount, m_flAddSelfAmount, blendFramesSeq0, VisibilityInputs, m_nFeatheringMode, m_bGammaCorrectVertexColors
        // TODO: do refraction ex: particles/units/heroes/hero_arc_warden/arc_warden_bracer_hand.vpcf_c
        this.getParamVectorValue(renderSpritesTempVec4, 'm_vecColorScale') ?? DEFAULT_COLOR_SCALE;
        const m_bFitCycleToLifetime = this.getParameter('animation_fit_lifetime');
        const rate = this.#animationRate; //this.getParameter('animation rate');
        const useAnimRate = this.getParameter('use animation rate as FPS');
        this.geometry.count = particleList.length * 6;
        const maxParticles = this.#maxParticles;
        this.#setupParticlesTexture(particleList);
        this.mesh.setUniform('uMaxParticles', maxParticles); //TODOv3:optimize
        this.mesh.setVisible(Source2ParticleManager.visible);
        this.mesh.setUniform('uOverbrightFactor', this.getParamScalarValue('m_flOverbrightFactor') ?? 1);
        const uvs = this.geometry.attributes.get('aTextureCoord')._array;
        const uvs2 = this.geometry.attributes.get('aTextureCoord2')._array;
        let index = 0;
        let index2 = 0;
        for (const particle of particleList) {
            const sequence = particle.sequence;
            if (m_bFitCycleToLifetime) {
                particle.timeToLive; //SubFloat(pLifeDuration[ nGroup * ld_stride ], nOffset);
            }
            else {
                if (useAnimRate) {
                    particle.frame += elapsedTime * rate;
                    this.material.getFrameSpan(sequence);
                }
            }
            particle.frame += elapsedTime;
            if (this.spriteSheet) {
                let coords = this.spriteSheet.getFrame(particle.sequence, particle.frame * 10.0); //?.coords;//sequences[particle.sequence].frames[particle.frame].coords;
                //coords = coords.m_TextureCoordData[0];
                if (coords) {
                    uvs[index++] = coords.uMin;
                    uvs[index++] = coords.vMin;
                    uvs[index++] = coords.uMax;
                    uvs[index++] = coords.vMin;
                    uvs[index++] = coords.uMin;
                    uvs[index++] = coords.vMax;
                    uvs[index++] = coords.uMax;
                    uvs[index++] = coords.vMax;
                }
                coords = this.spriteSheet.getFrame(particle.sequence2, particle.frame * 10.0); //?.coords;//sequences[particle.sequence].frames[particle.frame].coords;
                //coords = coords.m_TextureCoordData[0];
                if (coords) {
                    uvs2[index2++] = coords.uMin;
                    uvs2[index2++] = coords.vMin;
                    uvs2[index2++] = coords.uMax;
                    uvs2[index2++] = coords.vMin;
                    uvs2[index2++] = coords.uMin;
                    uvs2[index2++] = coords.vMax;
                    uvs2[index2++] = coords.uMax;
                    uvs2[index2++] = coords.vMax;
                }
            }
            else {
                index += 8;
                index2 += 8;
            }
        }
        this.geometry.attributes.get('aTextureCoord').dirty = true;
        this.geometry.attributes.get('aTextureCoord2').dirty = true;
    }
    setMaxParticles(maxParticles) {
        this.#maxParticles = Graphics$1.isWebGL2 ? maxParticles : ceilPowerOfTwo(maxParticles);
        this.#createParticlesArray();
        this.#initBuffers();
    }
    /**
     * @deprecated Please use `setPosition` instead.
     */
    set maxParticles(maxParticles) {
        this.setMaxParticles(maxParticles);
    }
    #initBuffers() {
        const geometry = this.geometry;
        const vertices = [];
        const uvs = [];
        const uvs2 = [];
        const indices = [];
        const id = [];
        for (let i = 0; i < this.#maxParticles; i++) {
            const indiceBase = i * 4;
            indices.push(indiceBase, indiceBase + 2, indiceBase + 1, indiceBase + 2, indiceBase + 3, indiceBase + 1);
            vertices.push(-1.0, 1.0, 0.0, 1.0, 1.0, 0.0, -1.0, -1.0, 0.0, 1.0, -1.0, 0.0);
            uvs.push(0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0);
            uvs2.push(0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0);
            id.push(i, i, i, i);
        }
        geometry.count = indices.length;
        geometry.setIndex(new Uint32BufferAttribute(indices, 1));
        geometry.setAttribute('aVertexPosition', new Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('aTextureCoord', new Float32BufferAttribute(uvs, 2));
        geometry.setAttribute('aTextureCoord2', new Float32BufferAttribute(uvs2, 2));
        geometry.setAttribute('aParticleId', new Float32BufferAttribute(id, 1));
        this.mesh.setUniform('uMaxParticles', this.#maxParticles); //TODOv3:optimize
    }
    initRenderer(particleSystem) {
        this.mesh.serializable = false;
        this.mesh.hideInExplorer = true;
        this.mesh.setDefine('HARDWARE_PARTICLES');
        this.#initParticlesTexture();
        this.mesh.setUniform('uParticles', this.texture);
        this.setMaxParticles(particleSystem.maxParticles);
        particleSystem.addChild(this.mesh);
    }
    #createParticlesArray() {
        this.imgData = new Float32Array(this.#maxParticles * 4 * TEXTURE_WIDTH);
    }
    #initParticlesTexture() {
        const gl = Graphics$1.glContext; //TODO
        gl.bindTexture(GL_TEXTURE_2D, this.texture.texture);
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        gl.bindTexture(GL_TEXTURE_2D, null);
    }
    updateParticlesTexture() {
        const gl = Graphics$1.glContext;
        gl.bindTexture(GL_TEXTURE_2D, this.texture.texture);
        if (Graphics$1.isWebGL2) {
            gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA32F, TEXTURE_WIDTH, this.#maxParticles, 0, GL_RGBA, GL_FLOAT, this.imgData);
        }
        else {
            gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, TEXTURE_WIDTH, this.#maxParticles, 0, GL_RGBA, GL_FLOAT, this.imgData);
        }
        gl.bindTexture(GL_TEXTURE_2D, null);
    }
    #setupParticlesTexture(particleList) {
        const a = this.imgData;
        let index = 0;
        const alphaScale = this.getParamScalarValue('m_flAlphaScale') ?? 1;
        const radiusScale = this.getParamScalarValue('m_flRadiusScale') ?? 1;
        for (const particle of particleList) { //TODOv3
            /*let pose = bone.boneMat;
            for (let k = 0; k < 16; ++k) {
                a[index++] = pose[k];
            }*/
            a[index++] = particle.position[0];
            a[index++] = particle.position[1];
            a[index++] = particle.position[2];
            index++;
            a[index++] = particle.color[0];
            a[index++] = particle.color[1];
            a[index++] = particle.color[2];
            a[index++] = particle.alpha * alphaScale;
            a[index++] = clamp$1(particle.radius * radiusScale, this.#minSize, this.#maxSize);
            index++;
            a[index++] = particle.rotationRoll;
            a[index++] = particle.rotationYaw;
            index++;
            index++;
            index++;
            index++;
            a[index++] = particle.normal[0];
            a[index++] = particle.normal[1];
            a[index++] = particle.normal[2];
            index += 13;
        }
        this.updateParticlesTexture();
    }
    init() {
        if (this.setDefaultTexture) {
            this.setTexture(DEFAULT_PARTICLE_TEXTURE);
        }
    }
}
RegisterSource2ParticleOperator('C_OP_RenderSprites', RenderSprites);
//RegisterSource2ParticleOperator('C_OP_RenderProjected', RenderSprites);//TODO: set proper renderer

const tempVec2 = vec2.create();
const DEFAULT_MIN_LENGTH = 0; // TODO: check default value
const DEFAULT_MAX_LENGTH = 2000; // TODO: check default value
const DEFAULT_ANIMATION_RATE = 1; // TODO: check default value
const DEFAULT_VERT_CROP_FIELD = 1; // TODO: check default value
const DEFAULT_TAIL_ALPHA_SCALE = 1; // TODO: check default value
const DEFAULT_IGNORE_DT = false; // TODO: check default value
const DEFAULT_LENGTH_FADE_IN_TIME = 0; // TODO: check default value
const DEFAULT_LENGTH_SCALE = 1; // TODO: check default value
const DEFAULT_MAX_PARTICLES = 1000; // TODO: check default value
const DEFAULT_ADD_SELF_AMOUNT = 1; // TODO: check default value
const DEFAULT_SATURATE_COLOR_PRE_ALPHA_BLEND = false; // TODO: check default value
const DEFAULT_RADIUS_HEAD_TAPER = 1; // TODO: check default value
class RenderTrails extends RenderBase {
    #geometry = new BufferGeometry();
    #minLength = DEFAULT_MIN_LENGTH;
    #maxLength = DEFAULT_MAX_LENGTH;
    #lengthFadeInTime = DEFAULT_LENGTH_FADE_IN_TIME;
    #ignoreDT = DEFAULT_IGNORE_DT;
    #lengthScale = DEFAULT_LENGTH_SCALE;
    #maxParticles = DEFAULT_MAX_PARTICLES; //TODO: default value
    #texture; //TODO: set private ?
    #imgData; //TODO: set private ?
    #animationRate = DEFAULT_ANIMATION_RATE;
    #vertCropField = DEFAULT_VERT_CROP_FIELD;
    #tailAlphaScale = DEFAULT_TAIL_ALPHA_SCALE;
    #addSelfAmount = DEFAULT_ADD_SELF_AMOUNT;
    #saturateColorPreAlphaBlend = DEFAULT_SATURATE_COLOR_PRE_ALPHA_BLEND;
    constructor(system) {
        super(system);
        this.mesh = new Mesh({ geometry: this.#geometry, material: this.material });
        this.material.setDefine('RENDER_SPRITE_TRAIL');
        this.setOrientationType(PARTICLE_ORIENTATION_SCREEN_ALIGNED);
        Source2MaterialManager.addMaterial(this.material);
        //this.setParam(OPERATOR_PARAM_TEXTURE, 'materials/particle/base_sprite');//TODOv3: make a const
        //this.setParam(OPERATOR_PARAM_MOD_2X, false);
        //this.setParam(OPERATOR_PARAM_ORIENTATION_TYPE, ORIENTATION_TYPE_SCREEN_ALIGN);
        //this.setParam(OPERATOR_PARAM_SEQUENCE_COMBINE_MODE, SEQUENCE_COMBINE_MODE_USE_SEQUENCE_0);//TODOv3: get the actual default value
    }
    _paramChanged(paramName, param) {
        switch (paramName) {
            case OPERATOR_PARAM_TEXTURE:
                console.error('do this param', paramName, param);
                this.setTexture(param.getValueAsString() ?? ''); // TODO: check default value
                break;
            /*case 'm_nSequenceCombineMode':
                this.setSequenceCombineMode(value);
                break;*/
            case 'm_flMinLength':
                this.#minLength = param.getValueAsNumber() ?? DEFAULT_MIN_LENGTH;
                break;
            case 'm_flMaxLength':
                this.#maxLength = param.getValueAsNumber() ?? DEFAULT_MAX_LENGTH;
                break;
            case 'm_flLengthFadeInTime':
                this.#lengthFadeInTime = param.getValueAsNumber() ?? DEFAULT_LENGTH_FADE_IN_TIME;
                break;
            case 'm_bIgnoreDT':
                this.#ignoreDT = param.getValueAsBool() ?? DEFAULT_IGNORE_DT;
                break;
            case 'm_flRadiusScale':
            case 'm_flFinalTextureScaleU':
            case 'm_flFinalTextureScaleV':
            case 'm_flRadiusHeadTaper':
            case 'm_flOverbrightFactor': // TODO: mutualize ?
                break;
            case 'm_flLengthScale':
                this.#lengthScale = param.getValueAsNumber() ?? DEFAULT_LENGTH_SCALE;
                break;
            case 'm_flAnimationRate':
                this.#animationRate = param.getValueAsNumber() ?? DEFAULT_ANIMATION_RATE;
                break;
            case 'm_nVertCropField':
                this.#vertCropField = param.getValueAsNumber() ?? DEFAULT_VERT_CROP_FIELD;
                break;
            case 'm_flTailAlphaScale':
                this.#tailAlphaScale = param.getValueAsNumber() ?? DEFAULT_TAIL_ALPHA_SCALE;
                break;
            case 'm_flAddSelfAmount': // TODO: mutualize ?
                this.#addSelfAmount = param.getValueAsNumber() ?? DEFAULT_ADD_SELF_AMOUNT;
                break;
            case 'm_bSaturateColorPreAlphaBlend':
                this.#saturateColorPreAlphaBlend = param.getValueAsBool() ?? DEFAULT_SATURATE_COLOR_PRE_ALPHA_BLEND;
                break;
            default:
                super._paramChanged(paramName, param);
        }
    }
    setSequenceCombineMode(sequenceCombineMode) {
        this.material.removeDefine('USE_TEXTURE_COORD_2');
        switch (sequenceCombineMode) {
            case 'SEQUENCE_COMBINE_MODE_ALPHA_FROM0_RGB_FROM_1':
                this.material.setDefine('SEQUENCE_COMBINE_MODE', String(SEQUENCE_COMBINE_MODE_ALPHA_FROM0_RGB_FROM_1));
                this.material.setDefine('USE_TEXTURE_COORD_2');
                break;
            default:
                console.error('Unknown sequenceCombineMode ', sequenceCombineMode);
        }
    }
    updateParticles(particleSystem, particleList, elapsedTime) {
        // TODO: use animationRate, vertCropField, m_flTailAlphaScale, m_flRadiusHeadTaper
        this.getParamScalarValue('m_flRadiusHeadTaper') ?? DEFAULT_RADIUS_HEAD_TAPER;
        this.mesh.setUniform('uOverbrightFactor', this.getParamScalarValue('m_flOverbrightFactor') ?? 1);
        const m_bFitCycleToLifetime = this.getParameter('animation_fit_lifetime');
        const rate = this.#animationRate; //this.getParameter('animation rate');
        const useAnimRate = this.getParameter('use animation rate as FPS');
        const geometry = this.#geometry;
        geometry.count = particleList.length * 6;
        const maxParticles = this.#maxParticles;
        this.#setupParticlesTexture(particleList, maxParticles, elapsedTime);
        this.mesh.setUniform('uMaxParticles', maxParticles); //TODOv3:optimize
        this.mesh.setVisible(Source2ParticleManager.visible);
        vec2.set(tempVec2, this.getParamScalarValue('m_flFinalTextureScaleU') ?? 1, this.getParamScalarValue('m_flFinalTextureScaleV') ?? 1);
        this.material.setUniform('uFinalTextureScale', tempVec2);
        geometry.attributes.get('aTextureCoord')._array;
        geometry.attributes.get('aTextureCoord2')._array;
        for (const particle of particleList) {
            const sequence = particle.sequence;
            if (m_bFitCycleToLifetime) {
                particle.timeToLive; //SubFloat(pLifeDuration[ nGroup * ld_stride ], nOffset);
            }
            else {
                if (useAnimRate) {
                    particle.frame += elapsedTime * rate;
                    this.material.getFrameSpan(sequence);
                }
            }
            particle.frame += elapsedTime;
            this.spriteSheet;
            geometry.attributes.get('aTextureCoord').dirty = true;
            geometry.attributes.get('aTextureCoord2').dirty = true;
        }
    }
    set maxParticles(maxParticles) {
        this.#maxParticles = Graphics$1.isWebGL2 ? maxParticles : ceilPowerOfTwo(maxParticles);
        this.#createParticlesArray();
        this.#initBuffers();
    }
    #initBuffers() {
        const geometry = this.#geometry;
        const vertices = [];
        const uvs = [];
        const uvs2 = [];
        const indices = [];
        const id = [];
        for (let i = 0; i < this.#maxParticles; i++) {
            const indiceBase = i * 4;
            indices.push(indiceBase, indiceBase + 2, indiceBase + 1, indiceBase + 2, indiceBase + 3, indiceBase + 1);
            vertices.push(-1.0, 1.0, 0.0, 1.0, 1.0, 0.0, -1.0, -1.0, 0.0, 1.0, -1.0, 0.0);
            uvs.push(0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0);
            uvs2.push(0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0);
            id.push(i, i, i, i);
        }
        geometry.count = indices.length;
        geometry.setIndex(new Uint32BufferAttribute(indices, 1));
        geometry.setAttribute('aVertexPosition', new Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('aTextureCoord', new Float32BufferAttribute(uvs, 2));
        geometry.setAttribute('aTextureCoord2', new Float32BufferAttribute(uvs2, 2));
        geometry.setAttribute('aParticleId', new Float32BufferAttribute(id, 1));
        this.mesh.setUniform('uMaxParticles', this.#maxParticles); //TODOv3:optimize
    }
    initRenderer(particleSystem) {
        this.mesh.serializable = false;
        this.mesh.hideInExplorer = true;
        this.mesh.setDefine('HARDWARE_PARTICLES');
        this.#createParticlesTexture();
        this.mesh.setUniform('uParticles', this.#texture);
        this.maxParticles = particleSystem.maxParticles;
        particleSystem.addChild(this.mesh);
    }
    #createParticlesArray() {
        this.#imgData = new Float32Array(this.#maxParticles * 4 * TEXTURE_WIDTH);
    }
    #createParticlesTexture() {
        this.#texture = TextureManager.createTexture();
        const gl = Graphics$1.glContext; //TODO
        gl.bindTexture(GL_TEXTURE_2D, this.#texture.texture);
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        gl.texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        gl.bindTexture(GL_TEXTURE_2D, null);
    }
    updateParticlesTexture() {
        const gl = Graphics$1.glContext;
        gl.bindTexture(GL_TEXTURE_2D, this.#texture.texture);
        if (Graphics$1.isWebGL2) {
            gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA32F, TEXTURE_WIDTH, this.#maxParticles, 0, GL_RGBA, GL_FLOAT, this.#imgData);
        }
        else {
            gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, TEXTURE_WIDTH, this.#maxParticles, 0, GL_RGBA, GL_FLOAT, this.#imgData);
        }
        gl.bindTexture(GL_TEXTURE_2D, null);
    }
    #setupParticlesTexture(particleList, maxParticles, elapsedTime) {
        const a = this.#imgData;
        const m_flMaxLength = this.#maxLength;
        const m_flMinLength = this.#minLength;
        const m_flLengthFadeInTime = this.#lengthFadeInTime;
        this.getParameter('animation rate') ?? 30;
        this.getParameter('animation_fit_lifetime') ?? 0;
        //const a = new Float32Array(maxParticles * 4 * TEXTURE_WIDTH);
        let index = 0;
        let flOODt;
        if (this.#ignoreDT) {
            flOODt = 1;
        }
        else {
            flOODt = (elapsedTime != 0.0) ? (1.0 / elapsedTime) : 1.0;
        }
        const radiusScale = this.getParamScalarValue('m_flRadiusScale') ?? 1;
        const alphaScale = this.getParamScalarValue('m_flAlphaScale') ?? 1;
        for (const particle of particleList) {
            const flAge = particle.currentTime;
            const flLengthScale = (flAge >= m_flLengthFadeInTime) ? 1.0 : (flAge / m_flLengthFadeInTime);
            const vecDelta = vec3.subtract(vec3.create(), particle.prevPosition, particle.position); //TODOv3: optimize
            const flMag = vec3.length(vecDelta);
            vec3.normalize(vecDelta, vecDelta);
            let flLength = flLengthScale * flMag * flOODt * particle.trailLength * this.#lengthScale;
            if (flLength <= 0.0) {
                return;
            }
            flLength = clamp$1(flLength, m_flMinLength, m_flMaxLength);
            //vec3.scale(vecDelta, vecDelta, flLength * 0.5);TODOv3
            //const vTangentY = vec3.cross(vec3.create(), vDirToBeam, vecDelta);
            let rad = particle.radius * radiusScale;
            if (flLength < rad) {
                rad = flLength;
            }
            a[index++] = particle.position[0];
            a[index++] = particle.position[1];
            a[index++] = particle.position[2];
            index++;
            a[index++] = particle.color[0];
            a[index++] = particle.color[1];
            a[index++] = particle.color[2];
            a[index++] = particle.alpha * alphaScale;
            a[index++] = rad;
            index++;
            a[index++] = particle.rotationRoll;
            a[index++] = particle.rotationYaw;
            a[index++] = vecDelta[0];
            a[index++] = vecDelta[1];
            a[index++] = vecDelta[2];
            a[index++] = flLength;
            a[index++] = particle.normal[0];
            a[index++] = particle.normal[1];
            a[index++] = particle.normal[2];
            index += 13;
        }
        this.updateParticlesTexture();
    }
    init() {
        if (this.setDefaultTexture) {
            this.setTexture(DEFAULT_PARTICLE_TEXTURE);
        }
    }
}
RegisterSource2ParticleOperator('C_OP_RenderTrails', RenderTrails);

var source2_decode_texture = `

vec4 vectorToColor(vec4 vec) {
	return ((vec * 0.5) + 0.5);
}

vec2 colorToVector(vec2 color) {
	return ((color * 2.0) - 1.0);
}

vec4 normalizeNormals(vec4 normal) {
	normal.rg = colorToVector(normal.ag);
	normal.g = -normal.g;
	normal.b = sqrt(1.0 - dot(normal.rg, normal.rg));

	return vectorToColor(normal);
}
`;

Includes['source2_decode_texture'] = source2_decode_texture;

var source2_fragment_compute_cs2_stickers = `
	#pragma unroll
	for ( int i = 0; i < 5; i ++ ) {

#ifdef ENABLE_STICKER{i}
#endif
	}
`;

var source2_fragment_declare_cs2_stickers = `
#pragma unroll
for ( int i = 0; i < 5; i ++ ) {
#ifdef ENABLE_STICKER{i}
	uniform float g_vSticker{i}Rotation;
	uniform float g_vSticker{i}Wear;
	uniform float g_fWearScratchesSticker{i};
	uniform vec4 g_vSticker{i}Offset;
	uniform vec4 g_vSticker{i}Scale;
	uniform vec4 g_vWearBiasSticker{i};

	uniform sampler2D sticker{i}Map;
	uniform sampler2D normalRoughnessSticker{i}Map;
	uniform sampler2D holoSpectrumSticker{i}Map;
	uniform sampler2D sfxMaskSticker{i}Map;
#endif
}

uniform sampler2D stickerWepInputsMap;
`;

var source2_varying_csgo_weapon_stattrak = `
#include varying_standard
`;

var source2_varying_csgo_weapon = `
#include varying_standard
`;

Includes['source2_fragment_compute_cs2_stickers'] = source2_fragment_compute_cs2_stickers;
Includes['source2_fragment_declare_cs2_stickers'] = source2_fragment_declare_cs2_stickers;
Includes['source2_varying_csgo_weapon_stattrak'] = source2_varying_csgo_weapon_stattrak;
Includes['source2_varying_csgo_weapon'] = source2_varying_csgo_weapon;

var source2_varying_hero_fluid = `
#include varying_standard
`;

var source2_varying_hero = `
#include varying_standard
`;

Includes['source2_varying_hero_fluid'] = source2_varying_hero_fluid;
Includes['source2_varying_hero'] = source2_varying_hero;

var source2_varying_crystal = `
#include varying_standard
`;

var source2_varying_global_lit_simple = `
#include varying_standard
`;

var source2_varying_pbr = `
#include varying_standard
`;

var source2_varying_spring_meteor = `
#include varying_standard
`;

var source2_varying_spritecard = `
#include varying_standard
varying vec4 vColor;
`;

var source2_varying_ui = `
#include varying_standard
`;

Includes['source2_varying_crystal'] = source2_varying_crystal;
Includes['source2_varying_global_lit_simple'] = source2_varying_global_lit_simple;
Includes['source2_varying_pbr'] = source2_varying_pbr;
Includes['source2_varying_spring_meteor'] = source2_varying_spring_meteor;
Includes['source2_varying_spritecard'] = source2_varying_spritecard;
Includes['source2_varying_ui'] = source2_varying_ui;

var source2_varying_vr_black_unlit = `
#include varying_standard
`;

var source2_varying_vr_complex = `
#include varying_standard
`;

var source2_varying_vr_eyeball = `
#include varying_standard
`;

var source2_varying_vr_glass = `
#include varying_standard
`;

var source2_varying_vr_simple_3layer_parallax = `
#include varying_standard
`;

var source2_varying_vr_simple = `
#include varying_standard
`;

var source2_varying_vr_skin = `
#include varying_standard
`;

var source2_varying_vr_xen_foliage = `
#include varying_standard
`;

Includes['source2_varying_vr_black_unlit'] = source2_varying_vr_black_unlit;
Includes['source2_varying_vr_complex'] = source2_varying_vr_complex;
Includes['source2_varying_vr_eyeball'] = source2_varying_vr_eyeball;
Includes['source2_varying_vr_glass'] = source2_varying_vr_glass;
Includes['source2_varying_vr_simple_3layer_parallax'] = source2_varying_vr_simple_3layer_parallax;
Includes['source2_varying_vr_simple'] = source2_varying_vr_simple;
Includes['source2_varying_vr_skin'] = source2_varying_vr_skin;
Includes['source2_varying_vr_xen_foliage'] = source2_varying_vr_xen_foliage;

var source2_detail_blend = `

#define DETAIL_BLEND_MODE_ADD 1
#define DETAIL_BLEND_MODE_ADD_SELF_ILLUM 2
#define DETAIL_BLEND_MODE_MOD2X 3
#define DETAIL_BLEND_MODE_WHAT 4

#ifdef USE_DETAIL1_MAP
	#ifdef DETAIL_BLEND_MODE
		vec4 detailColor;
		#if DETAIL_BLEND_MODE == DETAIL_BLEND_MODE_ADD
			//diffuseColor = diffuseColor + detail1Color * g_flDetailBlendFactor * texelMask1.r;
			detailColor = diffuseColor + detail1Color;
		#elif DETAIL_BLEND_MODE == DETAIL_BLEND_MODE_ADD_SELF_ILLUM
			//diffuseColor = diffuseColor + detail1Color * g_flDetailBlendFactor * texelMask1.r;//TODO selfillum
			detailColor = diffuseColor + detail1Color;//TODO selfillum
		#elif DETAIL_BLEND_MODE == DETAIL_BLEND_MODE_MOD2X
			//diffuseColor = mix(diffuseColor, diffuseColor * detail1Color * g_flDetailBlendFactor, texelMask1.r);//TODO: this is not quite right
			detailColor = 2.0 * diffuseColor * detail1Color;//TODO: this is not quite right
		#elif DETAIL_BLEND_MODE == DETAIL_BLEND_MODE_WHAT
			detailColor = (diffuseColor + detail1Color) * 0.5;
		#endif

		//diffuseColor = mix(diffuseColor, diffuseColor * detail1Color * g_flDetailBlendFactor, texelMask1.r);//TODO: this is not quite right

		diffuseColor = mix(diffuseColor, detailColor, g_flDetailBlendFactor * texelMask1.r);
	#endif
#endif
`;

var source2_fragment_compute_detail = `
#ifdef USE_DETAIL1_MAP
	vec2 detail1Coord = vTextureCoord.xy * g_vDetailTexCoordScale.xy + g_vDetailTexCoordOffset.xy;
	vec4 detail1Color = g_vDetail1ColorTint * texture2D(detail1Map, detail1Coord);
#endif
#ifdef USE_DETAIL2_MAP
	vec2 detail2Coord = vTextureCoord.xy * g_vDetail2TexCoordOffset.xy + g_vDetail2TexCoordOffset.xy;
	vec4 detail2Color = g_vDetail2ColorTint * texture2D(detail2Map, detail2Coord);
#endif
`;

var source2_fragment_compute_mask = `
#include compute_fragment_mask_map
#include compute_fragment_mask1_map
#include compute_fragment_mask2_map
#ifndef USE_MASK_MAP
	vec4 texelMask = vec4(1.0);
#endif
#ifndef USE_MASK1_MAP
	vec4 texelMask1 = vec4(1.0);
#endif
#ifndef USE_MASK2_MAP
	vec4 texelMask2 = vec4(1.0);
#endif
`;

var source2_fragment_compute_separate_alpha_transform = `
#ifdef USE_SEPARATE_ALPHA_TRANSFORM
	#ifdef USE_COLOR_MAP
		texelColor.a = texture2D(colorMap, vTextureCoord.xy + g_vAlphaTexCoordOffset.st).a;
	#endif
#endif
`;

var source2_fragment_declare_detail_map = `
#ifdef USE_DETAIL1_MAP
	uniform vec4 g_vDetailTexCoordScale;
	uniform vec4 g_vDetailTexCoordOffset;
	uniform vec4 g_vDetail1ColorTint;
	uniform sampler2D detail1Map;
#endif
#ifdef USE_DETAIL2_MAP
	uniform vec4 g_vDetail2TexCoordScale;
	uniform vec4 g_vDetail2TexCoordOffset;
	uniform vec4 g_vDetail2ColorTint;
	uniform sampler2D detail2Map;
#endif
`;

var source2_fragment_declare_separate_alpha_transform = `
#ifdef USE_SEPARATE_ALPHA_TRANSFORM
	uniform vec4 g_vAlphaTexCoordOffset;
#endif
`;

Includes['source2_detail_blend'] = source2_detail_blend;
Includes['source2_fragment_compute_detail'] = source2_fragment_compute_detail;
Includes['source2_fragment_compute_mask'] = source2_fragment_compute_mask;
Includes['source2_fragment_compute_separate_alpha_transform'] = source2_fragment_compute_separate_alpha_transform;
Includes['source2_fragment_declare_detail_map'] = source2_fragment_declare_detail_map;
Includes['source2_fragment_declare_separate_alpha_transform'] = source2_fragment_declare_separate_alpha_transform;

var source2_color_correction_fs = `

#include source2_varying_color_correction

void main(void) {
	if (length(floor((gl_FragCoord.xy + vec2(15.0)) / 30.0) * 30.0 - gl_FragCoord.xy) > 10.0) {
		discard;
	}
	gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
}
`;

var source2_color_correction_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning
#include declare_shadow_mapping

#include source2_varying_color_correction

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_shadow_mapping
	#include compute_vertex_standard
}
`;

var source2_sky_fs = `

#include source2_varying_sky

void main(void) {
	if (length(floor((gl_FragCoord.xy + vec2(15.0)) / 30.0) * 30.0 - gl_FragCoord.xy) > 10.0) {
		discard;
	}
	gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
}
`;

var source2_sky_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning
#include declare_shadow_mapping

#include source2_varying_sky

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_shadow_mapping
	#include compute_vertex_standard
}
`;

Shaders['source2_color_correction.fs'] = source2_color_correction_fs;
Shaders['source2_color_correction.vs'] = source2_color_correction_vs;
Shaders['source2_sky.fs'] = source2_sky_fs;
Shaders['source2_sky.vs'] = source2_sky_vs;

var source2_csgo_environment_fs = `
#include declare_camera_position
#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_alpha_test
#include declare_fragment_mask_map
#include declare_fragment_specular_map
#include source2_fragment_declare_detail_map
#include declare_fragment_cube_map
//#include source1_declare_phong

#include declare_lights
#include declare_shadow_mapping

uniform sampler2D g_tAmbientOcclusion;
uniform vec4 g_vColorTint;

#include source2_fragment_declare_separate_alpha_transform

uniform float g_flDetailBlendFactor;

#include source2_varying_hero
void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map
	#include compute_fragment_cube_map
	#include source2_fragment_compute_separate_alpha_transform
	#include compute_fragment_normal_map
	#include compute_fragment_specular_map
	#include source2_fragment_compute_mask
	#include source2_fragment_compute_detail
	diffuseColor *= texelColor;

#define DETAIL_MASK texelMask1.r
//#define FRESNEL_WARP texelMask1.g
#define METALNESS_MASK texelMask1.b
#define SELFILLUM_MASK texelMask1.a

#define SPECULAR_INTENSITY texelMask2.r
#define RIMLIGHT_INTENSITY texelMask2.g
#define TINT_MASK texelMask2.b
#define SPECULAR_EXPONENT texelMask2.a


	vec3 albedo = texelColor.rgb;

	#include compute_fragment_normal

	float phongMask = 1.0;
	float alpha = 1.0;
		float uPhongBoost = 1.0;
		float uPhongExponent = 1.0;

	#ifdef USE_NORMAL_MAP
		vec3 normal = normalize(vec3(texelNormal.ga * 2.0 - 1.0, 1.0));
		fragmentNormalCameraSpace = normalize(TBNMatrixCameraSpace * vec3(normal));
	#endif

	#include compute_fragment_alpha_test

	#include source2_detail_blend
	gl_FragColor.rgb = diffuseColor.rgb;
	gl_FragColor.a = diffuseColor.a;
	if (length(mod(gl_FragCoord.xy, vec2(2.0))) < 1.0) {
		//discard;
	}

#ifdef TESTING
#ifdef USE_SEPARATE_ALPHA_TRANSFORM
	/*gl_FragColor = vec4(vec3(g_vAlphaTexCoordOffset.y), 1.0);
	if (length(g_vAlphaTexCoordOffset.xy) < 0.5) {
		discard;
	}*/
#endif
#endif

/*
mask1.r: detail mask
mask1.g: diffuse warp
mask1.b: metalness
mask1.a: self illum
mask2.r: specular mask
mask2.g: rimlight
mask2.b: Base Tint Mask
mask2.a: Specular Exponent

*/


/* TEST SHADING BEGIN*/
	#include compute_lights_setup_vars



	BlinnPhongMaterial material;
	material.diffuseColor = diffuseColor.rgb;
#ifdef USE_PHONG_EXPONENT_MAP
	material.specularColor = mix(vec3(1.0), texelColor.rgb, texelPhongExponent.g) * phongMask;
	material.specularShininess = texelPhongExponent.r;
#else
	material.specularColor = vec3(phongMask);
	material.specularShininess = 5.0;//uPhongExponent;
#endif
	material.specularStrength = 1.0;//uPhongBoost;

#include compute_fragment_lights

/* TEST SHADING END*/





#ifdef SKIP_LIGHTING
	gl_FragColor.rgb = diffuseColor.rgb;
#else
	gl_FragColor.rgb = (reflectedLight.directSpecular + reflectedLight.directDiffuse + reflectedLight.indirectDiffuse);
#endif
gl_FragColor.a = texelColor.a;
//gl_FragColor.rgb = abs(normalize(fragmentNormalCameraSpace.rgb));
	#include compute_fragment_standard

#ifdef USE_CUBE_MAP
	gl_FragColor += cubeMapColor * METALNESS_MASK;//METALNESS_MASK;
#endif

#ifdef USE_COLOR_1_MAP
	gl_FragColor = texture2D(color1Map, vTextureCoord.xy);
#endif
	#include compute_fragment_render_mode
}
`;

var source2_csgo_environment_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning
#include declare_shadow_mapping

#include source2_varying_hero

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_shadow_mapping
	#include compute_vertex_standard
}
`;

var source2_csgo_weapon_stattrak_fs = `
#include declare_fragment_color_map

#include source2_varying_csgo_weapon_stattrak
void main(void) {
#ifdef USE_COLOR_MAP
	gl_FragColor = texture2D(colorMap, vTextureCoord.xy * vec2(6. / 16., 0.08));
	//gl_FragColor = texture2D(colorMap, vTextureCoord.xy);
#endif
}
`;

var source2_csgo_weapon_stattrak_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning
#include declare_shadow_mapping

#include source2_varying_csgo_weapon_stattrak

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_shadow_mapping
	#include compute_vertex_standard
}
`;

var source2_csgo_weapon_fs = `
#include declare_camera_position
#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_alpha_test
#include declare_fragment_mask_map
#include declare_fragment_specular_map
#include source2_fragment_declare_detail_map
#include declare_fragment_cube_map
#include source2_fragment_declare_cs2_stickers
//#include source1_declare_phong

#include declare_lights
#include declare_shadow_mapping

uniform sampler2D g_tAmbientOcclusion;
uniform vec4 g_vColorTint;

#include source2_fragment_declare_separate_alpha_transform

uniform float g_flDetailBlendFactor;
uniform float g_flMaterialCloakFactor;

#include source2_varying_csgo_weapon

void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map
	#include compute_fragment_cube_map
	#include source2_fragment_compute_separate_alpha_transform
	#include compute_fragment_normal_map
	#include compute_fragment_specular_map
	#include source2_fragment_compute_mask
	#include source2_fragment_compute_detail
	diffuseColor *= texelColor;

#define DETAIL_MASK texelMask1.r
//#define FRESNEL_WARP texelMask1.g
#define METALNESS_MASK texelMask1.b
#define SELFILLUM_MASK texelMask1.a

#define SPECULAR_INTENSITY texelMask2.r
#define RIMLIGHT_INTENSITY texelMask2.g
#define TINT_MASK texelMask2.b
#define SPECULAR_EXPONENT texelMask2.a

#ifdef ENABLE_CLOAK
	// TODO: fully code cloak, for now it's just a fix for io
	if (g_flMaterialCloakFactor == 1.0) {
		discard;
	}
#endif

	vec3 albedo = texelColor.rgb;

	#include compute_fragment_normal

	float phongMask = 1.0;
	float alpha = 1.0;
		float uPhongBoost = 1.0;
		float uPhongExponent = 1.0;

	#ifdef USE_NORMAL_MAP
		vec3 normal = normalize(vec3(texelNormal.ga * 2.0 - 1.0, 1.0));
		fragmentNormalCameraSpace = normalize(TBNMatrixCameraSpace * vec3(normal));
	#endif

	#include compute_fragment_alpha_test

	#include source2_detail_blend
	gl_FragColor.rgb = diffuseColor.rgb;
	gl_FragColor.a = diffuseColor.a;
	if (length(mod(gl_FragCoord.xy, vec2(2.0))) < 1.0) {
		//discard;
	}

#ifdef TESTING
#ifdef USE_SEPARATE_ALPHA_TRANSFORM
	/*gl_FragColor = vec4(vec3(g_vAlphaTexCoordOffset.y), 1.0);
	if (length(g_vAlphaTexCoordOffset.xy) < 0.5) {
		discard;
	}*/
#endif
#endif

/*
mask1.r: detail mask
mask1.g: diffuse warp
mask1.b: metalness
mask1.a: self illum
mask2.r: specular mask
mask2.g: rimlight
mask2.b: Base Tint Mask
mask2.a: Specular Exponent

*/


/* TEST SHADING BEGIN*/
	#include compute_lights_setup_vars



	BlinnPhongMaterial material;
	material.diffuseColor = diffuseColor.rgb;
#ifdef USE_PHONG_EXPONENT_MAP
	material.specularColor = mix(vec3(1.0), texelColor.rgb, texelPhongExponent.g) * phongMask;
	material.specularShininess = texelPhongExponent.r;
#else
	material.specularColor = vec3(phongMask);
	material.specularShininess = 5.0;//uPhongExponent;
#endif
	material.specularStrength = 1.0;//uPhongBoost;

#include compute_fragment_lights

/* TEST SHADING END*/





#ifdef SKIP_LIGHTING
	gl_FragColor.rgb = diffuseColor.rgb;
#else
	gl_FragColor.rgb = (reflectedLight.directSpecular + reflectedLight.directDiffuse + reflectedLight.indirectDiffuse);
#endif
gl_FragColor.a = texelColor.a;
//gl_FragColor.rgb = abs(normalize(fragmentNormalCameraSpace.rgb));

#ifdef USE_CUBE_MAP
	gl_FragColor += cubeMapColor * METALNESS_MASK;//METALNESS_MASK;
#endif

	#include source2_fragment_compute_cs2_stickers

	if (length (vVertexPositionModelSpace.xy - g_vSticker0Offset.xy*15.) < 15.) {
		gl_FragColor = vec4(1., 0., 0., 0.);
	}

	if (length (vVertexPositionModelSpace.xz - g_vSticker0Offset.xy * 15.) < 5.) {
		gl_FragColor = vec4(1., 0., 0., 0.);
	}

	gl_FragColor.a = 1.0;
	gl_FragColor = texture2D(stickerWepInputsMap, vTextureCoord.xy);

	gl_FragColor = vec4(vTextureCoord.xy, 0.0, 1.0);

//	gl_FragColor = texture2D(stickerWepInputsMap, vTextureCoord.xy);
//gl_FragColor = texture2D(colorMap, vTextureCoord.xy);



	#include compute_fragment_standard
	#include compute_fragment_render_mode
}
`;

var source2_csgo_weapon_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning
#include declare_shadow_mapping
#include declare_log_depth

#include source2_varying_csgo_weapon

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_shadow_mapping
	#include compute_vertex_standard

	vVertexPositionModelSpace = vertexPositionModelSpace;
	#include compute_vertex_log_depth
}
`;

Shaders['source2_csgo_environment.fs'] = source2_csgo_environment_fs;
Shaders['source2_csgo_environment.vs'] = source2_csgo_environment_vs;
Shaders['source2_csgo_weapon_stattrak.fs'] = source2_csgo_weapon_stattrak_fs;
Shaders['source2_csgo_weapon_stattrak.vs'] = source2_csgo_weapon_stattrak_vs;
Shaders['source2_csgo_weapon.fs'] = source2_csgo_weapon_fs;
Shaders['source2_csgo_weapon.vs'] = source2_csgo_weapon_vs;

var source2_hero_fluid_fs = `

#include declare_fragment_color_map
uniform sampler2D displacementMaskMap;
uniform sampler2D specularMap;
uniform sampler2D spiralNormalMap;
uniform sampler2D spiralOverlayMap;

#include declare_fragment_normal_map
#include declare_fragment_alpha_test
#include declare_fragment_mask_map
#include source2_fragment_declare_detail_map
//#include source1_declare_phong

#include declare_lights
#include declare_shadow_mapping

uniform sampler2D g_tAmbientOcclusion;
uniform vec4 g_vColorTint;

#include source2_fragment_declare_separate_alpha_transform

uniform float g_flDetailBlendFactor;

#include source2_varying_hero_fluid
void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map

#ifdef USE_DISPLACEMENT_MASK_MAP
	vec4 displacementMask = texture2D(displacementMaskMap, vTextureCoord.xy);
#else
	vec4 displacementMask = vec4(1.0);
#endif
#ifdef USE_SPECULAR_MAP
	vec4 specularColor = texture2D(specularMap, vTextureCoord.xy);
#else
	vec4 specularColor = vec4(1.0);
#endif
#ifdef USE_SPIRAL_NORMAL_MAP
	vec4 spiralNormal = texture2D(spiralNormalMap, vTextureCoord.xy);
#else
	vec4 spiralNormal = vec4(1.0);
#endif
#ifdef USE_SPIRAL_OVERLAY_MAP
	vec4 spiralOverlay = texture2D(spiralOverlayMap, vTextureCoord.xy);
#else
	vec4 spiralOverlay = vec4(1.0);
#endif

	#include source2_fragment_compute_separate_alpha_transform
	#include compute_fragment_normal_map
	#include source2_fragment_compute_mask
	#include source2_fragment_compute_detail
	diffuseColor *= texelColor;

	vec3 albedo = texelColor.rgb;

	#include compute_fragment_normal

	float phongMask = 1.0;
	float alpha = 1.0;
		float uPhongBoost = 1.0;
		float uPhongExponent = 1.0;

	#ifdef USE_NORMAL_MAP
		vec3 normal = normalize(vec3(texelNormal.ga * 2.0 - 1.0, 1.0));
		fragmentNormalCameraSpace = normalize(TBNMatrixCameraSpace * vec3(normal));
	#endif

	#include compute_fragment_alpha_test

	#include source2_detail_blend
	gl_FragColor.rgb = diffuseColor.rgb;
	gl_FragColor.a = diffuseColor.a;
	if (length(mod(gl_FragCoord.xy, vec2(2.0))) < 1.0) {
		//discard;
	}

#ifdef TESTING
#ifdef USE_SEPARATE_ALPHA_TRANSFORM
	/*gl_FragColor = vec4(vec3(g_vAlphaTexCoordOffset.y), 1.0);
	if (length(g_vAlphaTexCoordOffset.xy) < 0.5) {
		discard;
	}*/
#endif
#endif

/*
mask1.r: detail mask
mask1.g: diffuse warp
mask1.b: metalness
mask1.a: self illum
mask2.r: specular mask
mask2.g: rimlight
mask2.b: Base Tint Mask
mask2.a: Specular Exponent

*/


/* TEST SHADING BEGIN*/
	#include compute_lights_setup_vars



	BlinnPhongMaterial material;
	material.diffuseColor = diffuseColor.rgb;
#ifdef USE_PHONG_EXPONENT_MAP
	material.specularColor = mix(vec3(1.0), texelColor.rgb, texelPhongExponent.g) * phongMask;
	material.specularShininess = texelPhongExponent.r;
#else
	material.specularColor = vec3(phongMask);
	material.specularShininess = 5.0;//uPhongExponent;
#endif
	material.specularStrength = 1.0;//uPhongBoost;

#include compute_fragment_lights

/* TEST SHADING END*/





#ifdef SKIP_LIGHTING
	gl_FragColor.rgb = diffuseColor.rgb;
#else
	gl_FragColor.rgb = (reflectedLight.directSpecular + reflectedLight.directDiffuse + reflectedLight.indirectDiffuse);
#endif
gl_FragColor.a = texelColor.a;
//gl_FragColor.rgb = abs(normalize(fragmentNormalCameraSpace.rgb));
	#include compute_fragment_standard

	vec4 finalcolor;
	finalcolor.rgb = mix(texelColor.rgb, spiralOverlay.rgb, spiralOverlay.a);
	finalcolor.a = texelColor.a;

	gl_FragColor = finalcolor;
	#include compute_fragment_render_mode
}
`;

var source2_hero_fluid_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning
#include declare_shadow_mapping

#include source2_varying_hero_fluid

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_shadow_mapping
	#include compute_vertex_standard
}
`;

var source2_hero_fs = `
#include declare_camera_position
#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_alpha_test
#include declare_fragment_mask_map
#include declare_fragment_specular_map
#include source2_fragment_declare_detail_map
#include declare_fragment_cube_map
#include source2_decode_texture
//#include source1_declare_phong

#include declare_lights
#include declare_shadow_mapping

uniform sampler2D g_tAmbientOcclusion;
uniform vec4 g_vColorTint;

#include source2_fragment_declare_separate_alpha_transform

uniform float g_flDetailBlendFactor;
uniform float g_flMaterialCloakFactor;

#include source2_varying_hero
void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map
	#include compute_fragment_cube_map
	#include source2_fragment_compute_separate_alpha_transform
	#include compute_fragment_normal_map
	#include compute_fragment_specular_map
	#include source2_fragment_compute_mask
	#include source2_fragment_compute_detail
	diffuseColor *= texelColor;

#ifdef NORMALIZE_NORMALS
	texelNormal = normalizeNormals(texelNormal);
#endif

#define DETAIL_MASK texelMask1.r
//#define FRESNEL_WARP texelMask1.g
#define METALNESS_MASK texelMask1.b
#define SELFILLUM_MASK texelMask1.a

#define SPECULAR_INTENSITY texelMask2.r
#define RIMLIGHT_INTENSITY texelMask2.g
#define TINT_MASK texelMask2.b
#define SPECULAR_EXPONENT texelMask2.a

#ifdef ENABLE_CLOAK
	// TODO: fully code cloak, for now it's just a fix for io
	if (g_flMaterialCloakFactor == 1.0) {
		discard;
	}
#endif

	vec3 albedo = texelColor.rgb;

	#include compute_fragment_normal

	float phongMask = 1.0;
	float alpha = 1.0;
		float uPhongBoost = 1.0;
		float uPhongExponent = 1.0;

	#ifdef USE_NORMAL_MAP
		vec3 normal = normalize(vec3(texelNormal.ga * 2.0 - 1.0, 1.0));
		fragmentNormalCameraSpace = normalize(TBNMatrixCameraSpace * vec3(normal));
	#endif

	#include compute_fragment_alpha_test

	#include source2_detail_blend
	gl_FragColor.rgb = diffuseColor.rgb;
	gl_FragColor.a = diffuseColor.a;
	if (length(mod(gl_FragCoord.xy, vec2(2.0))) < 1.0) {
		//discard;
	}

#ifdef TESTING
#ifdef USE_SEPARATE_ALPHA_TRANSFORM
	/*gl_FragColor = vec4(vec3(g_vAlphaTexCoordOffset.y), 1.0);
	if (length(g_vAlphaTexCoordOffset.xy) < 0.5) {
		discard;
	}*/
#endif
#endif

/*
mask1.r: detail mask
mask1.g: diffuse warp
mask1.b: metalness
mask1.a: self illum
mask2.r: specular mask
mask2.g: rimlight
mask2.b: Base Tint Mask
mask2.a: Specular Exponent

*/


/* TEST SHADING BEGIN*/
	#include compute_lights_setup_vars



	BlinnPhongMaterial material;
	material.diffuseColor = diffuseColor.rgb;
#ifdef USE_PHONG_EXPONENT_MAP
	material.specularColor = mix(vec3(1.0), texelColor.rgb, texelPhongExponent.g) * phongMask;
	material.specularShininess = texelPhongExponent.r;
#else
	material.specularColor = vec3(phongMask);
	material.specularShininess = 5.0;//uPhongExponent;
#endif
	material.specularStrength = 1.0;//uPhongBoost;

#include compute_fragment_lights

/* TEST SHADING END*/





#ifdef SKIP_LIGHTING
	gl_FragColor.rgb = diffuseColor.rgb;
#else
	gl_FragColor.rgb = (reflectedLight.directSpecular + reflectedLight.directDiffuse + reflectedLight.indirectDiffuse);
#endif
gl_FragColor.a = texelColor.a;
//gl_FragColor.rgb = abs(normalize(fragmentNormalCameraSpace.rgb));

#ifdef USE_CUBE_MAP
	gl_FragColor += cubeMapColor * METALNESS_MASK;//METALNESS_MASK;
#endif
	#include compute_fragment_standard
	#include compute_fragment_render_mode
}
`;

var source2_hero_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning
#include declare_shadow_mapping

#include source2_varying_hero

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_shadow_mapping
	#include compute_vertex_standard
}
`;

Shaders['source2_hero_fluid.fs'] = source2_hero_fluid_fs;
Shaders['source2_hero_fluid.vs'] = source2_hero_fluid_vs;
Shaders['source2_hero.fs'] = source2_hero_fs;
Shaders['source2_hero.vs'] = source2_hero_vs;

var source2_vr_black_unlit_fs = `
#include source2_varying_vr_black_unlit

void main(void) {
		gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
	#include compute_fragment_standard
}
`;

var source2_vr_black_unlit_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_skinning

#include source2_varying_vr_black_unlit

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
}
`;

var source2_vr_complex_fs = `
#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_alpha_test
uniform sampler2D aoMap;
uniform vec4 g_vColorTint;

#include source2_varying_vr_complex

void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map

	diffuseColor *= texelColor;
	#include compute_fragment_alpha_test

	gl_FragColor = diffuseColor - vec4(vec3(0.5), 0.0);// * vec4(vec3(0.01), 1.0);
	//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
	gl_FragColor = vec4(diffuseColor);
	//gl_FragColor.rgb *= 0.00000;
	gl_FragColor.a = 1.0;



	//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
	//gl_FragColor = texture2D(colorMap, vTextureCoord * vec2(1.0, 1.0) + vec2(0.5, 0.0));
	gl_FragColor.rgb *= g_vColorTint.rgb;
	//gl_FragColor.rgb *= texture2D(g_tAmbientOcclusion, vTextureCoord).rrr;

#ifdef IS_TRANSLUCENT
	gl_FragColor.rgb = g_vColorTint.rgb * diffuseColor.rgb * diffuseColor.a;
	gl_FragColor.a = diffuseColor.a;
#else
	gl_FragColor.rgb = g_vColorTint.rgb * diffuseColor.rgb;
#endif
#ifdef USE_AO_MAP
	gl_FragColor.rgb *= texture2D(aoMap, vTextureCoord.xy).rrr;
#endif
	#include compute_fragment_standard
}
`;

var source2_vr_complex_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_skinning

#include source2_varying_vr_complex

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
}
`;

var source2_vr_eyeball_fs = `
#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_alpha_test
uniform sampler2D g_tAmbientOcclusion;
uniform vec4 g_vColorTint;

#include source2_varying_vr_eyeball

void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map

	diffuseColor *= texelColor;
	#include compute_fragment_alpha_test

	gl_FragColor = diffuseColor - vec4(vec3(0.5), 0.0);// * vec4(vec3(0.01), 1.0);
		//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
	gl_FragColor = vec4(diffuseColor);
		//gl_FragColor.rgb *= 0.00000;
		gl_FragColor.a = 1.0;



		//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
		//gl_FragColor = texture2D(colorMap, vTextureCoord * vec2(1.0, 1.0) + vec2(0.5, 0.0));
		gl_FragColor.rgb *= g_vColorTint.rgb;
		gl_FragColor.rgb *= texture2D(g_tAmbientOcclusion, vTextureCoord.xy).rrr;

#ifdef IS_TRANSLUCENT
	gl_FragColor.rgb = g_vColorTint.rgb * diffuseColor.rgb * diffuseColor.a;
	gl_FragColor.a = diffuseColor.a;
#else
	gl_FragColor.rgb = g_vColorTint.rgb * diffuseColor.rgb;
#endif
	#include compute_fragment_standard
}
`;

var source2_vr_eyeball_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_skinning

#include source2_varying_vr_eyeball

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
}
`;

var source2_vr_glass_fs = `
#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_alpha_test
uniform sampler2D g_tAmbientOcclusion;
uniform vec4 g_vColorTint;

uniform sampler2D tintColorMap;

#include source2_varying_vr_complex

void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map

	diffuseColor *= texelColor;
	#include compute_fragment_alpha_test

	gl_FragColor = diffuseColor - vec4(vec3(0.5), 0.0);// * vec4(vec3(0.01), 1.0);
	//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
	gl_FragColor = vec4(diffuseColor);
	//gl_FragColor.rgb *= 0.00000;
	gl_FragColor.a = 1.0;



	//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
	//gl_FragColor = texture2D(colorMap, vTextureCoord * vec2(1.0, 1.0) + vec2(0.5, 0.0));
	gl_FragColor.rgb *= g_vColorTint.rgb;
	gl_FragColor.rgb *= texture2D(g_tAmbientOcclusion, vTextureCoord.xy).rrr;

#ifdef IS_TRANSLUCENT
	gl_FragColor.rgb = g_vColorTint.rgb * diffuseColor.rgb * diffuseColor.a;
	gl_FragColor.a = diffuseColor.a;
#else
	gl_FragColor.rgb = g_vColorTint.rgb * diffuseColor.rgb;
#endif
	vec4 tintColorTexel = texture2D(tintColorMap, vTextureCoord.xy);
	gl_FragColor.rgb = tintColorTexel.rgb;
	#include compute_fragment_standard
}
`;

var source2_vr_glass_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_skinning

#include source2_varying_vr_complex

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
}
`;

var source2_vr_simple_2way_blend_fs = `
#ifdef USE_COLOR_A_MAP
	uniform sampler2D colorAMap;
#endif
#ifdef USE_COLOR_B_MAP
	uniform sampler2D colorBMap;
#endif
#include declare_fragment_normal_map
#include declare_fragment_mask_map
#include declare_fragment_alpha_test
uniform sampler2D aoMap;
uniform vec4 g_vColorTint;

#include source2_varying_vr_simple

void main(void) {
	vec4 diffuseColor = vec4(1.0);
	//#include compute_fragment_color_map

#ifdef USE_COLOR_A_MAP
	vec4 texelColorA = texture2D(colorAMap, vTextureCoord.xy);
#else
	vec4 texelColorA = vec4(1.0);
#endif
#ifdef USE_COLOR_B_MAP
	vec4 texelColorB = texture2D(colorBMap, vTextureCoord.xy);
#else
	vec4 texelColorB = vec4(1.0);
#endif


#ifdef USE_COLOR_MAP
	diffuseColor *= texelColor;
#endif
	#include compute_fragment_alpha_test
	#include source2_fragment_compute_mask

	gl_FragColor = diffuseColor - vec4(vec3(0.5), 0.0);// * vec4(vec3(0.01), 1.0);
	//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
	gl_FragColor = vec4(diffuseColor);
	//gl_FragColor.rgb *= 0.00000;
	gl_FragColor.a = 1.0;



	//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
	//gl_FragColor = texture2D(colorMap, vTextureCoord * vec2(1.0, 1.0) + vec2(0.5, 0.0));
	gl_FragColor.rgb *= g_vColorTint.rgb;
	//gl_FragColor.rgb *= texture2D(g_tAmbientOcclusion, vTextureCoord).rrr;

#ifdef IS_TRANSLUCENT
	gl_FragColor.rgb = g_vColorTint.rgb * diffuseColor.rgb * diffuseColor.a;
	gl_FragColor.a = diffuseColor.a;
#else
	gl_FragColor.rgb = g_vColorTint.rgb * diffuseColor.rgb;
#endif
#ifdef USE_AO_MAP
	gl_FragColor.rgb *= texture2D(aoMap, vTextureCoord.xy).rrr;
#endif
	#include compute_fragment_standard


	gl_FragColor.rgb = texelColorA.rgb * 0.0 + texelColorB.rgb;
}
`;

var source2_vr_simple_2way_blend_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_skinning

#include source2_varying_vr_simple

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
}
`;

var source2_vr_simple_3layer_parallax_fs = `
uniform sampler2D colorMap;
uniform sampler2D g_tAmbientOcclusion;
uniform sampler2D g_tColorA;
uniform sampler2D g_tColorB;
uniform sampler2D g_tColorC;
uniform sampler2D g_tMasks;
uniform sampler2D g_tNormalA;
uniform sampler2D g_tEmissiveB;
uniform sampler2D g_tEmissiveC;


uniform vec4 g_vColorTint;

#include source2_varying_vr_simple_3layer_parallax

void main(void) {
		vec4 textureColor = texture2D(colorMap, vTextureCoord.xy);
		gl_FragColor = textureColor - vec4(vec3(0.5), 0.0);// * vec4(vec3(0.01), 1.0);
		//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
		gl_FragColor = vec4(textureColor);
		//gl_FragColor.rgb *= 0.00000;
		gl_FragColor.a = 1.0;



		//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
		//gl_FragColor = texture2D(colorMap, vTextureCoord * vec2(1.0, 1.0) + vec2(0.5, 0.0));
		gl_FragColor.rgb *= g_vColorTint.rgb;
		//gl_FragColor.rgb *= texture2D(g_tAmbientOcclusion, vTextureCoord).rrr;
		//if (gl_FragCoord.x < 0.5 * 800.0)
		{
			gl_FragColor.rgb *= texture2D(g_tAmbientOcclusion, vTextureCoord).rrr;
		}
		gl_FragColor.rgb = texture2D(g_tEmissiveC, vTextureCoord.xy).rgb;
	#include compute_fragment_standard
}
`;

var source2_vr_simple_3layer_parallax_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_skinning

#include source2_varying_vr_simple_3layer_parallax

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
}
`;

var source2_vr_simple_fs = `
#include declare_lights
#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_alpha_test
#include declare_camera_position
uniform sampler2D aoMap;
uniform vec4 g_vColorTint;

#include compute_pbr

#include source2_varying_vr_simple

void main(void) {
	float metalness;
	float roughness;
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_normal
	#include compute_fragment_normal_world_space
	#include compute_fragment_color_map
	#include compute_fragment_normal_map

#ifdef USE_COLOR_MAP
	diffuseColor *= pow(texelColor, vec4(2.2));
	metalness = texelColor.a;
#endif


#ifdef USE_NORMAL_MAP
	roughness = texelNormal.b;
#endif

	#include compute_fragment_alpha_test

	gl_FragColor = diffuseColor - vec4(vec3(0.5), 0.0);// * vec4(vec3(0.01), 1.0);
	//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
	gl_FragColor = vec4(diffuseColor);
	//gl_FragColor.rgb *= 0.00000;
	gl_FragColor.a = 1.0;



	//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
	//gl_FragColor = texture2D(colorMap, vTextureCoord * vec2(1.0, 1.0) + vec2(0.5, 0.0));
	gl_FragColor.rgb *= g_vColorTint.rgb;
	//gl_FragColor.rgb *= texture2D(g_tAmbientOcclusion, vTextureCoord).rrr;

#ifdef IS_TRANSLUCENT
	gl_FragColor.rgb = g_vColorTint.rgb * diffuseColor.rgb * diffuseColor.a;
	gl_FragColor.a = diffuseColor.a;
#else
	gl_FragColor.rgb = g_vColorTint.rgb * diffuseColor.rgb;
#endif
#ifdef USE_AO_MAP
	float ao = texture2D(aoMap, vTextureCoord.xy).r;
#else
	float ao = 1.0;
#endif
	#include compute_fragment_standard
#if NUM_PBR_LIGHTS > 0

#ifdef USE_NORMAL_MAP
		vec3 N = normalize(vec3(texelNormal.rg, 1.) * 2.0 - 1.0);
#else
		vec3 N = vec3(0., 0., 1.);
#endif
	N = normalize(TBNMatrixWorldSpace * N);
	vec3 albedo = diffuseColor.rgb;
	vec3 F0 = mix(Fdielectric, albedo, metalness);
	vec3 color = computePBR(uPbrLights, N, uCameraPosition, vVertexPositionWorldSpace.xyz, F0, metalness, roughness, albedo, ao);
	color = color / (color + vec3(1.0));
	// gamma correct
	color = pow(color, vec3(1.0/2.2));
	gl_FragColor.rgb = color;
#endif
}
`;

var source2_vr_simple_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_skinning

#include source2_varying_vr_simple

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
}
`;

var source2_vr_skin_fs = `
uniform sampler2D colorMap;
uniform sampler2D g_tAmbientOcclusion;
uniform vec4 g_vColorTint;

#include source2_varying_vr_skin

void main(void) {
		vec4 textureColor = texture2D(colorMap, vTextureCoord.xy);
		gl_FragColor = textureColor - vec4(vec3(0.5), 0.0);// * vec4(vec3(0.01), 1.0);
		//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
		gl_FragColor = vec4(textureColor);
		//gl_FragColor.rgb *= 0.00000;
		gl_FragColor.a = 1.0;



		//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
		//gl_FragColor = texture2D(colorMap, vTextureCoord * vec2(1.0, 1.0) + vec2(0.5, 0.0));
		gl_FragColor.rgb *= g_vColorTint.rgb;
		gl_FragColor.rgb *= texture2D(g_tAmbientOcclusion, vTextureCoord.xy).rrr;

		gl_FragColor.rgb = textureColor.rgb;
	#include compute_fragment_standard
}
`;

var source2_vr_skin_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_skinning

#include source2_varying_vr_skin

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
}
`;

var source2_vr_xen_foliage_fs = `
#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_alpha_test
uniform sampler2D g_tAmbientOcclusion;
uniform vec4 g_vColorTint;

#ifdef F_SELF_ILLUM
	uniform vec4 g_vSelfIllumTint;
	uniform float g_flSelfIllumOverallScale;
	uniform float g_flSelfIllumFlowSpeed;
	uniform float g_flSelfIllumFlowAmount;
#endif
#ifdef USE_MASK_PARAMETERS_MAP
	uniform sampler2D maskParametersMap;
	/*
	RED : self illum mask
	GREEN : ?
	BLUE : self illum flow phase
	*/
#endif

#ifdef USE_SIFW_MAP
	uniform sampler2D selfIllumFlowWaveformMap;
#endif

#include source2_varying_vr_xen_foliage

void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map
	#include compute_fragment_normal_map

	diffuseColor *= texelColor;
	#include compute_fragment_alpha_test

	gl_FragColor = diffuseColor - vec4(vec3(0.5), 0.0);// * vec4(vec3(0.01), 1.0);
	//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
	gl_FragColor = vec4(diffuseColor);
	//gl_FragColor.rgb *= 0.00000;
	gl_FragColor.a = 1.0;



	//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
	//gl_FragColor = texture2D(colorMap, vTextureCoord * vec2(1.0, 1.0) + vec2(0.5, 0.0));
	gl_FragColor.rgb *= g_vColorTint.rgb;
	gl_FragColor.rgb *= texture2D(g_tAmbientOcclusion, vTextureCoord.xy).rrr;


#ifdef F_SELF_ILLUM
/*
	//---- Self Illum ----
	g_flSelfIllumBrightness "1.000"
	g_flSelfIllumCustomFlowTimer "0.000"
	g_flSelfIllumFlowAmount "1.000"
	g_flSelfIllumFlowFrequency "1.000"
	g_flSelfIllumFlowSpeed "4.000"
	g_flSelfIllumOverallScale "1.000"
	g_vSelfIllumTint "[1.000000 1.000000 1.000000 0.000000]"
	TextureSelfIllumFlowPhase "materials/default/default.tga"
	TextureSelfIllumFlowWaveform "materials/workshop_examples/combine/blind_zombie_crushed_wave.png"
	TextureSelfIllumMask "materials/workshop_examples/combine/combine_monitor_screens_selfillum.tga"
	*/
#endif

#ifdef IS_TRANSLUCENT
	gl_FragColor.rgb = g_vColorTint.rgb * diffuseColor.rgb * diffuseColor.a;
	gl_FragColor.a = diffuseColor.a;
#else
	gl_FragColor.rgb = g_vColorTint.rgb * diffuseColor.rgb;
#endif
#ifdef F_SELF_ILLUM
	vec3 selfIllumColor = g_vSelfIllumTint.rgb;
	float deltaUV = 0.0;
	#ifdef USE_MASK_PARAMETERS_MAP
		vec4 maskParametersTexel = texture2D(maskParametersMap, vTextureCoord.xy);
		//gl_FragColor.rgb = maskParametersTexel.rgb;
		selfIllumColor *= maskParametersTexel.r;
		deltaUV = maskParametersTexel.b;
	#endif

	#ifdef USE_SIFW_MAP
		vec4 selfIllumFlowWaveformTexel = texture2D(selfIllumFlowWaveformMap, vec2(mod(uTime.r * g_flSelfIllumFlowSpeed + pow(deltaUV, 2.0), 1.0), 0.5));
		//selfIllumFlowWaveStrength *= ;
		selfIllumColor *= mix(1.0, selfIllumFlowWaveformTexel.r, g_flSelfIllumFlowAmount);
	#endif


	gl_FragColor.rgb += g_flSelfIllumOverallScale * 0.5 * selfIllumColor;//TODO: why 0.5 ?
#endif

	/*vec4 selfIllumFlowWaveformTexel = texture2D(selfIllumFlowWaveformMap, vTextureCoord);
	gl_FragColor.rgb = selfIllumFlowWaveformTexel.rgb;*/
#ifdef USE_MASK_PARAMETERS_MAP
	//gl_FragColor.rgb = maskParametersTexel.rrr;
#endif
	#include compute_fragment_standard
}
`;

var source2_vr_xen_foliage_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_skinning

#include source2_varying_vr_xen_foliage

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
}
`;

Shaders['source2_vr_black_unlit.fs'] = source2_vr_black_unlit_fs;
Shaders['source2_vr_black_unlit.vs'] = source2_vr_black_unlit_vs;
Shaders['source2_vr_complex.fs'] = source2_vr_complex_fs;
Shaders['source2_vr_complex.vs'] = source2_vr_complex_vs;
Shaders['source2_vr_eyeball.fs'] = source2_vr_eyeball_fs;
Shaders['source2_vr_eyeball.vs'] = source2_vr_eyeball_vs;
Shaders['source2_vr_glass.fs'] = source2_vr_glass_fs;
Shaders['source2_vr_glass.vs'] = source2_vr_glass_vs;
Shaders['source2_vr_simple_2way_blend.fs'] = source2_vr_simple_2way_blend_fs;
Shaders['source2_vr_simple_2way_blend.vs'] = source2_vr_simple_2way_blend_vs;
Shaders['source2_vr_simple_3layer_parallax.fs'] = source2_vr_simple_3layer_parallax_fs;
Shaders['source2_vr_simple_3layer_parallax.vs'] = source2_vr_simple_3layer_parallax_vs;
Shaders['source2_vr_simple.fs'] = source2_vr_simple_fs;
Shaders['source2_vr_simple.vs'] = source2_vr_simple_vs;
Shaders['source2_vr_skin.fs'] = source2_vr_skin_fs;
Shaders['source2_vr_skin.vs'] = source2_vr_skin_vs;
Shaders['source2_vr_xen_foliage.fs'] = source2_vr_xen_foliage_fs;
Shaders['source2_vr_xen_foliage.vs'] = source2_vr_xen_foliage_vs;

var source2_crystal_fs = `
#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_alpha_test
#include declare_fragment_mask_map
#include source2_fragment_declare_detail_map

uniform sampler2D g_tAmbientOcclusion;
uniform vec4 g_vColorTint;

#include source2_fragment_declare_separate_alpha_transform

uniform float g_flDetailBlendFactor;
uniform float g_flOpacityScale;

uniform vec4 TextureTranslucency;

#include source2_varying_crystal

void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map
	#include source2_fragment_compute_separate_alpha_transform
	#include compute_fragment_normal_map
	#include source2_fragment_compute_mask
	#include source2_fragment_compute_detail
	diffuseColor *= texelColor;

	#include compute_fragment_alpha_test

	#include source2_detail_blend
	gl_FragColor.rgb = diffuseColor.rgb;
	gl_FragColor.a = 1.0;
	if (length(mod(gl_FragCoord.xy, vec2(2.0))) < 1.0) {
		//discard;
	}

#ifdef TESTING
#ifdef USE_SEPARATE_ALPHA_TRANSFORM
	/*gl_FragColor = vec4(vec3(g_vAlphaTexCoordOffset.y), 1.0);
	if (length(g_vAlphaTexCoordOffset.xy) < 0.5) {
		discard;
	}*/
#endif
#endif

//#ifdef TESTING
//	gl_FragColor = vec4(1.0, 0.0, 0.5, 1.0);
//	if (length(floor((gl_FragCoord.xy + vec2(15.0)) / 30.0) * 30.0 - gl_FragCoord.xy) > 10.0) {
//		discard;
//	}
//#endif
/*
mask1.r: detail mask
mask1.g: diffuse warp
mask1.b: metalness
mask1.a: self illum
mask2.r: specular mask
mask2.g: rimlight
mask2.b: Base Tint Mask
mask2.a: Specular Exponent

*/
	#include compute_fragment_standard
gl_FragColor.rgb *= TextureTranslucency.rgb;
}
`;

var source2_crystal_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning

#include source2_varying_crystal

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
}
`;

var source2_error_fs = `
#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_alpha_test
#include declare_fragment_mask_map
#include source2_fragment_declare_detail_map

uniform sampler2D g_tAmbientOcclusion;
uniform vec4 g_vColorTint;

#include source2_fragment_declare_separate_alpha_transform

uniform float g_flDetailBlendFactor;

#include source2_varying_crystal

void main(void) {
	gl_FragColor = vec4(1.0, 0.0, 0.5, 1.0);
	if (length(floor((gl_FragCoord.xy + vec2(15.0)) / 30.0) * 30.0 - gl_FragCoord.xy) > 10.0) {
		gl_FragColor = vec4(0.5, 0.0, 1.0, 1.0);
	}
}
`;

var source2_error_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning

#include source2_varying_crystal

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
}
`;

var source2_global_lit_simple_fs = `
#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_alpha_test
#include declare_fragment_mask_map
#include source2_fragment_declare_detail_map
//#include source1_declare_phong

uniform sampler2D g_tAmbientOcclusion;
uniform vec4 g_vColorTint;

#include source2_fragment_declare_separate_alpha_transform

uniform float g_flDetailBlendFactor;

#include declare_lights

#include source2_varying_global_lit_simple
void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map
	#include source2_fragment_compute_separate_alpha_transform
	#include compute_fragment_normal_map
	#include source2_fragment_compute_mask
	#include source2_fragment_compute_detail
	diffuseColor *= texelColor;

	vec3 albedo = texelColor.rgb;

	#include compute_fragment_normal

	float phongMask = 1.0;
	float alpha = 1.0;
		float uPhongBoost = 1.0;
		float uPhongExponent = 1.0;

		fragmentNormalCameraSpace = normalize(TBNMatrixCameraSpace * vec3(0.0, 0.0, 1.0));

	#include compute_fragment_alpha_test

	#include source2_detail_blend
	gl_FragColor.rgb = diffuseColor.rgb;
	gl_FragColor.a = diffuseColor.a;
	if (length(mod(gl_FragCoord.xy, vec2(2.0))) < 1.0) {
		//discard;
	}

#ifdef TESTING
#ifdef USE_SEPARATE_ALPHA_TRANSFORM
	/*gl_FragColor = vec4(vec3(g_vAlphaTexCoordOffset.y), 1.0);
	if (length(g_vAlphaTexCoordOffset.xy) < 0.5) {
		discard;
	}*/
#endif
#endif
/*
mask1.r: detail mask
mask1.g: diffuse warp
mask1.b: metalness
mask1.a: self illum
mask2.r: specular mask
mask2.g: rimlight
mask2.b: Base Tint Mask
mask2.a: Specular Exponent

*/


/* TEST SHADING BEGIN*/
	#include compute_lights_setup_vars



	BlinnPhongMaterial material;
	material.diffuseColor = albedo;//diffuseColor.rgb;//vec3(1.0);//diffuseColor.rgb;
#ifdef USE_PHONG_EXPONENT_MAP
	material.specularColor = mix(vec3(1.0), texelColor.rgb, texelPhongExponent.g) * phongMask;
	material.specularShininess = texelPhongExponent.r;
#else
	material.specularColor = vec3(phongMask);
	material.specularShininess = 5.0;//uPhongExponent;
#endif
	material.specularStrength = 1.0;//uPhongBoost;

#if NUM_POINT_LIGHTS > 0
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		computePointLightIrradiance(uPointLights[i], geometry, directLight);
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( uAmbientLight );

	irradiance += getLightProbeIrradiance( lightProbe, geometry );

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );

		}

	#endif

#endif

#if defined( RE_IndirectDiffuse )

	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );

#endif

#if defined( RE_IndirectSpecular )

	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );

#endif

/* TEST SHADING END*/





#ifdef SKIP_LIGHTING
	gl_FragColor.rgb = diffuseColor.rgb;
#else
	gl_FragColor.rgb = (reflectedLight.directSpecular + reflectedLight.directDiffuse + reflectedLight.indirectDiffuse);
#endif
gl_FragColor.a = texelColor.a;
//gl_FragColor.rgb = abs(normalize(fragmentNormalCameraSpace.rgb));
	#include compute_fragment_standard
	#include compute_fragment_render_mode
}
`;

var source2_global_lit_simple_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning

#include source2_varying_global_lit_simple

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
}
`;

var source2_pbr_fs = `
#include declare_camera_position
#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_alpha_test
#include declare_fragment_mask_map
#include declare_fragment_specular_map
#include source2_fragment_declare_detail_map
#include declare_fragment_cube_map
#include declare_fragment_self_illum_mask_map

#include declare_lights
#include declare_shadow_mapping

uniform sampler2D g_tAmbientOcclusion;
uniform vec4 g_vColorTint;

#include source2_fragment_declare_separate_alpha_transform

uniform float g_flDetailBlendFactor;
uniform float g_flMaterialCloakFactor;

// Constant normal incidence Fresnel factor for all dielectrics.

struct AnalyticalLight {
	vec3 direction;
	vec3 radiance;
};
#include compute_pbr

const float Epsilon = 0.00001;
const vec4 defaultNormalTexel = vec4(0.5, 0.5, 1.0, 1.0);
const int NumLights = 1;
AnalyticalLight lights[NumLights] = AnalyticalLight[](AnalyticalLight(vec3(40., 0., 50.), vec3(1)));

#include source2_varying_pbr
void main(void) {
	#include compute_fragment_normal
	#include compute_fragment_normal_world_space
	#include compute_fragment_color_map
	#include compute_fragment_normal_map
	#include compute_fragment_self_illum_mask_map


	// Sample input textures to get shading model params.
	vec3 albedo = texelColor.rgb;//vec3 albedo = texture(albedoTexture, vin.texcoord).rgb;
	float metalness = texelColor.a;//float metalness = texture(metalnessTexture, vin.texcoord).r;
	float roughness = 0.1;//float roughness = texture(roughnessTexture, vin.texcoord).r;

	// Outgoing light direction (vector from world-space fragment position to the "eye").
	vec3 Lo = normalize(vec3(40, 0., 50.) - vVertexPositionWorldSpace.xyz);//vec3 Lo = normalize(eyePosition - vin.position);

	// Get current fragment's normal and transform to world space.
#ifdef USE_NORMAL_MAP
	vec3 N = normalize(texelNormal.rgb);//vec3 N = normalize(2.0 * texture(normalTexture, vin.texcoord).rgb - 1.0);
#else
	vec3 N = normalize(defaultNormalTexel.rgb);//vec3 N = normalize(2.0 * texture(normalTexture, vin.texcoord).rgb - 1.0);
#endif
	N = normalize(TBNMatrixWorldSpace * N);//N = normalize(vin.tangentBasis * N);

	// Angle between surface normal and outgoing light direction.
	float cosLo = max(0.0, dot(N, Lo));


	// Specular reflection vector.
	vec3 Lr = 2.0 * cosLo * N - Lo;

	// Fresnel reflectance at normal incidence (for metals use albedo color).
	vec3 F0 = mix(Fdielectric, albedo, metalness);




	gl_FragColor.a = 1.0;

	#include compute_fragment_standard


	gl_FragColor.rgb = abs(N.rgb);
	gl_FragColor.rgb = abs(vVertexNormalModelSpace.rgb);
#if NUM_PBR_LIGHTS > 0
	vec3 color = computePBR(uPbrLights, N, uCameraPosition, vVertexPositionWorldSpace.xyz, F0, metalness, roughness, albedo, 1.);
	color = color / (color + vec3(1.0));
	// gamma correct
	color = pow(color, vec3(1.0/2.2));
	gl_FragColor.rgb = color;
#endif
}
`;

var source2_pbr_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning
#include declare_shadow_mapping

#include source2_varying_pbr

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_shadow_mapping
	#include compute_vertex_standard
}
`;

var source2_spring_meteor_fs = `
#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_alpha_test
#include declare_fragment_mask_map
#include source2_fragment_declare_detail_map
//#include source1_declare_phong

#include declare_lights
#include declare_shadow_mapping

uniform sampler2D g_tAmbientOcclusion;
uniform vec4 g_vColorTint;

#include source2_fragment_declare_separate_alpha_transform

uniform float g_flDetailBlendFactor;

#include source2_varying_spring_meteor
void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map
	#include source2_fragment_compute_separate_alpha_transform
	#include compute_fragment_normal_map
	#include source2_fragment_compute_mask
	#include source2_fragment_compute_detail
	diffuseColor *= texelColor;

	vec3 albedo = texelColor.rgb;

	#include compute_fragment_normal

	float phongMask = 1.0;
	float alpha = 1.0;
		float uPhongBoost = 1.0;
		float uPhongExponent = 1.0;

	#ifdef USE_NORMAL_MAP
		vec3 normal = normalize(vec3(texelNormal.ga * 2.0 - 1.0, 1.0));
		fragmentNormalCameraSpace = normalize(TBNMatrixCameraSpace * vec3(normal));
	#endif

	#include compute_fragment_alpha_test

	#include source2_detail_blend
	gl_FragColor.rgb = diffuseColor.rgb;
	gl_FragColor.a = diffuseColor.a;
	if (length(mod(gl_FragCoord.xy, vec2(2.0))) < 1.0) {
		//discard;
	}

#ifdef TESTING
#ifdef USE_SEPARATE_ALPHA_TRANSFORM
	/*gl_FragColor = vec4(vec3(g_vAlphaTexCoordOffset.y), 1.0);
	if (length(g_vAlphaTexCoordOffset.xy) < 0.5) {
		discard;
	}*/
#endif
#endif

/*
mask1.r: detail mask
mask1.g: diffuse warp
mask1.b: metalness
mask1.a: self illum
mask2.r: specular mask
mask2.g: rimlight
mask2.b: Base Tint Mask
mask2.a: Specular Exponent

*/


/* TEST SHADING BEGIN*/
	#include compute_lights_setup_vars



	BlinnPhongMaterial material;
	material.diffuseColor = diffuseColor.rgb;
#ifdef USE_PHONG_EXPONENT_MAP
	material.specularColor = mix(vec3(1.0), texelColor.rgb, texelPhongExponent.g) * phongMask;
	material.specularShininess = texelPhongExponent.r;
#else
	material.specularColor = vec3(phongMask);
	material.specularShininess = 5.0;//uPhongExponent;
#endif
	material.specularStrength = 1.0;//uPhongBoost;

#include compute_fragment_lights

/* TEST SHADING END*/





#ifdef SKIP_LIGHTING
	gl_FragColor.rgb = diffuseColor.rgb;
#else
	gl_FragColor.rgb = (reflectedLight.directSpecular + reflectedLight.directDiffuse + reflectedLight.indirectDiffuse);
#endif
gl_FragColor.a = texelColor.a;
//gl_FragColor.rgb = abs(normalize(fragmentNormalCameraSpace.rgb));
	#include compute_fragment_standard
	#include compute_fragment_render_mode
}
`;

var source2_spring_meteor_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_uv
#include declare_vertex_skinning
#include declare_shadow_mapping

#include source2_varying_spring_meteor

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	#include compute_vertex_shadow_mapping
	#include compute_vertex_standard
}
`;

var source2_spritecard_fs = `
#include source1_declare_gamma_functions

uniform sampler2D colorMap;
uniform float uAddSelf;
uniform float uOverbrightFactor;
uniform vec3 uColorScale;
#include declare_fragment_alpha_test

#include source2_varying_spritecard

#ifndef SEQUENCE_COMBINE_MODE
	#define SEQUENCE_COMBINE_MODE 0
#endif

void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map
	#ifdef USE_TEXTURE_COORD_2
		vec4 texelColor2 = texture2D(colorMap, vTexture2Coord.xy);
	#else
		vec4 texelColor2 = texelColor;
	#endif


#ifdef SPRITECARD_TEXTURE_CHANNEL_MIX_RGBA_RGBALPHA
	texelColor.a = texelColor.r;//TODO : use rgb luminance ?
#endif

	diffuseColor *= texelColor;


	#include compute_fragment_alpha_test
	//vec4 textureColor = texture2D(colorMap, vTextureCoord.xy);
	//gl_FragColor = textureColor * (vColor + vec4(uAddSelf));
	//gl_FragColor = texelColor * (vColor + vec4(uAddSelf)) * texelColor.a;
	vec4 blended_rgb = texelColor;
	blended_rgb.rgb *= uOverbrightFactor;
	//blended_rgb = pow(blended_rgb, vec4(2.2));
	#ifdef ADD_SELF
		blended_rgb.a *= vColor.a;
		blended_rgb.rgb *= blended_rgb.a;
		blended_rgb.rgb += uOverbrightFactor * uAddSelf * vColor.a * blended_rgb.rgb;
		blended_rgb.rgb *= GammaToLinear(vColor.rgb);
	#else
		blended_rgb *= GammaToLinear(vColor);
	#endif
	gl_FragColor = blended_rgb;
#ifdef IS_ROPE
	//gl_FragColor = vec4(1.0);
#endif
	#include compute_fragment_standard
	gl_FragColor = vec4(vTextureCoord.xy, 0.0, vColor.a) * vColor.a;
	gl_FragColor = texelColor * vColor * vColor.a;
	gl_FragColor = texelColor * pow(vColor, vec4(2.2)) * texelColor.a;
	gl_FragColor = texelColor * vColor * texelColor.a;
	//gl_FragColor = texelColor;
	//gl_FragColor.a = texelColor.a;
#if SEQUENCE_COMBINE_MODE == 0
	#define TEXEL_RGB texelColor.rgb
	#define TEXEL_ALPHA texelColor.a
#endif
#if SEQUENCE_COMBINE_MODE == 1//SEQUENCE_COMBINE_MODE_ALPHA_FROM0_RGB_FROM_1
	#define TEXEL_RGB texelColor2.rgb
	#define TEXEL_ALPHA texelColor.a
#endif
	gl_FragColor.rgb = TEXEL_RGB * vColor.rgb * TEXEL_ALPHA * uColorScale;
	//gl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(2.2));
	gl_FragColor.a = vColor.a * TEXEL_ALPHA;
	//gl_FragColor.a = TEXEL_ALPHA;
}`;

var source2_spritecard_vs = `
//#version 300 es

attribute float aParticleId;
#include declare_attributes

#include declare_matrix_uniforms

//uniform float uFaceCamera;
uniform vec3 uCameraPosition;
uniform vec2 uFinalTextureScale;

#include source_declare_particle

#include source1_declare_gamma_functions

#include source2_varying_spritecard

void main(void) {
#ifdef HARDWARE_PARTICLES
	#include source1_compute_particle_position
	vColor = p.color;
	vColor = GammaToLinear(p.color);
	vColor = p.color;

	vTextureCoord.xy = aTextureCoord * uFinalTextureScale;
#ifdef USE_TEXTURE_COORD_2
	vTexture2Coord.xy = aTextureCoord2;
#endif
#else
	#ifdef USE_VERTEX_COLOR
		vColor = aVertexColor;
	#else
		vColor = vec4(1.0);
	#endif
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
#endif



}
`;

var source2_ui_fs = `
#include declare_fragment_color_map
#include declare_fragment_normal_map
#include declare_fragment_alpha_test
uniform sampler2D aoMap;
uniform vec4 g_vColorTint;

#include source2_varying_ui

void main(void) {
	vec4 diffuseColor = vec4(1.0);
	#include compute_fragment_color_map

#ifdef USE_COLOR_MAP
	diffuseColor *= texelColor;
#endif
	#include compute_fragment_alpha_test

	gl_FragColor = diffuseColor - vec4(vec3(0.5), 0.0);// * vec4(vec3(0.01), 1.0);
	//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
	gl_FragColor = vec4(diffuseColor);
	//gl_FragColor.rgb *= 0.00000;
	gl_FragColor.a = 1.0;



	//gl_FragColor = vec4(vTextureCoord, 1.0, 1.0);
	//gl_FragColor = texture2D(colorMap, vTextureCoord * vec2(1.0, 1.0) + vec2(0.5, 0.0));
	gl_FragColor.rgb *= g_vColorTint.rgb;
	//gl_FragColor.rgb *= texture2D(g_tAmbientOcclusion, vTextureCoord).rrr;

#ifdef IS_TRANSLUCENT
	gl_FragColor.rgb = g_vColorTint.rgb * diffuseColor.rgb * diffuseColor.a;
	gl_FragColor.a = diffuseColor.a;
#else
	gl_FragColor.rgb = g_vColorTint.rgb * diffuseColor.rgb;
#endif
#ifdef USE_AO_MAP
	gl_FragColor.rgb *= texture2D(aoMap, vTextureCoord.xy).rrr;
#endif
	#include compute_fragment_standard
}
`;

var source2_ui_vs = `
#include declare_attributes
#include declare_matrix_uniforms
#include declare_vertex_skinning

#include source2_varying_ui

void main(void) {
	#include compute_vertex_uv
	#include compute_vertex
	#include compute_vertex_skinning
	#include compute_vertex_projection
	vTextureCoord.y = 1.0 - vTextureCoord.y;
}
`;

Shaders['source2_crystal.fs'] = source2_crystal_fs;
Shaders['source2_crystal.vs'] = source2_crystal_vs;
Shaders['source2_error.fs'] = source2_error_fs;
Shaders['source2_error.vs'] = source2_error_vs;
Shaders['source2_global_lit_simple.fs'] = source2_global_lit_simple_fs;
Shaders['source2_global_lit_simple.vs'] = source2_global_lit_simple_vs;
Shaders['source2_pbr.fs'] = source2_pbr_fs;
Shaders['source2_pbr.vs'] = source2_pbr_vs;
Shaders['source2_spring_meteor.fs'] = source2_spring_meteor_fs;
Shaders['source2_spring_meteor.vs'] = source2_spring_meteor_vs;
Shaders['source2_spritecard.fs'] = source2_spritecard_fs;
Shaders['source2_spritecard.vs'] = source2_spritecard_vs;
Shaders['source2_ui.fs'] = source2_ui_fs;
Shaders['source2_ui.vs'] = source2_ui_vs;

class CubeTexture extends Texture {
    isCubeTexture;
    #images;
    constructor(parameters) {
        super(parameters);
        this.isCubeTexture = true;
        this.setImages(parameters.images);
    }
    setImages(images) {
        if (!images) {
            return;
        }
        this.#images = images;
    }
    getImages() {
        return this.#images;
    }
    getWidth() {
        return this.#images?.[0]?.width ?? 0;
    }
    getHeight() {
        return this.#images?.[0]?.height ?? 0;
    }
    is(type) {
        return type === 'CubeTexture';
    }
}

const LOD_MIN = 4;
// The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.
const EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
// The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.
const MAX_SAMPLES = 20;
const flatCamera = new Camera({ projection: CameraProjection.Orthographic, position: vec3.fromValues(0, 0, 1) });
const clearColor = vec4.create();
// Golden Ratio
const PHI = (1 + Math.sqrt(5)) / 2;
const INV_PHI = 1 / PHI;
// Vertices of a dodecahedron (except the opposites, which represent the
// same axis), used as axis directions evenly spread on a sphere.
const axisDirections = [
    vec3.fromValues(1, 1, 1),
    vec3.fromValues(-1, 1, 1),
    vec3.fromValues(1, 1, -1),
    vec3.fromValues(-1, 1, -1),
    vec3.fromValues(0, PHI, INV_PHI),
    vec3.fromValues(0, PHI, -INV_PHI),
    vec3.fromValues(INV_PHI, 0, PHI),
    vec3.fromValues(-INV_PHI, 0, PHI),
    vec3.fromValues(PHI, INV_PHI, 0),
    vec3.fromValues(-PHI, INV_PHI, 0)
];
// Radiance Environment Map generator
class RemGenerator {
    #renderer;
    #pingPongRenderTarget;
    #blurMaterial;
    #cubemapMaterial;
    #equirectMaterial;
    #lodMax = 0;
    #cubeSize = 0;
    #lodPlanes = [];
    #sizeLods = [];
    #sigmas = [];
    constructor(renderer) {
        this.#renderer = renderer;
    }
    /*
    constructor(renderer) {

        this.#renderer = renderer;
        this.#pingPongRenderTarget = null;

        this.#lodMax = 0;
        this.#cubeSize = 0;
        this.#lodPlanes = [];
        this.#sizeLods = [];
        this.#sigmas = [];

        this.#blurMaterial = null;
        this.#cubemapMaterial = null;
        this.#equirectMaterial = null;

        this.#compileMaterial(this.#blurMaterial);
    }
        */
    fromScene(scene, sigma = 0, near = 0.1, far = 100) {
        /*
                _oldTarget = this.#renderer.getRenderTarget();
                _oldActiveCubeFace = this.#renderer.getActiveCubeFace();
                _oldActiveMipmapLevel = this.#renderer.getActiveMipmapLevel();
                */
        this.#setSize(256);
        const cubeUVRenderTarget = this.#allocateTargets();
        cubeUVRenderTarget.setDepthBuffer(true);
        this.#sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
        if (sigma > 0) {
            this.#blur(cubeUVRenderTarget, 0, 0, sigma);
        }
        this.#applyPMREM(cubeUVRenderTarget);
        this.#cleanup(cubeUVRenderTarget);
        return cubeUVRenderTarget;
    }
    /**
     * Generates a PMREM from an equirectangular texture, which can be either LDR
     * or HDR. The ideal input image size is 1k (1024 x 512),
     * as this matches best with the 256 x 256 cubemap output.
     */
    fromEquirectangular(equirectangular, renderTarget) {
        if (!this.#equirectMaterial) {
            this.#equirectMaterial = getEquirectMaterial();
        }
        return this.#fromTexture(equirectangular, renderTarget);
    }
    /**
     * Generates a PMREM from an cubemap texture, which can be either LDR
     * or HDR. The ideal input cube size is 256 x 256,
     * as this matches best with the 256 x 256 cubemap output.
     */
    fromCubemap(cubemap, renderTarget) {
        if (!this.#cubemapMaterial) {
            this.#cubemapMaterial = getCubemapMaterial();
        }
        return this.#fromTexture(cubemap, renderTarget);
    }
    /**
     * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
     * your texture's network fetch for increased concurrency.
     */
    compileCubemapShader() {
        if (this.#cubemapMaterial === null) {
            this.#cubemapMaterial = getCubemapMaterial();
            this.#compileMaterial(this.#cubemapMaterial);
        }
    }
    /**
     * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
     * your texture's network fetch for increased concurrency.
     */
    compileEquirectangularShader() {
        if (this.#equirectMaterial === null) {
            this.#equirectMaterial = getEquirectMaterial();
            this.#compileMaterial(this.#equirectMaterial);
        }
    }
    /**
     * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
     * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
     * one of them will cause any others to also become unusable.
     */
    dispose() {
        this.#dispose();
        this.#cubemapMaterial?.dispose();
        this.#equirectMaterial?.dispose();
    }
    // private interface
    #setSize(cubeSize) {
        this.#lodMax = Math.floor(Math.log2(cubeSize));
        this.#cubeSize = Math.pow(2, this.#lodMax);
    }
    #dispose() {
        if (this.#blurMaterial) {
            this.#blurMaterial.removeUser(this);
        }
        if (this.#pingPongRenderTarget) {
            this.#pingPongRenderTarget.dispose();
        }
        for (const lodPlane of this.#lodPlanes) {
            lodPlane.dispose();
        }
        this.#lodPlanes = [];
    }
    #cleanup(outputTarget) {
        //this.#renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel);
        //Graphics.pushRenderTarget();
        outputTarget.setScissorTest(false);
        //outputTarget.setViewport(0, 0, outputTarget.width, outputTarget.height);
    }
    #fromTexture(texture, renderTarget) {
        let size;
        if (texture.is('CubeTexture')) {
            size = texture.getWidth();
            this.#setSize(size);
        }
        else {
            size = texture.getWidth() * 0.25;
            this.#setSize(size);
        }
        /*
                _oldTarget = this.#renderer.getRenderTarget();
                _oldActiveCubeFace = this.#renderer.getActiveCubeFace();
                _oldActiveMipmapLevel = this.#renderer.getActiveMipmapLevel();

                */
        const cubeUVRenderTarget = renderTarget || this.#allocateTargets();
        this.#textureToCubeUV(texture, cubeUVRenderTarget);
        this.#applyPMREM(cubeUVRenderTarget);
        this.#cleanup(cubeUVRenderTarget);
        return cubeUVRenderTarget;
    }
    #allocateTargets() {
        const width = 3 * Math.max(this.#cubeSize, 16 * 7);
        const height = 4 * this.#cubeSize;
        const params = {
            //TODO
            /*
            magFilter: LinearFilter,
            minFilter: LinearFilter,
            generateMipmaps: false,
            type: HalfFloatType,
            format: RGBAFormat,
            colorSpace: LinearSRGBColorSpace,
            depthBuffer: false
            */
            width: width,
            height: height,
        };
        const cubeUVRenderTarget = createRenderTarget(params);
        if (!this.#pingPongRenderTarget || this.#pingPongRenderTarget.getWidth() !== width || this.#pingPongRenderTarget.getHeight() !== height) {
            if (this.#pingPongRenderTarget) {
                this.#dispose();
            }
            this.#pingPongRenderTarget = createRenderTarget(params);
            ({ sizeLods: this.#sizeLods, lodPlanes: this.#lodPlanes, sigmas: this.#sigmas } = createPlanes(this.#lodMax));
            this.#blurMaterial = getBlurShader(this.#lodMax, width, height);
            this.#blurMaterial.addUser(this);
        }
        return cubeUVRenderTarget;
    }
    #compileMaterial(material) {
        new Mesh({ geometry: this.#lodPlanes[0], material: material });
        //this.#renderer.compile(tmpMesh, flatCamera);
    }
    #sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
        const fov = 90;
        const aspect = 1;
        const cubeCamera = new Camera({ projection: CameraProjection.Perspective, verticalFov: fov, aspectRatio: aspect, nearPlane: near, farPlane: far });
        const upSign = [1, -1, 1, 1, 1, 1];
        const forwardSign = [1, 1, 1, -1, -1, -1];
        const renderer = this.#renderer;
        const originalAutoClear = Graphics$1.autoClear;
        const toneMapping = renderer.getToneMapping();
        Graphics$1.getClearColor(clearColor);
        renderer.setToneMapping(ToneMapping.None);
        Graphics$1.autoClear = false;
        const backgroundMaterial = new MeshBasicMaterial({
            name: 'PMREM.Background',
            //side: BackSide,
            depthWrite: false,
            depthTest: false,
        });
        const scene2 = new Scene();
        const backgroundBox = new Box({ material: backgroundMaterial, parent: scene2 });
        const background = scene.background;
        /*
                if (background) {

                    if (background.isColor) {

                        //backgroundMaterial.color.copy(background);
                        vec4.copy(backgroundMaterial.color, background);
                        scene.background = undefined;
                        useSolidColor = true;

                    }

                } else {

                    //backgroundMaterial.color.copy(_clearColor);
                    vec4.copy(backgroundMaterial.color, clearColor);
                    useSolidColor = true;

                }*/
        for (let i = 0; i < 6; i++) {
            const col = i % 3;
            if (col === 0) {
                cubeCamera.upVector = vec3.fromValues(0, upSign[i], 0); //cubeCamera.up.set(0, upSign[i], 0);
                cubeCamera.lookAt(vec3.fromValues(forwardSign[i], 0, 0));
            }
            else if (col === 1) {
                cubeCamera.upVector = vec3.fromValues(0, 0, upSign[i]); //cubeCamera.up.set(0, 0, upSign[i]);
                cubeCamera.lookAt(vec3.fromValues(0, forwardSign[i], 0));
            }
            else {
                cubeCamera.upVector = vec3.fromValues(0, upSign[i], 0); //cubeCamera.up.set(0, upSign[i], 0);
                cubeCamera.lookAt(vec3.fromValues(0, 0, forwardSign[i]));
            }
            const size = this.#cubeSize;
            cubeUVRenderTarget.setViewport(col * size, i > 2 ? size : 0, size, size);
            Graphics$1.pushRenderTarget(cubeUVRenderTarget);
            renderer.render(scene, cubeCamera, 0, { DisableToolRendering: true });
            Graphics$1.popRenderTarget();
        }
        backgroundBox.dispose();
        //renderer.toneMapping = toneMapping;
        renderer.setToneMapping(toneMapping);
        Graphics$1.autoClear = originalAutoClear;
        scene.background = background;
    }
    #textureToCubeUV(texture, cubeUVRenderTarget) {
        const renderer = this.#renderer;
        const isCubeTexture = texture.is('CubeTexture'); //(texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping);
        let material;
        if (isCubeTexture) {
            if (!this.#cubemapMaterial) {
                this.#cubemapMaterial = getCubemapMaterial();
            }
            this.#cubemapMaterial.uniforms.flipEnvMap = (texture.isRenderTargetTexture === false) ? -1 : 1;
            material = this.#cubemapMaterial;
        }
        else {
            if (!this.#equirectMaterial) {
                this.#equirectMaterial = getEquirectMaterial();
            }
            material = this.#equirectMaterial;
        }
        const mesh = new Mesh({ geometry: this.#lodPlanes[0], material: material });
        const scene = new Scene();
        scene.addChild(mesh);
        const uniforms = material.uniforms;
        uniforms['envMap'] = texture;
        const size = this.#cubeSize;
        cubeUVRenderTarget.setViewport(0, 0, 3 * size, 2 * size);
        Graphics$1.pushRenderTarget(cubeUVRenderTarget);
        renderer.render(scene, flatCamera, 0, { DisableToolRendering: true });
        Graphics$1.popRenderTarget();
    }
    #applyPMREM(cubeUVRenderTarget) {
        this.#renderer;
        const autoClear = Graphics$1.autoClear;
        Graphics$1.autoClear = false;
        for (let i = 1; i < this.#lodPlanes.length; i++) {
            const sigma = Math.sqrt(this.#sigmas[i] * this.#sigmas[i] - this.#sigmas[i - 1] * this.#sigmas[i - 1]);
            const poleAxis = axisDirections[(i - 1) % axisDirections.length];
            this.#blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
        }
        Graphics$1.autoClear = autoClear;
    }
    /**
     * This is a two-pass Gaussian blur for a cubemap. Normally this is done
     * vertically and horizontally, but this breaks down on a cube. Here we apply
     * the blur latitudinally (around the poles), and then longitudinally (towards
     * the poles) to approximate the orthogonally-separable blur. It is least
     * accurate at the poles, but still does a decent job.
     */
    #blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
        if (!this.#pingPongRenderTarget) {
            return;
        }
        this.#halfBlur(cubeUVRenderTarget, this.#pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);
        this.#halfBlur(this.#pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);
    }
    #halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
        const renderer = this.#renderer;
        if (!this.#blurMaterial) {
            return;
        }
        if (direction !== 'latitudinal' && direction !== 'longitudinal') {
            console.error('blur direction must be either latitudinal or longitudinal!');
        }
        // Number of standard deviations at which to cut off the discrete approximation.
        const STANDARD_DEVIATIONS = 3;
        const blurMesh = new Mesh({ geometry: this.#lodPlanes[lodOut], material: this.#blurMaterial });
        const blurUniforms = this.#blurMaterial.uniforms;
        const scene = new Scene();
        scene.addChild(blurMesh);
        const pixels = this.#sizeLods[lodIn] - 1;
        const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
        const sigmaPixels = sigmaRadians / radiansPerPixel;
        const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
        if (samples > MAX_SAMPLES) {
            console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
        }
        const weights = [];
        let sum = 0;
        for (let i = 0; i < MAX_SAMPLES; ++i) {
            const x = i / sigmaPixels;
            const weight = Math.exp(-x * x / 2);
            weights.push(weight);
            if (i === 0) {
                sum += weight;
            }
            else if (i < samples) {
                sum += 2 * weight;
            }
        }
        for (let i = 0; i < weights.length; i++) {
            weights[i] = weights[i] / sum;
        }
        blurUniforms['envMap'] = targetIn.getTexture();
        blurUniforms['samples'] = samples;
        blurUniforms['weights[0]'] = weights;
        blurUniforms['latitudinal'] = direction === 'latitudinal';
        if (poleAxis) {
            blurUniforms['poleAxis'] = poleAxis;
        }
        blurUniforms['dTheta'] = radiansPerPixel;
        blurUniforms['mipInt'] = this.#lodMax - lodIn;
        const outputSize = this.#sizeLods[lodOut];
        const x = 3 * outputSize * (lodOut > this.#lodMax - LOD_MIN ? lodOut - this.#lodMax + LOD_MIN : 0);
        const y = 4 * (this.#cubeSize - outputSize);
        targetOut.setViewport(x, y, 3 * outputSize, 2 * outputSize);
        Graphics$1.pushRenderTarget(targetOut);
        renderer.render(scene, flatCamera, 0, { DisableToolRendering: true });
        Graphics$1.popRenderTarget();
    }
}
function createPlanes(lodMax) {
    const lodPlanes = [];
    const sizeLods = [];
    const sigmas = [];
    let lod = lodMax;
    const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
    for (let i = 0; i < totalLods; i++) {
        const sizeLod = Math.pow(2, lod);
        sizeLods.push(sizeLod);
        let sigma = 1.0 / sizeLod;
        if (i > lodMax - LOD_MIN) {
            sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];
        }
        else if (i === 0) {
            sigma = 0;
        }
        sigmas.push(sigma);
        const texelSize = 1.0 / (sizeLod - 2);
        const min = -texelSize;
        const max = 1 + texelSize;
        const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
        const cubeFaces = 6;
        const vertices = 6;
        const positionSize = 3;
        const uvSize = 2;
        const faceIndexSize = 1;
        const indices = [];
        const position = new Float32Array(positionSize * vertices * cubeFaces);
        const uv = new Float32Array(uvSize * vertices * cubeFaces);
        const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
        let index = 0;
        for (let face = 0; face < cubeFaces; face++) {
            const x = (face % 3) * 2 / 3 - 1;
            const y = face > 2 ? 0 : -1;
            const coordinates = [
                x, y, 0,
                x + 2 / 3, y, 0,
                x + 2 / 3, y + 1, 0,
                x, y, 0,
                x + 2 / 3, y + 1, 0,
                x, y + 1, 0
            ];
            indices.push(index++);
            indices.push(index++);
            indices.push(index++);
            indices.push(index++);
            indices.push(index++);
            indices.push(index++);
            position.set(coordinates, positionSize * vertices * face);
            uv.set(uv1, uvSize * vertices * face);
            const fill = [face, face, face, face, face, face];
            faceIndex.set(fill, faceIndexSize * vertices * face);
        }
        const planes = new BufferGeometry();
        planes.setIndex(new Uint16BufferAttribute(indices, 1));
        planes.setAttribute('aVertexPosition', new BufferAttribute(position, positionSize));
        planes.setAttribute('aTextureCoord', new BufferAttribute(uv, uvSize));
        planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));
        planes.count = indices.length;
        lodPlanes.push(planes);
        if (lod > LOD_MIN) {
            lod--;
        }
    }
    return { lodPlanes, sizeLods, sigmas };
}
function createRenderTarget(params) {
    const cubeUVRenderTarget = new RenderTarget(params);
    const renderTargetTexture = cubeUVRenderTarget.getTexture();
    renderTargetTexture.mapping = TextureMapping.CubeUvMapping;
    //cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
    //cubeUVRenderTarget.getTexture().name = 'PMREM.cubeUv';
    cubeUVRenderTarget.setScissorTest(true);
    return cubeUVRenderTarget;
}
function getBlurShader(lodMax, width, height) {
    const weights = new Float32Array(MAX_SAMPLES);
    const poleAxis = vec3.fromValues(0, 1, 0);
    const shaderMaterial = new ShaderMaterial({
        name: 'SphericalGaussianBlur',
        defines: {
            'n': MAX_SAMPLES,
            'CUBEUV_TEXEL_WIDTH': 1.0 / width,
            'CUBEUV_TEXEL_HEIGHT': 1.0 / height,
            'CUBEUV_MAX_MIP': `${lodMax}.0`,
        },
        uniforms: {
            'envMap': null,
            'samples': 1,
            'weights[0]': weights,
            'latitudinal': false,
            'dTheta': 0,
            'mipInt': 0,
            'poleAxis': poleAxis
        },
        vertex: getCommonVertexShader(),
        fragment: /* glsl */ `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			//#include <cube_uv_reflection_fragment>

	float getFace( vec3 direction ) {

		vec3 absDirection = abs( direction );

		float face = - 1.0;

		if ( absDirection.x > absDirection.z ) {

			if ( absDirection.x > absDirection.y )

				face = direction.x > 0.0 ? 0.0 : 3.0;

			else

				face = direction.y > 0.0 ? 1.0 : 4.0;

		} else {

			if ( absDirection.z > absDirection.y )

				face = direction.z > 0.0 ? 2.0 : 5.0;

			else

				face = direction.y > 0.0 ? 1.0 : 4.0;

		}

		return face;

	}

	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	// RH coordinate system; PMREM face-indexing convention
	vec2 getUV( vec3 direction, float face ) {

		vec2 uv;

		if ( face == 0.0 ) {

			uv = vec2( direction.z, direction.y ) / abs( direction.x ); // pos x

		} else if ( face == 1.0 ) {

			uv = vec2( - direction.x, - direction.z ) / abs( direction.y ); // pos y

		} else if ( face == 2.0 ) {

			uv = vec2( - direction.x, direction.y ) / abs( direction.z ); // pos z

		} else if ( face == 3.0 ) {

			uv = vec2( - direction.z, direction.y ) / abs( direction.x ); // neg x

		} else if ( face == 4.0 ) {

			uv = vec2( - direction.x, direction.z ) / abs( direction.y ); // neg y

		} else {

			uv = vec2( direction.x, direction.y ) / abs( direction.z ); // neg z

		}

		return 0.5 * ( uv + 1.0 );

	}


			vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {

			float face = getFace( direction );

			float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );

			mipInt = max( mipInt, cubeUV_minMipLevel );

			float faceSize = exp2( mipInt );

			highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0; // #25071

			if ( face > 2.0 ) {

				uv.y += faceSize;

				face -= 3.0;

			}

			uv.x += face * faceSize;

			uv.x += filterInt * 3.0 * cubeUV_minTileSize;

			uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );

			uv.x *= CUBEUV_TEXEL_WIDTH;
			uv.y *= CUBEUV_TEXEL_HEIGHT;

			#ifdef texture2DGradEXT

				return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb; // disable anisotropic filtering

			#else

				return texture2D( envMap, uv ).rgb;

			#endif

		}

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        //blending: NoBlending,
        depthTest: false,
        depthWrite: false
    });
    return shaderMaterial;
}
function getEquirectMaterial() {
    return new ShaderMaterial({
        name: 'EquirectangularToCubeUV',
        uniforms: {
            'envMap': null
        },
        vertex: getCommonVertexShader(),
        fragment: /* glsl */ `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include common

			vec2 equirectUv( in vec3 dir ) {

	// dir is assumed to be unit length

	float u = atan( dir.z, dir.x ) * RECIPROCAL_TAU + 0.5;

	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;

	return vec2( u, v );

}

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );
				//gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);
				//gl_FragColor = vec4(outputDirection, 1.0);

			}
		`,
        //blending: NoBlending,
        depthTest: false,
        depthWrite: false
    });
}
function getCubemapMaterial() {
    return new ShaderMaterial({
        name: 'CubemapToCubeUV',
        uniforms: {
            'envMap': null,
            'flipEnvMap': -1
        },
        vertexShader: getCommonVertexShader(),
        fragmentShader: /* glsl */ `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        //blending: NoBlending,
        depthTest: false,
        depthWrite: false
    });
}
function getCommonVertexShader() {
    return /* glsl */ `

		#include declare_attributes
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( aTextureCoord, faceIndex );
			gl_Position = vec4( aVertexPosition, 1.0 );

		}
	`;
}

class ObjExporter {
    static #instance;
    #lines = [];
    #startIndex = 1;
    #fullScreenQuadMesh = new FullScreenQuad();
    scene = new Scene();
    camera = new Camera({ position: vec3.fromValues(0, 0, 100) });
    constructor() {
        if (ObjExporter.#instance) {
            return ObjExporter.#instance;
        }
        ObjExporter.#instance = this;
        this.scene.addChild(this.#fullScreenQuadMesh);
    }
    async #renderMeshes(files, meshes) {
        const [previousWidth, previousHeight] = Graphics$1.setSize(1024, 1024); //TODOv3: constant
        Graphics$1.setIncludeCode('EXPORT_TEXTURES', '#define EXPORT_TEXTURES');
        Graphics$1.setIncludeCode('SKIP_PROJECTION', '#define SKIP_PROJECTION');
        Graphics$1.setIncludeCode('SKIP_LIGHTING', '#define SKIP_LIGHTING');
        const previousClearColor = Graphics$1.getClearColor();
        Graphics$1.clearColor(vec4.fromValues(0, 0, 0, 0));
        let meshId = 0;
        const promises = [];
        for (const mesh of meshes) {
            if (!mesh.is('Mesh')) {
                continue;
            }
            if (mesh.parent?.isParticleSystem) {
                continue;
            }
            this.#fullScreenQuadMesh.material = mesh.material;
            this.#fullScreenQuadMesh.materialsParams = mesh.materialsParams;
            Graphics$1.render(this.scene, this.camera, 0, { DisableToolRendering: true });
            //let file = await Graphics.savePictureAsFile(`mat_${meshId}.png`);
            /*				let file = await Graphics.savePictureAsFile(`mat_${meshId}.png`);
                        files.add(file);*/
            const promise = Graphics$1.savePictureAsFile(`mat_${meshId}.png`);
            promise.then((file) => files.add(file));
            promises.push(promise);
            ++meshId;
        }
        Graphics$1.setIncludeCode('EXPORT_TEXTURES', '');
        Graphics$1.setIncludeCode('SKIP_PROJECTION', '');
        Graphics$1.setIncludeCode('SKIP_LIGHTING', '');
        Graphics$1.setSize(previousWidth, previousHeight);
        Graphics$1.clearColor(previousClearColor);
        await Promise.all(promises);
    }
    #addLine(line) {
        this.#lines.push(line + '\n');
    }
    async exportMeshes({ meshes = new Set(), exportTexture = false, singleMesh = false, digits = 4, subdivisions = 0, mergeTolerance = 0.0001 } = {}) {
        const files = new Set();
        const loopSubdivision = new LoopSubdivision();
        if (exportTexture && subdivisions == 0) {
            await this.#renderMeshes(files, meshes);
        }
        this.#lines = [];
        const mtlLines = [];
        this.#addLine('mtllib export.mtl');
        let objectId = 0;
        this.#startIndex = 1;
        for (const mesh of meshes) {
            if (mesh.parent.isParticleSystem) {
                continue;
            }
            if (mesh.exportObj) {
                const m = mesh.exportObj();
                let faces;
                let vertices;
                let normals;
                let uvs;
                if (subdivisions > 0) {
                    const result = await loopSubdivision.subdivide(m.f, m.v, subdivisions, mergeTolerance);
                    faces = result.indices;
                    vertices = result.vertices;
                }
                else {
                    faces = m['f'];
                    vertices = m['v'];
                    normals = m['vn'];
                    uvs = m['vt'];
                }
                if (!singleMesh) {
                    this.#addLine('o ' + objectId);
                }
                mtlLines.push(`newmtl mat_${objectId}.png\n`);
                mtlLines.push(`map_Kd mat_${objectId}.png\n`);
                this.#addLine(`usemtl mat_${objectId}.png`);
                if (faces && vertices) {
                    this.#exportMesh(digits, faces, vertices, normals, uvs);
                }
                ++objectId;
            }
        }
        files.add(new File([new Blob([this.#lines.join('')])], 'export.obj'));
        if (exportTexture) {
            files.add(new File([new Blob([mtlLines.join('')])], 'export.mtl'));
        }
        return files;
    }
    async #exportMesh(digits, indices, vertices, normals, uvs) {
        const attributes = [
            { name: 'v', stride: 3, arr: vertices },
            { name: 'vn', stride: 3, arr: normals },
            { name: 'vt', stride: 2, arr: uvs },
        ];
        let line;
        let verticeCount = 0;
        const startIndex = this.#startIndex;
        for (const attribute of attributes) {
            const attributesLength = attribute.stride;
            const arr = attribute.arr;
            if (arr) {
                let vertexIndex = 0;
                for (let i = 0; i < arr.length; i += attributesLength, ++vertexIndex) {
                    line = attribute.name;
                    for (let j = 0; j < attributesLength; ++j) {
                        const value = arr[i + j];
                        if (value) {
                            line += ' ' + value.toFixed(digits);
                        }
                    }
                    this.#addLine(line);
                    if (attribute.name == 'v') {
                        ++verticeCount;
                    }
                }
            }
        }
        for (let i = 0; i < indices.length; i += 3) {
            const i0 = startIndex + indices[i];
            const i1 = startIndex + indices[i + 1];
            const i2 = startIndex + indices[i + 2];
            let uv0 = '';
            let uv1 = '';
            let uv2 = '';
            let normals0 = '';
            let normals1 = '';
            let normals2 = '';
            if (uvs) {
                uv0 = `/${i0}`;
                uv1 = `/${i1}`;
                uv2 = `/${i2}`;
            }
            if (normals) {
                normals0 = `/${i0}`;
                normals1 = `/${i1}`;
                normals2 = `/${i2}`;
            }
            this.#addLine(`f ${i0}${uv0}${normals0} ${i1}${uv1}${normals1} ${i2}${uv2}${normals2}`);
        }
        this.#startIndex += verticeCount;
    }
}

const DEFAULT_SIZE = 256;
class RenderTargetViewer {
    #scene = new Scene();
    #camera = new Camera({ projection: CameraProjection.Orthographic, position: [0, 0, 1] });
    #plane = new Plane();
    #renderTarget;
    #position = vec2.create();
    #size = vec2.fromValues(DEFAULT_SIZE, DEFAULT_SIZE);
    isRenderTargetViewer = true;
    #material;
    constructor(renderTarget) {
        ContextObserver.observe(GraphicsEvents, this.#camera);
        ContextObserver.observe(GraphicsEvents, this);
        this.#scene.addChild(this.#plane);
        this.#renderTarget = renderTarget;
        this.refreshPlane();
    }
    /**
     * @deprecated Please use `setMaterial` instead.
     */
    set material(material) {
        throw 'deprecated';
    }
    setRenderTarget(renderTarget) {
        this.#renderTarget = renderTarget;
        this.#plane.material.setColorMap(renderTarget.getTexture());
    }
    setMaterial(material) {
        this.#material = material;
        this.#plane.setMaterial(material);
        material.setColorMap(this.#renderTarget.getTexture());
    }
    getMaterial() {
        return this.#material;
    }
    /**
     * @deprecated Please use `getMaterial` instead.
     */
    get material() {
        throw 'deprecated';
    }
    setPosition(x, y) {
        vec2.set(this.#position, x, y);
        this.refreshPlane();
    }
    setSize(x, y) {
        vec2.set(this.#size, x, y);
        this.refreshPlane();
    }
    refreshPlane() {
        vec3.set(this.#plane._position, (this.#size[0] - Graphics$1.getWidth()) * 0.5 + this.#position[0], (Graphics$1.getHeight() - this.#size[1]) * 0.5 - this.#position[1], 0);
        this.#plane.setSize(this.#size[0], this.#size[1]);
    }
    render(renderer) {
        renderer.render(this.#scene, this.#camera, 0, { DisableToolRendering: true });
    }
    is(s) {
        return s == 'RenderTargetViewer';
    }
}

export { Add, AgeNoise, AlphaFadeAndDecay, AlphaFadeInRandom, AlphaFadeOutRandom, AlphaRandom, AmbientLight, AnimatedTextureProxy, AnimatedWeaponSheen, ApplySticker, AttractToControlPoint, AudioGroup, AudioMixer, BackGround, BasicMovement, BeamBufferGeometry, BeamSegment, BenefactorLevel, Bias, BlendingEquation, BlendingFactor, BlendingMode, Bone, BoundingBox, BoundingBoxHelper, Box, BufferAttribute, BufferGeometry, BuildingInvis, BuildingRescueLevel, BurnLevel, CDmxAttributeType, CDmxElement, COLLISION_GROUP_DEBRIS, COLLISION_GROUP_NONE, CPVelocityForce, CParticleSystemDefinition, Camera, CameraControl, CameraFrustum, CameraProjection, CharacterMaterial, ChoreographiesManager, ChoreographyEventType, Circle, Clamp, ClampScalar, ClearPass, CollisionViaTraces, Color, ColorBackground, ColorFade, ColorInterpolate, ColorRandom, ColorSpace, CombineAdd, CombineLerp, CommunityWeapon, Composer, Cone, ConstrainDistance, ConstrainDistanceToControlPoint, ConstrainDistanceToPathBetweenTwoControlPoints, ContextObserver, ContinuousEmitter, ControlPoint, CopyPass, CreateFromParentParticles, CreateOnModel, CreateOnModelAtHeight, CreateSequentialPath, CreateWithinBox, CreateWithinSphere, CreationNoise, CrosshatchPass, CubeBackground, CubeEnvironment, CubeTexture, CubicBezierCurve, CustomSteamImageOnModel, CustomWeaponMaterial, Cylinder, DEFAULT_GROUP_ID, DEFAULT_MAX_PARTICLES$1 as DEFAULT_MAX_PARTICLES, DEFAULT_TEXTURE_SIZE, DEG_TO_RAD, DampenToCP, Decal, Detex, DistanceCull, DistanceToCP, Divide, DmeElement, DmeParticleSystemDefinition, DrawCircle, DummyEntity, EPSILON$2 as EPSILON, EmitContinuously, EmitInstantaneously, EmitNoise, Entity, EntityObserver, EntityObserverEventType, Environment, Equals, ExponentialDecay, EyeRefractMaterial, FLT_EPSILON, FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING, FadeAndKill, FadeIn, FadeInSimple, FadeOut, FadeOutSimple, FileNameFromPath, FirstPersonControl, Float32BufferAttribute, FloatArrayNode, FontManager, FrameBufferTarget, Framebuffer, FullScreenQuad, GL_ALPHA, GL_ALWAYS, GL_ARRAY_BUFFER, GL_BACK, GL_BLEND, GL_BLUE, GL_BOOL, GL_BOOL_VEC2, GL_BOOL_VEC3, GL_BOOL_VEC4, GL_BYTE, GL_CCW, GL_CLAMP_TO_EDGE, GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1, GL_COLOR_ATTACHMENT10, GL_COLOR_ATTACHMENT11, GL_COLOR_ATTACHMENT12, GL_COLOR_ATTACHMENT13, GL_COLOR_ATTACHMENT14, GL_COLOR_ATTACHMENT15, GL_COLOR_ATTACHMENT16, GL_COLOR_ATTACHMENT17, GL_COLOR_ATTACHMENT18, GL_COLOR_ATTACHMENT19, GL_COLOR_ATTACHMENT2, GL_COLOR_ATTACHMENT20, GL_COLOR_ATTACHMENT21, GL_COLOR_ATTACHMENT22, GL_COLOR_ATTACHMENT23, GL_COLOR_ATTACHMENT24, GL_COLOR_ATTACHMENT25, GL_COLOR_ATTACHMENT26, GL_COLOR_ATTACHMENT27, GL_COLOR_ATTACHMENT28, GL_COLOR_ATTACHMENT29, GL_COLOR_ATTACHMENT3, GL_COLOR_ATTACHMENT30, GL_COLOR_ATTACHMENT31, GL_COLOR_ATTACHMENT4, GL_COLOR_ATTACHMENT5, GL_COLOR_ATTACHMENT6, GL_COLOR_ATTACHMENT7, GL_COLOR_ATTACHMENT8, GL_COLOR_ATTACHMENT9, GL_COLOR_BUFFER_BIT, GL_CONSTANT_ALPHA, GL_CONSTANT_COLOR, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_CULL_FACE, GL_CW, GL_DEPTH24_STENCIL8, GL_DEPTH32F_STENCIL8, GL_DEPTH_ATTACHMENT, GL_DEPTH_BUFFER_BIT, GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_DEPTH_COMPONENT32F, GL_DEPTH_STENCIL, GL_DEPTH_TEST, GL_DITHER, GL_DRAW_FRAMEBUFFER, GL_DST_ALPHA, GL_DST_COLOR, GL_DYNAMIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, GL_ELEMENT_ARRAY_BUFFER, GL_EQUAL, GL_FALSE, GL_FLOAT, GL_FLOAT_32_UNSIGNED_INT_24_8_REV, GL_FLOAT_MAT2, GL_FLOAT_MAT2x3, GL_FLOAT_MAT2x4, GL_FLOAT_MAT3, GL_FLOAT_MAT3x2, GL_FLOAT_MAT3x4, GL_FLOAT_MAT4, GL_FLOAT_MAT4x2, GL_FLOAT_MAT4x3, GL_FLOAT_VEC2, GL_FLOAT_VEC3, GL_FLOAT_VEC4, GL_FRAGMENT_SHADER, GL_FRAMEBUFFER, GL_FRONT, GL_FRONT_AND_BACK, GL_FUNC_ADD, GL_FUNC_REVERSE_SUBTRACT, GL_FUNC_SUBTRACT, GL_GEQUAL, GL_GREATER, GL_GREEN, GL_HALF_FLOAT, GL_HALF_FLOAT_OES, GL_INT, GL_INT_SAMPLER_2D, GL_INT_SAMPLER_2D_ARRAY, GL_INT_SAMPLER_3D, GL_INT_SAMPLER_CUBE, GL_INT_VEC2, GL_INT_VEC3, GL_INT_VEC4, GL_INVALID_ENUM, GL_INVALID_OPERATION, GL_INVALID_VALUE, GL_LEQUAL, GL_LESS, GL_LINEAR, GL_LINEAR_MIPMAP_LINEAR, GL_LINEAR_MIPMAP_NEAREST, GL_LINES, GL_LINE_LOOP, GL_LINE_STRIP, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_MAX, GL_MAX_COLOR_ATTACHMENTS, GL_MAX_EXT, GL_MAX_RENDERBUFFER_SIZE, GL_MAX_VERTEX_ATTRIBS, GL_MIN, GL_MIN_EXT, GL_MIRRORED_REPEAT, GL_NEAREST, GL_NEAREST_MIPMAP_LINEAR, GL_NEAREST_MIPMAP_NEAREST, GL_NEVER, GL_NONE, GL_NOTEQUAL, GL_NO_ERROR, GL_ONE, GL_ONE_MINUS_CONSTANT_ALPHA, GL_ONE_MINUS_CONSTANT_COLOR, GL_ONE_MINUS_DST_ALPHA, GL_ONE_MINUS_DST_COLOR, GL_ONE_MINUS_SRC_ALPHA, GL_ONE_MINUS_SRC_COLOR, GL_OUT_OF_MEMORY, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_POINTS, GL_POLYGON_OFFSET_FILL, GL_R16I, GL_R16UI, GL_R32I, GL_R32UI, GL_R8, GL_R8I, GL_R8UI, GL_R8_SNORM, GL_RASTERIZER_DISCARD, GL_READ_FRAMEBUFFER, GL_RED, GL_RENDERBUFFER, GL_REPEAT, GL_RG16I, GL_RG16UI, GL_RG32I, GL_RG32UI, GL_RG8, GL_RG8I, GL_RG8UI, GL_RGB, GL_RGB10, GL_RGB10_A2, GL_RGB10_A2UI, GL_RGB12, GL_RGB16, GL_RGB16I, GL_RGB16UI, GL_RGB32F, GL_RGB32I, GL_RGB4, GL_RGB5, GL_RGB565, GL_RGB5_A1, GL_RGB8, GL_RGBA, GL_RGBA12, GL_RGBA16, GL_RGBA16F, GL_RGBA16I, GL_RGBA16UI, GL_RGBA2, GL_RGBA32F, GL_RGBA32I, GL_RGBA32UI, GL_RGBA4, GL_RGBA8, GL_RGBA8I, GL_RGBA8UI, GL_SAMPLER_2D, GL_SAMPLER_2D_ARRAY, GL_SAMPLER_2D_ARRAY_SHADOW, GL_SAMPLER_2D_SHADOW, GL_SAMPLER_3D, GL_SAMPLER_CUBE, GL_SAMPLER_CUBE_SHADOW, GL_SAMPLE_ALPHA_TO_COVERAGE, GL_SAMPLE_COVERAGE, GL_SCISSOR_TEST, GL_SHORT, GL_SRC_ALPHA, GL_SRC_ALPHA_SATURATE, GL_SRC_COLOR, GL_SRGB, GL_SRGB8, GL_SRGB8_ALPHA8, GL_SRGB_ALPHA, GL_STACK_OVERFLOW, GL_STACK_UNDERFLOW, GL_STATIC_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STENCIL_ATTACHMENT, GL_STENCIL_BUFFER_BIT, GL_STENCIL_INDEX8, GL_STENCIL_TEST, GL_STREAM_COPY, GL_STREAM_DRAW, GL_STREAM_READ, GL_TEXTURE0, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_WRAP_R, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TRANSFORM_FEEDBACK_BUFFER, GL_TRIANGLES, GL_TRIANGLE_FAN, GL_TRIANGLE_STRIP, GL_TRUE, GL_UNIFORM_BUFFER, GL_UNPACK_COLORSPACE_CONVERSION_WEBGL, GL_UNPACK_FLIP_Y_WEBGL, GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, GL_UNSIGNED_BYTE, GL_UNSIGNED_INT, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_5_9_9_9_REV, GL_UNSIGNED_INT_SAMPLER_2D, GL_UNSIGNED_INT_SAMPLER_2D_ARRAY, GL_UNSIGNED_INT_SAMPLER_3D, GL_UNSIGNED_INT_SAMPLER_CUBE, GL_UNSIGNED_INT_VEC2, GL_UNSIGNED_INT_VEC3, GL_UNSIGNED_INT_VEC4, GL_UNSIGNED_SHORT, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_5_6_5, GL_VERTEX_ARRAY, GL_VERTEX_SHADER, GL_ZERO, GRIDCELL, GrainPass, Graphics$1 as Graphics, GraphicsEvent, GraphicsEvents, Grid, GridMaterial, Group, HALF_PI, HeartbeatScale, HitboxHelper, Includes, InheritFromParentParticles, InitFloat, InitFromCPSnapshot, InitSkinnedPositionFromCPSnapshot, InitVec, InitialVelocityNoise, InstantaneousEmitter, IntArrayNode, IntProxy, InterpolateRadius, Intersection, Invis, ItemTintColor, JSONLoader, KeepOnlyLastChild, LerpEndCapScalar, LessOrEqualProxy, LifespanDecay$1 as LifespanDecay, LifetimeFromSequence, LifetimeRandom, Light, LightMappedGenericMaterial, LightShadow, Line, LineMaterial, LineSegments, LinearBezierCurve, LinearRamp, LockToBone$1 as LockToBone, LoopSubdivision, MATERIAL_BLENDING_NONE, MATERIAL_BLENDING_NORMAL, MATERIAL_CULLING_BACK, MATERIAL_CULLING_FRONT, MATERIAL_CULLING_FRONT_AND_BACK, MATERIAL_CULLING_NONE, MAX_FLOATS, MOUSE, MaintainEmitter, MaintainSequentialPath, ManifestRepository, Manipulator, MapEntities, MateriaParameter, MateriaParameterType, Material, MemoryCacheRepository, MemoryRepository, MergeRepository, Mesh, MeshBasicMaterial, MeshBasicPbrMaterial, MeshFlatMaterial, MeshPhongMaterial, Metaball, Metaballs, ModelGlowColor, ModelLoader, MovementBasic, MovementLocktoControlPoint, MovementMaxVelocity, MovementRigidAttachToCP$1 as MovementRigidAttachToCP, MovementRotateParticleAroundAxis$1 as MovementRotateParticleAroundAxis, Multiply$1 as Multiply, Node, NodeImageEditor, NodeImageEditorGui, NodeImageEditorMaterial, Noise, NoiseEmitter, NormalAlignToCP, NormalLock, NormalOffset, NormalizeVector, OBJImporter, ONE_EPS, ObjExporter, OldMoviePass, OrbitControl, OrientTo2dDirection, OscillateScalar$1 as OscillateScalar, OscillateScalarSimple, OscillateVector$1 as OscillateVector, OutlinePass, OverrideRepository, PI, PalettePass, ParametersNode, ParticleRandomFloat, ParticleRandomVec3, Pass, Path, PathPrefixRepository, PinParticleToCP, PixelatePass, Plane, PlaneCull, PointLight, PointLightHelper, PositionAlongPathRandom, PositionAlongPathSequential, PositionFromParentParticles$1 as PositionFromParentParticles, PositionLock, PositionModifyOffsetRandom, PositionOffset, PositionOnModelRandom, PositionWarp, PositionWithinBoxRandom, PositionWithinSphereRandom, Program, Properties, Property, PropertyType, ProxyManager, AttractToControlPoint$1 as PullTowardsControlPoint, QuadraticBezierCurve, RAD_TO_DEG, RadiusFromCPObject, RadiusRandom, RadiusScale, RampScalarLinear, RampScalarLinearSimple, RampScalarSpline, RandomColor, RandomFloat, RandomFloatExp, RandomForce$1 as RandomForce, RandomSecondSequence, RandomSequence, RandomVectorInUnitSphere, RandomYawFlip, Ray, Raycaster, RefractMaterial, RemGenerator, RemapCPOrientationToRotations, RemapCPSpeedToCP, RemapCPtoScalar, RemapCPtoVector, RemapControlPointDirectionToVector, RemapControlPointToScalar, RemapControlPointToVector, RemapDistanceToControlPointToScalar, RemapDistanceToControlPointToVector, RemapInitialScalar, RemapNoiseToScalar, RemapParticleCountToScalar, RemapScalar, RemapScalarToVector, RemapSpeed, RemapSpeedtoCP, RemapValClamped, RemapValClampedBias, RenderAnimatedSprites, RenderBlobs, RenderBufferInternalFormat, RenderDeferredLight, RenderFace, RenderModels, RenderPass, RenderRope, RenderRopes, RenderScreenVelocityRotate, RenderSpriteTrail, RenderSprites, RenderTarget, RenderTargetViewer, RenderTrails, Renderbuffer, RepeatedTriggerChildGroup, Repositories, RepositoryEntry, RepositoryError, RgbeImporter, RingWave, RotationBasic, RotationControl, RotationRandom, RotationSpeedRandom, RotationSpinRoll, RotationSpinYaw, RotationYawFlipRandom, RotationYawRandom, SOURCE2_DEFAULT_BODY_GROUP, SOURCE2_DEFAULT_RADIUS, SaturatePass, Scene, SceneExplorer, Select, SelectFirstIfNonZero, SequenceLifeTime, SequenceRandom, SetCPOrientationToGroundNormal, SetChildControlPointsFromParticlePositions, SetControlPointFromObjectScale, SetControlPointOrientation, SetControlPointPositions$1 as SetControlPointPositions, SetControlPointToCenter, SetControlPointToParticlesCenter, SetControlPointsToModelParticles, SetFloat, SetParentControlPointsToChildCP, SetPerChildControlPoint, SetRandomControlPointPosition, SetRigidAttachment, SetSingleControlPointPosition, SetToCP, SetVec, ShaderDebugMode, ShaderEditor, ShaderManager, ShaderMaterial, ShaderPrecision, ShaderQuality, ShaderToyMaterial, Shaders, ShadowMap, SimpleSpline, Sine, SkeletalMesh, Skeleton, SkeletonHelper, SketchPass, SnapshotRigidSkinToBones, Source1BspLoader, Source1Material, Source1MaterialManager, Source1MdlLoader, Source1ModelInstance, Source1ModelManager, Multiply as Source1Multiply, Source1ParticleControler, Source1ParticleOperators, Source1ParticleSystem, Source1PcfLoader, Source1SoundManager, Source1TextureManager, Source1VmtLoader, Source1Vtf, Source1VtxLoader, Source1VvdLoader, Source2CablesMaterial, Source2ColorCorrection, Source2Crystal, Source2CsgoCharacter, Source2CsgoComplex, Source2CsgoEffects, Source2CsgoEnvironment, Source2CsgoEnvironmentBlend, Source2CsgoFoliage, Source2CsgoGlass, Source2CsgoSimple, Source2CsgoStaticOverlay, Source2CsgoUnlitGeneric, Source2CsgoVertexLitGeneric, Source2CsgoWeapon, Source2CsgoWeaponStattrak, Source2EnvironmentBlend, Source2Error, Source2File, Source2FileLoader, Source2Generic, Source2GlobalLitSimple, Source2GrassTile, Source2Hero, Source2HeroFluid, Source2IceSurfaceDotaMaterial, LifespanDecay as Source2LifespanDecay, Source2LiquidFx, LockToBone as Source2LockToBone, Source2Material, Source2MaterialManager, Source2ModelInstance, Source2ModelLoader, Source2ModelManager, MovementRotateParticleAroundAxis as Source2MovementRotateParticleAroundAxis, OscillateScalar as Source2OscillateScalar, OscillateVector as Source2OscillateVector, Source2Panorama, Source2PanoramaFancyQuad, Source2ParticleLoader, Source2ParticleManager, Source2ParticlePathParams, Source2ParticleSystem, Source2Pbr, Source2PhyscisWireframe, Source2ProjectedDotaMaterial, RandomForce as Source2RandomForce, Source2RefractMaterial, SetControlPointPositions as Source2SetControlPointPositions, Source2Sky, Source2SnapshotLoader, Source2SpringMeteor, Source2SpriteCard, Source2StickersMaterial, Source2TextureManager, TwistAroundAxis as Source2TwistAroundAxis, Source2UI, Source2Unlit, VelocityRandom as Source2VelocityRandom, Source2VrBlackUnlit, Source2VrComplex, Source2VrEyeball, Source2VrGlass, Source2VrMonitor, Source2VrSimple, Source2VrSimple2WayBlend, Source2VrSimple3LayerParallax, Source2VrSkin, Source2VrXenFoliage, SourceBSP, SourceModel, SourcePCF, Sphere, Spin, SpinUpdate, SpotLight, SpotLightHelper, SpriteCardMaterial, SpriteMaterial, SpriteSheet, SpriteSheetCoord, SpriteSheetFrame, SpriteSheetSequence, SpyInvis, StatTrakDigit, StatTrakIllum, StickybombGlowColor, TAU, TEXTUREFLAGS_ALL_MIPS, TEXTUREFLAGS_ANISOTROPIC, TEXTUREFLAGS_BORDER, TEXTUREFLAGS_CLAMPS, TEXTUREFLAGS_CLAMPT, TEXTUREFLAGS_CLAMPU, TEXTUREFLAGS_DEPTHRENDERTARGET, TEXTUREFLAGS_EIGHTBITALPHA, TEXTUREFLAGS_ENVMAP, TEXTUREFLAGS_HINT_DXT5, TEXTUREFLAGS_NODEBUGOVERRIDE, TEXTUREFLAGS_NODEPTHBUFFER, TEXTUREFLAGS_NOLOD, TEXTUREFLAGS_NOMIP, TEXTUREFLAGS_NORMAL, TEXTUREFLAGS_ONEBITALPHA, TEXTUREFLAGS_POINTSAMPLE, TEXTUREFLAGS_PROCEDURAL, TEXTUREFLAGS_RENDERTARGET, TEXTUREFLAGS_SINGLECOPY, TEXTUREFLAGS_SRGB, TEXTUREFLAGS_SSBUMP, TEXTUREFLAGS_TRILINEAR, TEXTUREFLAGS_UNUSED_01000000, TEXTUREFLAGS_UNUSED_40000000, TEXTUREFLAGS_UNUSED_80000000, TEXTUREFLAGS_VERTEXTEXTURE, TEXTURE_FORMAT_COMPRESSED_BPTC, TEXTURE_FORMAT_COMPRESSED_RGBA_BC4, TEXTURE_FORMAT_COMPRESSED_RGBA_BC5, TEXTURE_FORMAT_COMPRESSED_RGBA_BC7, TEXTURE_FORMAT_COMPRESSED_RGBA_DXT1, TEXTURE_FORMAT_COMPRESSED_RGBA_DXT3, TEXTURE_FORMAT_COMPRESSED_RGBA_DXT5, TEXTURE_FORMAT_COMPRESSED_RGB_DXT1, TEXTURE_FORMAT_COMPRESSED_RGTC, TEXTURE_FORMAT_COMPRESSED_S3TC, TEXTURE_FORMAT_UNCOMPRESSED, TEXTURE_FORMAT_UNCOMPRESSED_BGRA8888, TEXTURE_FORMAT_UNCOMPRESSED_R8, TEXTURE_FORMAT_UNCOMPRESSED_RGB, TEXTURE_FORMAT_UNCOMPRESSED_RGBA, TEXTURE_FORMAT_UNKNOWN, TRIANGLE, TWO_PI, Target, Text3D, Texture, TextureFactoryEventTarget, TextureFormat, TextureLookup, TextureManager, TextureMapping, TextureScroll, TextureTarget, TextureTransform, TextureType, Timeline, TimelineChannel, TimelineClip, TimelineElement, TimelineElementType, TimelineGroup, ToneMapping, TrailLengthRandom, TranslationControl, Triangles, TwistAroundAxis$1 as TwistAroundAxis, Uint16BufferAttribute, Uint32BufferAttribute, Uint8BufferAttribute, UniformNoiseProxy, UnlitGenericMaterial, UnlitTwoTextureMaterial, VTEX_TO_INTERNAL_IMAGE_FORMAT, Vec3Middle, VectorNoise, VelocityNoise, VelocityRandom$1 as VelocityRandom, VertexLitGenericMaterial, VpkRepository, WaterLod, WaterMaterial, WeaponDecalMaterial, WeaponInvis, WeaponLabelText, WeaponSkin, WebGLRenderingState, WebGLShaderSource, WebGLStats, WebRepository, Wireframe, World, WorldVertexTransitionMaterial, YellowLevel, ZipRepository, Zstd, addIncludeSource, ceilPowerOfTwo, clamp$1 as clamp, createTexture, customFetch, decodeLz4, degToRad, deleteTexture, exportToBinaryFBX, fillCheckerTexture, fillFlatTexture, fillNoiseTexture, fillTextureWithImage, flipPixelArray, generateRandomUUID, getHelper, getIncludeList, getIncludeSource, getLoader, getRandomInt, getSceneExplorer, imageDataToImage, initRandomFloats, isNumeric, lerp, loadAnimGroup, pcfToSTring, polygonise, pow2, quatFromEulerRad, quatToEuler, quatToEulerDeg, radToDeg, registerLoader, setCustomIncludeSource, setFetchFunction, setTextureFactoryContext, smartRound, stringToQuat, stringToVec3, vec3ClampScalar, vec3RandomBox };
